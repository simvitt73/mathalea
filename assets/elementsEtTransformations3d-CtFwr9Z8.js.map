{"version":3,"file":"elementsEtTransformations3d-CtFwr9Z8.js","sources":["../../src/lib/3d/3dProjectionMathalea2d/elementsEtTransformations3d.ts"],"sourcesContent":["import { cross, dot, matrix, multiply, norm, type Matrix } from 'mathjs'\nimport { context } from '../../../modules/context'\nimport { colorToLatexOrHTML } from '../../2d/colorToLatexOrHtml'\nimport { Droite, droite } from '../../2d/droites'\nimport { fixeBordures } from '../../2d/fixeBordures'\nimport { ObjetMathalea2D } from '../../2d/ObjetMathalea2D'\nimport { PointAbstrait, pointAbstrait } from '../../2d/PointAbstrait'\nimport { Polygone, polygone } from '../../2d/polygones'\nimport { polyline } from '../../2d/Polyline'\nimport { representant } from '../../2d/representantVecteur'\nimport { Segment, segment } from '../../2d/segmentsVecteurs'\nimport { Vecteur, vecteur } from '../../2d/Vecteur'\n\nexport const math = { matrix, multiply, norm, cross, dot }\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJET PARENT %%%%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n/*\n * Classe parente de tous les objets de MathALEA2D\n *\n * @author Rémi Angot\n */\n// let numId = 0\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS DE BASE %%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n/**\n * LE POINT\n *\n * @author Jean-Claude Lhote\n * PointAbstrait de l'espace défini par ses trois coordonnées (Si deux sont données seulement, le point est dans le plan XY)\n * le paramètre visible définit si ce point est placé devant (par défaut) ou derrière une surface. Il sera utilisé pour définir la visibilité des arêtes qui en partent\n */\n\nexport class Point3d {\n  x: number\n  y: number\n  z: number\n  isVisible: boolean\n  label: string\n  typeObjet: string\n  c2d: PointAbstrait\n  constructor(\n    x: number,\n    y: number,\n    z: number,\n    isVisible: boolean,\n    label: string,\n    positionLabel: string,\n  ) {\n    const alpha = (context.anglePerspective * Math.PI) / 180 // context.anglePerspective peut être changé globalement pour modifier la perspective\n    const rapport = context.coeffPerspective // idem pour context.coefficientPerspective qui est la réduction sur l'axe y.\n    const MT = math.matrix([\n      [1, rapport * Math.cos(alpha), 0],\n      [0, rapport * Math.sin(alpha), 1],\n    ]) // La matrice de projection 3d -> 2d\n    this.x = x\n    this.y = y\n    this.z = z\n    this.isVisible = isVisible\n    this.label = label\n    this.typeObjet = 'point3d'\n    const V = math.matrix([this.x, this.y, this.z])\n    const W = (math.multiply(MT, V) as any).toArray().map(Number)\n    this.c2d = pointAbstrait(\n      Number(W[0].toFixed(2)),\n      Number(W[1].toFixed(2)),\n      this.label,\n      positionLabel,\n    )\n  }\n}\n\nexport function point3d(\n  x: number,\n  y: number,\n  z = 0,\n  visible = true,\n  label = '',\n  positionLabel = 'above left',\n) {\n  return new Point3d(x, y, z, visible, label, positionLabel)\n}\n/**\n * LE VECTEUR\n *\n * @author Jean-Claude Lhote\n * le vecteur3d est sans doute l'objet le plus important de cette base d'objets\n * On les utilise dans tous les objets complexes et dans toutes les transformations\n * Ils servent notament à définir la direction des plans.\n *\n * 3 usages : vecteur3d(A,B) ou vecteur3d(x,y,z) ou vecteur3d(math.matrix([x,y,z]))\n * A et B sont deux objets de type Point3d\n * x,y et z sont trois nombres\n * la commande math.matrix([x,y,z]) crée une matrice colonne.\n *\n * L'objet créé est de type Vecteur3d\n * sa propriété p2d est un objet Vecteur (2 dimensions : c'est la projection du vecteur)\n * sa propriété this.representant(A) est le dessin du représentant d'origine A.\n * exemples :\n * let v = vecteur3d(3,5,1) -> définit un vecteur de composantes (3;5;1)\n * let w = vecteur(point3d(0,0,0),point3d(1,1,1)) -> définit un vecteur d'origine O et d'extrémité M(1;1;1)\n * let fleche = w.representant(point3d(5,0,0)) -> fleche est un objet 2d qui représente le vecteur w au point (5;0;0)\n */\n\nexport class Vecteur3d {\n  x: number = 0\n  y: number = 0\n  z: number = 0\n  matrice: Matrix\n  norme: number\n  c2d: Vecteur\n  representant: (A: Point3d) => Segment\n  constructor(\n    ...args: [Point3d, Point3d] | [number, number, number] | [Matrix]\n  ) {\n    const alpha = (context.anglePerspective * Math.PI) / 180\n    const rapport = context.coeffPerspective\n    const MT = matrix([\n      [1, rapport * Math.cos(alpha), 0],\n      [0, rapport * Math.sin(alpha), 1],\n    ]) // ceci est la matrice de projection 3d -> 2d\n    if (args.length === 2) {\n      this.x = args[1].x - args[0].x\n      this.y = args[1].y - args[0].y\n      this.z = args[1].z - args[0].z\n    } else if (args.length === 3) {\n      this.x = args[0]\n      this.y = args[1]\n      this.z = args[2]\n    } else if (args.length === 1) {\n      const w = (args[0] as any).toArray().map(Number)\n      this.x = w[0]\n      this.y = w[1]\n      this.z = w[2]\n    }\n    this.matrice = matrix([this.x, this.y, this.z]) // On exporte cette matrice colonne utile pour les calculs vectoriels qui seront effectués par math\n    this.norme = Math.sqrt(this.x ** 2 + this.y ** 2 + this.z ** 2) // la norme du vecteur\n    const W = (multiply(MT, this.matrice) as any).toArray().map(Number) // voilà comment on obtient les composantes du projeté 2d du vecteur\n    this.c2d = vecteur(W[0], W[1]) // this.c2d est l'objet 2d qui représente l'objet 3d this\n    this.representant = function (A: Point3d) {\n      const B = translation3d(A, this)\n      return representant(vecteur(A.c2d, B.c2d), A.c2d) // qui retourne un représentant de vecteur 2d (objet dessiné)\n    }\n  }\n}\n\nexport function vecteur3d(\n  ...args: [Point3d, Point3d] | [number, number, number] | [Matrix]\n) {\n  return new Vecteur3d(...args)\n}\n/**\n * L'ARETE\n * @author Jean-Claude lhote\n * Une telle arête est définie par deux points\n * Si l'un des deux points n'est pas visible (propriété visible à false) alors l'arête aura aussi visible à false\n * sa propriété p2d est un segment en pointillé ou en trait plein suivant sa visibilité.\n */\n\nexport class Arete3d {\n  extremite1: Point3d\n  extremite2: Point3d\n  color: string\n  isVisible: boolean\n  c2d: Segment\n  constructor(\n    point1: Point3d,\n    point2: Point3d,\n    color: string,\n    isVisible: boolean,\n  ) {\n    this.extremite1 = point1\n    this.extremite2 = point2\n    this.color = Array.isArray(color) ? color[0] : color // MGu parfois un tableau de couleurs, pasd compatible avec segment.\n    this.isVisible = isVisible\n    if (!point1.isVisible || !point2.isVisible || !this.isVisible) {\n      this.isVisible = false\n    } else {\n      this.isVisible = true\n    }\n    this.c2d = segment(point1.c2d, point2.c2d, this.color)\n    if (!this.isVisible) {\n      this.c2d.pointilles = 2\n    } else {\n      this.c2d.pointilles = 0\n    }\n  }\n}\n// l'arête est visible par défaut sauf si p1 ou p2 sont invisibles\n\nexport function arete3d(\n  p1: Point3d,\n  p2: Point3d,\n  color = 'black',\n  visible = true,\n) {\n  return new Arete3d(p1, p2, color, visible)\n}\n/**\n * LA DROITE\n *\n * @author Jean-claude Lhote\n * Droite de l'espace définie par point et vecteur directeur droite3d(A,v)\n * Droite de l'espace définie par 2 points droite3d(A,B)\n * Les droites servent principalement à définir des axes de rotation dans l'espace\n */\nexport class Droite3d {\n  directeur: Vecteur3d = vecteur3d(0, 0, 1) // le vecteur directeur de la droite\n  origine: Point3d\n  point: any\n  c2d: Droite\n  constructor(point3D: Point3d, vecteur3D: Vecteur3d) {\n    if (vecteur3D.constructor === Vecteur3d) {\n      this.directeur = vecteur3D\n    } else if (vecteur3D.constructor === Point3d) {\n      this.directeur = vecteur3d(point3D, vecteur3D)\n    }\n    this.origine = point3D\n    const M = translation3d(this.origine, this.directeur)\n    this.point = M\n    this.c2d = droite(this.origine.c2d, M.c2d) // la droite correspndant à la projection de cette droite dans le plan Mathalea2d\n    this.c2d.isVisible = false\n  }\n}\n\nexport function droite3d(point3D: Point3d, vecteur3D: Vecteur3d) {\n  return new Droite3d(point3D, vecteur3D)\n}\n\n/**\n * Crée un demi-cercle\n * @param {Point3d} centre Centre du demi-cercle\n * @param {Vecteur3d} normal Vecteur normal au demi-cercle\n * @param {Vecteur3d} rayon Vecteur correspondant au rayon\n * @param {string} [sens = 'direct'] Sens de rotation pour créer le demi-cercle ('direct' ou 'indirect\")\n * @param {boolean} [estCache = false] Si false, alors le tracé est en trait plein, sinon le tracé est en pointillés\n * @param {string} [color = 'black'] Couleur du demi-cercle : du type 'blue' ou du type '#f15929'\n * @param {number} [angledepart = context.anglePerspective] Angle en degré entre le vecteur rayon depuis le centre et le point de début de tracé du demi-cercle\n * @example demicercle3d(A,n,v) // Crée un demi-cercle noir en trait plein de centre A, de vecteur normal v, dont le rayon correspond au vecteur v et le sens est direct\n * @example demicercle3d(A,n,v,'indirect',true,'red',0) // Crée un demi-cercle rouge en pointillés de centre A, de vecteur normal v, dont le rayon correspond au vecteur v, le sens est direct et l'angle de départ est 0°.\n * @author Eric Elter (d'après version précédente de Jean-Claude Lhote)\n * @return {demiCercle}\n */\n\nexport function demicercle3d(\n  centre: Point3d,\n  normal: Vecteur3d,\n  rayon: Vecteur3d,\n  sens: string = 'direct',\n  estCache: boolean = false,\n  color: string = 'black',\n  angledepart: number = context.anglePerspective,\n) {\n  let signe\n  const M = []\n  const listepoints = []\n  const listePoints3d = []\n  if (sens === 'direct') {\n    signe = 1\n  } else {\n    signe = -1\n  }\n  const d = droite3d(centre, normal)\n  M.push(rotation3d(translation3d(centre, rayon), d, angledepart))\n  listePoints3d.push(M[0])\n  listepoints.push(M[0].c2d)\n\n  for (let i = 1; i < 19; i++) {\n    M.push(rotation3d(M[i - 1], d, 10 * signe))\n    listePoints3d.push(M[i])\n    listepoints.push(M[i].c2d)\n  }\n  const demiCercle = polyline(listepoints, color)\n  if (estCache) {\n    demiCercle.pointilles = 2\n    demiCercle.opacite = 0.9\n  }\n  return demiCercle\n}\n/**\n * L'ARC\n *\n *@author Mickael Guironnet\n * Le nom est trompeur, il s'agit le plus souvent d'un morceau d'ellipse représentant un arc projeté\n * Utilisé pour représenter un arc dont une moitié est visible mais pas l'autre.\n *\n * normal et rayon sont deux vecteurs 3d\n * normal est un vecteur normal au plan du cercle\n * rayon est le vecteur qui part du centre et qui joint la 1ere extremité visible.\n * cote est soit 'caché' soit 'visible'\n *\n */\n\nexport function arc3d(\n  centre: Point3d,\n  normal: Vecteur3d,\n  rayon: Vecteur3d,\n  cote: 'visible' | 'caché',\n  color: string,\n  angledepart: number,\n  angledefin: number,\n) {\n  const M = []\n  const listepoints = []\n  const d = droite3d(centre, normal)\n  M.push(rotation3d(translation3d(centre, rayon), d, angledepart))\n  listepoints.push(M[0].c2d)\n\n  const nbr = Math.floor((angledefin - angledepart) / 10)\n  for (let i = 1; i <= nbr; i++) {\n    M.push(rotation3d(M[i - 1], d, 10))\n    listepoints.push(M[i].c2d)\n  }\n  const arc = polyline(listepoints, color)\n  if (cote === 'caché') {\n    arc.pointilles = 2\n    arc.opacite = 0.3\n  }\n  return arc\n}\n/**\n * LE CERCLE\n *\n * @author Jean-Claude Lhote\n *\n * C'est la version entière du cercle : soit totalement visible, soit totalement caché.\n * visible est un booléen\n *\n */\n\nexport function cercle3d(\n  centre: Point3d,\n  normal: Vecteur3d,\n  rayon: Vecteur3d,\n  visible: boolean = true,\n  color: string = 'black',\n  pointilles: boolean = false,\n): [Polygone, Point3d[], PointAbstrait[]] {\n  const M: Point3d[] = []\n  const listepoints: PointAbstrait[] = []\n  const listepoints3d: Point3d[] = []\n  const d = droite3d(centre, normal)\n  M.push(rotation3d(translation3d(centre, rayon), d, context.anglePerspective))\n  listepoints3d.push(M[0])\n  listepoints.push(M[0].c2d)\n  for (let i = 1; i < 36; i++) {\n    M.push(rotation3d(M[i - 1], d, 10))\n    listepoints3d.push(M[i])\n    listepoints.push(M[i].c2d)\n  }\n  const C = polygone(listepoints, color)\n  C.isVisible = visible\n  if (pointilles) {\n    C.pointilles = 2\n  }\n  return [C, listepoints3d, listepoints]\n}\n/**\n * LE POLYGONE\n *\n * @author Jean-Claude Lhote\n * usages : polygone3d([A,B,C,...],color) ou polygone3d(A,B,C...) où A,B,C ... sont des point3d. color='black' par défaut.\n */\nexport class Polygone3d {\n  listePoints: Point3d[]\n  color: string = 'black'\n  listePoints2d: PointAbstrait[]\n  aretes: Arete3d[]\n  c2d: Segment[]\n  constructor(...args: [Point3d[], string] | Point3d[]) {\n    if (Array.isArray(args[0])) {\n      // Si le premier argument est un tableau\n      this.listePoints = args[0]\n      if (typeof args[1] === 'string' && args[1] !== '') {\n        this.color = args[1]\n      }\n    } else {\n      this.listePoints = args.filter((arg) => arg instanceof Point3d)\n      this.color = 'black'\n    }\n    const segments3d = []\n    let A\n    const segments = []\n    A = this.listePoints[0]\n    this.listePoints2d = [A.c2d]\n    for (let i = 1; i < this.listePoints.length; i++) {\n      segments3d.push(\n        arete3d(\n          A,\n          this.listePoints[i],\n          this.color,\n          A.isVisible && this.listePoints[i].isVisible,\n        ),\n      )\n      segments.push(segments3d[i - 1].c2d)\n      A = this.listePoints[i]\n      this.listePoints2d.push(A.c2d)\n    }\n    segments3d.push(\n      arete3d(\n        A,\n        this.listePoints[0],\n        this.color,\n        A.isVisible && this.listePoints[0].isVisible,\n      ),\n    )\n    segments.push(segments3d[this.listePoints.length - 1].c2d)\n    this.aretes = segments3d\n    this.c2d = segments\n  }\n}\n\nexport function polygone3d(\n  ...args: [Point3d[], string] | Point3d[]\n): Polygone3d {\n  return new Polygone3d(...args)\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% TRANSFORMATIONS%%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n/**\n * LA ROTATION VECTORIELLE\n *\n * @author Jean-Claude Lhote\n * Cette rotation se distingue de la rotation d'axe (d) par le fait qu'on tourne autour d'une droite vectorielle\n * Elle sert à faire tourner des vecteurs essentiellement.\n * Si on l'utilise sur un point, alors il tournera autour d'une droite passant par l'origine.\n *\n * @param {*} point3D pour l'instant, cette fonction ne fait tourner qu'un point3d ou un vecteur3d\n * @param {*} vecteur3D vecteur directeur de l'axe de rotation (l'axe passe par l'origine, pour tourner autour d'une droite particulière on utilise rotation3d())\n * @param {*} angle Angle de rotation\n */\n\nexport function rotationV3d<T extends Point3d | Vecteur3d>(\n  point3D: T,\n  vecteur3D: Vecteur3d,\n  angle: number,\n): T {\n  let V, p2\n  const norme = math.norm(vecteur3D.matrice)\n  const unitaire = (math.multiply(vecteur3D.matrice, 1 / Number(norme)) as any)\n    .toArray()\n    .map(Number)\n  const u = unitaire[0]\n  const v = unitaire[1]\n  const w = unitaire[2]\n  const c = Math.cos((angle * Math.PI) / 180)\n  const s = Math.sin((angle * Math.PI) / 180)\n  const k = 1 - c\n  const matrice = math.matrix([\n    [u * u * k + c, u * v * k - w * s, u * w * k + v * s],\n    [u * v * k + w * s, v * v * k + c, v * w * k - u * s],\n    [u * w * k - v * s, v * w * k + u * s, w * w * k + c],\n  ])\n  if (point3D instanceof Point3d) {\n    V = math.matrix([point3D.x, point3D.y, point3D.z])\n    p2 = (math.multiply(matrice, V) as any).toArray().map(Number)\n    return point3d(p2[0], p2[1], p2[2]) as T\n  } else {\n    V = point3D\n    p2 = (math.multiply(matrice, V.matrice) as any).toArray().map(Number)\n    return vecteur3d(p2[0], p2[1], p2[2]) as T\n  }\n}\n\n/**\n * LA ROTATION D'AXE UNE DROITE\n *\n * @author Jean-Claude Lhote\n *\n * @param {Point3d} point3D Pour l'instant on ne fait tourner qu'un point3d\n * Remarque : ça n'a aucun sens de faire tourner un vecteur autour d'une droite particulière, on utilise la rotation vectorielle pour ça.\n * @param {Droite3d} droite3D Axe de rotation\n * @param {Number} angle Angle de rotation\n * @param {string} color couleur du polygone créé. si non précisé la couleur sera celle du polygone argument\n */\n\nexport function rotation3d<T extends Point3d | Vecteur3d | Polygone3d>(\n  point3D: T,\n  droite3D: Droite3d,\n  angle: number,\n  color?: string,\n): T {\n  const directeur = droite3D.directeur\n  const origine = droite3D.origine\n  if (point3D instanceof Point3d) {\n    const V = vecteur3d(origine, point3d(0, 0, 0))\n    const W = vecteur3d(point3d(0, 0, 0), origine)\n    const M = translation3d(point3D, V)\n    const N = rotationV3d(M, directeur, angle)\n    return translation3d(N, W)\n  }\n  if (point3D instanceof Vecteur3d) {\n    return rotationV3d(point3D, directeur, angle)\n  }\n  if (point3D instanceof Polygone3d) {\n    const rotated = point3D.listePoints.map((p: Point3d) =>\n      rotation3d(p, droite3D, angle),\n    )\n    return polygone3d(rotated, color ?? point3D.color) as T\n  }\n  return point3D\n}\n\n/**\n * @author Jean-Claude Lhote\n * Crée une flèche en arc de cercle pour montrer un sens de rotation autour d'un axe 3d\n * cette flèche est dessinée dans le plan orthogonal à l'axe qui passe par l'origine de l'axe\n * le rayon est ici un vecteur 3d qui permet de fixer le point de départ de la flèche par translation de l'origine de l'axe\n * l'angle définit l'arc formé par la flèche\n * son sens est définit par le vecteur directeur de l'axe (changer le signe de chaque composante de ce vecteur pour changer le sens de rotation)\n */\n\nexport class SensDeRotation3d extends ObjetMathalea2D {\n  constructor(\n    axe: Droite3d,\n    rayon: Vecteur3d,\n    angle: number,\n    epaisseur: number,\n    color: string,\n  ) {\n    super()\n    this.epaisseur = epaisseur\n    this.color = colorToLatexOrHTML(color)\n    this.c2d = []\n    let M\n    let N\n    let s\n    M = translation3d(axe.origine, rayon)\n    for (let i = 0; i < angle; i += 5) {\n      N = rotation3d(M, axe, 5)\n      s = segment(M.c2d, N.c2d, color)\n      s.epaisseur = this.epaisseur\n      this.c2d.push(s)\n      M = N\n    }\n    N = rotation3d(M, axe, 5)\n    s = segment(M.c2d, N.c2d, color)\n    s.epaisseur = this.epaisseur\n    this.c2d.push(s)\n    const d = droite3d(N, axe.directeur)\n    const A = rotation3d(M, d, 30)\n    const B = rotation3d(M, d, -30)\n    s = segment(N.c2d, A.c2d, color)\n    s.epaisseur = this.epaisseur\n    this.c2d.push(s)\n    s = segment(N.c2d, B.c2d, color)\n    s.epaisseur = this.epaisseur\n    this.c2d.push(s)\n  }\n}\n\nexport function sensDeRotation3d(\n  axe: Droite3d,\n  rayon: Vecteur3d,\n  angle: number,\n  epaisseur: number,\n  color: string,\n) {\n  return new SensDeRotation3d(axe, rayon, angle, epaisseur, color)\n}\n\n/**\n * LA TRANSLATION\n *\n * @author Jean-Claude Lhote\n * @param {Point3d | Polygone3d} point3D Pour l'instant on ne translate qu'un point3d ou un polygone3d\n * @param {Vecteur3d} vecteur3D\n */\n\nexport function translation3d<T extends Point3d | Polygone3d>(\n  point3D: T,\n  vecteur3D: Vecteur3d,\n): T {\n  if (point3D instanceof Point3d) {\n    const x = point3D.x + vecteur3D.x\n    const y = point3D.y + vecteur3D.y\n    const z = point3D.z + vecteur3D.z\n    return point3d(x, y, z) as T\n  } else if (point3D instanceof Polygone3d) {\n    const p = []\n    for (let i = 0; i < point3D.listePoints.length; i++) {\n      p.push(translation3d(point3D.listePoints[i], vecteur3D))\n    }\n    return polygone3d(p, point3D.color) as T\n  }\n  window.notify(\n    \"translation3d ne peut être appliqué qu'à un point3d ou un polygone3d\",\n    point3D,\n  )\n  return point3D\n}\n/**\n * L'homothetie\n * @author Jean-Claude Lhote\n * La même chose qu'ne 2d, mais en 3d...\n * Pour les points3d les polygones ou les vecteurs (multiplication scalaire par rapport)\n */\n\nexport function homothetie3d<T extends Point3d | Vecteur3d | Polygone3d>(\n  point3D: T,\n  centre: Point3d,\n  rapport: number,\n  color?: string,\n): T {\n  let V\n  const p = []\n  if (point3D instanceof Point3d) {\n    V = vecteur3d(centre, point3D)\n    V.x *= rapport\n    V.y *= rapport\n    V.z *= rapport\n    return translation3d(centre, V) as T\n  } else if (point3D instanceof Vecteur3d) {\n    V = vecteur3d(point3D.x, point3D.y, point3D.z)\n    V.x *= rapport\n    V.y *= rapport\n    V.z *= rapport\n    return V as T\n  } else if (point3D instanceof Polygone3d) {\n    for (let i = 0; i < point3D.listePoints.length; i++) {\n      p.push(homothetie3d(point3D.listePoints[i], centre, rapport, color))\n    }\n    return polygone3d(p, color ?? point3D.color) as T\n  }\n  window.notify(\n    \"homothetie3d ne peut être appliqué qu'à un point3d, un vecteur3d ou un polygone3d\",\n    point3D,\n  )\n  return point3D\n}\n\nexport class CodageAngleDroit3D extends ObjetMathalea2D {\n  constructor(A: Point3d, B: Point3d, C: Point3d, color = 'black', taille = 1) {\n    super()\n    const BA = vecteur3d(B, A)\n    const BC = vecteur3d(B, C)\n    const k1 = BA.norme\n    const k2 = BC.norme\n    const M1 = homothetie3d(A, B, (taille * 0.5) / k1)\n    const M3 = homothetie3d(C, B, (taille * 0.5) / k2)\n    const BM1 = vecteur3d(B, M1)\n    const BM3 = vecteur3d(B, M3)\n    const x = B.x + BM1.x + BM3.x\n    const y = B.y + BM1.y + BM3.y\n    const z = B.z + BM1.z + BM3.z\n    const M2 = point3d(x, y, z)\n    const M1M2 = arete3d(M1, M2, color)\n    const M2M3 = arete3d(M2, M3, color)\n    const bordures = fixeBordures([M1M2.c2d, M2M3.c2d])\n    this.bordures = [bordures.xmin, bordures.ymin, bordures.xmax, bordures.ymax]\n    this.svg = function (coeff) {\n      return M1M2.c2d.svg(coeff) + M2M3.c2d.svg(coeff)\n    }\n    this.tikz = function () {\n      return M1M2.c2d.tikz() + M2M3.c2d.tikz()\n    }\n  }\n}\n"],"names":["math","matrix","multiply","norm","cross","dot","Point3d","x","y","z","isVisible","label","positionLabel","__publicField","alpha","context","rapport","MT","V","W","pointAbstrait","point3d","visible","Vecteur3d","args","w","vecteur","A","B","translation3d","representant","vecteur3d","Arete3d","point1","point2","color","segment","arete3d","p1","p2","Droite3d","point3D","vecteur3D","M","droite","droite3d","demicercle3d","centre","normal","rayon","sens","estCache","angledepart","signe","listepoints","d","rotation3d","i","demiCercle","polyline","arc3d","cote","angledefin","nbr","arc","cercle3d","pointilles","listepoints3d","C","polygone","Polygone3d","arg","segments3d","segments","polygone3d","rotationV3d","angle","norme","unitaire","u","v","c","s","k","matrice","droite3D","directeur","origine","N","rotated","p","SensDeRotation3d","ObjetMathalea2D","axe","epaisseur","colorToLatexOrHTML","sensDeRotation3d","homothetie3d","CodageAngleDroit3D","taille","BA","BC","k1","k2","M1","M3","BM1","BM3","M2","M1M2","M2M3","bordures","fixeBordures","coeff"],"mappings":"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"}