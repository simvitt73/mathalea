{"version":3,"file":"2G23-2-wkmJNXix.js","sources":["../../src/exercices/2e/2G23-2.ts"],"sourcesContent":["import { colorToLatexOrHTML } from '../../lib/2d/colorToLatexOrHtml'\nimport { fixeBordures } from '../../lib/2d/fixeBordures'\nimport { nomVecteurParPosition } from '../../lib/2d/NomVecteurParPosition'\nimport { point } from '../../lib/2d/PointAbstrait'\nimport { repere } from '../../lib/2d/reperes'\nimport {\n  representant,\n  representantNomme,\n} from '../../lib/2d/representantVecteur'\nimport { segment } from '../../lib/2d/segmentsVecteurs'\nimport { latexParPoint, texteParPosition } from '../../lib/2d/textes'\nimport { tracePoint } from '../../lib/2d/TracePoint'\nimport { homothetie } from '../../lib/2d/transformations'\nimport { longueur } from '../../lib/2d/utilitairesGeometriques'\nimport { vecteur } from '../../lib/2d/Vecteur'\nimport { handleAnswers } from '../../lib/interactif/gestionInteractif'\nimport { remplisLesBlancs } from '../../lib/interactif/questionMathLive'\nimport { choice, combinaisonListes } from '../../lib/outils/arrayOutils'\nimport {\n  ecritureAlgebrique,\n  ecritureParentheseSiNegatif,\n} from '../../lib/outils/ecritures'\nimport { mathalea2d } from '../../modules/mathalea2d'\nimport { listeQuestionsToContenu, randint } from '../../modules/outils'\nimport Exercice from '../Exercice'\n\nexport const interactifReady = true\nexport const interactifType = 'mathLive'\nexport const titre = \"Calculer les coordonnées d'un point par une translation\"\nexport const dateDeModifImportante = '17/04/2024'\n\n/**\n * Calculer les coordonnées d'un point image ou antécédent d'un autre par une translation\n * @author Stéphane Guyon, Jean-Claude Lhote, Stéphan Grignon et Nathan Scheinmann\n\n */\nexport const uuid = 'fa7b9'\n\nexport const refs = {\n  'fr-fr': ['2G23-2'],\n  'fr-ch': [],\n}\n\nexport default class TranslationEtCoordonnes extends Exercice {\n  constructor() {\n    super()\n    this.nbQuestions = 3\n    this.sup = 2\n    this.correctionDetailleeDisponible = true\n    this.besoinFormulaireNumerique = [\n      'Type de questions',\n      3,\n      \"1 :Calculer les coordonnées de l'image d'un point. \\n 2 :Calculer les coordonnées de l'antécédent d'un point.\\n3 : Mélange\",\n    ]\n  }\n\n  nouvelleVersion() {\n    let typeQuestionsDisponibles: ('coorImage' | 'coorPre' | 'melange')[]\n    if (this.sup === 1) {\n      typeQuestionsDisponibles = ['coorImage']\n    } else if (this.sup === 2) {\n      typeQuestionsDisponibles = ['coorPre']\n    } else {\n      typeQuestionsDisponibles = ['coorImage', 'coorPre']\n    }\n\n    const listeTypeQuestions = combinaisonListes(\n      typeQuestionsDisponibles,\n      this.nbQuestions,\n    )\n    for (let i = 0, cpt = 0; i < this.nbQuestions && cpt < 50; ) {\n      let xA, yA, xB, yB, ux, uy, AbsRep, OrdRep\n      const objets = []\n      xA = randint(2, 8) * choice([-1, 1])\n      yA = randint(2, 8) * choice([-1, 1])\n      ux = randint(2, 8) * choice([-1, 1])\n      uy = randint(2, 8) * choice([-1, 1])\n      xB = xA + ux\n      yB = yA + uy\n      while (Math.abs(xB) < 2 || Math.abs(xB) > 8) {\n        // On s'assure de choisir des points bien placés dans le repère.\n        xA = randint(2, 8) * choice([-1, 1])\n        ux = randint(2, 8) * choice([-1, 1])\n        xB = xA + ux\n      }\n      while (Math.abs(yB) < 2 || Math.abs(yB) > 8) {\n        // Idem pour les ordonnées\n        yA = randint(2, 8) * choice([-1, 1])\n        uy = randint(2, 8) * choice([-1, 1])\n        yB = yA + uy\n      }\n\n      const r = repere({\n        xUnite: 1,\n        yUnite: 1,\n        xMin: Math.min(-2, xA - 2, xB - 2, 2),\n        yMin: Math.min(-2, yA - 2, yB - 2, 2),\n        xMax: Math.max(-2, xA + 2, xB + 2, 2),\n        yMax: Math.max(-2, yA + 2, yB + 2, 2),\n        thickHauteur: 0.1,\n        yLabelEcart: 0.4,\n        xLabelEcart: 0.3,\n        axeXStyle: '->',\n        axeYStyle: '->',\n      }) // On définit le repère\n      const A = point(xA, yA) // On définit et on trace le point A\n      const B = point(xB, yB) // On définit et on trace le point B\n      const traceAetB = tracePoint(A, B, 'red') // Variable qui trace les points avec une croix\n      const posLabelA = homothetie(B, A, -0.7 / longueur(A, B)) // pour positionner les noms des points aux extrémités proprement\n      const posLabelB = homothetie(A, B, -0.7 / longueur(A, B))\n      const labelA = latexParPoint('A', posLabelA, 'red', 10, 12, '')\n      const labelB = latexParPoint(\"A'\", posLabelB, 'red', 10, 12, '')\n      const s = segment(A, B, 'red') // On trace en rouge [AB]\n      s.styleExtremites = '->' // Variable qui transforme [AB] en vecteur\n      const O = point(0, 0) // On définit et on trace le point O\n      const o = texteParPosition('O', -0.3, -0.3)\n      const I = point(1, 0) // On définit sans tracer le point I\n      const J = point(0, 1) // On définit sans tracer le point J\n      const vi = vecteur(O, I) // Variable qui définit vecteur OI\n      const vj = vecteur(O, J) // Variable qui définit vecteur OJ\n      const k = representant(vi, O) // Variable qui trace [OI]\n      const j = representant(vj, O) // Variable qui trace [OJ]\n      s.epaisseur = 2 // Variable qui grossit le tracé du vecteur AB\n      s.color = colorToLatexOrHTML('red')\n      k.epaisseur = 2 // Variable qui grossit le tracé du vecteur OI\n      j.epaisseur = 2 // Variable qui grossit le tracé du vecteur OJ\n      const nomi = nomVecteurParPosition('i', 0.5, -0.7, 1.5, 0)\n      const nomj = nomVecteurParPosition('j', -0.7, 0.5, 1.5, 0)\n      const nomAB = representantNomme(vecteur(A, B), A, \"AA'\", 1.5, 'red')\n      objets.push(r, traceAetB, labelA, labelB, s, o, k, j, nomi, nomj, nomAB)\n      let texte = ''\n      let texteCorr = ''\n      switch (listeTypeQuestions[i]) {\n        case 'coorImage':\n          AbsRep = xB\n          OrdRep = yB\n          texte = `Dans un repère orthonormé $\\\\big(O\\\\,;\\\\,\\\\vec \\\\imath,\\\\,\\\\vec \\\\jmath\\\\big)$, déterminer les coordonnées du point $A'$, image du point $A\\\\left(${xA}\\\\,;\\\\,${yA}\\\\right)$ par la translation de vecteur $\\\\vec{u}\\\\begin{pmatrix}${ux}\\\\\\\\${uy}\\\\end{pmatrix}$.<br>`\n          if (this.interactif) {\n            texte +=\n              \"Le point $A'$ est donné par\" +\n              remplisLesBlancs(this, i, \"A'(%{champ1};{%{champ2}).\")\n            handleAnswers(\n              this,\n              i,\n              {\n                bareme: (listePoints: number[]) => [\n                  Math.min(listePoints[0], listePoints[1]),\n                  1,\n                ],\n                champ1: { value: String(AbsRep) },\n                champ2: { value: String(OrdRep) },\n              },\n              { formatInteractif: 'fillInTheBlank' },\n            )\n          }\n          break\n        case 'coorPre':\n          AbsRep = xA\n          OrdRep = yA\n          texte = `Dans un repère orthonormé $\\\\big(O\\\\,;\\\\,\\\\vec \\\\imath,\\\\,\\\\vec \\\\jmath\\\\big)$, déterminer les coordonnées du point $A$, dont l'image par la translation de vecteur $\\\\vec{u}\\\\begin{pmatrix}${ux}\\\\\\\\${uy}\\\\end{pmatrix}$ est le point $A'\\\\left(${xB}\\\\,;\\\\,${yB}\\\\right)$.<br>`\n          if (this.interactif) {\n            texte +=\n              'Le point $A$ est donné par' +\n              remplisLesBlancs(this, i, 'A(%{champ1};%{champ2})')\n            handleAnswers(\n              this,\n              i,\n              {\n                bareme: (listePoints: number[]) => [\n                  Math.min(listePoints[0], listePoints[1]),\n                  1,\n                ],\n                champ1: { value: String(AbsRep) },\n                champ2: { value: String(OrdRep) },\n              },\n              { formatInteractif: 'fillInTheBlank' },\n            )\n          }\n          break\n      }\n      if (this.correctionDetaillee) {\n        texteCorr +=\n          \"On sait d'après le cours que si $A'$ est l'image de $A$ par la translation de vecteur $\\\\vec{u}$, alors on a l'égalité : $\\\\overrightarrow{AA'}=\\\\vec{u}$.<br>\"\n        texteCorr +=\n          \"On connaît les coordonnées de $\\\\vec{u}$ avec l'énoncé, on calcule donc celles de $\\\\overrightarrow{AA'}$.<br>\"\n        texteCorr +=\n          \"On sait d'après le cours que si $A(x_A\\\\,;\\\\,y_A)$ et $B(x_B\\\\,;\\\\,y_B)$ sont deux points d'un repère, alors on a $\\\\overrightarrow{AB}\\\\begin{pmatrix}x_B-x_A\\\\\\\\y_B-y_A\\\\end{pmatrix}$.<br>\"\n        texteCorr += \"On applique ci-dessous aux données de l'énoncé.<br><br>\"\n      }\n\n      switch (listeTypeQuestions[i]) {\n        case 'coorImage':\n          texteCorr += `Soit $(x\\\\,;\\\\,y)$ les coordonnées du point $A'$, on a donc $\\\\overrightarrow{AA'}\\\\begin{pmatrix}x-${ecritureParentheseSiNegatif(xA)}\\\\\\\\y-${ecritureParentheseSiNegatif(yA)}\\\\end{pmatrix}$`\n          if (xA < 0 || yA < 0) {\n            texteCorr += ` soit $\\\\overrightarrow{AA'}\\\\begin{pmatrix}x${ecritureAlgebrique(-xA)}\\\\\\\\y${ecritureAlgebrique(-yA)}\\\\end{pmatrix}$.<br>`\n          } else {\n            texteCorr += '.<br>'\n          }\n          texteCorr +=\n            \"Dire que $\\\\overrightarrow{AA'}=\\\\vec{u}$ équivaut à résoudre :<br><br>\"\n          texteCorr += '$\\\\left\\\\{\\\\begin{array}{l}'\n          texteCorr += `x${ecritureAlgebrique(-xA)}=${ux} \\\\\\\\`\n          texteCorr += `y${ecritureAlgebrique(-yA)}=${uy}`\n          texteCorr += '\\\\end{array}'\n          texteCorr += '\\\\right.$'\n          texteCorr += '$\\\\Leftrightarrow\\\\left\\\\{\\\\begin{array}{l}'\n          texteCorr += `x=${ux}${ecritureAlgebrique(xA)} \\\\\\\\`\n          texteCorr += `y=${uy}${ecritureAlgebrique(yA)}`\n          texteCorr += '\\\\end{array}'\n          texteCorr += '\\\\right.$'\n          texteCorr += '$\\\\Leftrightarrow\\\\left\\\\{\\\\begin{array}{l}'\n          texteCorr += `x=${xB} \\\\\\\\`\n          texteCorr += `y=${yB}`\n          texteCorr += '\\\\end{array}'\n          texteCorr += `\\\\right.$ soit $A'(${xB}\\\\,;\\\\,${yB})$.<br>`\n          // texteCorr += `$\\\\begin{cases}x${ecritureAlgebrique(-xA)}=${ux}\\\\\\\\y${ecritureAlgebrique(-yA)}=${uy}\\\\end{cases}$`\n          // texteCorr += `$\\\\Leftrightarrow\\\\begin{cases}x=${ux}${ecritureAlgebrique(xA)}\\\\\\\\y=${uy}${ecritureAlgebrique(yA)}\\\\end{cases}$`\n          // texteCorr += `$\\\\Leftrightarrow\\\\begin{cases}x=${xB}\\\\\\\\y=${yB}\\\\end{cases}$ soit $A'(${xB}\\\\,;\\\\,${yB})$.<br>`\n          break\n        case 'coorPre':\n          texteCorr += `Soit $(x\\\\,;\\\\,y)$ les coordonnées du point $A$, on a donc : $\\\\overrightarrow{AA'}\\\\begin{pmatrix}${xB}-x\\\\\\\\${yB}-y\\\\end{pmatrix}$.<br>`\n          texteCorr +=\n            \"Dire que $\\\\overrightarrow{AA'}=\\\\vec{u}$ équivaut à résoudre :<br><br>\"\n          texteCorr += '$\\\\left\\\\{\\\\begin{array}{l}'\n          texteCorr += `${xB}-x=${ux} \\\\\\\\`\n          texteCorr += `${yB}-y=${uy}`\n          texteCorr += '\\\\end{array}'\n          texteCorr += '\\\\right.$'\n          texteCorr += '$\\\\Leftrightarrow\\\\left\\\\{\\\\begin{array}{l}'\n          texteCorr += `x=${xB}${ecritureAlgebrique(-ux)} \\\\\\\\`\n          texteCorr += `y=${yB}${ecritureAlgebrique(-uy)}`\n          texteCorr += '\\\\end{array}'\n          texteCorr += '\\\\right.$'\n          texteCorr += '$\\\\Leftrightarrow\\\\left\\\\{\\\\begin{array}{l}'\n          texteCorr += `x=${xA} \\\\\\\\`\n          texteCorr += `y=${yA}`\n          texteCorr += '\\\\end{array}'\n          texteCorr += `\\\\right.$ soit $A(${xA}\\\\,;\\\\,${yA})$.<br>`\n          // texteCorr += `$\\\\begin{cases}${xB}-x=${ux}\\\\\\\\${yB}-y=${uy}\\\\end{cases}$`\n          // texteCorr += `$\\\\Leftrightarrow\\\\begin{cases}x=${xB}${ecritureAlgebrique(-ux)}\\\\\\\\y=${yB}${ecritureAlgebrique(-uy)}\\\\end{cases}$`\n          // texteCorr += `$\\\\Leftrightarrow\\\\begin{cases}x=${xA}\\\\\\\\y=${yA}\\\\end{cases}$ soit $A(${xA}\\\\,;\\\\,${yA})$.<br>`\n          break\n      }\n\n      if (this.correctionDetaillee) {\n        texteCorr += mathalea2d(\n          Object.assign({ zoom: 1, scale: 0.6 }, fixeBordures(objets)),\n          objets,\n        ) // On trace le graphique\n      }\n      // texte += ajouteChampTexteMathLive(this, 2 * i, '', {texteAvant: '<br><br>Abscisse du point :' })\n      // texte += ajouteChampTexteMathLive(this, 2 * i + 1, '', {texteAvant: '<br><br>Ordonnée du point :' })\n      // setReponse(this, 2 * i, AbsRep)\n      // setReponse(this, 2 * i + 1, OrdRep)\n      if (this.questionJamaisPosee(i, xA, yA, xB, yB)) {\n        // Si la question n'a jamais été posée, on en créé une autre\n        this.listeQuestions[i] = texte\n        this.listeCorrections[i] = texteCorr\n        i++\n      }\n      cpt++\n    }\n    listeQuestionsToContenu(this)\n  }\n}\n"],"names":["interactifReady","interactifType","titre","dateDeModifImportante","uuid","refs","TranslationEtCoordonnes","Exercice","typeQuestionsDisponibles","listeTypeQuestions","combinaisonListes","i","cpt","xA","yA","xB","yB","ux","uy","AbsRep","OrdRep","objets","randint","choice","r","repere","A","point","B","traceAetB","tracePoint","posLabelA","homothetie","longueur","posLabelB","labelA","latexParPoint","labelB","s","segment","O","o","texteParPosition","I","vi","vecteur","vj","k","representant","j","colorToLatexOrHTML","nomi","nomVecteurParPosition","nomj","nomAB","representantNomme","texte","texteCorr","remplisLesBlancs","handleAnswers","listePoints","ecritureParentheseSiNegatif","ecritureAlgebrique","mathalea2d","fixeBordures","listeQuestionsToContenu"],"mappings":"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"}