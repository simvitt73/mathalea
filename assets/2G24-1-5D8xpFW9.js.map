{"version":3,"file":"2G24-1-5D8xpFW9.js","sources":["../../src/exercices/2e/2G24-1.ts"],"sourcesContent":["import { fixeBordures } from '../../lib/2d/fixeBordures'\nimport { point } from '../../lib/2d/PointAbstrait'\nimport { Repere } from '../../lib/2d/reperes'\nimport { Segment, segment } from '../../lib/2d/segmentsVecteurs'\nimport { labelPoint, texteParPosition } from '../../lib/2d/textes'\nimport { tracePoint } from '../../lib/2d/TracePoint'\nimport { KeyboardType } from '../../lib/interactif/claviers/keyboard'\nimport { handleAnswers } from '../../lib/interactif/gestionInteractif'\nimport { remplisLesBlancs } from '../../lib/interactif/questionMathLive'\nimport { choice } from '../../lib/outils/arrayOutils'\nimport { ecritureParentheseSiNegatif } from '../../lib/outils/ecritures'\nimport { creerNomDePolygone } from '../../lib/outils/outilString'\nimport FractionEtendue from '../../modules/FractionEtendue'\nimport { mathalea2d } from '../../modules/mathalea2d'\nimport { listeQuestionsToContenu, randint } from '../../modules/outils'\nimport Exercice from '../Exercice'\n\nimport { nomVecteurParPosition } from '../../lib/2d/NomVecteurParPosition'\nimport {\n  representant,\n  representantNomme,\n} from '../../lib/2d/representantVecteur'\nimport { vecteur } from '../../lib/2d/Vecteur'\nimport { miseEnEvidence } from '../../lib/outils/embellissements'\n\nexport const interactifReady = true\nexport const interactifType = 'mathLive'\nexport const titre =\n  \"Calculer les coordonnées d'un vecteur à partir des coordonnées de deux points\"\nexport const dateDeModifImportante = '30/06/2023'\n\n/**\n * Coordonnées d'un vecteur à partir de deux points\n * @author Stéphane Guyon & Stéphan Grignon Interactif Gilles Mora le 11 juin 2024\n */\nexport const uuid = 'f71c1'\n\nexport const refs = {\n  'fr-fr': ['2G24-1'],\n  'fr-ch': [],\n}\nexport default class Calculercoordonneesvecteurs extends Exercice {\n  constructor() {\n    super()\n    this.besoinFormulaireNumerique = [\n      'Situations différentes ',\n      2,\n      '1 : Coordonnées entières\\n 2 : Coordonnées en écriture fractionnaire',\n    ]\n\n    this.nbQuestions = 2\n    this.sup = 1\n    this.correctionDetaillee = false\n    this.correctionDetailleeDisponible = true\n  }\n\n  nouvelleVersion() {\n    for (let i = 0, cpt = 0; i < this.nbQuestions && cpt < 50; ) {\n      let texte = ''\n      let texteCorr = ''\n      let xA: number | FractionEtendue\n      let yA: number | FractionEtendue\n      let xB: number | FractionEtendue\n      let yB: number\n      let xABFraction: number | FractionEtendue\n      let yABFraction: number | FractionEtendue\n      let r: Repere\n      const nomsPoints = creerNomDePolygone(2, [\n        'Q',\n        'I',\n        'J',\n        'O',\n        'X',\n        'Y',\n        'Z',\n      ])\n      const objets = []\n      if (this.sup === 1) {\n        xA = randint(-4, 4)\n        yA = randint(-4, 4)\n        xABFraction = new FractionEtendue(randint(-4, 4), 1)\n        yABFraction = new FractionEtendue(\n          randint(-4, 4, [xABFraction.valeurDecimale]),\n          1,\n        )\n        xB = xA + xABFraction.valeurDecimale\n        yB = yA + yABFraction.valeurDecimale\n        r = new Repere({\n          xUnite: 1,\n          yUnite: 1,\n          xMin: Math.min(-2, xA - 2, xB - 2, 2),\n          yMin: Math.min(-2, yA - 2, yB - 2, 2),\n          xMax: Math.max(-2, xA + 2, xB + 2, 2),\n          yMax: Math.max(-2, yA + 2, yB + 2, 2),\n          thickHauteur: 0.1,\n          yLabelEcart: 0.4,\n          xLabelEcart: 0.3,\n          axeXStyle: '->',\n          axeYStyle: '->',\n        })\n\n        texte = `Dans un repère orthonormé $\\\\big(O\\\\,;\\\\,\\\\vec \\\\imath,\\\\,\\\\vec \\\\jmath\\\\big)$, on donne les points suivants : $${nomsPoints[0]}\\\\left(${xA}\\\\,;\\\\,${yA}\\\\right)$ et $${nomsPoints[1]}\\\\left(${xB}\\\\,;\\\\,${yB}\\\\right)$.<br>`\n        texte += `Déterminer les coordonnées du vecteur $\\\\overrightarrow{${nomsPoints[0]}${nomsPoints[1]}}$.`\n\n        texteCorr = `$\\\\overrightarrow{${nomsPoints[0]}${nomsPoints[1]}}\\\\begin{pmatrix}${xB}-${ecritureParentheseSiNegatif(xA)}\\\\\\\\${yB}-${ecritureParentheseSiNegatif(yA)}\\\\end{pmatrix}$, soit $\\\\overrightarrow{${nomsPoints[0]}${nomsPoints[1]}}\\\\begin{pmatrix}${miseEnEvidence(xABFraction.texFSD)}\\\\\\\\[0.7em]${miseEnEvidence(yABFraction.texFSD)}\\\\end{pmatrix}$.<br>`\n                                                                                                                                                                                                                                                     \n        if (this.correctionDetaillee) {\n          texteCorr =\n            \"On sait d'après le cours que si $A(x_A\\\\,;\\\\,y_A)$ et $B(x_B\\\\,;\\\\,y_B)$ sont deux points d'un repère, alors on a $\\\\overrightarrow{AB}\\\\begin{pmatrix}x_B-x_A\\\\\\\\y_B-y_A\\\\end{pmatrix}$.<br>\"\n          texteCorr += `On applique ici aux données de l'énoncé : $\\\\overrightarrow{${nomsPoints[0]}${nomsPoints[1]}}\\\\begin{pmatrix}${xB}-${ecritureParentheseSiNegatif(xA)}\\\\\\\\${yB}-${ecritureParentheseSiNegatif(yA)}\\\\end{pmatrix}$.<br>`\n          texteCorr += `Ce qui donne au final : $\\\\overrightarrow{${nomsPoints[0]}${nomsPoints[1]}}\\\\begin{pmatrix}${miseEnEvidence(xABFraction.texFraction)}\\\\\\\\${miseEnEvidence(yABFraction.texFraction)}\\\\end{pmatrix}$.<br><br>`\n        }\n      } else {\n        const listeFractions1 = [\n          [1, 2],\n          [3, 2],\n          [5, 2],\n          [1, 3],\n          [2, 3],\n          [4, 3],\n          [5, 3],\n          [1, 4],\n          [3, 4],\n          [5, 4],\n          [1, 5],\n          [2, 5],\n          [3, 5],\n          [4, 5],\n          [1, 6],\n          [5, 6],\n        ]\n        const frac1 = choice(listeFractions1)\n        xA = new FractionEtendue(frac1[0], frac1[1])\n        xABFraction = new FractionEtendue(randint(-4, 4, [0]), 1)\n        xB = xA.sommeFractions(xABFraction).simplifie()\n        const frac2 = choice(listeFractions1)\n        yABFraction = new FractionEtendue(frac2[0], frac2[1])\n        yB = randint(-4, 4, [0])\n        yA = new FractionEtendue(yB * frac2[1] - frac2[0], frac2[1])\n        r = new Repere({\n          xUnite: 1,\n          yUnite: 1,\n          xMin: Math.min(\n            -2,\n            Math.trunc(xA.valeurDecimale - 2.5),\n            Math.trunc(xB.valeurDecimale - 2.5),\n            2,\n          ),\n          yMin: Math.min(\n            -2,\n            Math.trunc(yA.valeurDecimale - 2.5),\n            Math.trunc(yB - 2.5),\n            2,\n          ),\n          xMax: Math.max(\n            -2,\n            Math.trunc(xA.valeurDecimale + 2.5),\n            Math.trunc(xB.valeurDecimale + 2.5),\n            2,\n          ),\n          yMax: Math.max(\n            -2,\n            Math.trunc(yA.valeurDecimale + 2.5),\n            Math.trunc(yB + 2.5),\n            2,\n          ),\n          thickHauteur: 0.1,\n          yLabelEcart: 0.4,\n          xLabelEcart: 0.3,\n          axeXStyle: '->',\n          axeYStyle: '->',\n          grilleSecondaire: true,\n          grilleSecondaireXDistance: 1 / frac1[1],\n          grilleSecondaireYDistance: 1 / frac2[1],\n          grilleSecondaireYMin: Math.min(\n            -2,\n            Math.trunc(yA.valeurDecimale - 2.5),\n            Math.trunc(yB - 2.5),\n            2,\n          ),\n          grilleSecondaireYMax: Math.max(\n            -2,\n            Math.trunc(yA.valeurDecimale + 2.5),\n            Math.trunc(yB + 2.5),\n            2,\n          ),\n          grilleSecondaireXMin: Math.min(\n            -2,\n            Math.trunc(xA.valeurDecimale - 2.5),\n            Math.trunc(xB.valeurDecimale - 2.5),\n            2,\n          ),\n          grilleSecondaireXMax: Math.max(\n            -2,\n            Math.trunc(xA.valeurDecimale + 2.5),\n            Math.trunc(xB.valeurDecimale + 2.5),\n            2,\n          ),\n        }) // On définit le repère\n\n        texte = `Dans un repère orthonormé $\\\\big(O\\\\,;\\\\,\\\\vec \\\\imath,\\\\,\\\\vec \\\\jmath\\\\big)$, on donne les points suivants : $${nomsPoints[0]}\\\\left(${xA.texFSD}\\\\,;\\\\,${yA.texFSD}\\\\right)$ et $${nomsPoints[1]}\\\\left(${xB.texFSD}\\\\,;\\\\,${yB}\\\\right)$.<br>`\n        texte += `Déterminer les coordonnées du vecteur $\\\\overrightarrow{${nomsPoints[0]}${nomsPoints[1]}}$.`\n\n        texteCorr = `$\\\\overrightarrow{${nomsPoints[0]}${nomsPoints[1]}}\\\\begin{pmatrix}${xB.texFSD}-${xA.texFSP}\\\\\\\\[0.7em]${yB}-${yA.texFSP}\\\\end{pmatrix}$, soit $\\\\overrightarrow{${nomsPoints[0]}${nomsPoints[1]}}\\\\begin{pmatrix}${miseEnEvidence(xABFraction.texFSD)}\\\\\\\\[0.7em]${miseEnEvidence(yABFraction.texFSD)}\\\\end{pmatrix}$.<br>`\n        if (this.correctionDetaillee) {\n          texteCorr =\n            \"On sait d'après le cours que si $A(x_A\\\\,;\\\\,y_A)$ et $B(x_B\\\\,;\\\\,y_B)$ sont deux points d'un repère, alors on a $\\\\overrightarrow{AB}\\\\begin{pmatrix}x_B-x_A\\\\\\\\y_B-y_A\\\\end{pmatrix}$.<br>\"\n          texteCorr += `On applique ici aux données de l'énoncé : $\\\\overrightarrow{${nomsPoints[0]}${nomsPoints[1]}}\\\\begin{pmatrix}${xB.texFSD}-${xA.texFSP}\\\\\\\\[0.7em]${yB}-${yA.texFSP}\\\\end{pmatrix}$.<br>`\n          texteCorr += `Ce qui donne au final : $\\\\overrightarrow{${nomsPoints[0]}${nomsPoints[1]}}\\\\begin{pmatrix}${miseEnEvidence(xABFraction.texFraction)}\\\\\\\\[0.7em]${miseEnEvidence(yABFraction.texFraction)}\\\\end{pmatrix}$.<br><br>`\n        }\n      }\n      const xDeA = xA instanceof FractionEtendue ? xA.valeurDecimale : xA // On récupère la valeur décimale de xA\n      const yDeA = yA instanceof FractionEtendue ? yA.valeurDecimale : yA // On récupère la valeur décimale de yA\n      const xDeB = xB instanceof FractionEtendue ? xB.valeurDecimale : xB // On récupère la valeur décimale de xB\n      const yDeB = yB\n\n      const A = point(xDeA, yDeA, nomsPoints[0]) // On définit et on trace le point A\n      const B = point(xDeB, yDeB, nomsPoints[1]) // On définit et on trace le point B\n      const traceAetB = tracePoint(A, B, 'red') // Variable qui trace les points avec une croix\n      traceAetB.taille = 1.5\n      const labelAetB = labelPoint(A, B, 'red') // Variable qui trace les noms A et B\n      const vecteurAB = vecteur(A, B, 'red') // On créé le vecteur AB\n      const vecteurABRep = representant(vecteurAB, A, 'red') as Segment // On trace le vecteur AB\n      const O = point(0, 0, 'O') // On définit et on trace le point O\n      const nomO = texteParPosition('O', -0.3, -0.3, 0, 'black', 1)\n      const I = point(1, 0) // On définit sans tracer le point I\n      const J = point(0, 1) // On définit sans tracer le point J\n      const vecteurOI = segment(O, I) // Variable qui trace [OI] en rouge\n      const vecteurOJ = segment(O, J) // Variable qui trace [OJ] en rouge\n      vecteurABRep.styleExtremites = '->' // Variable qui transforme [AB] en vecteur\n      vecteurOI.styleExtremites = '->' // Variable qui transforme [OI] en vecteur\n      vecteurOJ.styleExtremites = '->' // Variable qui transforme [OJ] en vecteur\n      vecteurABRep.epaisseur = 1.75 // Variable qui grossit le tracé du vecteur AB\n      vecteurOI.epaisseur = 1.75 // Variable qui grossit le tracé du vecteur OI\n      vecteurOJ.epaisseur = 1.75 // Variable qui grossit le tracé du vecteur OJ\n      vecteurOI.tailleExtremites = 2.5\n      vecteurOJ.tailleExtremites = 2.5\n      vecteurABRep.tailleExtremites = 2.5\n      const nomi = nomVecteurParPosition('i', 0.5, -0.7, 1.5, 0)\n      const nomj = nomVecteurParPosition('j', -0.7, 0.5, 1.5, 0)\n      const nomAB = representantNomme(\n        vecteurAB,\n        A,\n        nomsPoints[0] + nomsPoints[1],\n        1,\n        'red',\n      ) // affiche le nom du vecteur\n      // const nomAB = nomVecteurParPosition(nomsPoints[0] + nomsPoints[1], (xA + xB) / 2 + 1, (yA + yB) / 2 + 1, 1, 0) // affiche le nom du vecteur\n      objets.push(\n        r,\n        traceAetB,\n        labelAetB,\n        vecteurOI,\n        vecteurOJ,\n        vecteurABRep,\n        nomO,\n        nomi,\n        nomj,\n        nomAB,\n      )\n\n      if (this.correctionDetaillee) {\n        texteCorr += `On peux vérifier graphiquement ci-dessous les coordonnées du vecteur $\\\\overrightarrow{${nomsPoints[0]}${nomsPoints[1]}}$.<br>`\n        texteCorr += mathalea2d(\n          Object.assign({ zoom: 2 }, fixeBordures(objets)),\n          objets,\n        ) // On trace le graphique\n      }\n      handleAnswers(this, i, {\n        bareme: (listePoints) => [Math.min(listePoints[0], listePoints[1]), 1],\n        champ1: { value: xABFraction.texFraction },\n        champ2: { value: yABFraction.texFraction },\n      })\n      if (this.interactif) {\n        texte +=\n          `<br>$\\\\overrightarrow{${nomsPoints[0]}${nomsPoints[1]}}$` +\n          remplisLesBlancs(\n            this,\n            i,\n            '\\\\begin{pmatrix}%{champ1}\\\\\\\\\\\\\\\\%{champ2}\\\\end{pmatrix}',\n            KeyboardType.clavierDeBaseAvecFraction,\n          )\n      }\n\n      if (\n        this.questionJamaisPosee(\n          i,\n          xABFraction.texFraction,\n          yABFraction.texFraction,\n        )\n      ) {\n        // Si la question n'a jamais été posée, on en créé une autre\n        this.listeQuestions[i] = texte\n        this.listeCorrections[i] = texteCorr\n        i++\n      }\n      cpt++\n    }\n    listeQuestionsToContenu(this)\n  }\n}\n"],"names":["interactifReady","interactifType","titre","dateDeModifImportante","uuid","refs","Calculercoordonneesvecteurs","Exercice","i","cpt","texte","texteCorr","xA","yA","xB","yB","xABFraction","yABFraction","r","nomsPoints","creerNomDePolygone","objets","randint","FractionEtendue","Repere","ecritureParentheseSiNegatif","miseEnEvidence","listeFractions1","frac1","choice","frac2","xDeA","yDeA","xDeB","yDeB","A","point","B","traceAetB","tracePoint","labelAetB","labelPoint","vecteurAB","vecteur","vecteurABRep","representant","O","nomO","texteParPosition","I","J","vecteurOI","segment","vecteurOJ","nomi","nomVecteurParPosition","nomj","nomAB","representantNomme","mathalea2d","fixeBordures","handleAnswers","listePoints","remplisLesBlancs","KeyboardType","listeQuestionsToContenu"],"mappings":"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"}