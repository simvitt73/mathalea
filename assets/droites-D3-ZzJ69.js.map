{"version":3,"file":"droites-D3-ZzJ69.js","sources":["../../src/lib/2d/Vecteur.ts","../../src/lib/2d/droites.ts"],"sourcesContent":["import type { IPointAbstrait, IVecteur } from './Interfaces'\nimport type { PointAbstrait } from './PointAbstrait'\n\nexport class Vecteur {\n  nom: string\n  x: number\n  y: number\n\n  // Surcharges\n  constructor(x: number, y: number, nom?: string)\n  constructor(\n    A: PointAbstrait | IPointAbstrait,\n    B: PointAbstrait | IPointAbstrait,\n    nom?: string,\n  )\n  constructor(\n    a: number | PointAbstrait | IPointAbstrait,\n    b: number | PointAbstrait | IPointAbstrait,\n    nom: string = '',\n  ) {\n    this.nom = nom ?? ''\n\n    const isPointLike = (v: unknown): v is { x: number; y: number } =>\n      typeof v === 'object' &&\n      v != null &&\n      'x' in (v as any) &&\n      'y' in (v as any)\n\n    if (typeof a === 'number' && typeof b === 'number') {\n      // Construction par composantes\n      this.x = a\n      this.y = b\n      return\n    }\n\n    if (isPointLike(a) && isPointLike(b)) {\n      // Construction par deux points A -> B\n      this.x = b.x - a.x\n      this.y = b.y - a.y\n      return\n    }\n\n    // Cas invalide\n    window.notify(\n      'Vecteur : utilisez (x: number, y: number) ou (A, B) pour construire un vecteur.',\n      { a, b, nom },\n    )\n    this.x = 0\n    this.y = 0\n  }\n\n  norme() {\n    return Math.sqrt(this.x ** 2 + this.y ** 2)\n  }\n\n  oppose() {\n    this.x = -this.x\n    this.y = -this.y\n  }\n\n  xSVG(coeff: number) {\n    return this.x * coeff\n  }\n\n  ySVG(coeff: number) {\n    return -this.y * coeff\n  }\n}\n\n/**\n * @example v = vecteur('V') // son nom\n * @example v = vecteur(x,y) // ses composantes\n * @example v = vecteur(A,B) // son origine et son extrémité (deux Points)\n * @example v = vecteur(x,y,'v') // son nom et ses composantes.\n * @author Jean-Claude Lhote et Rémi Angot\n */\n// Surcharges pour la fabrique\n\nexport function vecteur(x: number, y: number, nom?: string): IVecteur\nexport function vecteur(\n  A: PointAbstrait | IPointAbstrait,\n  B: PointAbstrait | IPointAbstrait,\n  nom?: string,\n): IVecteur\nexport function vecteur(\n  a: number | PointAbstrait | IPointAbstrait,\n  b: number | PointAbstrait | IPointAbstrait,\n  nom: string = '',\n): IVecteur {\n  return new Vecteur(a as any, b as any, nom)\n}\n","import { context } from '../../modules/context'\nimport { egal } from '../../modules/outils'\nimport { arrondi } from '../outils/nombres'\nimport { colorToLatexOrHTML } from './colorToLatexOrHtml'\nimport { ObjetMathalea2D } from './ObjetMathalea2D'\nimport { PointAbstrait, pointAbstrait } from './PointAbstrait'\nimport { segment } from './segmentsVecteurs'\nimport {\n  Latex2d,\n  latex2d,\n  TexteParPoint,\n  texteParPosition,\n  type LetterSizeType,\n} from './textes'\nimport { angleOriente, norme } from './utilitairesGeometriques'\nimport { pointSurDroite, pointSurSegment } from './utilitairesPoint'\nimport { Vecteur, vecteur } from './Vecteur'\nimport { vide2d } from './Vide2d'\n\n/**\n * Ajouter une étiquette sur une droite.\n * @param {*} droite La droite où on va rajouter une étiquette\n * @param {*} nom Le nom de la droite doit être en latex et sera rendu avec Latex2d (donc en mode math) : Ne pas mettre de $ $ !\n * @param {*} options Les options permettant de personnaliser la position de l'étiquette et la mise en forme\n *  options.preferedPosition La position à privilégier si possible sur le bord de l'image ('left', 'right', 'above', 'below')\n *  options.usedPosition Un tableau des anciennes positions déjà allouées pour éviter les colisions avec des étiquettes d'autres droites\n *  options.taille La taille de la police de l'étiquette par défaut 6\n *  options.color La couleur de l'étiquette par défaut 'red'\n * @returns {Latex2d} L'étiquette\n *\n * Exemple :\n *   context.fenetreMathalea2d = [xmin + 0.2, ymin, xmax, ymax] // important pour la position des labels\n *   const d3nom = labelOnLine(d3, '$' + noms[3] + '$', { color: 'blue', taille: 8, preferedPosition: 'left' })\n *   const d0nom = labelOnLine(d0, '$' + noms[0] + '$', { color: 'red', taille: 8, usedPosition: [d3nom] })\n *\n * @author Mickael Guironnet\n * Modifications par Jean-Claude Lhote : factorisation dans droites.ts, passage en typescript et utilisation de latex2d à la place de LAtexParCoordonneesBox\n */\nexport function labelOnLine(\n  droite: Droite,\n  nom: string,\n  {\n    preferedPosition = 'auto',\n    usedPosition = [],\n    letterSize = 'footnotesize',\n    color = 'red',\n    backgroundColor = 'white',\n  }: {\n    preferedPosition?: 'left' | 'right' | 'above' | 'below' | 'auto'\n    usedPosition?: Latex2d[]\n    letterSize?: LetterSizeType\n    color?: string\n    backgroundColor?: string\n  } = {},\n): Latex2d | ObjetMathalea2D {\n  const debug = false\n  const largeur = 30\n  const hauteur = 20\n  let absNom, ordNom, leNom, anchor\n  let oneUsedPosition\n  const positions: {\n    label: Latex2d\n    position: string\n    anch: string\n    colision: [number, boolean][]\n  }[] = []\n  if (nom !== '') {\n    if (egal(droite.b, 0, 0.05)) {\n      // ax+c=0 x=-c/a est l'équation de la droite\n      // droite quasi verticale\n      absNom =\n        -droite.c / droite.a +\n        (largeur * 0.5) / context.pixelsParCm +\n        2 / context.pixelsParCm\n      ordNom = context.fenetreMathalea2d[1] + 1 // l'ordonnée du label est ymin +1\n      anchor = 'right'\n      oneUsedPosition = 'below'\n      leNom = latex2d(nom, absNom, ordNom, {\n        color,\n        backgroundColor: 'white',\n        letterSize,\n      })\n      positions.push({\n        label: leNom,\n        position: oneUsedPosition,\n        anch: anchor,\n        colision: [],\n      })\n    } else if (egal(droite.a, 0, 0.05)) {\n      // by+c=0 y=-c/b est l'équation de la droite\n      // droite quasi horizontale\n      absNom = context.fenetreMathalea2d[0] + 1 // l'abscisse du label est xmin +1\n      ordNom = -droite.c / droite.b + (hauteur * 0.5) / context.pixelsParCm\n      anchor = 'above'\n      oneUsedPosition = 'left'\n      leNom = latex2d(nom, absNom, ordNom, {\n        color,\n        backgroundColor: 'white',\n        letterSize,\n      })\n      positions.push({\n        label: leNom,\n        position: oneUsedPosition,\n        anch: anchor,\n        colision: [],\n      })\n    } else {\n      // a et b sont différents de 0 ax+by+c=0 est l'équation\n      // y=(-a.x-c)/b est l'equation cartésienne et x=(-by-c)/a\n      const y0 =\n        (-droite.a * (context.fenetreMathalea2d[0] + 1) - droite.c) / droite.b\n      const y1 =\n        (-droite.a * (context.fenetreMathalea2d[2] - 1) - droite.c) / droite.b\n      const x0 =\n        (-droite.b * (context.fenetreMathalea2d[1] + 1) - droite.c) / droite.a\n      const x1 =\n        (-droite.b * (context.fenetreMathalea2d[3] - 1) - droite.c) / droite.a\n      if (\n        y0 > context.fenetreMathalea2d[1] &&\n        y0 < context.fenetreMathalea2d[3]\n      ) {\n        // à gauche : soit en dessous ou en dessous\n        absNom = context.fenetreMathalea2d[0] + 1\n        ordNom =\n          y0 -\n          droite.pente * ((largeur * 0.5) / context.pixelsParCm) +\n          ((droite.pente > 0 ? -1 : 1) * hauteur * 0.5) / context.pixelsParCm\n        anchor = droite.pente > 0 ? 'below' : 'above'\n        oneUsedPosition = 'left'\n        if (\n          ordNom < context.fenetreMathalea2d[1] + 1 ||\n          ordNom > context.fenetreMathalea2d[3] - 1\n        ) {\n          if (debug)\n            console.info(\n              'probl:nom:' +\n                nom +\n                ':position:' +\n                oneUsedPosition +\n                (context.fenetreMathalea2d[1] + 1) +\n                '<' +\n                ordNom +\n                '<' +\n                (context.fenetreMathalea2d[3] - 1),\n            )\n        } else {\n          leNom = latex2d(nom, absNom, ordNom, {\n            color,\n            backgroundColor: 'white',\n            letterSize,\n          })\n          positions.push({\n            label: leNom,\n            position: oneUsedPosition,\n            anch: anchor,\n            colision: [],\n          })\n        }\n        // à gauche : soit en dessous ou en dessous\n        absNom = context.fenetreMathalea2d[0] + 1\n        ordNom =\n          y0 +\n          droite.pente * ((largeur * 0.5) / context.pixelsParCm) -\n          ((droite.pente > 0 ? -1 : 1) * hauteur * 0.5) / context.pixelsParCm\n        anchor = droite.pente > 0 ? 'above' : 'below'\n        oneUsedPosition = 'left'\n        if (\n          ordNom < context.fenetreMathalea2d[1] + 1 ||\n          ordNom > context.fenetreMathalea2d[3] - 1\n        ) {\n          if (debug)\n            console.info(\n              'probl:nom:' +\n                nom +\n                ':position:' +\n                oneUsedPosition +\n                (context.fenetreMathalea2d[1] + 1) +\n                '<' +\n                ordNom +\n                '<' +\n                (context.fenetreMathalea2d[3] - 1),\n            )\n        } else {\n          leNom = latex2d(nom, absNom, ordNom, {\n            color,\n            backgroundColor: 'white',\n            letterSize,\n          })\n          positions.push({\n            label: leNom,\n            position: oneUsedPosition,\n            anch: anchor,\n            colision: [],\n          })\n        }\n      }\n      if (\n        y1 > context.fenetreMathalea2d[1] &&\n        y1 < context.fenetreMathalea2d[3]\n      ) {\n        // à droite\n        absNom = context.fenetreMathalea2d[2] - 1\n        ordNom =\n          y1 -\n          droite.pente * ((largeur * 0.5) / context.pixelsParCm) +\n          ((droite.pente > 0 ? -1 : 1) * hauteur * 0.5) / context.pixelsParCm\n        anchor = droite.pente > 0 ? 'below' : 'above'\n        oneUsedPosition = 'right'\n        if (\n          ordNom < context.fenetreMathalea2d[1] + 1 ||\n          ordNom > context.fenetreMathalea2d[3] - 1\n        ) {\n          if (debug)\n            console.info(\n              'probl:nom:' +\n                nom +\n                ':position:' +\n                oneUsedPosition +\n                (context.fenetreMathalea2d[1] + 1) +\n                '<' +\n                ordNom +\n                '<' +\n                (context.fenetreMathalea2d[3] - 1),\n            )\n        } else {\n          leNom = latex2d(nom, absNom, ordNom, {\n            color,\n            backgroundColor: 'white',\n            letterSize,\n          })\n          positions.push({\n            label: leNom,\n            position: oneUsedPosition,\n            anch: anchor,\n            colision: [],\n          })\n        }\n      }\n      if (\n        x0 > context.fenetreMathalea2d[0] &&\n        x0 < context.fenetreMathalea2d[2]\n      ) {\n        // en bas : soit à gauche ou à droite\n        absNom =\n          x0 +\n          ((droite.pente > 0 ? -1 : 1) * largeur * 0.5) / context.pixelsParCm -\n          ((droite.pente > 0 ? 1 : 1) *\n            ((hauteur * 0.5) / context.pixelsParCm)) /\n            droite.pente -\n          ((droite.pente > 0 ? 1 : -1) * 2) / context.pixelsParCm\n        ordNom = context.fenetreMathalea2d[1] + 1\n        anchor = droite.pente > 0 ? 'left' : 'right'\n        oneUsedPosition = 'below'\n        if (\n          absNom < context.fenetreMathalea2d[0] + 1 ||\n          absNom > context.fenetreMathalea2d[2] - 1\n        ) {\n          if (debug)\n            console.info(\n              'problème:nom:' +\n                nom +\n                ':position:' +\n                oneUsedPosition +\n                (context.fenetreMathalea2d[0] + 1) +\n                '<' +\n                absNom +\n                '<' +\n                (context.fenetreMathalea2d[2] - 1),\n            )\n        } else {\n          leNom = latex2d(nom, absNom, ordNom, {\n            color,\n            backgroundColor: 'white',\n            letterSize,\n          })\n          positions.push({\n            label: leNom,\n            position: oneUsedPosition,\n            anch: anchor,\n            colision: [],\n          })\n        }\n        // en bas de l'autre côté\n        absNom =\n          x0 -\n          ((droite.pente > 0 ? -1 : 1) * largeur * 0.5) / context.pixelsParCm +\n          ((droite.pente > 0 ? 1 : 1) *\n            ((hauteur * 0.5) / context.pixelsParCm)) /\n            droite.pente +\n          ((droite.pente > 0 ? 1 : -1) * 2) / context.pixelsParCm\n        ordNom = context.fenetreMathalea2d[1] + 1\n        anchor = droite.pente > 0 ? 'right' : 'left'\n        oneUsedPosition = 'below'\n        if (\n          absNom < context.fenetreMathalea2d[0] + 1 ||\n          absNom > context.fenetreMathalea2d[2] - 1\n        ) {\n          if (debug)\n            console.info(\n              'problème:nom:' +\n                nom +\n                ':position:' +\n                oneUsedPosition +\n                (context.fenetreMathalea2d[0] + 1) +\n                '<' +\n                absNom +\n                '<' +\n                (context.fenetreMathalea2d[2] - 1),\n            )\n        } else {\n          leNom = latex2d(nom, absNom, ordNom, {\n            color,\n            backgroundColor: 'white',\n            letterSize,\n          })\n          positions.push({\n            label: leNom,\n            position: oneUsedPosition,\n            anch: anchor,\n            colision: [],\n          })\n        }\n      }\n      if (\n        x1 > context.fenetreMathalea2d[0] &&\n        x1 < context.fenetreMathalea2d[2]\n      ) {\n        // au haut : soit à gauche ou à droite\n        absNom =\n          x1 +\n          ((droite.pente > 0 ? -1 : 1) * largeur * 0.5) / context.pixelsParCm -\n          ((droite.pente > 0 ? 1 : 1) *\n            ((hauteur * 0.5) / context.pixelsParCm)) /\n            droite.pente -\n          ((droite.pente > 0 ? 1 : -1) * 2) / context.pixelsParCm\n        ordNom = context.fenetreMathalea2d[3] - 1\n        anchor = droite.pente > 0 ? 'left' : 'right'\n        oneUsedPosition = 'above'\n        if (\n          absNom < context.fenetreMathalea2d[0] + 1 ||\n          absNom > context.fenetreMathalea2d[2] - 1\n        ) {\n          if (debug)\n            console.info(\n              'problème:nom:' +\n                nom +\n                ':position:' +\n                oneUsedPosition +\n                (context.fenetreMathalea2d[0] + 1) +\n                '<' +\n                absNom +\n                '<' +\n                (context.fenetreMathalea2d[2] - 1),\n            )\n        } else {\n          leNom = latex2d(nom, absNom, ordNom, {\n            color,\n            backgroundColor: 'white',\n            letterSize,\n          })\n          positions.push({\n            label: leNom,\n            position: oneUsedPosition,\n            anch: anchor,\n            colision: [],\n          })\n        }\n        // au haut de l'autre côté\n        absNom =\n          x1 -\n          ((droite.pente > 0 ? -1 : 1) * largeur * 0.5) / context.pixelsParCm +\n          ((droite.pente > 0 ? 1 : 1) *\n            ((hauteur * 0.5) / context.pixelsParCm)) /\n            droite.pente +\n          ((droite.pente > 0 ? 1 : -1) * 2) / context.pixelsParCm\n        ordNom = context.fenetreMathalea2d[3] - 1\n        anchor = droite.pente > 0 ? 'right' : 'left'\n        oneUsedPosition = 'above'\n        if (\n          absNom < context.fenetreMathalea2d[0] + 1 ||\n          absNom > context.fenetreMathalea2d[2] - 1\n        ) {\n          if (debug)\n            console.info(\n              'problème:nom:' +\n                nom +\n                ':position:' +\n                oneUsedPosition +\n                (context.fenetreMathalea2d[0] + 1) +\n                '<' +\n                absNom +\n                '<' +\n                (context.fenetreMathalea2d[2] - 1),\n            )\n        } else {\n          leNom = latex2d(nom, absNom, ordNom, {\n            color,\n            backgroundColor: 'white',\n            letterSize,\n          })\n          positions.push({\n            label: leNom,\n            position: oneUsedPosition,\n            anch: anchor,\n            colision: [],\n          })\n        }\n      }\n      let xgauche, xdroite\n      if (\n        y0 > context.fenetreMathalea2d[1] &&\n        y0 < context.fenetreMathalea2d[3]\n      ) {\n        xgauche = context.fenetreMathalea2d[0]\n      } else {\n        xgauche = Math.min(x0, x1)\n      }\n      if (\n        y1 > context.fenetreMathalea2d[1] &&\n        y1 < context.fenetreMathalea2d[3]\n      ) {\n        xdroite = context.fenetreMathalea2d[2]\n      } else {\n        xdroite = Math.max(x0, x1)\n      }\n      // au milieu\n      absNom = (xgauche + xdroite) / 2\n      ordNom = pointSurDroite(droite, absNom, '').y\n      anchor = droite.pente > 0 ? 'left' : 'right'\n      oneUsedPosition = 'middle'\n      leNom = latex2d(nom, absNom, ordNom, {\n        color,\n        backgroundColor: 'white',\n        letterSize,\n      })\n      positions.push({\n        label: leNom,\n        position: oneUsedPosition,\n        anch: anchor,\n        colision: [],\n      })\n    }\n    leNom = latex2d(nom, absNom, ordNom, {\n      color,\n      backgroundColor: 'white',\n      letterSize,\n    })\n\n    // vérifie s'il y a des colisions entre labels\n    for (let i = 0; i < positions.length; i++) {\n      if (positions[i].position === 'middle') continue\n      const coli: [number, boolean][] = []\n      for (let j = 0; j < usedPosition.length; j++) {\n        const label = usedPosition[j]\n        const dis =\n          Math.sqrt(\n            (label.x - positions[i].label.x) ** 2 +\n              (label.y - positions[i].label.y) ** 2,\n          ) * context.pixelsParCm\n        // colision deux rectangles\n        const XYlabel = [\n          label.x * context.pixelsParCm - largeur / 2,\n          label.x * context.pixelsParCm + largeur / 2,\n          label.y * context.pixelsParCm - hauteur / 2,\n          label.y * context.pixelsParCm + hauteur / 2,\n        ]\n        const XYlabel2 = [\n          positions[i].label.x * context.pixelsParCm - largeur / 2,\n          positions[i].label.x * context.pixelsParCm + largeur / 2,\n          positions[i].label.y * context.pixelsParCm - hauteur / 2,\n          positions[i].label.y * context.pixelsParCm + hauteur / 2,\n        ]\n        if (debug)\n          console.info(\n            'coli:nom:' +\n              nom +\n              ':position:' +\n              positions[i].position +\n              ':i:' +\n              i +\n              ':j:' +\n              j +\n              ':dis:' +\n              dis.toFixed(2) +\n              ':texte:' +\n              label.latex +\n              ':XYlabel:' +\n              XYlabel[0].toFixed(1) +\n              ',' +\n              XYlabel[1].toFixed(1) +\n              ',' +\n              XYlabel[2].toFixed(1) +\n              ',' +\n              XYlabel[3].toFixed(1) +\n              ':XYlabel2:' +\n              XYlabel2[0].toFixed(1) +\n              ',' +\n              XYlabel2[1].toFixed(1) +\n              ',' +\n              XYlabel2[2].toFixed(1) +\n              ',' +\n              XYlabel2[3].toFixed(1),\n          )\n        const colision =\n          XYlabel[0] < XYlabel2[1] &&\n          XYlabel[1] > XYlabel2[0] &&\n          XYlabel[2] < XYlabel2[3] &&\n          XYlabel[3] > XYlabel2[2]\n        // colision deux cercles\n        const r0 = Math.max(largeur / 2, hauteur / 2)\n        const r1 = Math.max(largeur / 2, hauteur / 2)\n        let colision2 = true\n        if (dis > r0 + r1 || dis < Math.abs(r0 - r1)) colision2 = false\n        coli[j] = [dis, colision]\n        if (debug)\n          console.info(\n            'coli:nom:' +\n              nom +\n              ':position:' +\n              positions[i].position +\n              ':anchor:' +\n              positions[i].anch +\n              ':i:' +\n              i +\n              ':j:' +\n              j +\n              ':dis:' +\n              dis.toFixed(2) +\n              'texte:' +\n              label.latex +\n              ':colision:' +\n              (colision ? '1' : '0') +\n              ':coli_cer:' +\n              (colision2 ? '1' : '0'),\n          )\n      }\n      positions[i].colision = [...coli]\n    }\n    // 1ere stratégie : la préférence de l'utilisateur\n    // on vérifie seulement s'il y a une colision\n    const found: [boolean, number] = [false, 0]\n    for (let i = 0; i < positions.length && !found[0]; i++) {\n      if (positions[i].position === 'middle') continue\n      if (positions[i].position === preferedPosition) {\n        found[0] = true\n        for (let j = 0; j < usedPosition.length; j++) {\n          if (positions[i].colision[j][1]) found[0] = false\n          if (debug)\n            console.info(\n              '1er:nom:' +\n                nom +\n                ':position:' +\n                positions[i].position +\n                ':i:' +\n                i +\n                ':j:' +\n                j +\n                ':colision:' +\n                positions[i].colision[j][1] +\n                ':preferedPosition:' +\n                preferedPosition,\n            )\n        }\n        found[1] = i\n      }\n    }\n\n    // 2e stratégie : le plus loin en terme de distance!\n    let disMax = [0, 0, 0]\n    for (\n      let i = 0;\n      i < positions.length && !found[0] && usedPosition.length > 0;\n      i++\n    ) {\n      if (positions[i].position === 'middle') continue\n      let dis = [1000, 0, 0]\n      for (let j = 0; j < usedPosition.length; j++) {\n        if (positions[i].colision[j][0] < dis[0]) {\n          dis = [positions[i].colision[j][0], i, j]\n          if (debug)\n            console.info(\n              '2e:nom:' +\n                nom +\n                ':position:' +\n                positions[i].position +\n                ':anchor:' +\n                positions[i].anch +\n                ':i:' +\n                i +\n                ':j:' +\n                j +\n                'dis:' +\n                dis[0].toFixed(2) +\n                ':colision:' +\n                positions[i].colision[j][1],\n            )\n        }\n      }\n      if (dis[0] > disMax[0]) {\n        disMax = dis\n        if (debug)\n          console.info(\n            'Max 2e:nom:' +\n              nom +\n              ':position:' +\n              positions[i].position +\n              ':anchor:' +\n              positions[i].anch +\n              ':i:' +\n              i +\n              'dis:' +\n              dis[0].toFixed(2),\n          )\n      }\n    }\n    let colision = false\n    if (disMax[0] > 0) {\n      colision = positions[disMax[1]].colision[disMax[2]][1]\n      if (debug)\n        console.info(\n          'Max fin : 2e:nom:' +\n            nom +\n            ':position:' +\n            positions[disMax[1]].position +\n            ':anchor:' +\n            positions[disMax[1]].anch +\n            ':i:' +\n            disMax[1] +\n            ':j:' +\n            disMax[2] +\n            'disMax:' +\n            disMax[0] +\n            ':colision:' +\n            positions[disMax[1]].colision[disMax[2]][1],\n        )\n    }\n    // 1er : si préférence alors Ok sinon distance la plus loin sans chevauchement sinon la première solution si pas de comparaison sinon la dernière milieu\n    leNom = found[0]\n      ? positions[found[1]].label\n      : disMax[0] > 0 && !colision\n        ? positions[disMax[1]].label\n        : positions[usedPosition.length === 0 ? 0 : positions.length - 1].label\n  } else {\n    leNom = vide2d()\n  }\n  return leNom\n}\n\n/**\n * Afin de régler le problème des noms de droites en latex qui ne peuvent se fondre dans le svg, cette fonction retourne un Array de deux objets :\n * Le premier est la droite (avec toutes ses propriétés et méthodes)\n * Le deuxième est un objet latexParCoordonnees\n * @param {Droite} d\n * @param {string} nom\n * @param {string} color\n * @returns {[Droite, LatexParCoordonnees|Vide2d]}\n */\nexport function droiteAvecNomLatex(d: Droite, nom: string, color = 'black') {\n  // nom est un latexParCoordonnees\n  d.color = colorToLatexOrHTML(color ?? 'black')\n  let absNom, ordNom\n  d.epaisseur = 1\n  d.opacite = 1\n  if (egal(d.b, 0, 0.05)) {\n    // ax+c=0 x=-c/a est l'équation de la droite\n    absNom = -d.c / d.a + 0.8 // l'abscisse du label est décalé de 0.8\n    ordNom = context.fenetreMathalea2d[1] + 1 // l'ordonnée du label est ymin +1\n  } else if (egal(d.a, 0, 0.05)) {\n    // by+c=0 y=-c/b est l'équation de la droite\n    absNom = context.fenetreMathalea2d[0] + 0.8 // l'abscisse du label est xmin +1\n    ordNom = -d.c / d.b + 0.8 // l'ordonnée du label est décalée de 0.8\n  } else {\n    // a et b sont différents de 0 ax+by+c=0 est l'équation\n    // y=(-a.x-c)/b est l'aquation cartésienne et x=(-by-c)/a\n    const y0 = (-d.a * (context.fenetreMathalea2d[0] + 1) - d.c) / d.b\n    const y1 = (-d.a * (context.fenetreMathalea2d[2] - 1) - d.c) / d.b\n    const x0 = (-d.b * (context.fenetreMathalea2d[1] + 1) - d.c) / d.a\n    const x1 = (-d.b * (context.fenetreMathalea2d[3] - 1) - d.c) / d.a\n    if (\n      y0 > context.fenetreMathalea2d[1] &&\n      y0 < context.fenetreMathalea2d[3]\n    ) {\n      absNom = context.fenetreMathalea2d[0] + 1\n      ordNom = y0 + d.pente\n    } else {\n      if (\n        y1 > context.fenetreMathalea2d[1] &&\n        y1 < context.fenetreMathalea2d[3]\n      ) {\n        absNom = context.fenetreMathalea2d[2] - 1\n        ordNom = y1 - d.pente\n      } else {\n        if (\n          x0 > context.fenetreMathalea2d[0] &&\n          x0 < context.fenetreMathalea2d[2]\n        ) {\n          absNom = x0\n          ordNom = context.fenetreMathalea2d[1] + Math.abs(d.pente)\n        } else {\n          if (\n            x1 > context.fenetreMathalea2d[0] &&\n            x1 < context.fenetreMathalea2d[2]\n          ) {\n            absNom = x1\n            ordNom = context.fenetreMathalea2d[3] + d.pente\n          } else {\n            absNom =\n              (context.fenetreMathalea2d[0] + context.fenetreMathalea2d[2]) / 2\n            ordNom = pointSurDroite(d, absNom, '').y\n          }\n        }\n      }\n    }\n  }\n  const leNom = latex2d(nom, absNom, ordNom, {\n    color,\n  })\n  return [d, leNom]\n}\n\n/**  Trace une droite\n * @param {PointAbstrait | number} arg1 Premier point de la droite OU BIEN coefficient a de l'équation de la droite ax+by+c=0\n * @param {PointAbstrait | number} arg2 Deuxième point de la droite OU BIEN coefficient b de l'équation de la droite ax+by+c=0\n * @param {string | number} arg3 Nom affiché de la droite OU BIEN coefficient c de l'équation de la droite ax+by+c=0\n * @param {string} arg4 Couleur de la droite : du type 'blue' ou du type '#f15929' OU BIEN Nom affiché de la droite si arg1 est un nombre\n * @param {string} arg5 Couleur de la droite : du type 'blue' ou du type '#f15929' si arg1 est un nombre\n * @property {string} svg Sortie au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} svgml Sortie, à main levée, au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} tikz Sortie au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @property {string} tikzml Sortie, à main levée, au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @property {number} a Coefficient a de l'équation de la droite ax+by+c=0\n * @property {number} b Coefficient b de l'équation de la droite ax+by+c=0\n * @property {number} c Coefficient c de l'équation de la droite ax+by+c=0\n * @property {number} x1 Abscisse de arg1 (si ce point existe)\n * @property {number} y1 Ordonnée de arg1 (si ce point existe)\n * @property {number} x2 Abscisse de arg2 (si ce point existe)\n * @property {number} y2 Ordonnée de arg2 (si ce point existe)\n * @property {string} nom Nom affiché de la droite\n * @property {string} color Couleur de la droite. À associer obligatoirement à colorToLatexOrHTML().\n * @property {Vecteur} normal Vecteur normal de la droite\n * @property {Vecteur} directeur Vecteur directeur de la droite\n * @property {number} angleAvecHorizontale Valeur de l'angle orienté entre la droite et l'horizontale\n * @property {number} epaisseur\n * @property {number} pointilles\n * @property {number} opacite\n * @author Jean-Claude Lhote\n * @class\n */\n// JSDOC Validee par EE Aout 2022\nexport class Droite extends ObjetMathalea2D {\n  x1: number\n  x2: number\n  y1: number\n  y2: number\n  a: number\n  b: number\n  c: number\n  pente: number\n  angleAvecHorizontale: number\n  nom: string\n  normal: Vecteur\n  directeur: Vecteur\n  stringColor: string\n  usePgfplots: boolean\n  pgfplotsOptions?: string\n  pgfplotsDomain?: {\n    xmin?: number\n    xmax?: number\n    ymin?: number\n    ymax?: number\n  }\n\n  leNom?: TexteParPoint\n  constructor(\n    arg1: number | PointAbstrait,\n    arg2: number | PointAbstrait,\n    arg3?: number | string,\n    arg4?: number | string,\n    arg5?: string,\n  ) {\n    super()\n    let a, b, c\n    this.stringColor = 'black'\n    this.usePgfplots = false\n\n    if (arguments.length === 2) {\n      if (arg1 instanceof PointAbstrait && arg2 instanceof PointAbstrait) {\n        this.x1 = arg1.x\n        this.x2 = arg2.x\n        this.y1 = arg1.y\n        this.y2 = arg2.y\n      } else {\n        window.notify(\n          'Droite : (attendus : A et B) les arguments de sont pas des points valides',\n          {\n            arg1,\n            arg2,\n          },\n        )\n        this.x1 = 0\n        this.x2 = 0\n        this.y1 = 0\n        this.y2 = 0\n      }\n      this.nom = ''\n      this.pointilles = 0\n      this.opacite = 1\n      this.epaisseur = 1\n      this.a = this.y1 - this.y2\n      this.b = this.x2 - this.x1\n      this.c = (this.x1 - this.x2) * this.y1 + (this.y2 - this.y1) * this.x1\n      this.pente = NaN\n    } else if (arguments.length === 3) {\n      if (typeof arg1 === 'number') {\n        if (isNaN(arg1) || Number.isNaN(arg2) || Number.isNaN(arg3)) {\n          window.notify(\n            'Droite : (attendus : a, b et c) les arguments de sont pas des nombres valides',\n            {\n              arg1,\n              arg2,\n              arg3,\n            },\n          )\n        }\n\n        // droite d'équation ax +by +c =0\n        this.nom = ''\n        this.a = Number(arg1)\n        this.b = Number(arg2)\n        this.c = Number(arg3)\n        a = Number(arg1)\n        b = Number(arg2)\n        c = Number(arg3)\n        if (egal(a, 0)) {\n          this.x1 = 0\n          this.x2 = 1\n          this.y1 = -c / b\n          this.y2 = -c / b\n        } else if (egal(b, 0)) {\n          this.y1 = 0\n          this.y2 = 1\n          this.x1 = -c / a\n          this.x2 = -c / a\n        } else {\n          this.x1 = 0\n          this.y1 = -c / b\n          this.x2 = 1\n          this.y2 = (-c - a) / b\n        }\n      } else {\n        if (\n          isNaN(arg1.x) ||\n          isNaN(arg1.y) ||\n          isNaN((arg2 as PointAbstrait).x) ||\n          isNaN((arg2 as PointAbstrait).y)\n        ) {\n          window.notify(\n            'Droite : (attendus : A, B et \"nom\") les arguments de sont pas des points valides',\n            {\n              arg1,\n              arg2,\n            },\n          )\n        }\n        this.x1 = arg1.x\n        this.y1 = arg1.y\n        this.x2 = (arg2 as PointAbstrait).x\n        this.y2 = (arg2 as PointAbstrait).y\n        this.a = this.y1 - this.y2\n        this.b = this.x2 - this.x1\n        this.c = (this.x1 - this.x2) * this.y1 + (this.y2 - this.y1) * this.x1\n        this.nom = String(arg3)\n      }\n    } else if (arguments.length === 4) {\n      if (typeof arg1 === 'number') {\n        if (isNaN(arg1) || Number.isNaN(arg2) || Number.isNaN(arg3)) {\n          window.notify(\n            'Droite : (attendus : a, b, c et \"nom\") les arguments de sont pas des nombres valides',\n            {\n              arg1,\n              arg2,\n              arg3,\n            },\n          )\n        }\n        this.a = Number(arg1)\n        this.b = Number(arg2)\n        this.c = Number(arg3)\n        a = Number(arg1)\n        b = Number(arg2)\n        c = Number(arg3)\n        this.nom = String(arg4)\n        if (egal(a, 0)) {\n          this.x1 = 0\n          this.x2 = 1\n          this.y1 = -c / b\n          this.y2 = -c / b\n        } else if (egal(b, 0)) {\n          this.y1 = 0\n          this.y2 = 1\n          this.x1 = -c / a\n          this.x2 = -c / a\n        } else {\n          this.x1 = 0\n          this.y1 = -c / b\n          this.x2 = 1\n          this.y2 = (-c - a) / b\n        }\n      } else {\n        if (\n          isNaN(arg1.x) ||\n          isNaN(arg1.y) ||\n          isNaN((arg2 as PointAbstrait).x) ||\n          isNaN((arg2 as PointAbstrait).y)\n        ) {\n          window.notify(\n            'Droite : (attendus : A, B, \"nom\" et \"couleur\") les arguments de sont pas des points valides',\n            {\n              arg1,\n              arg2,\n            },\n          )\n        }\n        this.x1 = arg1.x\n        this.y1 = arg1.y\n        this.x2 = (arg2 as PointAbstrait).x\n        this.y2 = (arg2 as PointAbstrait).y\n        this.a = this.y1 - this.y2\n        this.b = this.x2 - this.x1\n        this.c = (this.x1 - this.x2) * this.y1 + (this.y2 - this.y1) * this.x1\n        this.nom = String(arg3)\n        this.color = colorToLatexOrHTML(String(arg4))\n        this.stringColor = String(arg4)\n      }\n    } else {\n      // arguments.length === 5\n      if (Number.isNaN(arg1) || Number.isNaN(arg2) || Number.isNaN(arg3)) {\n        window.notify(\n          'Droite : (attendus : a, b, c et \"nom\") les arguments de sont pas des nombres valides',\n          {\n            arg1,\n            arg2,\n            arg3,\n          },\n        )\n      }\n      this.a = Number(arg1)\n      this.b = Number(arg2)\n      this.c = Number(arg3)\n      a = Number(arg1)\n      b = Number(arg2)\n      c = Number(arg3)\n      this.nom = String(arg4)\n      this.color = colorToLatexOrHTML(String(arg5))\n      this.stringColor = String(arg5)\n      if (egal(a, 0)) {\n        this.x1 = 0\n        this.x2 = 1\n        this.y1 = -c / b\n        this.y2 = -c / b\n      } else if (egal(b, 0)) {\n        this.y1 = 0\n        this.y2 = 1\n        this.x1 = -c / a\n        this.x2 = -c / a\n      } else {\n        this.x1 = 0\n        this.y1 = -c / b\n        this.x2 = 1\n        this.y2 = (-c - a) / b\n      }\n    }\n    if (this.b !== 0) this.pente = -this.a / this.b\n    else this.pente = NaN\n    let xsav, ysav\n    if (this.x1 > this.x2) {\n      xsav = this.x1\n      ysav = this.y1\n      this.x1 = this.x2 + 0\n      this.y1 = this.y2 + 0\n      this.x2 = xsav\n      this.y2 = ysav\n    }\n    // Limiter la taille des coordonnées à 2 décimales amplement suffisantes\n    this.x1 = arrondi(this.x1, 2)\n    this.y1 = arrondi(this.y1, 2)\n    this.x2 = arrondi(this.x2, 2)\n    this.y2 = arrondi(this.y2, 2)\n\n    this.normal = vecteur(this.a, this.b)\n    this.directeur = vecteur(this.b, -this.a)\n    this.angleAvecHorizontale = angleOriente(\n      pointAbstrait(1, 0),\n      pointAbstrait(0, 0),\n      pointAbstrait(this.directeur.x, this.directeur.y),\n    )\n    this.bordures = [\n      Math.min(this.x1, this.x2),\n      Math.min(this.y1, this.y2),\n      Math.max(this.x1, this.x2),\n      Math.max(this.y1, this.y2),\n    ]\n    let absNom: number\n    let ordNom: number\n    if (this.nom !== '') {\n      if (egal(this.b, 0, 0.05)) {\n        // ax+c=0 x=-c/a est l'équation de la droite\n        absNom = -this.c / this.a + 0.8 // l'abscisse du label est décalé de 0.8\n        ordNom = context.fenetreMathalea2d[1] + 1 // l'ordonnée du label est ymin +1\n      } else if (egal(this.a, 0, 0.05)) {\n        // by+c=0 y=-c/b est l'équation de la droite\n        absNom = context.fenetreMathalea2d[0] + 0.8 // l'abscisse du label est xmin +1\n        ordNom = -this.c / this.b + 0.8 // l'ordonnée du label est décalée de 0.8\n      } else {\n        // a et b sont différents de 0 ax+by+c=0 est l'équation\n        // y=(-a.x-c)/b est l'aquation cartésienne et x=(-by-c)/a\n        const y0 =\n          (-this.a * (context.fenetreMathalea2d[0] + 1) - this.c) / this.b\n        const y1 =\n          (-this.a * (context.fenetreMathalea2d[2] - 1) - this.c) / this.b\n        const x0 =\n          (-this.b * (context.fenetreMathalea2d[1] + 1) - this.c) / this.a\n        const x1 =\n          (-this.b * (context.fenetreMathalea2d[3] - 1) - this.c) / this.a\n        if (\n          y0 > context.fenetreMathalea2d[1] &&\n          y0 < context.fenetreMathalea2d[3]\n        ) {\n          absNom = context.fenetreMathalea2d[0] + 1\n          ordNom = y0 + this.pente\n        } else {\n          if (\n            y1 > context.fenetreMathalea2d[1] &&\n            y1 < context.fenetreMathalea2d[3]\n          ) {\n            absNom = context.fenetreMathalea2d[2] - 1\n            ordNom = y1 - this.pente\n          } else {\n            if (\n              x0 > context.fenetreMathalea2d[0] &&\n              x0 < context.fenetreMathalea2d[2]\n            ) {\n              absNom = x0\n              ordNom = context.fenetreMathalea2d[1] + Math.abs(this.pente)\n            } else {\n              if (\n                x1 > context.fenetreMathalea2d[0] &&\n                x1 < context.fenetreMathalea2d[2]\n              ) {\n                absNom = x1\n                ordNom = context.fenetreMathalea2d[3] + this.pente\n              } else {\n                absNom =\n                  (context.fenetreMathalea2d[0] +\n                    context.fenetreMathalea2d[2]) /\n                  2\n                ordNom = pointSurDroite(this, absNom, '').y\n              }\n            }\n          }\n        }\n      }\n      // if (this.nom.includes('$')) {\n      //   this.leNom = latex2d(this.nom.replaceAll('$', ''), absNom, ordNom, { color: this.stringColor })\n      // } else {\n      this.leNom = texteParPosition(\n        this.nom,\n        absNom,\n        ordNom,\n        0,\n        this.stringColor,\n        1,\n        'milieu',\n        true,\n      ) as TexteParPoint\n      //  }\n    }\n\n    if (this.nom.includes('$')) {\n      // On a du Latex, donc on ne peut pas utiliser droite() tel quel.\n      window.notify(\n        \"Droite() appelé avec un nom contenant du Latex... utiliser droiteAvecNom() à la place !\\nOn va retourner un array contenant la droite et un latexParCoordonnees dans un proche avenir !\\nIl faut donc adapter l'exo qui a provoqué ça.\\n Pour l'instant on retourne une droite sans nom.\",\n        { nom: this.nom },\n      )\n      // On retourne une droite sans nom accompagnée de son nom Latex\n      // return droiteAvecNomLAtex(new Droite(pointAbstrait(this.x1, this.y1), pointAbstrait(this.x2, this.y2)), leNom)\n      // @fixme la ligne suivante sera à retirer lorsque les exos concernés auront été repérés. Et la précédente à utiliser.\n      return new Droite(\n        pointAbstrait(this.x1, this.y1),\n        pointAbstrait(this.x2, this.y2),\n      ) // On retourne une droite sans nom en attendant que quelqu'un adapte l'exo et utilise droiteAvecNom() à la place de droite.\n    }\n  }\n\n  svg(coeff: number) {\n    if (this.epaisseur !== 1) {\n      this.style += ` stroke-width=\"${this.epaisseur}\" `\n    }\n    switch (this.pointilles) {\n      case 1:\n        this.style += ' stroke-dasharray=\"6 10\" '\n        break\n      case 2:\n        this.style += ' stroke-dasharray=\"6 3\" '\n        break\n      case 3:\n        this.style += ' stroke-dasharray=\"3 2 6 2 \" '\n        break\n      case 4:\n        this.style += ' stroke-dasharray=\"1 2\" '\n        break\n      case 5:\n        this.style += ' stroke-dasharray=\"5 5\" '\n        break\n    }\n    if (this.opacite !== 1) {\n      this.style += ` stroke-opacity=\"${this.opacite}\" `\n    }\n    const A = pointAbstrait(this.x1, this.y1)\n    const B = pointAbstrait(this.x2, this.y2)\n    const A1 = pointSurSegment(A, B, -50)\n    const B1 = pointSurSegment(B, A, -50)\n    if (this.nom === '') {\n      return `<line x1=\"${A1.xSVG(coeff)}\" y1=\"${A1.ySVG(coeff)}\" x2=\"${B1.xSVG(\n        coeff,\n      )}\" y2=\"${B1.ySVG(coeff)}\" stroke=\"${this.color[0]}\" ${this.style} id =\"${this.id}\" />`\n    } else {\n      return (\n        `<line x1=\"${A1.xSVG(coeff)}\" y1=\"${A1.ySVG(coeff)}\" x2=\"${B1.xSVG(\n          coeff,\n        )}\" y2=\"${B1.ySVG(coeff)}\" stroke=\"${this.color[0]}\" ${this.style} id =\"${this.id}\" />` +\n        (this.leNom != null ? (this.leNom?.svg(coeff) ?? '') : '')\n      )\n    }\n  }\n\n  tikz(\n    axisYMin?: number,\n    axisYMax?: number,\n    axisXMin?: number,\n    axisXMax?: number,\n  ) {\n    const tableauOptions: string[] = []\n    if (this.color[1].length > 1 && this.color[1] !== 'black') {\n      tableauOptions.push(`color=${this.color[1]}`)\n    }\n    if (this.epaisseur !== 1) {\n      tableauOptions.push(`line width = ${this.epaisseur}`)\n    }\n    switch (this.pointilles) {\n      case 1:\n        tableauOptions.push(' dash dot ')\n        break\n      case 2:\n        tableauOptions.push(' densely dash dot dot ')\n        break\n      case 3:\n        tableauOptions.push(' dash dot dot ')\n        break\n      case 4:\n        tableauOptions.push(' dotted ')\n        break\n      case 5:\n        tableauOptions.push(' dashed ')\n        break\n    }\n\n    if (this.opacite !== 1) {\n      tableauOptions.push(`opacity = ${this.opacite}`)\n    }\n\n    const optionsDraw =\n      tableauOptions.length > 0 ? '[' + tableauOptions.join(',') + ']' : ''\n\n    const shouldUsePgfplots =\n      this.usePgfplots &&\n      axisYMin !== undefined &&\n      axisYMax !== undefined &&\n      axisXMin !== undefined &&\n      axisXMax !== undefined\n\n    const formatNombre = (val: number) =>\n      Number.isFinite(val) ? Number(val.toFixed(4)).toString() : '0'\n    const formatSlope = (val: number) => {\n      const formatted = Number(val.toFixed(6))\n      if (Math.abs(formatted) < 1e-9) return '0'\n      return formatted.toString()\n    }\n\n    if (shouldUsePgfplots) {\n      const pgfplotsOptions = [...tableauOptions]\n      if (this.pgfplotsOptions && this.pgfplotsOptions.trim() !== '') {\n        pgfplotsOptions.push(this.pgfplotsOptions)\n      }\n      const domainMin = this.pgfplotsDomain?.xmin ?? axisXMin\n      const domainMax = this.pgfplotsDomain?.xmax ?? axisXMax\n      const rangeMin = this.pgfplotsDomain?.ymin ?? axisYMin\n      const rangeMax = this.pgfplotsDomain?.ymax ?? axisYMax\n      const optionsList = [...pgfplotsOptions]\n      const vertical = egal(this.b, 0, 0.0001)\n      let code = ''\n      if (vertical) {\n        const xValue = formatNombre(this.x1)\n        const coordYMin = formatNombre(rangeMin ?? axisYMin)\n        const coordYMax = formatNombre(rangeMax ?? axisYMax)\n        const options =\n          optionsList.length > 0 ? '[' + optionsList.join(',') + ']' : ''\n        code += `\\\\addplot${options} coordinates {(${xValue},${coordYMin}) (${xValue},${coordYMax})};\\n`\n      } else {\n        const slope = (this.y2 - this.y1) / (this.x2 - this.x1)\n        const intercept = this.y1 - slope * this.x1\n        if (domainMin !== undefined && domainMax !== undefined) {\n          optionsList.push(\n            `domain=${formatNombre(domainMin)}:${formatNombre(domainMax)}`,\n          )\n        }\n        if (rangeMin !== undefined && rangeMax !== undefined) {\n          optionsList.push(\n            `restrict y to domain=${formatNombre(rangeMin)}:${formatNombre(rangeMax)}`,\n          )\n        }\n        const options =\n          optionsList.length > 0 ? '[' + optionsList.join(',') + ']' : ''\n        const slopeStr = formatSlope(slope)\n        const interceptStr = formatSlope(intercept)\n        const expression = interceptStr.startsWith('-')\n          ? `${slopeStr}*x${interceptStr}`\n          : `${slopeStr}*x+${interceptStr}`\n        code += `\\\\addplot${options} {${expression}};\\n`\n      }\n      return code\n    }\n\n    const A = pointAbstrait(this.x1, this.y1)\n    const B = pointAbstrait(this.x2, this.y2)\n    const A1 = pointSurSegment(A, B, -50)\n    const B1 = pointSurSegment(B, A, -50)\n\n    if (this.nom !== '') {\n      return (\n        `\\\\draw${optionsDraw} (${A1.x},${A1.y})--(${B1.x},${B1.y});` +\n        (this.leNom != null ? (this.leNom?.tikz() ?? '') : '')\n      )\n    } else {\n      return `\\\\draw${optionsDraw} (${A1.x},${A1.y})--(${B1.x},${B1.y});`\n    }\n  }\n\n  svgml(coeff: number, amp: number) {\n    const A = pointAbstrait(this.x1, this.y1)\n    const B = pointAbstrait(this.x2, this.y2)\n    const A1 = pointSurSegment(A, B, -50)\n    const B1 = pointSurSegment(B, A, -50)\n    const s = segment(A1, B1, this.color[0])\n    return s.svgml(coeff, amp)\n  }\n\n  tikzml(amp: number) {\n    const A = pointAbstrait(this.x1, this.y1)\n    const B = pointAbstrait(this.x2, this.y2)\n    const A1 = pointSurSegment(A, B, -50)\n    const B1 = pointSurSegment(B, A, -50)\n    const s = segment(A1, B1, this.color[1])\n    return s.tikzml(amp)\n  }\n}\n\n/**  Trace une droite définie par 2 points OU BIEN par les coefficients de son équation\n * @property {number} epaisseur\n * @param {PointAbstrait | number} arg1 Premier point de la droite OU BIEN coefficient a de l'équation de la droite ax+by+c=0 avec (a,b)!=(0,0)\n * @param {PointAbstrait | number} arg2 Deuxième point de la droite OU BIEN coefficient b de l'équation de la droite ax+by+c=0 avec (a,b)!=(0,0)\n * @param {string | number} arg3 Nom affiché de la droite OU BIEN coefficient c de l'équation de la droite ax+by+c=0\n * @param {string} arg4 Couleur de la droite : du type 'blue' ou du type '#f15929' OU BIEN nom affiché de la droite si arg1 est un nombre\n * @param {string} arg5 Couleur de la droite : du type 'blue' ou du type '#f15929' si arg1 est un nombre\n * @example droite(M, N, '(d1)') // Trace la droite passant par M et N se nommant (d1) et de couleur noire\n * @example droite(M, N, '(d1)','blue') // Trace la droite passant par M et N se nommant (d1) et de couleur bleue\n * @example droite(m, n, p) // Trace la droite définie par les coefficients de mx+ny+p=0 et de couleur noire\n * @example droite(m, n, p, '(d1)', 'red') // Trace la droite définie par les coefficients de mx+ny+p=0, se nommant (d1) et de couleur rouge\n * @author Jean-Claude Lhote\n * @return {Droite}\n */\nexport function droite(\n  arg1: number | PointAbstrait,\n  arg2: number | PointAbstrait,\n  arg3?: number | string,\n  arg4?: number | string,\n  arg5?: string,\n) {\n  if (arguments.length === 2) return new Droite(arg1, arg2)\n  if (arguments.length === 3) return new Droite(arg1, arg2, arg3)\n  if (arguments.length === 4) return new Droite(arg1, arg2, arg3, arg4)\n  return new Droite(arg1, arg2, arg3, arg4, arg5)\n}\n\n/**  Donne la position du point A par rapport à la droite d\n * @param {Droite} d\n * @param {PointAbstrait} A\n * @param {number} [tolerance = 0.0001] Seuil de tolérance pour évaluer la proximité entre d et A.\n * @example dessousDessus(d1, M) // Renvoie la position de M par rapport à d1 parmi ces 5 possibilités : 'sur', 'droite', 'gauche', 'dessous', 'dessus'\n * @example dessousDessus(d1, M, 0.005) // Renvoie la position de M par rapport à d1 parmi ces 5 possibilités : 'sur', 'droite', 'gauche', 'dessous', 'dessus' (avec une tolérance de 0,005)\n * @return {'sur' | 'droite' | 'gauche' | 'dessous' | 'dessus'}\n */\n// JSDOC Validee par EE Aout 2022\n\nexport function dessousDessus(d: Droite, A: PointAbstrait, tolerance = 0.0001) {\n  if (egal(d.a * A.x + d.b * A.y + d.c, 0, tolerance)) return 'sur'\n  if (egal(d.b, 0)) {\n    if (A.x < -d.c / d.a) return 'gauche'\n    else return 'droite'\n  } else {\n    if (d.a * A.x + d.b * A.y + d.c < 0) return 'dessous'\n    else return 'dessus'\n  }\n}\n\n/**\n *\n * @param {Droite} d\n * @param {object} param1 les bordures de la fenêtre\n * @param {number} param1.xmin\n * @param {number} param1.xmax\n * @param {number} param1.ymin\n * @param {number} param1.ymax\n * @return {PointAbstrait} le point qui servira à placer le label.\n */\nexport function positionLabelDroite(\n  d: Droite,\n  { xmin = 0, ymin = 0, xmax = 10, ymax = 10 },\n) {\n  let xLab, yLab\n  let fXmax, fYmax, fXmin, fYmin\n  if (d.b === 0) {\n    // Si la droite est verticale son équation est x = -d.c/d.a on choisit un label au Nord.\n    xLab = -d.b / d.c - 0.5\n    yLab = ymax - 0.5\n  } else {\n    // la droite n'étant pas verticale, on peut chercher ses intersections avec les différents bords.\n    const f = (x: number) => (-d.c - d.a * x) / d.b\n    fXmax = f(xmax)\n    if (fXmax <= ymax && fXmax >= ymin) {\n      // la droite coupe le bord Est entre ymin+1 et ymax-1\n      xLab = xmax - 0.8\n      yLab = f(xLab)\n    } else {\n      fXmin = f(xmin)\n      if (fXmin <= ymax && fXmin >= ymin) {\n        xLab = xmin + 0.8\n        yLab = f(xLab)\n      } else {\n        // la droite ne coupe ni la bordue Est ni la bordure Ouest elle coupe donc les bordures Nord et Sud\n        const g = (y: number) => (-d.c - d.b * y) / d.a\n        fYmax = g(ymax)\n        if (fYmax <= xmax && fYmax >= xmin) {\n          yLab = ymax - 0.8\n          xLab = g(yLab)\n        } else {\n          fYmin = g(ymin)\n          if (fYmin <= xmax && fYmin >= xmin) {\n            yLab = ymin + 0.8\n            xLab = g(yLab)\n          } else {\n            // La droite ne passe pas dans la fenêtre on retourne un objet vide\n            return vide2d()\n          }\n        }\n      }\n    }\n  }\n  const scale = 0.5 / norme(vecteur(d.a, d.b))\n  return pointAbstrait(xLab + d.a * scale, yLab + d.b * scale)\n}\n\n/**  Trace la droite passant par le point A et de vecteur directeur v\n * @param {PointAbstrait} A PointAbstrait de la droite\n * @param {Vecteur} v Vecteur directeur de la droite\n * @param {string} [nom = ''] Nom affiché de la droite\n * @param {string} [color = 'black'] Couleur de la droite : du type 'blue' ou du type '#f15929'\n * @example droiteParPointEtVecteur(M, v1) // Trace la droite passant par le point M et de vecteur directeur v1\n * @example droiteParPointEtVecteur(M, v1, 'd1', 'red') // Trace, en rouge, la droite d1 passant par le point M et de vecteur directeur v1\n * @author Jean-Claude Lhote\n * @return {Droite}\n */\n// JSDOC Validee par EE Aout 2022\nexport function droiteParPointEtVecteur(\n  A: PointAbstrait,\n  v: Vecteur,\n  nom = '',\n  color = 'black',\n) {\n  const B = pointAbstrait(A.x + v.x, A.y + v.y)\n  return new Droite(A, B, nom, color)\n}\n\n/**  Trace la droite parallèle à d passant par le point A\n * @param {PointAbstrait} A PointAbstrait de la droite\n * @param {Droite} d Droite\n * @param {string} [nom = ''] Nom affiché de la droite\n * @param {string} [color = 'black'] Couleur de la droite : du type 'blue' ou du type '#f15929'\n * @example droiteParPointEtParallele(M, d2) // Trace la droite parallèle à d2 passant par le point M\n * @example droiteParPointEtParallele(M, d2, 'd1', 'red') // Trace, en rouge, la droite d1 parallèle à d2 passant par le point M\n * @author Jean-Claude Lhote\n * @return {Droite}\n */\n// JSDOC Validee par EE Aout 2022\nexport function droiteParPointEtParallele(\n  A: PointAbstrait,\n  d: Droite,\n  nom = '',\n  color = 'black',\n) {\n  return droiteParPointEtVecteur(A, d.directeur, nom, color)\n}\n\n/**  Trace la droite perpendiculaire à d passant par le point A\n * @param {PointAbstrait} A PointAbstrait de la droite\n * @param {Droite} d Droite\n * @param {string} [nom = ''] Nom affiché de la droite\n * @param {string} [color = 'black'] Couleur de la droite : du type 'blue' ou du type '#f15929'\n * @example droiteParPointEtPerpendiculaire(M, d2) // Trace la droite perpendiculaire à d2 passant par le point M\n * @example droiteParPointEtPerpendiculaire(M, d2, 'd1', 'red') // Trace, en rouge, la droite d1 perpendiculaire à d2 passant par le point M\n * @author Jean-Claude Lhote\n * @return {Droite}\n */\n// JSDOC Validee par EE Aout 2022\nexport function droiteParPointEtPerpendiculaire(\n  A: PointAbstrait,\n  d: Droite,\n  nom = '',\n  color = 'black',\n) {\n  return droiteParPointEtVecteur(A, d.normal, nom, color)\n}\n\n/**  Trace la droite horizontale passant par le point A\n * @param {PointAbstrait} A PointAbstrait de la droite\n * @param {string} [nom = ''] Nom affiché de la droite\n * @param {string} [color = 'black'] Couleur de la droite : du type 'blue' ou du type '#f15929'\n * @example droiteHorizontaleParPoint(M) // Trace la droite horizontale passant par le point M\n * @example droiteHorizontaleParPoint(M, 'd1', 'red') // Trace, en rouge, la droite horizontale d1 passant par le point M\n * @author Jean-Claude Lhote\n * @return {Droite}\n */\n// JSDOC Validee par EE Aout 2022\nexport function droiteHorizontaleParPoint(\n  A: PointAbstrait,\n  nom = '',\n  color = 'black',\n) {\n  return droiteParPointEtPente(A, 0, nom, color)\n}\n\n/**  Trace la droite verticale passant par le point A\n * @param {PointAbstrait} A PointAbstrait de la droite\n * @param {string} [nom = ''] Nom affiché de la droite\n * @param {string} [color = 'black'] Couleur de la droite : du type 'blue' ou du type '#f15929'\n * @example droiteVerticaleParPoint(M) // Trace la droite verticale passant par le point M\n * @example droiteVerticaleParPoint(M, 'd1', 'red') // Trace, en rouge, la droite verticale d1 passant par le point M\n * @author Jean-Claude Lhote\n * @return {Droite}\n */\n// JSDOC Validee par EE Aout 2022\nexport function droiteVerticaleParPoint(\n  A: PointAbstrait,\n  nom = '',\n  color = 'black',\n) {\n  return droiteParPointEtVecteur(A, vecteur(0, 1), nom, color)\n}\n\n/**  Trace la droite passant par le point A et de pente k\n * @param {PointAbstrait} A PointAbstrait de la droite\n * @param {number} k Pente de la droite\n * @param {string} [nom = ''] Nom affiché de la droite\n * @param {string} [color = 'black'] Couleur de la droite : du type 'blue' ou du type '#f15929'\n * @example droiteParPointEtPente(M, p) // Trace la droite passant par le point M et de pente p\n * @example droiteParPointEtPente(M, p, 'd1', 'red') // Trace, en rouge, la droite d1 passant par le point M et de pente p\n * @author Jean-Claude Lhote\n * @return {Droite}\n */\n// JSDOC Validee par EE Aout 2022\nexport function droiteParPointEtPente(\n  A: PointAbstrait,\n  k: number,\n  nom = '',\n  color = 'black',\n) {\n  const B = pointAbstrait(A.x + 1, A.y + k)\n  return new Droite(A, B, nom, color)\n}\n\n/**  Donne la distance entre le point A et la droite d\n * @param {PointAbstrait} A\n * @param {Droite} d\n * @example distancePointDroite (M, d1) // Retourne la distance entre le point M et la droite d1\n * @author Jean-Claude Lhote\n * @return {number}\n */\n// JSDOC Validee par EE Aout 2022\nexport function distancePointDroite(A: PointAbstrait, d: Droite) {\n  // Formule: |a*xA + b*yA + c| / ||(a,b)||\n  const denom = norme(vecteur(d.a, d.b))\n  if (denom < 1e-12) return 0\n  return arrondi(Math.abs(d.a * A.x + d.b * A.y + d.c) / denom, 9)\n}\n"],"names":["Vecteur","b","nom","__publicField","isPointLike","v","coeff","vecteur","a","labelOnLine","droite","preferedPosition","usedPosition","letterSize","color","backgroundColor","absNom","ordNom","leNom","anchor","oneUsedPosition","positions","egal","context","latex2d","y0","y1","x0","x1","xgauche","xdroite","pointSurDroite","i","coli","j","label","dis","XYlabel","XYlabel2","colision","found","disMax","vide2d","droiteAvecNomLatex","d","colorToLatexOrHTML","Droite","ObjetMathalea2D","arg1","arg2","arg3","arg4","arg5","c","PointAbstrait","xsav","ysav","arrondi","angleOriente","pointAbstrait","texteParPosition","A","B","A1","pointSurSegment","B1","_a","axisYMin","axisYMax","axisXMin","axisXMax","tableauOptions","optionsDraw","shouldUsePgfplots","formatNombre","val","formatSlope","formatted","pgfplotsOptions","domainMin","domainMax","_b","rangeMin","_c","rangeMax","_d","optionsList","vertical","code","xValue","coordYMin","coordYMax","options","slope","intercept","slopeStr","interceptStr","expression","_e","amp","segment","dessousDessus","tolerance","positionLabelDroite","xmin","ymin","xmax","ymax","xLab","yLab","fXmax","fYmax","fXmin","fYmin","f","x","g","y","scale","norme","droiteParPointEtVecteur","droiteParPointEtParallele","droiteParPointEtPerpendiculaire","droiteHorizontaleParPoint","droiteParPointEtPente","droiteVerticaleParPoint","k","distancePointDroite","denom"],"mappings":"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"}