{"version":3,"file":"Spline-VwczRhmB.js","sources":["../../src/lib/2d/BezierPath.ts","../../src/lib/mathFonctions/Spline.ts"],"sourcesContent":["import { colorToLatexOrHTML } from './colorToLatexOrHtml'\nimport { ObjetMathalea2D } from './ObjetMathalea2D'\n/**\n * Une fonction pour convertir des abscisses en unité Mathalé en abscisses svg\n * @param x\n * @param coeff\n * @return {number}\n */\nconst xSVG = (x: number, coeff: number) => Number((x * coeff).toFixed(1))\n/**\n * Une fonction pour convertir des ordonnées en unité Mathalé en ordonnées svg\n * @param y\n * @param coeff\n * @return {number}\n */\nconst ySVG = (y: number, coeff: number) => Number((-y * coeff).toFixed(1))\nexport class BezierPath extends ObjetMathalea2D {\n  xStart: number\n  yStart: number\n  listeOfTriplets: [number, number][][]\n  constructor({\n    xStart = 0,\n    yStart = 0,\n    listeOfTriplets = [\n      [\n        [1, 1],\n        [-1, -1],\n        [1, 1],\n      ],\n    ] as [number, number][][],\n    color = 'black',\n    epaisseur = 2,\n    opacite = 1,\n  }) {\n    super()\n    this.color = colorToLatexOrHTML(color)\n    this.opacite = opacite\n    this.epaisseur = epaisseur\n    this.xStart = xStart\n    this.yStart = yStart\n    this.listeOfTriplets = listeOfTriplets\n  }\n\n  svg(coeff: number) {\n    //\n    let path = `<path fill=\"none\" stroke=\"${this.color[0]}\" stroke-width=${this.epaisseur} d=\"M${xSVG(this.xStart, coeff)},${ySVG(this.yStart, coeff)} c`\n    for (const triplet of this.listeOfTriplets) {\n      path += `${xSVG(triplet[0][0], coeff)},${ySVG(triplet[0][1], coeff)} ${xSVG(triplet[1][0], coeff)},${ySVG(triplet[1][1], coeff)} ${xSVG(triplet[2][0], coeff)},${ySVG(triplet[2][1], coeff)} `\n    }\n    path += '\" />\\n'\n    return path\n  }\n\n  tikz() {\n    let path = `\\n\\t\\\\draw[color = ${this.color[1]},line width = ${this.epaisseur}, opacity = ${this.opacite}](${this.xStart},${this.yStart})`\n    // Pour tikz, les coordonnées du point initial et final doivent être en coordonnées absolues, seules les points de contrôles peuvent-être en relatif à leur noeud respectif\n    let x0 = this.xStart\n    let y0 = this.yStart\n    for (const triplet of this.listeOfTriplets) {\n      const x3 = x0 + triplet[2][0]\n      const y3 = y0 + triplet[2][1]\n      const dX2X3 = triplet[1][0] - triplet[2][0] // tikz prend comme origine le point final pour calculer les coordonnées relatives du point de contrôle 2 !\n      const dY2Y3 = triplet[1][1] - triplet[2][1]\n      path += ` .. controls +(${triplet[0][0].toFixed(2)},${triplet[0][1].toFixed(2)}) and +(${dX2X3.toFixed(2)},${dY2Y3.toFixed(2)})  .. (${x3.toFixed(2)},${y3.toFixed(2)})\\n`\n      x0 = x3 // Le nouveau point de départ est le point d'arrivée du tronçon précédent !\n      y0 = y3\n    }\n    path += ';\\n'\n    return path\n  }\n}\n","import { polynomialRoot, round } from 'mathjs'\n\nimport type Point from 'apigeom/src/elements/points/Point'\nimport type Figure from 'apigeom/src/Figure'\nimport Decimal from 'decimal.js'\nimport FractionEtendue from '../../modules/FractionEtendue'\nimport { egal, randint } from '../../modules/outils'\nimport { BezierPath } from '../2d/BezierPath'\nimport { colorToLatexOrHTML } from '../2d/colorToLatexOrHtml'\nimport { ObjetMathalea2D } from '../2d/ObjetMathalea2D'\nimport { point } from '../2d/PointAbstrait'\nimport { tracePoint } from '../2d/TracePoint'\nimport { choice } from '../outils/arrayOutils'\nimport { rangeMinMax } from '../outils/nombres'\nimport { stringNombre } from '../outils/texNombre'\nimport { brent, tableauDeVariation, variationsFonction } from './etudeFonction'\nimport { Matrice, matrice } from './Matrice'\nimport { chercheMinMaxLocal, Polynome } from './Polynome'\n\nexport type NoeudSpline = {\n  x: number\n  y: number\n  deriveeGauche: number\n  deriveeDroit: number\n  isVisible: boolean\n}\ntype OptionsNoeuds = {\n  color?: string\n  epaisseur?: number\n  taille?: number\n  style?: string\n  visible?: boolean\n  couleurDeRemplissage?: string\n}\n/**\n * Une fonction pour créer une Spline aléatoire\n * @param {number} n\n * @param {boolean} noeudsVisibles\n * @param {number} xMin\n * @param {number} step\n * @param {number} y0 ordonnée de départ de la spline aléatoire\n * @returns {Array<NoeudSpline>}\n */\nexport function noeudsSplineAleatoire(\n  n: number,\n  noeudsVisibles: boolean,\n  xMin = -n / 2,\n  y0 = 0,\n  step = 2,\n) {\n  const noeuds = []\n  const isVisible = noeudsVisibles\n\n  let y = y0\n  let deriveeDroit = Math.cos(Math.random() * Math.PI) * randint(1, 2)\n  for (let x = xMin; x < -xMin + 1; x += step) {\n    const y0 = y\n    noeuds.push({ x, y, deriveeGauche: deriveeDroit, deriveeDroit, isVisible })\n    do {\n      y = y + choice([-1, 1]) * randint(1, 2)\n    } while (y > 5 || y < -5)\n    do {\n      deriveeDroit = Math.cos(Math.random() * Math.PI) * randint(0, 2)\n    } while (deriveeDroit * (y - y0) < 0)\n  }\n  return noeuds\n}\n\n/**\n * Une fonction pour créer un nuage de noeuds différents d'un nuage passé en argument avec certaines options\n * @param {Array<{x: number, y:number, deriveeGauche:number, deriveeDroit:number, isVisible:boolean}>} noeudsF\n * @param {objet} options\n * @param {boolean} [options.symetrieH]\n * @param {boolean} [options.symetrieV]\n * @param {number} [options.echangeNoeuds]\n * @param {number} [options.decalVertical]\n * @param {number} [options.decalHorizontal]\n * @return {Array<{x: number, y:number, deriveeGauche:number, deriveeDroit:number, isVisible:boolean}>}\n */\ntype OptionsModifieNoeuds = {\n  symetrieH?: boolean\n  symetrieV?: boolean\n  echangeNoeuds?: number\n  decalVertical?: number\n  decalHorizontal?: number\n}\nexport function modifieNoeuds(\n  noeudsF: NoeudSpline[],\n  options: OptionsModifieNoeuds,\n) {\n  const noeudsG = noeudsF.map((el) =>\n    Object.assign(\n      {},\n      {\n        x: el.x,\n        y: el.y,\n        deriveeGauche: el.deriveeGauche,\n        deriveeDroit: el.deriveeDroit,\n        isVisible: el.isVisible,\n      },\n    ),\n  )\n  const nbNoeuds = noeudsF.length\n  if (options.symetrieH) {\n    for (let i = nbNoeuds; i > 0; i--) {\n      noeudsG[nbNoeuds - i] = {\n        x: noeudsF[nbNoeuds - i].x,\n        y: noeudsF[i - 1].y,\n        deriveeGauche: noeudsF[i - 1].deriveeDroit,\n        deriveeDroit: noeudsF[i - 1].deriveeGauche,\n        isVisible: noeudsF[i - 1].isVisible,\n      }\n    }\n  }\n  if (options.symetrieV) {\n    for (let i = 0; i < nbNoeuds; i++) {\n      noeudsG[i] = {\n        x: noeudsG[i].x,\n        y: -noeudsG[i].y,\n        deriveeGauche: -noeudsG[i].deriveeGauche,\n        deriveeDroit: -noeudsG[i].deriveeDroit,\n        isVisible: noeudsG[i].isVisible,\n      }\n    }\n  }\n  if (options.echangeNoeuds) {\n    const indices = rangeMinMax(0, nbNoeuds - 1)\n    // le nombre de modifications doit être pair car on va échanger 2 par 2 et il doit y en avoir moins que nbNoeuds.\n    const nbModifs =\n      options.echangeNoeuds ?? 2 * Math.round(randint(2, nbNoeuds) / 2)\n    const indiceDepartArrivee: number[] = []\n    for (let i = 0, cpt = 0; i < nbModifs / 2 && cpt < 50; ) {\n      const choix1 = choice(indices, indiceDepartArrivee)\n      const choix2 = choice(indices, indiceDepartArrivee)\n      if (choix1 != null && choix2 != null) {\n        indiceDepartArrivee.push(choix1, choix2)\n        i++\n      }\n      cpt++\n    }\n    for (let i = 0; i < indiceDepartArrivee.length; i += 2) {\n      // on va de 2 en 2 car les indices impairs sont les indices d'arrivée\n      const depart = indiceDepartArrivee[i]\n      const arrivee = indiceDepartArrivee[i + 1]\n      // on n'échange que si l'indice du noeud concerné est avant celui d'arrivée\n      const noeudInter = {\n        x: noeudsG[arrivee].x,\n        y: noeudsG[depart].y,\n        deriveeGauche: noeudsG[depart].deriveeGauche,\n        deriveeDroit: noeudsG[depart].deriveeDroit,\n        isVisible: noeudsG[depart].isVisible,\n      }\n      noeudsG[depart] = {\n        x: noeudsG[depart].x,\n        y: noeudsG[arrivee].y,\n        deriveeGauche: noeudsG[arrivee].deriveeGauche,\n        deriveeDroit: noeudsG[arrivee].deriveeDroit,\n        isVisible: noeudsG[arrivee].isVisible,\n      }\n      noeudsG[arrivee] = {\n        x: noeudInter.x,\n        y: noeudInter.y,\n        deriveeGauche: noeudInter.deriveeGauche,\n        deriveeDroit: noeudInter.deriveeDroit,\n        isVisible: noeudInter.isVisible,\n      }\n    }\n  }\n  if (options.decalVertical) {\n    const offset = Number.isInteger(options.decalVertical)\n      ? options.decalVertical\n      : randint(-2, 2, 0)\n    for (let i = 0; i < noeudsG.length; i++) {\n      noeudsG[i] = {\n        x: noeudsG[i].x,\n        y: noeudsG[i].y + offset,\n        deriveeGauche: noeudsG[i].deriveeGauche,\n        deriveeDroit: noeudsG[i].deriveeDroit,\n        isVisible: noeudsG[i].isVisible,\n      }\n    }\n  }\n  if (options.decalHorizontal) {\n    const offset = Number.isInteger(options.decalHorizontal)\n      ? options.decalHorizontal\n      : randint(-2, 2, 0)\n    for (let i = 0; i < noeudsG.length; i++) {\n      noeudsG[i] = {\n        x: noeudsG[i].x + offset,\n        y: noeudsG[i].y,\n        deriveeGauche: noeudsG[i].deriveeGauche,\n        deriveeDroit: noeudsG[i].deriveeDroit,\n        isVisible: noeudsG[i].isVisible,\n      }\n    }\n  }\n  return noeudsG\n}\n/**\n * Les noeuds sont des objets : {x,y, nombreDerive} attention à les donner dans l'ordre des x croissants\n * @author Jean-Claude Lhote\n */\nexport class Spline {\n  /**\n   * Passer au moins deux noeuds, sinon ça ne peut pas fonctionner d'où la valeur par défaut...\n   * @param {Array<{x: number, y:number, deriveeGauche:number, deriveeDroit:number, isVisible:boolean}>} noeuds la liste des noeuds avec leurs nombres dérivés\n   */\n  n: number\n  polys: Polynome[]\n  nbPointsForApiGeom: number\n  noeuds: NoeudSpline[]\n  x: number[]\n  y: number[]\n  visibles: boolean[]\n  fonctions: ((x: number) => number)[]\n\n  constructor(noeuds: NoeudSpline[]) {\n    this.polys = []\n    this.x = []\n    this.y = []\n    this.noeuds = []\n    this.visibles = []\n    this.nbPointsForApiGeom = 100 // On pourra modifier cette propriété avant de récupérer pointOfSpline\n    this.fonctions = []\n    if (noeuds == null || !Array.isArray(noeuds) || noeuds.length < 2) {\n      // on ne peut pas interpoler une courbe avec moins de 2 noeuds\n      window.notify('Spline : nombre de noeuds insuffisant', { noeuds })\n      noeuds = [\n        { x: -3, y: -5, deriveeGauche: 0, deriveeDroit: 2, isVisible: false },\n        { x: 3, y: 0, deriveeGauche: -2, deriveeDroit: -2, isVisible: false },\n      ]\n    }\n    if (!trieNoeuds(noeuds)) {\n      this.n = noeuds.length\n\n      window.notify(\n        'Il y a un problème avec ces noeuds (peut-être un doublon ?) ',\n        { noeuds },\n      )\n      return\n    } // les noeuds comportent une anomalie : deux valeur de x identiques\n    this.n = noeuds.length\n\n    for (let i = 0; i < noeuds.length - 1; i++) {\n      const x0 = noeuds[i].x\n      const y0 = noeuds[i].y\n      const d0 = noeuds[i].deriveeDroit\n      const x1 = noeuds[i + 1].x\n      const y1 = noeuds[i + 1].y\n      const d1 = noeuds[i + 1].deriveeGauche\n      const maMatrice = matrice([\n        [x0 ** 3, x0 ** 2, x0, 1],\n        [x1 ** 3, x1 ** 2, x1, 1],\n        [3 * x0 ** 2, 2 * x0, 1, 0],\n        [3 * x1 ** 2, 2 * x1, 1, 0],\n      ])\n      if (y0 + (x1 - x0) * d1 === y1 && d0 === d1) {\n        const a = (y1 - y0) / (x1 - x0)\n        const b = y0 - a * x0\n        this.polys.push(new Polynome({ coeffs: [b, a, 0, 0] }))\n      } else if (maMatrice != null) {\n        if (maMatrice.determinant() === 0) {\n          window.notify(\n            \"Spline : impossible de trouver un polynome ici car la matrice n'est pas inversible, il faut revoir vos noeuds : \",\n            {\n              noeudGauche: noeuds[i],\n              noeudDroit: noeuds[i + 1],\n            },\n          )\n          return\n        }\n        const matriceInverse = maMatrice.inverse()\n        if (matriceInverse != null) {\n          const vecteur = [y0, y1, d0, d1]\n          const prodV = matriceInverse.multiply(vecteur)\n          if (prodV != null) {\n            this.polys.push(\n              new Polynome({\n                useFraction: true,\n                coeffs: (\n                  (prodV instanceof Matrice\n                    ? prodV.toArray()\n                    : prodV) as number[]\n                )\n                  .reverse()\n                  .map((el) => Number(Number(el).toFixed(6))), // parti pris : on arrondit au millionnième pour les entiers qui s'ignorent (pour les 1/3 c'est rapé, mais c'est suffisamment précis)\n              }),\n            )\n          } else {\n            window.notify(\n              \"Spline : impossible de trouver un polynome ici car la matrice n'est pas inversible, il faut revoir vos noeuds : \",\n              {\n                noeudGauche: noeuds[i],\n                noeudDroit: noeuds[i + 1],\n              },\n            )\n            return\n          }\n        }\n      }\n    }\n    this.noeuds = [...noeuds]\n    this.n = this.noeuds.length\n    this.x = this.noeuds.map((noeud) => noeud.x)\n    this.y = this.noeuds.map((noeud) => noeud.y)\n    this.visibles = this.noeuds.map((noeud) => noeud.isVisible) // On récupère la visibilité des noeuds pour la courbe\n    this.n = this.y.length // on a n valeurs de y et donc de x, soit n-1 intervalles numérotés de 1 à n-1.\n    // this.step = step // on en a besoin pour la dérivée...\n    this.fonctions = this.#convertPolyFunction()\n  }\n\n  get image() {\n    return this.fonction\n  }\n\n  pointsOfSpline(figure: Figure) {\n    const points: Point[] = []\n    const stepPoints =\n      (this.x[this.x.length - 1] - this.x[0]) / this.nbPointsForApiGeom // on fait 50 points ça devrait suffir...\n    let x = this.x[0]\n    do {\n      points.push(\n        figure.create('Point', { x, y: this.#image(x), isVisible: false }),\n      )\n      x += stepPoints\n    } while (x <= this.x[this.x.length - 1])\n    points.push(\n      figure.create('Point', {\n        x: this.x[this.x.length - 1],\n        y: this.#image(this.x[this.x.length - 1]),\n        isVisible: false,\n      }),\n    )\n    return points\n  }\n\n  /**\n   * convertit les polynomes en fonctions\n   * @returns {Function[]}\n   */\n  #convertPolyFunction(): ((x: number) => number)[] {\n    const f = []\n    for (let i = 0; i < this.n - 1; i++) {\n      f.push(this.polys[i].fonction)\n    }\n    return f\n  }\n\n  /**\n   * une méthode pour ajouter deux splines... et retourner une nouvelle spline !\n   * Attention ! il faut que les deux splines aient exactement le même nombre de noeuds, et que les abscisses de ces noeuds soient les mêmes !\n   * @param {Spline} s\n   * @param {boolean} opposite\n   */\n  add(s: Spline, opposite: boolean) {\n    if (this.n !== s.n) {\n      throw Error('Veuillez vous assurer de donner deux splines compatibles')\n    }\n    if (this.x.filter((el) => s.x.includes(el)).length !== this.n) {\n      throw Error('Veuillez vous assurer de donner deux splines compatibles')\n    }\n    const noeuds = []\n    for (let i = 0; i < this.n; i++) {\n      const x = this.x[i]\n      const y = this.y[i] + (opposite ? -1 : 1) * s.y[i]\n      const deriveeGauche =\n        this.noeuds[i].deriveeGauche +\n        (opposite ? -1 : 1) * s.noeuds[i].deriveeGauche\n      const deriveeDroit =\n        this.noeuds[i].deriveeDroit +\n        (opposite ? -1 : 1) * s.noeuds[i].deriveeDroit\n      const isVisible = this.noeuds[i].isVisible && s.noeuds[i].isVisible\n      noeuds.push({ x, y, deriveeGauche, deriveeDroit, isVisible })\n    }\n    return new Spline(noeuds)\n  }\n\n  zeros(precision = 1) {\n    const zeros = []\n    for (let x = this.x[0]; x < this.x[this.n - 1]; x += 0.5) {\n      if (this.#image(x) * this.#image(x + 0.5) < 0) {\n        const { root } = brent(this.fonction, x, x + 0.5, 0.000000001, 100)\n        if (root != null) zeros.push(round(root, precision))\n      } else {\n        if (this.#image(x) === 0) zeros.push(round(x, precision))\n        if (this.#image(x + 0.5) === 0) zeros.push(round(x + 0.5, precision))\n      }\n    }\n    return Array.from(new Set(zeros).values())\n  }\n\n  /**\n   * retourne les solutions de f(x) = y sur son domaine de définition\n   * @param {number} y\n   * @param {number} precision préciser la tolérance dans la recherche de solutions : une précision de 2 signifie que y-0.01<f(x)<y+0.01\n   * mettre 0 comme précision signifie potentiellement y-0.5<f(x)<y+0.5 !\n   * @returns {number[]}\n   */\n  solve(y: number, precision = 2) {\n    // On a eu des soucis plus loin dans polynome.add(-y) donc on s'assure que y est bien un number.\n    const yArg = y\n    y = Number(y)\n    if (!isNaN(y)) {\n      const antecedents: number[] = []\n      for (let i = 0; i < this.polys.length; i++) {\n        const polEquation = this.polys[i].add(-y) // Le polynome dont les racines sont les antécédents de y\n        // Algebrite n'aime pas beaucoup les coefficients decimaux...\n        try {\n          // si le polynome utilise des FractionEtendue, il faut les convertir au format mathjs pour polynomialRoot\n          const [coeff0, coeff1, coeff2, coeff3] =\n            polEquation.monomes.map(Number)\n          const liste = polEquation.useFraction\n            ? polynomialRoot(coeff0, coeff1, coeff2, coeff3)\n            : polynomialRoot(coeff0, coeff1, coeff2, coeff3)\n          for (const valeur of liste) {\n            let arr\n            if (typeof valeur === 'number') {\n              arr = round(valeur, precision)\n            } else {\n              // complexe !\n              const module = valeur.toPolar().r\n              if (module < 10 ** (-precision - 4)) {\n                // module trop petit pour être complexe, c'est 0 !\n                arr = 0\n              } else {\n                const argument = valeur.toPolar().phi\n                if (\n                  Math.abs(argument) < 0.001 ||\n                  Math.abs(Math.abs(argument) - Math.PI) < 0.001\n                ) {\n                  // si l'argument est proche de 0 ou de Pi ou de -Pi\n                  arr = round(valeur.re, precision) // on prend la partie réelle\n                } else {\n                  arr = null // c'est une vraie racine complexe, du coup, on prend null\n                }\n              }\n            }\n            if (arr !== null && arr >= this.x[i] && arr <= this.x[i + 1]) {\n              if (!antecedents.includes(arr)) {\n                antecedents.push(arr)\n              }\n            }\n          }\n        } catch (e) {\n          const err = e instanceof Error ? e.message : String(e)\n          window.notify('Erreur dans Spline.solve()' + err, { valeur_de_y: y })\n        }\n      }\n      return antecedents\n    } else {\n      window.notify(\n        `Spline.solve() a reçu un truc bizarre à la place d'un nombre : ${yArg} !`,\n        { valeurArgument: yArg },\n      )\n    }\n  }\n\n  /**\n   * retourne un array décrivant les variations de la Spline sur son domaine de déf\n   * à améliorer... la fonction variationsFonctions ne travaille pas proprement. on peut faire beaucoup mieux avec Spline\n   * @returns {*[]|null}\n   */\n  variations(step: number | FractionEtendue = new FractionEtendue(1, 100)) {\n    return variationsFonction(\n      this.derivee,\n      this.noeuds[0].x,\n      this.noeuds[this.n - 1].x,\n      step,\n    )\n  }\n\n  /**\n   * retourne les signes pris par la Spline sur son domaine de déf\n   * à améliorer... la fonction signesFonctions ne travaille pas proprement. on peut faire beaucoup mieux avec Spline\n   * @returns {T[]}\n   */\n  signes() {\n    const signes = []\n    const zeros = this.zeros(1)\n    let x\n    if (zeros.length === 0) {\n      return [\n        {\n          xG: this.x[0],\n          xD: this.x[this.n - 1],\n          signe: this.y[0] > 0 ? '+' : '-',\n        },\n      ]\n    }\n    if (this.x[0] !== zeros[0])\n      signes.push({\n        xG: this.x[0],\n        xD: zeros[0],\n        signe: this.y[0] > 0 ? '+' : '-',\n      })\n    x = zeros[0]\n    signes.push({ xG: zeros[0], xD: zeros[0], signe: 'z' })\n    for (let i = 1; i < zeros.length; i++) {\n      const y = this.#image((x + zeros[i]) / 2)\n      signes.push({ xG: x, xD: zeros[i], signe: y > 0 ? '+' : '-' })\n      signes.push({ xG: zeros[i], xD: zeros[i], signe: 'z' })\n      x = zeros[i]\n    }\n    if (zeros[zeros.length - 1] === this.x[this.n - 1]) return signes\n    const y = this.#image((zeros[zeros.length - 1] + this.x[this.n - 1]) / 2)\n    signes.push({\n      xG: zeros[zeros.length - 1],\n      xD: this.x[this.n - 1],\n      signe: y > 0 ? '+' : '-',\n    })\n    return signes // signesFonction(this.fonction, this.noeuds[0].x, this.noeuds[this.n - 1].x, step ?? new FractionEtendue(1, 10), 0.001)\n  }\n\n  /**\n   * renvoie le tableau de signes d'une fonction\n   * @param fonction\n   * @param {object} options\n   * @param {string} [options.nomVariable] // ce qui est écrit dans l'entête de la première ligne 'x' par défaut\n   * @param {string} [options.nomFonction] // ce qui est écrit dans l'entête de la première ligne 'x' par défaut\n   * @returns {string} [options.nomFonction] // ce  qui est écrit dans l'entête de la deuxième ligne 'f(x)' par défaut\n   */\n  tableauSignes(nomVariable = 'x', nomFonction = 'f(x)') {\n    const signes = this.signes()\n    const premiereLigne = []\n    for (let i = 0; i < signes.length; i++) {\n      if (i === 0) {\n        premiereLigne.push(stringNombre(signes[0].xG, 2), 10)\n      }\n      if (i > 0 && signes[i].xG !== signes[i - 1].xG) {\n        premiereLigne.push(stringNombre(signes[i].xG, 2), 10)\n      }\n    }\n    if (signes[signes.length - 1].xD !== signes[signes.length - 1].xG)\n      premiereLigne.push(stringNombre(signes[signes.length - 1].xD, 2), 10)\n    const tabLine = ['Line', 30]\n    if (!egal(this.#image(this.x[0]), 0)) {\n      tabLine.push('', 10)\n    }\n\n    for (let i = 0; i < signes.length; i++) {\n      tabLine.push(signes[i].signe, 10)\n    }\n\n    return tableauDeVariation({\n      tabInit: [\n        [\n          [nomVariable, 2, 10],\n          [nomFonction, 2, 10],\n        ],\n        premiereLigne,\n      ],\n      tabLines: [tabLine],\n      espcl: 3.5, // taille en cm entre deux antécédents\n      deltacl: 0.8, // distance entre la bordure et les premiers et derniers antécédents\n      lgt: 8, // taille de la première colonne en cm\n    })\n  }\n\n  /**\n   * retourne le nombre d'antécédents entiers trouvés pour une valeur y donnée\n   * @param {number} y\n   * @returns {number}\n   */\n  nombreAntecedentsEntiers(y: number) {\n    const solutions = this.solve(y)\n    const solutionsEntieres =\n      solutions?.filter((sol) => Number.isInteger(sol)) ?? []\n    return solutionsEntieres.length\n  }\n\n  /**\n   * retourne le nombre d'antécédents de y\n   * @param {number} y\n   * @returns {number}\n   */\n  nombreAntecedents(y: number) {\n    const solutions = this.solve(y)\n    return solutions?.length ?? 0\n  }\n\n  nombreAntecedentsMaximum(\n    yMin: number,\n    yMax: number,\n    yentier = true,\n    entiers = true,\n  ) {\n    let nbMax = 0\n    for (let k = yMin; k < yMax; k += yentier ? 1 : 0.1) {\n      if (entiers) {\n        nbMax = Math.max(nbMax, this.nombreAntecedentsEntiers(k))\n      } else {\n        nbMax = Math.max(nbMax, this.nombreAntecedents(k))\n      }\n    }\n    return nbMax\n  }\n\n  /**\n   * Retourne une valeur de y (si trouvée) pour laquelle il y a exactement n antécédents\n   * @param {number} n\n   * @param {number} yMin\n   * @param {number} yMax\n   * @returns {boolean|string|*}\n   */\n  trouveYPourNAntecedents(\n    n: number,\n    yMin: number,\n    yMax: number,\n    yEntier = true,\n    antecedentsEntiers = true,\n  ) {\n    const candidats = []\n    if (Number.isInteger(yMin) && Number.isInteger(yMax)) {\n      if (yEntier) {\n        for (let y = yMin; y <= yMax; y++) {\n          if (\n            (antecedentsEntiers &&\n              this.nombreAntecedentsEntiers(y) === n &&\n              this.nombreAntecedents(y) === n) ||\n            (!antecedentsEntiers && this.nombreAntecedents(y) === n)\n          ) {\n            candidats.push(y)\n          }\n        }\n      } else {\n        // ici, on n'a pas trouvé avec y entier entre xMin et yMax, on recommence avec un pas de 0.1\n        for (let y = yMin; y <= yMax; y += 0.1) {\n          if (\n            (antecedentsEntiers &&\n              this.nombreAntecedentsEntiers(y) === n &&\n              this.nombreAntecedents(y) === n) ||\n            (!antecedentsEntiers && this.nombreAntecedents(y) === n)\n          ) {\n            candidats.push(y)\n          }\n        }\n      }\n    } else {\n      window.notify(\n        'trouveYPourNAntecedentsEntiers() appelé avec des valeurs incorrectes',\n        { n, yMin, yMax },\n      )\n    }\n    if (candidats.length < 1) {\n      // window.notify('trouveYPourNAntecedents() : Je n\\'ai rien trouvé !', { n, yMin, yMax })\n      return false\n    }\n    return choice(candidats) // normalement, il ne devrait jamais retourner cette valeur.\n  }\n\n  /**\n   * retourne les min et max pour un repère contenant la courbe si ceux-ci sont sur des noeuds (c'est vivement conseillé)\n   * Ne fonctionne pas si yMax ou yMin sont atteints entre deux noeuds\n   */\n  trouveMaxes(): { xMin: number; xMax: number; yMin: number; yMax: number } {\n    if (Array.isArray(this.noeuds) && this.noeuds.length > 0) {\n      const xMin = Math.ceil(Math.min(...this.noeuds.map((el) => el.x)))\n      const yMin = Math.ceil(Math.min(...this.noeuds.map((el) => el.y)))\n      const xMax = Math.floor(Math.max(...this.noeuds.map((el) => el.x)))\n      const yMax = Math.floor(Math.max(...this.noeuds.map((el) => el.y)))\n      return { xMin, xMax, yMin, yMax }\n    } else {\n      window.notify(\n        \"Spline.trouveMaxes() on demande ça alors que la Spline n'a pas de noeuds !\",\n        { laSpline: JSON.stringify(this) },\n      )\n      return { xMin: 0, xMax: 0, yMin: 0, yMax: 0 }\n    }\n  }\n\n  /**\n   * retourne le minimum et le maximum de la fonction\n   * @returns {{yMin: number, yMax: number}}\n   */\n  amplitude() {\n    let yMin = 1000\n    let yMax = -1000\n    for (let i = 0; i < this.x.length - 1; i++) {\n      const { minLocal, maxLocal } = chercheMinMaxLocal({\n        poly: this.polys[i],\n        xG: this.x[i],\n        xD: this.x[i + 1],\n      })\n      yMin = Math.min(yMin, minLocal)\n      yMax = Math.max(yMax, maxLocal)\n    }\n    return { yMin, yMax }\n  }\n\n  /**\n   * fournit la fonction à passer pour simuler une fonction mathématique du type (x)=>f(x)\n   * @returns {function(*): number|*}\n   */\n  get fonction() {\n    return (x: number) => this.#image(x)\n  }\n\n  /**\n   * Retourne l'image de x par la fonction\n   * @param {number} x\n   * @returns {number}\n   */\n  #image(x: unknown) {\n    if (typeof x !== 'number') {\n      if (x instanceof FractionEtendue) {\n        x = x.valeurDecimale\n      } else if (x instanceof Decimal) {\n        x = x.toNumber()\n      }\n    }\n    const xNumber = x as number\n    let trouveK = false\n    let k = 0\n    for (let i = 0; i < this.n - 1; i++) {\n      if (xNumber >= this.x[i] && xNumber <= this.x[i + 1]) {\n        k = i\n        trouveK = true\n        break\n      }\n    }\n    if (!trouveK) {\n      const intervalle = `D = [${this.x[0]} ; ${this.x[this.n - 1]}]`\n      window.notify(\n        \"Spline: la valeur de x fournie n'est pas dans lìntervalle de définition de la fonction\",\n        {\n          x,\n          intervalle,\n        },\n      )\n      return NaN\n    } else {\n      return this.fonctions[k](xNumber)\n    }\n  }\n\n  /**\n   * retourne un array de polynomes dérivés (degré 2) de ceux de la Spline utilisé par derivee() pour définir la dérivée pour tout x du domaine\n   * la fonction est continue, mais les dérivées à gauche et à droite des noeuds ne seront pas identiques\n   * donc on ne peut pas en faire une Spline.\n   */\n  get derivees() {\n    const derivees = []\n    for (let i = 0; i < this.polys.length; i++) {\n      derivees.push(this.polys[i].derivee())\n    }\n    return derivees\n  }\n\n  /**\n   * retourne une fonction dérivée de la spline sur son domaine de définition\n   */\n  get derivee() {\n    const intervalles: { xG: number; xD: number }[] = []\n    for (let i = 0; i < this.noeuds.length - 1; i++) {\n      intervalles.push({ xG: this.noeuds[i].x, xD: this.noeuds[i + 1].x })\n    }\n    return (x: number) => {\n      const index = intervalles.findIndex(\n        (intervalle) => x >= intervalle.xG && x <= intervalle.xD,\n      )\n      return this.derivees[index].image(x)\n    }\n  }\n\n  /** retourne une spline construite avec les valeurs dérivées aux noeuds de la spline.\n   * Il faut impérativement que cette fonction soit continue donc les nombre dérivés à gauche et à droite en chacun des noeuds doivent être égaux !\n   */\n  get splineDerivee() {\n    const noeudsDerivee /** Array<{x: number, y:number, deriveeGauche:number, deriveeDroit:number, isVisible:boolean}> */ =\n      []\n    for (const noeud of this.noeuds) {\n      noeudsDerivee.push({\n        x: noeud.x,\n        y: noeud.deriveeGauche,\n        deriveeGauche: 0,\n        deriveeDroit: 0,\n        isVisible: noeud.isVisible,\n      })\n    }\n    return new Spline(noeudsDerivee)\n  }\n\n  /**\n   * crée l'objet mathalea2d correspondant à la courbe tracée\n   * @param {Repere} repere\n   * @param {string} color\n   * @param {number} epaisseur\n   * @param {boolean} ajouteNoeuds\n   * @param {Object} optionsNoeuds\n   * @returns {Trace}\n   */\n  courbe({\n    color = 'black',\n    epaisseur = 1,\n    ajouteNoeuds = false,\n    optionsNoeuds = {},\n  }: {\n    color?: string\n    epaisseur?: number\n    ajouteNoeuds?: boolean\n    optionsNoeuds?: Object\n  } = {}) {\n    return new Trace(this, {\n      color,\n      epaisseur,\n      ajouteNoeuds,\n      optionsNoeuds,\n    })\n  }\n}\n\n/**\n * un raccourcis pour new Spline(noeuds)\n * @param {Array<{x: number, y:number, deriveeGauche:number, deriveeDroit:number, isVisible:boolean}>} noeuds\n * @returns {Spline}\n */\nexport function spline(noeuds: NoeudSpline[]) {\n  return new Spline(noeuds)\n}\n\n/**\n * Fonction qui trie des noeuds pour Spline afin de les remettre dans l'ordre des x croissant\n * @param {Array<{x: number, y:number,nombreDerive:number}>} noeuds\n * @author Jean-Claude Lhote\n */\nexport function trieNoeuds(noeuds: NoeudSpline[]) {\n  let xInter, yInter, dGaucheInter, dDroitInter, isVisibleInter\n  for (let i = 0; i < noeuds.length - 1; i++) {\n    for (let j = i + 1; j < noeuds.length; j++) {\n      if (noeuds[i].x > noeuds[j].x) {\n        xInter = noeuds[i].x\n        yInter = noeuds[i].y\n        dGaucheInter = noeuds[i].deriveeGauche\n        dDroitInter = noeuds[i].deriveeDroit\n        isVisibleInter = noeuds[i].isVisible\n        noeuds[i].x = noeuds[j].x\n        noeuds[i].y = noeuds[j].y\n        noeuds[i].deriveeGauche = noeuds[j].deriveeGauche\n        noeuds[i].deriveeDroit = noeuds[j].deriveeDroit\n        noeuds[i].isVisible = noeuds[j].isVisible\n        noeuds[j].x = xInter\n        noeuds[j].y = yInter\n        noeuds[j].deriveeGauche = dGaucheInter\n        noeuds[j].deriveeDroit = dDroitInter\n        noeuds[j].isVisible = isVisibleInter\n      } else if (egal(noeuds[i].x, noeuds[j].x)) {\n        return false\n      }\n    }\n  }\n  return true\n}\n\n/**\n * @class\n * crée la courbe de la spline (objet mathalea2d)\n */\nexport class Trace extends ObjetMathalea2D {\n  /**\n   * @param {Spline}spline La splineCatmulRom ou Spline dont on veut la Trace\n   * @param {Repere} repere le repère associé\n   * @param {number} step le pas entre deux points\n   * @param {string} color la couleur\n   * @param {number} epaisseur son épaisseur\n   * @param {boolean} ajouteNoeuds si true, des points sont ajoutés aux endroits des noeuds\n   * @param {Object} optionsNoeud\n   */\n  constructor(\n    spline: Spline,\n    {\n      color = 'black',\n      epaisseur = 2,\n      opacite = 1,\n      ajouteNoeuds = true,\n      optionsNoeuds = {},\n    }: {\n      color?: string\n      epaisseur?: number\n      opacite?: number\n      ajouteNoeuds?: boolean\n      optionsNoeuds?: OptionsNoeuds\n    },\n  ) {\n    super()\n    this.objets = []\n    const { xMin, xMax, yMin, yMax } = spline.trouveMaxes()\n    this.bordures = [xMin, yMin, xMax, yMax]\n    const listeOfTriplets: [\n      [number, number],\n      [number, number],\n      [number, number],\n    ][] = []\n\n    for (let i = 0; i < spline.n - 1; i++) {\n      const deltaX = spline.x[i + 1] - spline.x[i]\n      const deltaY = spline.y[i + 1] - spline.y[i]\n      const x1 = deltaX / 3\n      const y1 = (spline.noeuds[i].deriveeDroit * deltaX) / 3\n      const x2 = (2 * deltaX) / 3\n      const y2 = deltaY - (spline.noeuds[i + 1].deriveeGauche * deltaX) / 3\n      const x3 = deltaX\n      const y3 = deltaY\n      listeOfTriplets.push([\n        [x1, y1],\n        [x2, y2],\n        [x3, y3],\n      ])\n    }\n    this.objets.push(\n      new BezierPath({\n        xStart: spline.x[0],\n        yStart: spline.y[0],\n        listeOfTriplets,\n        color,\n        epaisseur,\n        opacite,\n      }),\n    )\n    if (ajouteNoeuds) {\n      for (let i = 0; i < spline.n; i++) {\n        if (spline.visibles[i]) {\n          const noeud = point(spline.x[i], spline.y[i])\n          const traceNoeud = tracePoint(noeud)\n          if (optionsNoeuds) {\n            if (optionsNoeuds.color) {\n              traceNoeud.color = colorToLatexOrHTML(optionsNoeuds.color)\n              traceNoeud.couleurDeRemplissage = colorToLatexOrHTML(\n                optionsNoeuds.color,\n              )\n            }\n            if (optionsNoeuds.epaisseur) {\n              traceNoeud.epaisseur = optionsNoeuds.epaisseur\n            }\n            if (optionsNoeuds.style) {\n              traceNoeud.style = optionsNoeuds.style\n            }\n            if (optionsNoeuds.taille) {\n              traceNoeud.taille = optionsNoeuds.taille\n            }\n          }\n          this.objets.push(traceNoeud)\n        }\n      }\n    }\n    this.svg = function (coeff) {\n      let code = ''\n      if (this.objets == null) return code\n      for (const objet of this.objets) {\n        code += '\\n\\t' + objet.svg(coeff)\n      }\n      return code\n    }\n    this.tikz = function () {\n      let code = ''\n      if (this.objets == null) return code\n      for (const objet of this.objets) {\n        code += objet.tikz()\n      }\n      return code\n    }\n  }\n}\n"],"names":["xSVG","x","coeff","ySVG","y","BezierPath","ObjetMathalea2D","xStart","yStart","listeOfTriplets","color","epaisseur","opacite","__publicField","colorToLatexOrHTML","path","triplet","x0","y0","x3","y3","dX2X3","dY2Y3","noeudsSplineAleatoire","n","noeudsVisibles","xMin","step","noeuds","isVisible","deriveeDroit","randint","choice","_Spline","__privateAdd","_Spline_instances","trieNoeuds","i","d0","x1","y1","d1","maMatrice","matrice","a","Polynome","matriceInverse","vecteur","prodV","Matrice","el","noeud","__privateMethod","convertPolyFunction_fn","figure","points","stepPoints","image_fn","s","opposite","deriveeGauche","precision","zeros","root","brent","round","yArg","antecedents","polEquation","coeff0","coeff1","coeff2","coeff3","liste","polynomialRoot","valeur","arr","argument","e","err","FractionEtendue","variationsFonction","signes","nomVariable","nomFonction","premiereLigne","stringNombre","tabLine","egal","tableauDeVariation","solutions","sol","yMin","yMax","yentier","entiers","nbMax","k","yEntier","antecedentsEntiers","candidats","xMax","minLocal","maxLocal","chercheMinMaxLocal","derivees","intervalles","index","intervalle","noeudsDerivee","ajouteNoeuds","optionsNoeuds","Trace","f","Decimal","xNumber","trouveK","Spline","spline","xInter","yInter","dGaucheInter","dDroitInter","isVisibleInter","j","deltaX","deltaY","x2","y2","point","traceNoeud","tracePoint","code","objet"],"mappings":"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"}