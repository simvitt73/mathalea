{"version":3,"file":"5G30-3-DmdunhNE.js","sources":["../../src/exercices/5e/5G30-3.ts"],"sourcesContent":["import { codageAngle } from '../../lib/2d/angles'\nimport {\n  Droite,\n  droite,\n  droiteParPointEtPente,\n  droiteParPointEtPerpendiculaire,\n} from '../../lib/2d/droites'\nimport { PointAbstrait, pointAbstrait } from '../../lib/2d/PointAbstrait'\nimport { tracePoint } from '../../lib/2d/TracePoint'\nimport { rotation, translation2Points } from '../../lib/2d/transformations'\nimport { angleOriente, longueur } from '../../lib/2d/utilitairesGeometriques'\nimport { pointSurDroite } from '../../lib/2d/utilitairesPoint'\nimport { handleAnswers } from '../../lib/interactif/gestionInteractif'\nimport { choixDeroulant } from '../../lib/interactif/questionListeDeroulante'\nimport { mathalea2d } from '../../modules/mathalea2d'\nimport {\n  gestionnaireFormulaireTexte,\n  listeQuestionsToContenu,\n  randint,\n} from '../../modules/outils'\nimport Exercice from '../Exercice'\n\nimport { number } from 'mathjs'\nimport type { CodageAngle } from '../../lib/2d/CodageAngle'\nimport { CodageAngleDroit } from '../../lib/2d/CodageAngleDroit'\nimport { demiDroite, type DemiDroite } from '../../lib/2d/DemiDroite'\nimport type { TracePoint } from '../../lib/2d/TracePoint'\nimport { bleuMathalea, vertMathalea } from '../../lib/colors'\nimport { choice } from '../../lib/outils/arrayOutils'\nimport { texteEnCouleurEtGras } from '../../lib/outils/embellissements'\nimport { arrondi, range } from '../../lib/outils/nombres'\nimport { context } from '../../modules/context'\n\nexport const interactifReady = true\nexport const interactifType = 'listeDeroulante'\nexport const titre = 'Connaitre le vocabulaire sur les angles'\nexport const dateDePublication = '29/11/2024'\nexport const dateDeModifImportante = '24/12/2024'\n\n/**\n * Connaitre le vocabulaire sur les angles\n * @author Éric Elter (sur un scénario voulu par Rémi Angot)\n */\nexport const uuid = '1f334'\nexport const refs = {\n  'fr-fr': ['5G30-3'],\n  'fr-ch': ['1mG1-3', '11ES2-4'],\n}\n\n// Fonction pour vérifier si tous les points sont dans l'intervalle\nfunction tousDansIntervalle(points: PointAbstrait[]): boolean {\n  return points.every(\n    (point) => point.x >= -8 && point.x <= 8 && point.y >= -8 && point.y <= 8,\n  )\n}\n\nexport default class VocabulaireAngles extends Exercice {\n  constructor() {\n    super()\n    this.nbQuestions = 3\n    this.besoinFormulaireTexte = [\n      \"Vocabulaire de l'exercice\",\n      `Nombres séparés par des tirets :\n    1 : Correspondants\n    2 : Alternes-internes\n    3 : Supplémentaires\n    4 : Opposés par le sommet\n    5 : Complémentaires\n    6 : Côté\n    7 : Sommet\n    8 : Adjacent\n    9 : Mélange`,\n    ]\n    this.besoinFormulaire2CaseACocher = ['Avec distracteur', false]\n    this.besoinFormulaire3CaseACocher = ['En noir et blanc', false]\n    this.sup = 9\n  }\n\n  nouvelleVersion() {\n    const typesDeQuestionsDisponibles = gestionnaireFormulaireTexte({\n      saisie: this.sup,\n      min: 1,\n      max: 8,\n      melange: 9,\n      defaut: 9,\n      nbQuestions: this.nbQuestions,\n    })\n\n    for (let i = 0, cpt = 0; i < this.nbQuestions && cpt < 50; ) {\n      let texteCorr = ''\n      const objets = []\n\n      const origine = pointAbstrait(0, 0)\n\n      let ARot,\n        BRot,\n        CRot,\n        DRot,\n        IRot,\n        JRot,\n        E,\n        F,\n        G,\n        H,\n        d1Rot,\n        d2Rot,\n        d3Rot,\n        d4Rot\n      const distracteur = this.sup2\n      do {\n        const xA = randint(4, 8)\n        const yA = randint(4, 8)\n        const xB = xA * -1\n        const yB = yA * -1\n\n        const A = pointAbstrait(xA, yA)\n        const B = pointAbstrait(xB, yB)\n        const d1 = droiteParPointEtPente(A, 0.5)\n        const d2 = droiteParPointEtPente(B, 0.3)\n        let C\n        do {\n          C = pointSurDroite(d1, randint(-4, 4, [0]), 'C')\n        } while (longueur(A, C) < 0.5)\n        const D = pointSurDroite(d2, 1.5, 'D')\n        const d3 = droite(C, D, '', this.sup3 ? 'black' : 'red')\n        const d4 = droiteParPointEtPerpendiculaire(C, d3)\n\n        const choix = randint(0, 3) * 90\n\n        ARot = rotation(A, origine, choix)\n        BRot = rotation(B, origine, choix)\n        CRot = rotation(C, origine, choix)\n        DRot = rotation(D, origine, choix)\n        d1Rot = rotation(d1, origine, choix) as Droite\n        d2Rot = rotation(d2, origine, choix) as Droite\n        d3Rot = rotation(d3, origine, choix) as Droite\n        d4Rot = rotation(d4, origine, choix) as Droite\n        E = translation2Points(CRot, ARot, CRot)\n        F = translation2Points(DRot, BRot, DRot)\n        G = translation2Points(CRot, DRot, CRot)\n        H = translation2Points(DRot, CRot, DRot)\n\n        // I et J sont sur la droite perpendiculaire, leur usage sera en fonction des angles affichés pour éviter la superposition\n        // I = pointSurDroite(d4, ((C.x + A.x) / 2), 'I')\n        // J = pointSurDroite(d4, ((C.x + E.x) / 2), 'J')\n        // IRot = rotation(I, origine, choix)\n        // JRot = rotation(J, origine, choix)\n        IRot = pointSurDroite(d4Rot, (CRot.x + ARot.x) / 2, 'I')\n        JRot = pointSurDroite(d4Rot, (CRot.x + E.x) / 2, 'I')\n      } while (!tousDansIntervalle([ARot, BRot, CRot, DRot, E, F, G, H])) // Afin de ne pas avoir de placements de points qui puissent changer le format de la fenêtre prévue\n      const tracePts = tracePoint(\n        ARot,\n        BRot,\n        CRot,\n        DRot,\n        E,\n        F,\n        G,\n        H,\n        IRot,\n        JRot,\n        this.sup3 ? 'black' : 'red',\n      ) // Variable qui trace les points avec une croix\n      tracePts.epaisseur = 2\n\n      const tabAngles: [\n        CodageAngle | CodageAngleDroit,\n        (\n          | CodageAngle\n          | CodageAngleDroit\n          | PointAbstrait\n          | DemiDroite\n          | TracePoint\n        ),\n        CodageAngle | CodageAngleDroit,\n      ][] = []\n      const choixQuestion = number(typesDeQuestionsDisponibles[i]) - 1\n      let texteSousFigure = ''\n      switch (choixQuestion) {\n        case 0:\n          // Angles correspondants\n          texteCorr = `Ce sont des angles ${texteEnCouleurEtGras('correspondants')}.`\n          // tabAngles contient deux angles correspondants puis un angle droit qui ne chevauche pas ces angles\n          tabAngles.push([\n            codageAngle(\n              E,\n              CRot,\n              G,\n              2.25,\n              '',\n              this.sup3 ? 'black' : 'red',\n              2,\n              1,\n              this.sup3 ? 'black' : 'red',\n            ),\n            codageAngle(\n              BRot,\n              DRot,\n              G,\n              1.75,\n              '',\n              this.sup3 ? 'black' : bleuMathalea,\n              2,\n              1,\n              this.sup3 ? 'black' : bleuMathalea,\n            ),\n            codageAngle(\n              DRot,\n              CRot,\n              90,\n              1,\n              '',\n              vertMathalea,\n              2,\n              1,\n              vertMathalea,\n            ),\n          ])\n          tabAngles.push([\n            codageAngle(\n              E,\n              CRot,\n              DRot,\n              2.25,\n              '',\n              this.sup3 ? 'black' : 'red',\n              2,\n              1,\n              this.sup3 ? 'black' : 'red',\n            ),\n            codageAngle(\n              BRot,\n              DRot,\n              H,\n              1.75,\n              '',\n              this.sup3 ? 'black' : bleuMathalea,\n              2,\n              1,\n              this.sup3 ? 'black' : bleuMathalea,\n            ),\n            codageAngle(G, CRot, 90, 1, '', vertMathalea, 2, 1, vertMathalea),\n          ])\n          tabAngles.push([\n            codageAngle(\n              ARot,\n              CRot,\n              DRot,\n              2.25,\n              '',\n              this.sup3 ? 'black' : 'red',\n              2,\n              1,\n              this.sup3 ? 'black' : 'red',\n            ),\n            codageAngle(\n              F,\n              DRot,\n              H,\n              1.75,\n              '',\n              this.sup3 ? 'black' : bleuMathalea,\n              2,\n              1,\n              this.sup3 ? 'black' : bleuMathalea,\n            ),\n            codageAngle(G, CRot, 90, 1, '', vertMathalea, 2, 1, vertMathalea),\n          ])\n          tabAngles.push([\n            codageAngle(\n              ARot,\n              CRot,\n              G,\n              2.25,\n              '',\n              this.sup3 ? 'black' : 'red',\n              2,\n              1,\n              this.sup3 ? 'black' : 'red',\n            ),\n            codageAngle(\n              F,\n              DRot,\n              G,\n              1.75,\n              '',\n              this.sup3 ? 'black' : bleuMathalea,\n              2,\n              1,\n              this.sup3 ? 'black' : bleuMathalea,\n            ),\n            codageAngle(\n              DRot,\n              CRot,\n              90,\n              1,\n              '',\n              vertMathalea,\n              2,\n              1,\n              vertMathalea,\n            ),\n          ])\n          texteSousFigure = this.sup3\n            ? \"Qu'est-ce qui caractérise les angles qui ne sont pas des angles droits ? \"\n            : \"Qu'est-ce qui caractérise les angles bleu et rouge ? \"\n          break\n        case 1:\n          // Angles alternes-internes\n          texteCorr = `Ce sont des angles ${texteEnCouleurEtGras('alternes-internes')}.`\n          // tabAngles contient deux angles alternes-internes puis un angle droit qui ne chevauche pas ces angles\n          tabAngles.push([\n            codageAngle(\n              ARot,\n              CRot,\n              DRot,\n              2.25,\n              '',\n              this.sup3 ? 'black' : 'red',\n              2,\n              1,\n              this.sup3 ? 'black' : 'red',\n            ),\n            codageAngle(\n              BRot,\n              DRot,\n              G,\n              1.75,\n              '',\n              this.sup3 ? 'black' : bleuMathalea,\n              2,\n              1,\n              this.sup3 ? 'black' : bleuMathalea,\n            ),\n            codageAngle(G, CRot, 90, 1, '', vertMathalea, 2, 1, vertMathalea),\n          ])\n          tabAngles.push([\n            codageAngle(\n              E,\n              CRot,\n              DRot,\n              2.25,\n              '',\n              this.sup3 ? 'black' : 'red',\n              2,\n              1,\n              this.sup3 ? 'black' : 'red',\n            ),\n            codageAngle(\n              CRot,\n              DRot,\n              F,\n              1.75,\n              '',\n              this.sup3 ? 'black' : bleuMathalea,\n              2,\n              1,\n              this.sup3 ? 'black' : bleuMathalea,\n            ),\n            codageAngle(G, CRot, 90, 1, '', vertMathalea, 2, 1, vertMathalea),\n          ])\n          texteSousFigure = this.sup3\n            ? \"Qu'est-ce qui caractérise les angles qui ne sont pas des angles droits ? \"\n            : \"Qu'est-ce qui caractérise les angles bleu et rouge ? \"\n          break\n        case 2:\n          // Angles supplémentaires\n          texteCorr = `Ce sont des angles  ${texteEnCouleurEtGras('supplémentaires')} car la somme de leurs mesures est égale à 180° (angle plat).`\n          // tabAngles contient deux angles supplémentaires puis un angle droit qui ne chevauche pas ces angles\n          tabAngles.push([\n            codageAngle(\n              G,\n              DRot,\n              BRot,\n              2.25,\n              '',\n              this.sup3 ? 'black' : 'red',\n              2,\n              1,\n              this.sup3 ? 'black' : 'red',\n            ),\n            codageAngle(\n              F,\n              DRot,\n              G,\n              1.75,\n              '',\n              this.sup3 ? 'black' : bleuMathalea,\n              2,\n              1,\n              this.sup3 ? 'black' : bleuMathalea,\n            ),\n            codageAngle(\n              DRot,\n              CRot,\n              90,\n              1,\n              '',\n              vertMathalea,\n              2,\n              1,\n              vertMathalea,\n            ),\n          ])\n          tabAngles.push([\n            codageAngle(\n              F,\n              DRot,\n              H,\n              2.25,\n              '',\n              this.sup3 ? 'black' : 'red',\n              2,\n              1,\n              this.sup3 ? 'black' : 'red',\n            ),\n            codageAngle(\n              F,\n              DRot,\n              G,\n              1.75,\n              '',\n              this.sup3 ? 'black' : bleuMathalea,\n              2,\n              1,\n              this.sup3 ? 'black' : bleuMathalea,\n            ),\n            codageAngle(\n              DRot,\n              CRot,\n              90,\n              1,\n              '',\n              vertMathalea,\n              2,\n              1,\n              vertMathalea,\n            ),\n          ])\n          tabAngles.push([\n            codageAngle(\n              ARot,\n              CRot,\n              G,\n              2.25,\n              '',\n              this.sup3 ? 'black' : 'red',\n              2,\n              1,\n              this.sup3 ? 'black' : 'red',\n            ),\n            codageAngle(\n              ARot,\n              CRot,\n              DRot,\n              1.75,\n              '',\n              this.sup3 ? 'black' : bleuMathalea,\n              2,\n              1,\n              this.sup3 ? 'black' : bleuMathalea,\n            ),\n            //  codageAngle(DRot, CRot, 90, 1, '', vertMathalea, 2, 1, vertMathalea)\n            codageAngle(\n              DRot,\n              CRot,\n              -90,\n              1,\n              '',\n              vertMathalea,\n              2,\n              1,\n              vertMathalea,\n            ),\n          ])\n          tabAngles.push([\n            codageAngle(\n              ARot,\n              CRot,\n              G,\n              2.25,\n              '',\n              this.sup3 ? 'black' : 'red',\n              2,\n              1,\n              this.sup3 ? 'black' : 'red',\n            ),\n            codageAngle(\n              E,\n              CRot,\n              G,\n              1.75,\n              '',\n              this.sup3 ? 'black' : bleuMathalea,\n              2,\n              1,\n              this.sup3 ? 'black' : bleuMathalea,\n            ),\n            codageAngle(\n              DRot,\n              CRot,\n              90,\n              1,\n              '',\n              vertMathalea,\n              2,\n              1,\n              vertMathalea,\n            ),\n          ])\n          texteSousFigure = this.sup3\n            ? \"Qu'est-ce qui caractérise les angles adjacents qui ne sont pas des angles droits ? \"\n            : \"Qu'est-ce qui caractérise les angles adjacents bleu et rouge ? \"\n          break\n        case 3:\n          // Angles opposés par le sommet\n          texteCorr = `Ce sont des angles  ${texteEnCouleurEtGras('opposés')} par le sommet.`\n          // tabAngles contient deux angles opposés par le sommet puis un angle droit qui ne chevauche pas ces angles\n          if (Math.abs(angleOriente(G, CRot, ARot)) < 90) {\n            tabAngles.push([\n              codageAngle(\n                G,\n                CRot,\n                ARot,\n                2.25,\n                '',\n                this.sup3 ? 'black' : 'red',\n                2,\n                1,\n                this.sup3 ? 'black' : 'red',\n              ),\n              codageAngle(\n                E,\n                CRot,\n                H,\n                1.75,\n                '',\n                this.sup3 ? 'black' : bleuMathalea,\n                2,\n                1,\n                this.sup3 ? 'black' : bleuMathalea,\n              ),\n              codageAngle(\n                DRot,\n                CRot,\n                90,\n                1,\n                '',\n                vertMathalea,\n                2,\n                1,\n                vertMathalea,\n              ),\n            ])\n          }\n          tabAngles.push([\n            codageAngle(\n              F,\n              DRot,\n              G,\n              2.25,\n              '',\n              this.sup3 ? 'black' : 'red',\n              2,\n              1,\n              this.sup3 ? 'black' : 'red',\n            ),\n            codageAngle(\n              BRot,\n              DRot,\n              H,\n              1.75,\n              '',\n              this.sup3 ? 'black' : bleuMathalea,\n              2,\n              1,\n              this.sup3 ? 'black' : bleuMathalea,\n            ),\n            codageAngle(\n              DRot,\n              CRot,\n              90,\n              1,\n              '',\n              vertMathalea,\n              2,\n              1,\n              vertMathalea,\n            ),\n          ])\n          tabAngles.push([\n            codageAngle(\n              F,\n              DRot,\n              H,\n              2.25,\n              '',\n              this.sup3 ? 'black' : 'red',\n              2,\n              1,\n              this.sup3 ? 'black' : 'red',\n            ), // OK\n            codageAngle(\n              BRot,\n              DRot,\n              G,\n              1.75,\n              '',\n              this.sup3 ? 'black' : bleuMathalea,\n              2,\n              1,\n              this.sup3 ? 'black' : bleuMathalea,\n            ),\n            codageAngle(\n              DRot,\n              CRot,\n              90,\n              1,\n              '',\n              vertMathalea,\n              2,\n              1,\n              vertMathalea,\n            ),\n          ])\n          texteSousFigure = this.sup3\n            ? \"Qu'est-ce qui caractérise les angles qui ne sont pas des angles droits ? \"\n            : \"Qu'est-ce qui caractérise les angles bleu et rouge ? \"\n          break\n        case 4:\n          // Angles complémentaires\n          texteCorr = `Ce sont des angles  ${texteEnCouleurEtGras('complémentaires')} car la somme de leurs mesures est égale à 90° (angle droit).`\n          // tabAngles contient deux angles complémentaires puis un angle droit qui chevauche ou pas ces angles selon si c'est un distracteur ou pas\n          if (\n            arrondi(\n              Math.abs(angleOriente(IRot, CRot, ARot)) +\n                Math.abs(angleOriente(G, CRot, ARot)),\n              0,\n            ) === 90\n          ) {\n            tabAngles.push([\n              codageAngle(\n                IRot,\n                CRot,\n                ARot,\n                3.25,\n                '',\n                this.sup3 ? 'black' : 'red',\n                2,\n                1,\n                this.sup3 ? 'black' : 'red',\n              ),\n              codageAngle(\n                G,\n                CRot,\n                ARot,\n                2.75,\n                '',\n                this.sup3 ? 'black' : bleuMathalea,\n                2,\n                1,\n                this.sup3 ? 'black' : bleuMathalea,\n              ),\n              codageAngle(G, CRot, 90, 1, '', vertMathalea, 2, 1, vertMathalea),\n            ])\n          } else if (\n            arrondi(\n              Math.abs(angleOriente(IRot, CRot, ARot)) +\n                Math.abs(angleOriente(DRot, CRot, ARot)),\n              0,\n            ) === 90\n          ) {\n            tabAngles.push([\n              codageAngle(\n                DRot,\n                CRot,\n                ARot,\n                3.25,\n                '',\n                this.sup3 ? 'black' : 'red',\n                2,\n                1,\n                this.sup3 ? 'black' : 'red',\n              ),\n              codageAngle(\n                IRot,\n                CRot,\n                ARot,\n                2.75,\n                '',\n                this.sup3 ? 'black' : bleuMathalea,\n                2,\n                1,\n                this.sup3 ? 'black' : bleuMathalea,\n              ),\n              codageAngle(\n                DRot,\n                CRot,\n                -90,\n                1,\n                '',\n                vertMathalea,\n                2,\n                1,\n                vertMathalea,\n              ),\n            ])\n          } else if (\n            Math.abs(angleOriente(JRot, CRot, E)) <\n            Math.abs(angleOriente(IRot, CRot, E))\n          ) {\n            // if (Math.abs(angleOriente(DRot, CRot, E)) < 90) {\n            tabAngles.push([\n              codageAngle(\n                DRot,\n                CRot,\n                E,\n                3,\n                '',\n                'black',\n                2,\n                1,\n                this.sup3 ? 'white' : 'red',\n              ),\n              // codageAngle(IRot, CRot, E, 2.75, '', this.sup3 ? 'black' : bleuMathalea, 2, 1, this.sup3 ? 'black' : bleuMathalea),\n              codageAngle(\n                JRot,\n                CRot,\n                E,\n                2.75,\n                '',\n                this.sup3 ? 'black' : bleuMathalea,\n                2,\n                1,\n                this.sup3 ? 'black' : bleuMathalea,\n              ),\n              codageAngle(\n                DRot,\n                CRot,\n                90,\n                1,\n                '',\n                vertMathalea,\n                2,\n                1,\n                vertMathalea,\n              ),\n            ])\n          } else {\n            tabAngles.push([\n              codageAngle(\n                DRot,\n                CRot,\n                E,\n                3,\n                '',\n                'black',\n                2,\n                1,\n                this.sup3 ? 'white' : 'red',\n              ),\n              // codageAngle(IRot, CRot, E, 2.75, '', this.sup3 ? 'black' : bleuMathalea, 2, 1, this.sup3 ? 'black' : bleuMathalea),\n              codageAngle(\n                IRot,\n                CRot,\n                E,\n                2.75,\n                '',\n                this.sup3 ? 'black' : bleuMathalea,\n                2,\n                1,\n                this.sup3 ? 'black' : bleuMathalea,\n              ),\n              codageAngle(G, CRot, 90, 1, '', vertMathalea, 2, 1, vertMathalea),\n            ])\n            // }\n          }\n          if (distracteur) {\n            if (Math.abs(angleOriente(G, CRot, ARot)) > 90) {\n              tabAngles.push([\n                codageAngle(\n                  IRot,\n                  CRot,\n                  ARot,\n                  3.25,\n                  '',\n                  this.sup3 ? 'black' : 'red',\n                  2,\n                  1,\n                  this.sup3 ? 'black' : 'red',\n                ),\n                codageAngle(\n                  DRot,\n                  CRot,\n                  ARot,\n                  2.75,\n                  '',\n                  this.sup3 ? 'black' : bleuMathalea,\n                  2,\n                  1,\n                  this.sup3 ? 'black' : bleuMathalea,\n                ),\n                codageAngle(\n                  DRot,\n                  CRot,\n                  -90,\n                  1,\n                  '',\n                  vertMathalea,\n                  2,\n                  1,\n                  vertMathalea,\n                ),\n              ])\n            } else if (Math.abs(angleOriente(JRot, CRot, E)) > 90) {\n              tabAngles.push([\n                codageAngle(\n                  IRot,\n                  CRot,\n                  E,\n                  3.25,\n                  '',\n                  this.sup3 ? 'black' : 'red',\n                  2,\n                  1,\n                  this.sup3 ? 'black' : 'red',\n                ),\n                codageAngle(\n                  DRot,\n                  CRot,\n                  E,\n                  2.75,\n                  '',\n                  this.sup3 ? 'black' : bleuMathalea,\n                  2,\n                  1,\n                  this.sup3 ? 'black' : bleuMathalea,\n                ),\n                codageAngle(\n                  DRot,\n                  CRot,\n                  90,\n                  1,\n                  '',\n                  vertMathalea,\n                  2,\n                  1,\n                  vertMathalea,\n                ),\n              ])\n            } else if (Math.abs(angleOriente(IRot, CRot, E)) > 90) {\n              tabAngles.push([\n                codageAngle(\n                  JRot,\n                  CRot,\n                  E,\n                  3.25,\n                  '',\n                  this.sup3 ? 'black' : 'red',\n                  2,\n                  1,\n                  this.sup3 ? 'black' : 'red',\n                ),\n                codageAngle(\n                  DRot,\n                  CRot,\n                  E,\n                  2.75,\n                  '',\n                  this.sup3 ? 'black' : bleuMathalea,\n                  2,\n                  1,\n                  this.sup3 ? 'black' : bleuMathalea,\n                ),\n                codageAngle(\n                  DRot,\n                  CRot,\n                  90,\n                  1,\n                  '',\n                  vertMathalea,\n                  2,\n                  1,\n                  vertMathalea,\n                ),\n              ])\n            }\n          }\n          texteSousFigure = this.sup3\n            ? \"Qu'est-ce qui caractérise les angles adjacents qui ne sont pas des angles droits ? \"\n            : \"Qu'est-ce qui caractérise les angles adjacents bleu et rouge ? \"\n          break\n        case 5:\n          // Côté de l'angle\n          texteCorr = `C'est un  ${texteEnCouleurEtGras('côté')} de l'angle, une demi-droite.`\n          // tabAngles contient un angle et un de ses côtés puis un angle droit qui ne chevauche pas l'angle\n          tabAngles.push([\n            codageAngle(\n              BRot,\n              DRot,\n              G,\n              1.75,\n              '',\n              this.sup3 ? 'black' : bleuMathalea,\n              2,\n              1,\n              this.sup3 ? 'black' : bleuMathalea,\n            ),\n            demiDroite(DRot, BRot, this.sup3 ? 'black' : 'red'),\n            codageAngle(\n              DRot,\n              CRot,\n              90,\n              1,\n              '',\n              vertMathalea,\n              2,\n              1,\n              vertMathalea,\n            ),\n          ])\n          tabAngles.push([\n            codageAngle(\n              BRot,\n              DRot,\n              G,\n              1.75,\n              '',\n              this.sup3 ? 'black' : bleuMathalea,\n              2,\n              1,\n              this.sup3 ? 'black' : bleuMathalea,\n            ),\n            demiDroite(DRot, G, this.sup3 ? 'black' : 'red'),\n            codageAngle(\n              DRot,\n              CRot,\n              90,\n              1,\n              '',\n              vertMathalea,\n              2,\n              1,\n              vertMathalea,\n            ),\n          ])\n          tabAngles.push([\n            codageAngle(\n              E,\n              CRot,\n              G,\n              1.75,\n              '',\n              this.sup3 ? 'black' : bleuMathalea,\n              2,\n              1,\n              this.sup3 ? 'black' : bleuMathalea,\n            ),\n            demiDroite(CRot, G, this.sup3 ? 'black' : 'red'),\n            codageAngle(\n              DRot,\n              CRot,\n              90,\n              1,\n              '',\n              vertMathalea,\n              2,\n              1,\n              vertMathalea,\n            ),\n          ])\n          tabAngles.push([\n            codageAngle(\n              E,\n              CRot,\n              G,\n              1.75,\n              '',\n              this.sup3 ? 'black' : bleuMathalea,\n              2,\n              1,\n              this.sup3 ? 'black' : bleuMathalea,\n            ),\n            demiDroite(CRot, E, this.sup3 ? 'black' : 'red'),\n            codageAngle(\n              DRot,\n              CRot,\n              90,\n              1,\n              '',\n              vertMathalea,\n              2,\n              1,\n              vertMathalea,\n            ),\n          ])\n          texteSousFigure = this.sup3\n            ? \"Qu'est-ce que caractérise la demi-droite (plus épaisse que les autres) pour l'angle ? \"\n            : \"Qu'est-ce que caractérise la demi-droite en couleur pour l'angle ? \"\n          break\n        case 6:\n          // Sommet de  l'angle\n          texteCorr = `C'est le  ${texteEnCouleurEtGras('sommet')} de l'angle, un point.`\n          // tabAngles contient un angle et le sommet de l'angle puis un angle droit qui ne chevauche pas l'angle\n          tabAngles.push([\n            codageAngle(\n              BRot,\n              DRot,\n              G,\n              1.75,\n              '',\n              this.sup3 ? 'black' : bleuMathalea,\n              2,\n              1,\n              this.sup3 ? 'black' : bleuMathalea,\n            ),\n            pointAbstrait(DRot.x, DRot.y),\n            codageAngle(\n              DRot,\n              CRot,\n              90,\n              1,\n              '',\n              vertMathalea,\n              2,\n              1,\n              vertMathalea,\n            ),\n          ])\n          tabAngles.push([\n            codageAngle(\n              E,\n              CRot,\n              G,\n              1.75,\n              '',\n              this.sup3 ? 'black' : bleuMathalea,\n              2,\n              1,\n              this.sup3 ? 'black' : bleuMathalea,\n            ),\n            pointAbstrait(CRot.x, CRot.y),\n            codageAngle(\n              DRot,\n              CRot,\n              90,\n              1,\n              '',\n              vertMathalea,\n              2,\n              1,\n              vertMathalea,\n            ),\n          ])\n          texteSousFigure = this.sup3\n            ? \"Qu'est-ce que caractérise le point pour l'angle ? \"\n            : \"Qu'est-ce que caractérise le point en couleur pour l'angle ? \"\n          break\n        case 7:\n          // Angles adjacents (non complémentaires)\n          texteCorr = `Ce sont des angles  ${texteEnCouleurEtGras('adjacents')} car ils ont un sommet commun, ils ont un côté en commun et sont de part et d'autre de ce sommet.`\n          // tabAngles contient deux angles adjacents (non complémentaires) puis un angle droit qui ne chevauche pas ces angles\n          if (Math.abs(angleOriente(G, CRot, ARot)) > 90) {\n            tabAngles.push([\n              codageAngle(\n                G,\n                CRot,\n                E,\n                3.25,\n                '',\n                this.sup3 ? 'black' : 'red',\n                2,\n                1,\n                this.sup3 ? 'black' : 'red',\n              ),\n              codageAngle(\n                JRot,\n                CRot,\n                E,\n                2.75,\n                '',\n                this.sup3 ? 'black' : bleuMathalea,\n                2,\n                1,\n                this.sup3 ? 'black' : bleuMathalea,\n                undefined,\n                undefined,\n                true,\n              ),\n              codageAngle(\n                DRot,\n                CRot,\n                90,\n                1,\n                '',\n                vertMathalea,\n                2,\n                1,\n                vertMathalea,\n              ),\n            ])\n            tabAngles.push([\n              codageAngle(\n                G,\n                CRot,\n                E,\n                3.25,\n                '',\n                this.sup3 ? 'black' : 'red',\n                2,\n                1,\n                this.sup3 ? 'black' : 'red',\n              ),\n              codageAngle(\n                IRot,\n                CRot,\n                G,\n                2.75,\n                '',\n                this.sup3 ? 'black' : bleuMathalea,\n                2,\n                1,\n                this.sup3 ? 'black' : bleuMathalea,\n                undefined,\n                undefined,\n                true,\n              ),\n              codageAngle(\n                DRot,\n                CRot,\n                90,\n                1,\n                '',\n                vertMathalea,\n                2,\n                1,\n                vertMathalea,\n              ),\n            ])\n            tabAngles.push([\n              codageAngle(\n                IRot,\n                CRot,\n                ARot,\n                3.25,\n                '',\n                this.sup3 ? 'black' : 'red',\n                2,\n                1,\n                this.sup3 ? 'black' : 'red',\n              ),\n              codageAngle(\n                IRot,\n                CRot,\n                G,\n                2.75,\n                '',\n                this.sup3 ? 'black' : bleuMathalea,\n                2,\n                1,\n                this.sup3 ? 'black' : bleuMathalea,\n                undefined,\n                undefined,\n                true,\n              ),\n              codageAngle(\n                DRot,\n                CRot,\n                -90,\n                1,\n                '',\n                vertMathalea,\n                2,\n                1,\n                vertMathalea,\n              ),\n            ])\n          } else {\n            /*\n              tabAngles.push([\n              codageAngle(ARot, CRot, G, 3.25, '', this.sup3 ? 'black' : 'red', 2, 1, this.sup3 ? 'red' : 'red'),\n              codageAngle(IRot, CRot, G, 2.75, '', this.sup3 ? 'black' : bleuMathalea, 2, 1, this.sup3 ? 'black' : bleuMathalea, undefined, undefined, true),\n              // codageAngle(DRot, CRot, 90, 1, '', vertMathalea, 2, 1, vertMathalea)\n              codageAngle(JRot, CRot, -90, 1, '', vertMathalea, 2, 1, vertMathalea)\n            ]) */\n            tabAngles.push([\n              codageAngle(\n                JRot,\n                CRot,\n                E,\n                3.25,\n                '',\n                this.sup3 ? 'black' : 'red',\n                2,\n                1,\n                this.sup3 ? 'black' : 'red',\n              ),\n              codageAngle(\n                JRot,\n                CRot,\n                G,\n                2.75,\n                '',\n                this.sup3 ? 'black' : bleuMathalea,\n                2,\n                1,\n                this.sup3 ? 'black' : bleuMathalea,\n                undefined,\n                undefined,\n                true,\n              ),\n              // codageAngle(DRot, CRot, 90, 1, '', vertMathalea, 2, 1, vertMathalea)\n              // codageAngle(G, CRot, 90, 1, '', vertMathalea, 2, 1, vertMathalea)\n              codageAngle(\n                IRot,\n                CRot,\n                -90,\n                1,\n                '',\n                vertMathalea,\n                2,\n                1,\n                vertMathalea,\n              ),\n            ])\n          }\n          texteSousFigure = this.sup3\n            ? \"Qu'est-ce qui caractérise les angles qui ne sont pas des angles droits ? \"\n            : \"Qu'est-ce qui caractérise les angles bleu et rouge ? \"\n          break\n          break\n      }\n      const choixPossibilitesAngles = range(tabAngles.length - 1)\n      const choixAngle = choice(choixPossibilitesAngles)\n      const ang1 = tabAngles[choixAngle][0]\n      let objet2 = tabAngles[choixAngle][1]\n      if (\n        choixQuestion === 5 &&\n        !(objet2 instanceof PointAbstrait) &&\n        !(objet2 instanceof CodageAngleDroit)\n      )\n        objet2.epaisseur = 3\n      else if (choixQuestion === 6 && objet2 instanceof PointAbstrait) {\n        objet2 = tracePoint(objet2, this.sup3 ? 'black' : 'red')\n        objet2.epaisseur = 2\n        objet2.taille = 5\n      }\n      const ang3 = tabAngles[choixAngle][2]\n\n      /*\n      // Ne pas effacer : utile pour le débuggage\n      const labelA = latexParPoint('A', ARot, this.sup3 ? 'black' : 'red', 10, 12, '', 10)\n      const labelB = latexParPoint('B', BRot, this.sup3 ? 'black' : 'red', 10, 12, '', 10)\n      const labelC = latexParPoint('C', CRot, this.sup3 ? 'black' : 'red', 10, 12, '', 10)\n      const labelD = latexParPoint('D', DRot, this.sup3 ? 'black' : 'red', 10, 12, '', 10)\n      const labelE = latexParPoint('E', E, this.sup3 ? 'black' : 'red', 10, 12, '', 10)\n      const labelF = latexParPoint('F', F, this.sup3 ? 'black' : 'red', 10, 12, '', 10)\n      const labelG = latexParPoint('G', G, this.sup3 ? 'black' : 'red', 10, 12, '', 10)\n      const labelH = latexParPoint('H', H, this.sup3 ? 'black' : 'red', 10, 12, '', 10)\n\n      const labelI = latexParPoint('I', IRot, this.sup3 ? 'black' : 'red', 10, 12, '', 10)\n      const labelJ = latexParPoint('J', JRot, this.sup3 ? 'black' : 'red', 10, 12, '', 10)\n      objets.push(tracePts, labelA, labelB, labelC, labelD, labelE, labelF, labelG, labelH, labelI, labelJ)\n      */\n\n      switch (choixQuestion) {\n        case 0:\n        case 1:\n          if (distracteur) {\n            objets.push(ang3, d4Rot)\n          }\n          objets.push(d1Rot, d2Rot)\n          break\n        case 2:\n          if (choixAngle < 2) objets.push(d2Rot)\n          else objets.push(d1Rot)\n          if (distracteur) {\n            objets.push(ang3, d1Rot, d2Rot, d4Rot)\n          }\n          break\n        case 3:\n          if (distracteur) {\n            objets.push(ang3, d1Rot, d2Rot, d4Rot)\n          }\n          if (choixAngle === 0 && tabAngles.length === 3) objets.push(d1Rot)\n          else objets.push(d2Rot)\n          break\n        case 4:\n          if (distracteur) {\n            objets.push(d2Rot)\n          }\n          objets.push(ang3, d1Rot, d4Rot)\n          break\n        case 5:\n          if (choixAngle < 2) objets.push(d2Rot)\n          else objets.push(d1Rot)\n          if (distracteur) {\n            objets.push(ang3, d4Rot, d1Rot, d2Rot)\n          }\n          break\n        case 6:\n          if (choixAngle < 1) objets.push(d2Rot)\n          else objets.push(d1Rot)\n          if (distracteur) {\n            objets.push(ang3, d4Rot)\n          }\n          break\n        case 7:\n          if (distracteur) {\n            objets.push(ang3, d2Rot)\n          }\n          objets.push(d1Rot, d4Rot)\n          break\n      }\n      objets.push(ang1, objet2, d3Rot)\n\n      const choixTypeAngles = [\n        { label: \"Choisir le type d'angles\", value: '' },\n        { label: 'correspondants', value: 'correspondants' },\n        { label: 'alternes-internes', value: 'alternes-internes' },\n        { label: 'supplémentaires', value: 'supplémentaires' },\n        { label: 'opposés par le sommet', value: 'opposés par le sommet' },\n        { label: 'complémentaires', value: 'complémentaires' },\n        { label: 'côté', value: 'côté' },\n        { label: 'sommet', value: 'sommet' },\n      ]\n      if (choixQuestion !== 2 && choixQuestion !== 4)\n        choixTypeAngles.push({ label: 'adjacents', value: 'adjacents' })\n      if (this.interactif) {\n        texteSousFigure += choixDeroulant(this, i, choixTypeAngles)\n        handleAnswers(\n          this,\n          i,\n          {\n            bareme: (listePoints: number[]) => [\n              Math.min(listePoints[0], listePoints[1]),\n              1,\n            ],\n            reponse: {\n              value: choixTypeAngles[choixQuestion + 1].value,\n              options: { texteSansCasse: true },\n            },\n          },\n          { formatInteractif: 'listeDeroulante' },\n        )\n      }\n\n      // On impose xmin et le reste pour avoir toujours la même taille de fenêtre.\n      let texte = context.isHtml ? '<br>' : ''\n      texte += mathalea2d(\n        {\n          zoom: 1,\n          scale: 0.25,\n          xmin: -8,\n          xmax: 8,\n          ymin: -8,\n          ymax: 8,\n          optionsTikz: ['baseline=(current bounding box.north)'],\n        },\n        objets,\n      ) // On trace le graphique\n      texte += texteSousFigure\n      if (\n        this.questionJamaisPosee(\n          i,\n          ARot.x,\n          ARot.y,\n          BRot.x,\n          BRot.y,\n          CRot.x,\n          CRot.y,\n          choixQuestion,\n        )\n      ) {\n        // Si la question n'a jamais été posée, on en créé une autre\n        this.listeQuestions[i] = texte\n        this.listeCorrections[i] = texteCorr\n        i++\n      }\n      cpt++\n    }\n    listeQuestionsToContenu(this)\n  }\n}\n"],"names":["interactifReady","interactifType","titre","dateDePublication","dateDeModifImportante","uuid","refs","tousDansIntervalle","points","point","VocabulaireAngles","Exercice","typesDeQuestionsDisponibles","gestionnaireFormulaireTexte","i","cpt","texteCorr","objets","origine","pointAbstrait","ARot","BRot","CRot","DRot","IRot","JRot","E","F","G","H","d1Rot","d2Rot","d3Rot","d4Rot","distracteur","xA","randint","yA","xB","yB","A","B","d1","droiteParPointEtPente","d2","C","pointSurDroite","longueur","D","d3","droite","d4","droiteParPointEtPerpendiculaire","choix","rotation","translation2Points","tracePts","tracePoint","tabAngles","choixQuestion","number","texteSousFigure","texteEnCouleurEtGras","codageAngle","bleuMathalea","vertMathalea","angleOriente","arrondi","demiDroite","choixPossibilitesAngles","range","choixAngle","choice","ang1","objet2","PointAbstrait","CodageAngleDroit","ang3","choixTypeAngles","choixDeroulant","handleAnswers","listePoints","texte","context","mathalea2d","listeQuestionsToContenu"],"mappings":"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U,KAAA,EAExBmC,EACE1C,EACAE,EACAK,EACA,KACA,GACA,KAAK,KAAO,QAAUoC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EACExC,EACAD,EACA,GACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EACDP,EAAU,KAAK,CACbK,EACErC,EACAJ,EACAC,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExBwC,EACE1C,EACAE,EACAM,EACA,KACA,GACA,KAAK,KAAO,QAAUmC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EAAYnC,EAAGN,EAAM,GAAI,EAAG,GAAI2C,EAAc,EAAG,EAAGA,CAAY,CAAA,CACjE,EACDP,EAAU,KAAK,CACbK,EACE3C,EACAE,EACAC,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExBwC,EACEpC,EACAJ,EACAM,EACA,KACA,GACA,KAAK,KAAO,QAAUmC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EAAYnC,EAAGN,EAAM,GAAI,EAAG,GAAI2C,EAAc,EAAG,EAAGA,CAAY,CAAA,CACjE,EACDP,EAAU,KAAK,CACbK,EACE3C,EACAE,EACAM,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExBmC,EACEpC,EACAJ,EACAK,EACA,KACA,GACA,KAAK,KAAO,QAAUoC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EACExC,EACAD,EACA,GACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EACDJ,EAAkB,KAAK,KACnB,4EACA,wDACJ,MACF,IAAK,GAEH7C,EAAY,sBAAsB8C,EAAqB,mBAAmB,CAAC,IAE3EJ,EAAU,KAAK,CACbK,EACE3C,EACAE,EACAC,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExBwC,EACE1C,EACAE,EACAK,EACA,KACA,GACA,KAAK,KAAO,QAAUoC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EAAYnC,EAAGN,EAAM,GAAI,EAAG,GAAI2C,EAAc,EAAG,EAAGA,CAAY,CAAA,CACjE,EACDP,EAAU,KAAK,CACbK,EACErC,EACAJ,EACAC,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExBwC,EACEzC,EACAC,EACAI,EACA,KACA,GACA,KAAK,KAAO,QAAUqC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EAAYnC,EAAGN,EAAM,GAAI,EAAG,GAAI2C,EAAc,EAAG,EAAGA,CAAY,CAAA,CACjE,EACDJ,EAAkB,KAAK,KACnB,4EACA,wDACJ,MACF,IAAK,GAEH7C,EAAY,uBAAuB8C,EAAqB,iBAAiB,CAAC,gEAE1EJ,EAAU,KAAK,CACbK,EACEnC,EACAL,EACAF,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExB0C,EACEpC,EACAJ,EACAK,EACA,KACA,GACA,KAAK,KAAO,QAAUoC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EACExC,EACAD,EACA,GACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EACDP,EAAU,KAAK,CACbK,EACEpC,EACAJ,EACAM,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExBkC,EACEpC,EACAJ,EACAK,EACA,KACA,GACA,KAAK,KAAO,QAAUoC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EACExC,EACAD,EACA,GACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EACDP,EAAU,KAAK,CACbK,EACE3C,EACAE,EACAM,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExBmC,EACE3C,EACAE,EACAC,EACA,KACA,GACA,KAAK,KAAO,QAAUyC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAGxBD,EACExC,EACAD,EACA,IACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EACDP,EAAU,KAAK,CACbK,EACE3C,EACAE,EACAM,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExBmC,EACErC,EACAJ,EACAM,EACA,KACA,GACA,KAAK,KAAO,QAAUoC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EACExC,EACAD,EACA,GACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EACDJ,EAAkB,KAAK,KACnB,sFACA,kEACJ,MACF,IAAK,GAEH7C,EAAY,uBAAuB8C,EAAqB,SAAS,CAAC,kBAE9D,KAAK,IAAII,EAAatC,EAAGN,EAAMF,CAAI,CAAC,EAAI,IAC1CsC,EAAU,KAAK,CACbK,EACEnC,EACAN,EACAF,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExB2C,EACErC,EACAJ,EACAO,EACA,KACA,GACA,KAAK,KAAO,QAAUmC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EACExC,EACAD,EACA,GACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EAEHP,EAAU,KAAK,CACbK,EACEpC,EACAJ,EACAK,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExBmC,EACE1C,EACAE,EACAM,EACA,KACA,GACA,KAAK,KAAO,QAAUmC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EACExC,EACAD,EACA,GACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EACDP,EAAU,KAAK,CACbK,EACEpC,EACAJ,EACAM,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExBkC,EACE1C,EACAE,EACAK,EACA,KACA,GACA,KAAK,KAAO,QAAUoC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EACExC,EACAD,EACA,GACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EACDJ,EAAkB,KAAK,KACnB,4EACA,wDACJ,MACF,IAAK,GAEH7C,EAAY,uBAAuB8C,EAAqB,iBAAiB,CAAC,gEAGxEK,GACE,KAAK,IAAID,EAAa1C,EAAMF,EAAMF,CAAI,CAAC,EACrC,KAAK,IAAI8C,EAAatC,EAAGN,EAAMF,CAAI,CAAC,EACtC,CAAA,IACI,GAENsC,EAAU,KAAK,CACbK,EACEvC,EACAF,EACAF,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExB2C,EACEnC,EACAN,EACAF,EACA,KACA,GACA,KAAK,KAAO,QAAU4C,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EAAYnC,EAAGN,EAAM,GAAI,EAAG,GAAI2C,EAAc,EAAG,EAAGA,CAAY,CAAA,CACjE,EAEDE,GACE,KAAK,IAAID,EAAa1C,EAAMF,EAAMF,CAAI,CAAC,EACrC,KAAK,IAAI8C,EAAa3C,EAAMD,EAAMF,CAAI,CAAC,EACzC,CAAA,IACI,GAENsC,EAAU,KAAK,CACbK,EACExC,EACAD,EACAF,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExB2C,EACEvC,EACAF,EACAF,EACA,KACA,GACA,KAAK,KAAO,QAAU4C,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EACExC,EACAD,EACA,IACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EAED,KAAK,IAAIC,EAAazC,EAAMH,EAAMI,CAAC,CAAC,EACpC,KAAK,IAAIwC,EAAa1C,EAAMF,EAAMI,CAAC,CAAC,EAGpCgC,EAAU,KAAK,CACbK,EACExC,EACAD,EACAI,EACA,EACA,GACA,QACA,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAGxBqC,EACEtC,EACAH,EACAI,EACA,KACA,GACA,KAAK,KAAO,QAAUsC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EACExC,EACAD,EACA,GACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EAEDP,EAAU,KAAK,CACbK,EACExC,EACAD,EACAI,EACA,EACA,GACA,QACA,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAGxBqC,EACEvC,EACAF,EACAI,EACA,KACA,GACA,KAAK,KAAO,QAAUsC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EAAYnC,EAAGN,EAAM,GAAI,EAAG,GAAI2C,EAAc,EAAG,EAAGA,CAAY,CAAA,CACjE,EAGC/B,IACE,KAAK,IAAIgC,EAAatC,EAAGN,EAAMF,CAAI,CAAC,EAAI,GAC1CsC,EAAU,KAAK,CACbK,EACEvC,EACAF,EACAF,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExB2C,EACExC,EACAD,EACAF,EACA,KACA,GACA,KAAK,KAAO,QAAU4C,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EACExC,EACAD,EACA,IACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EACQ,KAAK,IAAIC,EAAazC,EAAMH,EAAMI,CAAC,CAAC,EAAI,GACjDgC,EAAU,KAAK,CACbK,EACEvC,EACAF,EACAI,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExBqC,EACExC,EACAD,EACAI,EACA,KACA,GACA,KAAK,KAAO,QAAUsC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EACExC,EACAD,EACA,GACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EACQ,KAAK,IAAIC,EAAa1C,EAAMF,EAAMI,CAAC,CAAC,EAAI,IACjDgC,EAAU,KAAK,CACbK,EACEtC,EACAH,EACAI,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExBqC,EACExC,EACAD,EACAI,EACA,KACA,GACA,KAAK,KAAO,QAAUsC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBD,EACExC,EACAD,EACA,GACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,GAGLJ,EAAkB,KAAK,KACnB,sFACA,kEACJ,MACF,IAAK,GAEH7C,EAAY,aAAa8C,EAAqB,MAAM,CAAC,gCAErDJ,EAAU,KAAK,CACbK,EACE1C,EACAE,EACAK,EACA,KACA,GACA,KAAK,KAAO,QAAUoC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBI,EAAW7C,EAAMF,EAAM,KAAK,KAAO,QAAU,KAAK,EAClD0C,EACExC,EACAD,EACA,GACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EACDP,EAAU,KAAK,CACbK,EACE1C,EACAE,EACAK,EACA,KACA,GACA,KAAK,KAAO,QAAUoC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBI,EAAW7C,EAAMK,EAAG,KAAK,KAAO,QAAU,KAAK,EAC/CmC,EACExC,EACAD,EACA,GACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EACDP,EAAU,KAAK,CACbK,EACErC,EACAJ,EACAM,EACA,KACA,GACA,KAAK,KAAO,QAAUoC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBI,EAAW9C,EAAMM,EAAG,KAAK,KAAO,QAAU,KAAK,EAC/CmC,EACExC,EACAD,EACA,GACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EACDP,EAAU,KAAK,CACbK,EACErC,EACAJ,EACAM,EACA,KACA,GACA,KAAK,KAAO,QAAUoC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExBI,EAAW9C,EAAMI,EAAG,KAAK,KAAO,QAAU,KAAK,EAC/CqC,EACExC,EACAD,EACA,GACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EACDJ,EAAkB,KAAK,KACnB,yFACA,sEACJ,MACF,IAAK,GAEH7C,EAAY,aAAa8C,EAAqB,QAAQ,CAAC,yBAEvDJ,EAAU,KAAK,CACbK,EACE1C,EACAE,EACAK,EACA,KACA,GACA,KAAK,KAAO,QAAUoC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExB7C,EAAcI,EAAK,EAAGA,EAAK,CAAC,EAC5BwC,EACExC,EACAD,EACA,GACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EACDP,EAAU,KAAK,CACbK,EACErC,EACAJ,EACAM,EACA,KACA,GACA,KAAK,KAAO,QAAUoC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,CAAA,EAExB7C,EAAcG,EAAK,EAAGA,EAAK,CAAC,EAC5ByC,EACExC,EACAD,EACA,GACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EACDJ,EAAkB,KAAK,KACnB,qDACA,gEACJ,MACF,IAAK,GAEH7C,EAAY,uBAAuB8C,EAAqB,WAAW,CAAC,oGAEhE,KAAK,IAAII,EAAatC,EAAGN,EAAMF,CAAI,CAAC,EAAI,IAC1CsC,EAAU,KAAK,CACbK,EACEnC,EACAN,EACAI,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExBqC,EACEtC,EACAH,EACAI,EACA,KACA,GACA,KAAK,KAAO,QAAUsC,EACtB,EACA,EACA,KAAK,KAAO,QAAUA,EACtB,OACA,OACA,EAAA,EAEFD,EACExC,EACAD,EACA,GACA,EACA,GACA2C,EACA,EACA,EACAA,CAAA,CACF,CACD,EACDP,EAAU,KAAK,CACbK,EACEnC,EACAN,EACAI,EACA,KACA,GACA,KAAK,KAAO,QAAU,MACtB,EACA,EACA,KAAK,KAAO,QAAU,KAAA,EAExBqC,EACEvC,EACAF,EACAM,EACA,KACA,GACA,KAAK,KAAO,QAAUoC,EACtB,EACA,EAC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"}