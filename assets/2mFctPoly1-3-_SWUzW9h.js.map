{"version":3,"file":"2mFctPoly1-3-_SWUzW9h.js","sources":["../../src/exercices/ch/2mFctPoly1-3.ts"],"sourcesContent":["import { round } from 'mathjs'\nimport { colorToLatexOrHTML } from '../../lib/2d/colorToLatexOrHtml'\nimport { Courbe } from '../../lib/2d/Courbe'\nimport { repere } from '../../lib/2d/reperes'\nimport { texteParPosition } from '../../lib/2d/textes'\nimport PolynomeFactorisable from '../../lib/mathFonctions/PolynomeFactorisableDegMax4'\nimport PolynomePlusieursVariables from '../../lib/mathFonctions/PolynomePlusieursVariables'\nimport { miseEnEvidence } from '../../lib/outils/embellissements'\nimport FractionEtendue from '../../modules/FractionEtendue'\nimport { mathalea2d } from '../../modules/mathalea2d'\nimport {\n  gestionnaireFormulaireTexte,\n  listeQuestionsToContenu,\n  randint,\n} from '../../modules/outils'\nimport Exercice from '../Exercice'\n\nexport const titre =\n  \"Déterminer l'expression factorisée d'une fonction polynomiale à partir de sa représentation graphique\"\nexport const dateDePublication = '09/10/2025'\nexport const interactifReady = false\nexport const uuid = '25430'\nexport const refs = {\n  'fr-fr': [],\n  'fr-ch': ['2mFctPoly1-3'],\n}\n\n/**\n * Déterminer l'expression factorisée d'une fonction polynomiale à partir de sa représentation graphique. bug: nZkz\n * @author Nathan Scheinmann\n */\n\nexport default class ExerciceFactorisePoly extends Exercice {\n  constructor() {\n    super()\n    this.besoinFormulaireNumerique = [\n      'Coefficient dominant',\n      4,\n      '1: Égal à 1\\n2: Entier relatif\\n3: Fractionnaire\\n4: Mélange',\n    ]\n    this.besoinFormulaire2Numerique = [\n      'Degré du polynôme',\n      4,\n      '1: 3\\n2: 4\\n3: Mélange',\n    ]\n    this.sup = 4\n    this.sup2 = 5\n    this.nbQuestions = 3\n    this.correctionDetailleeDisponible = true\n  }\n\n  nouvelleVersion() {\n    const listeTypeDeQuestions = gestionnaireFormulaireTexte({\n      saisie: this.sup,\n      min: 1,\n      max: 3,\n      melange: 4,\n      defaut: 4,\n      listeOfCase: ['1', 'relatif', 'fractionnaire'],\n      shuffle: true,\n      nbQuestions: this.nbQuestions,\n    })\n    const listeTypeDeQuestions2 = gestionnaireFormulaireTexte({\n      saisie: this.sup2,\n      min: 1,\n      max: 2,\n      melange: 3,\n      defaut: 3,\n      listeOfCase: [3, 4],\n      shuffle: true,\n      nbQuestions: this.nbQuestions,\n    })\n    for (let i = 0, cpt = 0; i < this.nbQuestions && cpt < 50; ) {\n      let texte = ''\n      let texteCorr = ''\n      let deg: number\n      let lMult: number[]\n      let lRoots: FractionEtendue[]\n      let coeffDom: FractionEtendue\n\n      // Déterminer le degré selon le paramètre sup2\n      deg = listeTypeDeQuestions2[i] as number\n\n      // Générer une liste de multiplicités qui somme à deg\n      lMult = []\n      let sommeMult = 0\n\n      // Déterminer combien de racines distinctes (entre 1 et deg)\n      const nbRacines = randint(round(deg / 2), Math.min(deg, 3))\n\n      lMult = Array(nbRacines).fill(1)\n      sommeMult = nbRacines\n      while (sommeMult < deg) {\n        const idx = randint(0, nbRacines - 1)\n        if (lMult[idx] < 2) {\n          // Limiter la multiplicité à 2 pour éviter les cas trop plats\n          lMult[idx]++\n          sommeMult++\n        }\n      }\n\n      // Générer des racines distinctes\n      lRoots = []\n      for (let j = 0; j < deg; j++) {\n        // Exclure les racines existantes et leurs voisins ±1\n        const exclusions = lRoots.flatMap((r) => [r.num - 1, r.num])\n        const racine = new FractionEtendue(randint(-3, 3, exclusions), 1)\n        for (let k = 0; k < lMult[j]; k++) {\n          lRoots.push(racine)\n        }\n      }\n      coeffDom = new FractionEtendue(1, 1)\n      // Déterminer le coefficient dominant selon le paramètre sup\n      const typeCoeff = listeTypeDeQuestions[i] as string\n      if (typeCoeff === '1') {\n        coeffDom = new FractionEtendue(1, 1)\n      } else if (typeCoeff === 'relatif') {\n        coeffDom = new FractionEtendue(randint(-2, 2, [0]), 1)\n      } else if (typeCoeff === 'fractionnaire') {\n        do {\n          coeffDom = new FractionEtendue(\n            randint(-4, 4, [0]),\n            randint(1, 4),\n          ).simplifie()\n        } while (coeffDom.estEntiere)\n      }\n      const polynome = PolynomePlusieursVariables.createPolynomeFromRoots(\n        lRoots,\n        coeffDom,\n      )\n\n      // Créer une fonction à partir du polynôme pour la courbe\n      const f = (x: number) =>\n        polynome.evaluer({ x: new FractionEtendue(x, 1) }).valeurDecimale\n\n      const r = repere({\n        xMin: -6,\n        xMax: 6,\n        yMin: -8,\n        yMax: 8,\n        yLabelEcart: 0.8,\n        yLabelDistance: 2,\n        xLabelDistance: 2,\n        grilleX: false,\n        grilleY: false,\n        grilleSecondaire: true,\n        grilleSecondaireYDistance: 1,\n        grilleSecondaireXDistance: 1,\n        grilleSecondaireYMin: -8,\n        grilleSecondaireYMax: 8,\n        grilleSecondaireXMin: -8,\n        grilleSecondaireXMax: 8,\n      })\n\n      const courbe = new Courbe(f, {\n        repere: r,\n        step: 0.1,\n        xMin: -6,\n        xMax: 6,\n        yMin: -1000,\n        yMax: 1000,\n        usePgfplots: true,\n        fLatex: polynome.toPgfplots(), // Use the polynomial's pgfplots expression\n      })\n      courbe.color = colorToLatexOrHTML('red')\n      courbe.epaisseur = 2\n\n      const o = texteParPosition('O', -0.5, -0.5, 0, 'black', 1)\n      let Px = new FractionEtendue(0, 1)\n      let Py = polynome.evaluer({ x: Px })\n      while (Py.num === 0) {\n        Px = new FractionEtendue(randint(-3, 3), 1)\n        Py = polynome.evaluer({ x: Px })\n      }\n      texte += `Déterminer l'expression algébrique factorisée de la fonction polynomiale de degré minimal ayant la représentation ci-dessous et passant par le point $P\\\\left(${Px.texFractionSimplifiee}\\\\,;\\\\,${Py.texFractionSimplifiee}\\\\right)$.<br><br>`\n      texte += mathalea2d(\n        {\n          xmin: -8,\n          ymin: -8,\n          xmax: 8,\n          ymax: 8,\n          scale: 1,\n          usePgfplots: true,\n          centerLatex: true,\n        },\n        r,\n        o,\n        courbe,\n      )\n      const polynomeFact = new PolynomeFactorisable(lRoots, coeffDom)\n      const polynomeFactSansCoeff = new PolynomeFactorisable(\n        lRoots,\n        new FractionEtendue(1, 1),\n      )\n\n      if (this.correctionDetaillee) {\n        texteCorr += `On commence par identifier les racines de la fonction polynomiale à partir de son graphique. On trouve les racines suivantes :`\n        const racinesGraph = Array.from(\n          new Set(lRoots.map((r) => r.texFractionSimplifiee)),\n        )\n          .sort((a, b) => parseFloat(a) - parseFloat(b))\n          .join(';\\\\, ')\n        texteCorr += `$${racinesGraph}$.<br> Pour chaque racine, on détermine la multiplicité en observant le comportement de la courbe au voisinage de la racine : si la courbe coupe l'axe des abscisses, la multiplicité est impaire et si la courbe est tangente à l'axe des abscisses, la multiplicité est paire.<br> On recherche le polynôme de degré minimal, donc on choisit la plus petite multiplicité possible pour chaque racine. On a ainsi que l'expression de la fonction est de la forme<br>\\\\[f(x)=a${polynomeFactSansCoeff.toLatex(true)}.\\\\] \n        On évalue dans le point $P$ pour déterminer le coefficient $a$ :<br>\n        $\\\\begin{aligned}\n        f(${Px.texFractionSimplifiee})&=${Py.texFractionSimplifiee}\\\\\\\\\n        &=a${polynomeFactSansCoeff.toLatexFactoriseSubstitue(Px)}\\\\\\\\\n        &=${polynomeFactSansCoeff.polynome.evaluer({ x: Px }).texFractionSimplifiee}a\n        \\\\end{aligned}$<br>\n        d'où $a=${coeffDom.texFractionSimplifiee}$.<br>`\n      }\n      texteCorr += `La forme factorisée de la fonction polynomiale est :<br>\n      $f(x) = ${miseEnEvidence(polynomeFact.toLatex(true))}$.`\n\n      if (this.questionJamaisPosee(i, texte)) {\n        this.listeQuestions[i] = texte\n        this.listeCorrections[i] = texteCorr\n        i++\n      }\n      cpt++\n    }\n    listeQuestionsToContenu(this)\n  }\n}\n"],"names":["titre","dateDePublication","interactifReady","uuid","refs","ExerciceFactorisePoly","Exercice","listeTypeDeQuestions","gestionnaireFormulaireTexte","listeTypeDeQuestions2","i","cpt","texte","texteCorr","deg","lMult","lRoots","coeffDom","sommeMult","nbRacines","randint","round","idx","j","exclusions","r","racine","FractionEtendue","k","typeCoeff","polynome","PolynomePlusieursVariables","f","x","repere","courbe","Courbe","colorToLatexOrHTML","o","texteParPosition","Px","Py","mathalea2d","polynomeFact","PolynomeFactorisable","polynomeFactSansCoeff","racinesGraph","a","b","miseEnEvidence","listeQuestionsToContenu"],"mappings":"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"}