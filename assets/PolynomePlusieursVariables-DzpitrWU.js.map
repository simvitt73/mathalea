{"version":3,"file":"PolynomePlusieursVariables-DzpitrWU.js","sources":["../../src/lib/mathFonctions/PolynomePlusieursVariables.ts"],"sourcesContent":["import { context } from '../../modules/context'\nimport FractionEtendue from '../../modules/FractionEtendue'\nimport { randint } from '../../modules/outils'\nimport { shuffle } from '../outils/arrayOutils'\nimport { miseEnEvidence } from '../outils/embellissements'\nimport { ppcmListe } from '../outils/primalite'\nimport MonomePlusieursVariables from './MonomePlusieursVariables'\n\nclass PolynomePlusieursVariables {\n  monomes: MonomePlusieursVariables[]\n  coefficients: FractionEtendue[]\n\n  constructor(monomes: MonomePlusieursVariables[] | MonomePlusieursVariables) {\n    this.monomes = Array.isArray(monomes) ? monomes : [monomes]\n    this.coefficients = this.monomes.map((m) => m.coefficient.simplifie())\n  }\n\n  get degre(): number {\n    if (this.monomes.length === 0) return 0\n    return Math.max(...this.monomes.map((m) => m.degre))\n  }\n\n  get ppcm(): number {\n    return ppcmListe(this.monomes.map((m) => m.coefficient.simplifie().den))\n  }\n\n  static PolynomeNonReduit(\n    monomes: MonomePlusieursVariables[],\n  ): PolynomePlusieursVariables {\n    return new PolynomePlusieursVariables(monomes)\n  }\n\n  static PolynomeReduit(\n    monomes: MonomePlusieursVariables[],\n  ): PolynomePlusieursVariables {\n    const monomesNew: MonomePlusieursVariables[] = []\n\n    monomes.forEach((monome) => ajouterMonome(monome))\n\n    function ajouterMonome(monome: MonomePlusieursVariables): void {\n      const index = monomesNew.findIndex((m) => m.estSemblable(monome))\n      if (index !== -1) {\n        monomesNew[index] = monomesNew[index].somme(monome)\n        if (monomesNew[index].coefficient.num === 0) {\n          monomesNew.splice(index, 1)\n        }\n      } else {\n        monomesNew.push(monome)\n      }\n    }\n    // order the monomials by decreasing degree\n    monomesNew.sort((a, b) => {\n      return -(a.degre - b.degre)\n    })\n\n    return new PolynomePlusieursVariables(monomesNew)\n  }\n\n  // Créer un polynome aléatoire de degré donné avec le nombre de terme donné en paramètre. Il faudrait également ajouter un paramètre pour le type de coefficient, les variables et si on veut spécifier un ou plusieurs monômes (parties littérales) particuliers qui doivent être inclus dans le polynôme\n  static createRandomPolynome(\n    degMin: number,\n    degMax: number,\n    nbTermes: number,\n    typeCoeff: string,\n    variables: string[],\n    monomes: MonomePlusieursVariables[] = [],\n    coeffMax: number = 10,\n  ): PolynomePlusieursVariables {\n    const monomesListe = [\n      MonomePlusieursVariables.createRandomMonome(\n        randint(degMin, degMax),\n        typeCoeff,\n        variables,\n        coeffMax,\n      ),\n    ]\n    // Add a check to make sure that all the monomials have a different literal part\n    while (monomesListe.length < nbTermes) {\n      if (monomes.length > monomesListe.length) {\n        monomesListe.push(\n          MonomePlusieursVariables.createMonomeFromPartieLitterale(\n            typeCoeff,\n            monomes[monomesListe.length].partieLitterale,\n            coeffMax,\n          ),\n        )\n      } else {\n        let isSemblable = false\n        do {\n          const m = MonomePlusieursVariables.createRandomMonome(\n            randint(0, degMax),\n            typeCoeff,\n            variables,\n            coeffMax,\n          )\n          isSemblable = false\n          // check if m is not sembable with any of the monomes in monomesListe\n          for (let j = 0; j < monomesListe.length; j++) {\n            if (m.estSemblable(monomesListe[j])) {\n              isSemblable = true\n              break\n            }\n          }\n          if (!isSemblable) {\n            monomesListe.push(m)\n          }\n        } while (isSemblable)\n      }\n    }\n    shuffle(monomesListe)\n    return new PolynomePlusieursVariables(monomesListe)\n  }\n\n  static createPolynomeFromMonome(\n    monome: MonomePlusieursVariables,\n  ): PolynomePlusieursVariables {\n    return new PolynomePlusieursVariables(monome)\n  }\n\n  static createPolynomeFromRoots(\n    racines: (number | FractionEtendue)[],\n    coeffDominant: FractionEtendue = new FractionEtendue(1, 1),\n  ): PolynomePlusieursVariables {\n    let polynome = new PolynomePlusieursVariables(\n      new MonomePlusieursVariables(new FractionEtendue(1, 1), {\n        variables: ['x'],\n        exposants: [0],\n      }),\n    )\n    racines.forEach((racine) => {\n      const polynomeSimple = new PolynomePlusieursVariables([\n        new MonomePlusieursVariables(new FractionEtendue(1, 1), {\n          variables: ['x'],\n          exposants: [1],\n        }),\n        new MonomePlusieursVariables(\n          new FractionEtendue(-1, 1).produitFraction(racine),\n          {\n            variables: ['x'],\n            exposants: [0],\n          },\n        ),\n      ])\n      polynome = polynome.produit(polynomeSimple)\n    })\n    return polynome\n      .produit(\n        new MonomePlusieursVariables(coeffDominant, {\n          variables: ['x'],\n          exposants: [0],\n        }),\n      )\n      .reduire()\n  }\n\n  // Ajoute un monome au PolynomePlusieursVariables, en combinant avec les monomes semblables\n\n  // Additionne deux PolynomePlusieursVariabless ou un PolynomePlusieursVariables et un monome\n  somme(\n    p: PolynomePlusieursVariables | MonomePlusieursVariables,\n  ): PolynomePlusieursVariables {\n    const nouveauxMonomes = [...this.monomes]\n\n    if (p instanceof PolynomePlusieursVariables) {\n      p.monomes.forEach((monome) => nouveauxMonomes.push(monome))\n    } else {\n      nouveauxMonomes.push(p)\n    }\n\n    return PolynomePlusieursVariables.PolynomeNonReduit(nouveauxMonomes)\n  }\n\n  oppose(): PolynomePlusieursVariables {\n    const nouveauxMonomes = this.monomes.map((monome) => monome.oppose())\n    return PolynomePlusieursVariables.PolynomeNonReduit(nouveauxMonomes)\n  }\n\n  melangerTermes(melange: boolean): PolynomePlusieursVariables {\n    if (melange) {\n      let nouveauxMonomes = shuffle(this.monomes)\n      if (this.monomes.length === 1) {\n        return this\n      } else {\n        do {\n          nouveauxMonomes = shuffle(this.monomes)\n        } while (\n          nouveauxMonomes.map((m) => m.toString()).join('') ===\n          this.monomes.map((m) => m.toString()).join('')\n        )\n        return PolynomePlusieursVariables.PolynomeNonReduit(nouveauxMonomes)\n      }\n    } else {\n      return this\n    }\n  }\n\n  toStringSansLeTerme(index: number): string {\n    if (this.monomes.length === 0) return '\\\\ldots\\\\ldots'\n    if (index < 0 || index >= this.monomes.length) return this.toString()\n\n    let result = ''\n    let firstPieceAdded = false\n\n    this.monomes.forEach((monome, i) => {\n      if (monome.coefficient.num === 0 && i !== index) {\n        return\n      }\n\n      if (i === index) {\n        // Replace this term by ellipsis\n        if (!firstPieceAdded) {\n          // First position\n          if (monome.coefficient.signe === -1) {\n            result += '-\\\\ldots\\\\ldots'\n          } else {\n            result += '\\\\ldots\\\\ldots'\n          }\n        } else {\n          if (monome.coefficient.signe === 1) {\n            result += ' + \\\\ldots\\\\ldots'\n          } else {\n            result += ' - \\\\ldots\\\\ldots'\n          }\n        }\n        firstPieceAdded = true\n        return\n      }\n\n      const monomeStr = monome.toString()\n      if (!firstPieceAdded) {\n        result += monomeStr\n      } else {\n        if (monome.coefficient.signe === 1) {\n          result += ' + ' + monomeStr\n        } else {\n          result += ' ' + monomeStr\n        }\n      }\n      firstPieceAdded = true\n    })\n\n    if (!firstPieceAdded) {\n      // Case where only the hidden term existed\n      return '\\\\ldots\\\\ldots'\n    }\n\n    return result\n  }\n\n  toStringAvecTermeEnEvidence(index: number): string {\n    if (this.monomes.length === 0) return ''\n    if (index < 0 || index >= this.monomes.length) return this.toString()\n\n    let result = ''\n    let firstPieceAdded = false\n\n    this.monomes.forEach((monome, i) => {\n      if (monome.coefficient.num === 0) return\n\n      const monomeStr = monome.toString()\n\n      if (i === index) {\n        // Mettre en évidence ce terme\n        if (!firstPieceAdded) {\n          // Premier terme\n          if (monome.coefficient.signe === -1) {\n            result += '-' + miseEnEvidence(monome.oppose().toString())\n          } else {\n            result += miseEnEvidence(monomeStr)\n          }\n        } else {\n          // Terme suivant\n          if (monome.coefficient.signe === 1) {\n            result += ' + ' + miseEnEvidence(monomeStr)\n          } else {\n            result += ' - ' + miseEnEvidence(monome.oppose().toString())\n          }\n        }\n        firstPieceAdded = true\n      } else {\n        // Terme normal (non mis en évidence)\n        if (!firstPieceAdded) {\n          result += monomeStr\n        } else {\n          if (monome.coefficient.signe === 1) {\n            result += ' + ' + monomeStr\n          } else {\n            result += monomeStr\n          }\n        }\n        firstPieceAdded = true\n      }\n    })\n\n    return result\n  }\n\n  // Une méthode pour déterminer si un terme est un carré\n  // Pas encore terminée\n  contientCarre(): boolean {\n    return this.monomes.some((monome) => monome.estCarre())\n  }\n\n  // Une méthode pour déterminer la mise en facteur commun\n  miseEnFacteurCommun(): MonomePlusieursVariables {\n    const monomes = this.monomes\n    if (monomes.length === 0) {\n      return new MonomePlusieursVariables(0, { variables: [], exposants: [] })\n    }\n\n    let pgcdMonome = monomes[0]\n    for (let i = 1; i < monomes.length; i++) {\n      pgcdMonome = pgcdMonome.pgcd(monomes[i])\n    }\n    return pgcdMonome\n  }\n\n  // une méthode pour diviser un polynome par un monome\n  diviserParMonome(m: MonomePlusieursVariables): PolynomePlusieursVariables {\n    // un nouveau polynome dont tous les termes sont divisés par le monome\n    const nouveauxMonomes = this.monomes.map((monome) => monome.diviserPar(m))\n    return PolynomePlusieursVariables.PolynomeNonReduit(nouveauxMonomes)\n  }\n\n  /**\n   * Divise ce polynôme par un autre polynôme (division euclidienne)\n   * @param diviseur - Le polynôme diviseur\n   * @returns Un objet contenant le quotient et le reste de la division\n   */\n  diviser(diviseur: PolynomePlusieursVariables): {\n    quotient: PolynomePlusieursVariables\n    reste: PolynomePlusieursVariables\n  } {\n    const dividende = this.reduire().ordonner()\n    const div = diviseur.reduire().ordonner()\n\n    // Vérifier que le diviseur n'est pas nul\n    if (\n      div.monomes.length === 0 ||\n      div.monomes.every((m) => m.coefficient.num === 0)\n    ) {\n      throw new Error('Division par un polynôme nul impossible')\n    }\n\n    // Algorithme de division euclidienne de polynômes\n    let reste = dividende\n    const quotientMonomes: MonomePlusieursVariables[] = []\n\n    const degreDiv = Math.max(...div.monomes.map((m) => m.degre))\n    const monomeLeadingDiv = div.monomes.find((m) => m.degre === degreDiv)!\n\n    while (reste.monomes.length > 0) {\n      const resteOrdonne = reste.reduire().ordonner()\n      if (resteOrdonne.monomes.length === 0) break\n\n      const degreReste = Math.max(...resteOrdonne.monomes.map((m) => m.degre))\n      if (degreReste < degreDiv) break\n\n      const monomeLeadingReste = resteOrdonne.monomes.find(\n        (m) => m.degre === degreReste,\n      )!\n\n      // Calculer le monôme du quotient\n      const monomeQuotient = monomeLeadingReste.diviserPar(monomeLeadingDiv)\n      quotientMonomes.push(monomeQuotient)\n\n      // Calculer le produit monomeQuotient * diviseur\n      const produit = div.produit(monomeQuotient).reduire()\n\n      // Soustraire ce produit du reste\n      const nouveauReste = reste.difference(produit).reduire()\n\n      reste = nouveauReste\n    }\n\n    const quotient = PolynomePlusieursVariables.PolynomeReduit(quotientMonomes)\n\n    return { quotient, reste }\n  }\n\n  // Générer des identités remarquables sans avoir de carré dans les termes de départ\n\n  difference(\n    p: PolynomePlusieursVariables | MonomePlusieursVariables,\n  ): PolynomePlusieursVariables {\n    const nouveauxMonomes = [...this.monomes]\n\n    if (p instanceof PolynomePlusieursVariables) {\n      // Negate each monomial in the polynomial and add to nouveauxMonomes\n      p.monomes.forEach((monome) => {\n        const negatedMonome = monome.produit(\n          new MonomePlusieursVariables(new FractionEtendue(-1, 1), {\n            variables: [],\n            exposants: [],\n          }),\n        )\n        nouveauxMonomes.push(negatedMonome)\n      })\n    } else {\n      // Negate the single monomial and add to nouveauxMonomes\n      const negatedMonome = p.produit(\n        new MonomePlusieursVariables(new FractionEtendue(-1, 1), {\n          variables: [],\n          exposants: [],\n        }),\n      )\n      nouveauxMonomes.push(negatedMonome)\n    }\n\n    // Return the non-reduced polynomial as per the original intent\n    return PolynomePlusieursVariables.PolynomeNonReduit(nouveauxMonomes)\n  }\n\n  // Multiplie deux PolynomePlusieursVariabless ou un PolynomePlusieursVariables et un monome\n  produit(\n    p: PolynomePlusieursVariables | MonomePlusieursVariables,\n  ): PolynomePlusieursVariables {\n    const nouveauxMonomes: MonomePlusieursVariables[] = []\n\n    if (p instanceof PolynomePlusieursVariables) {\n      this.monomes.forEach((monome1) => {\n        p.monomes.forEach((monome2) => {\n          nouveauxMonomes.push(monome1.produit(monome2))\n        })\n      })\n    } else {\n      this.monomes.forEach((monome) => {\n        nouveauxMonomes.push(monome.produit(p))\n      })\n    }\n    return PolynomePlusieursVariables.PolynomeNonReduit(nouveauxMonomes)\n  }\n\n  // Réduit le PolynomePlusieursVariables en combinant les monomes semblables\n  reduire(): PolynomePlusieursVariables {\n    const reduit = PolynomePlusieursVariables.PolynomeReduit(this.monomes)\n    return reduit\n  }\n\n  ordonner(): PolynomePlusieursVariables {\n    const monomes = this.monomes\n    monomes.sort((a, b) => {\n      return -a.degre + b.degre\n    })\n    return PolynomePlusieursVariables.PolynomeNonReduit(monomes)\n  }\n\n  evaluer(valeurs: { [key: string]: FractionEtendue }): FractionEtendue {\n    return this.monomes.reduce(\n      (acc, monome) => acc.sommeFraction(monome.evaluer(valeurs)),\n      new FractionEtendue(0, 1),\n    )\n  }\n\n  /**\n   * Génère un tableau LaTeX avec les évaluations du polynôme pour une liste de valeurs candidates\n   * et retourne la liste des racines (valeurs pour lesquelles P(x) = 0)\n   * @param candidats - Tableau de FractionEtendue à tester\n   * @param variable - Nom de la variable (par défaut 'x')\n   * @param nbColonnes - Nombre de colonnes dans le tableau (par défaut 3)\n   * @returns Object contenant le code LaTeX du tableau et le tableau des racines\n   */\n  tableauEvaluations(\n    candidats: FractionEtendue[],\n    variable: string = 'x',\n    nbColonnes: number = 3,\n  ): { tableauLatex: string; racines: FractionEtendue[] } {\n    const racines: FractionEtendue[] = []\n    const evaluations: Array<{\n      valeur: FractionEtendue\n      resultat: FractionEtendue\n    }> = []\n\n    // Calculer toutes les évaluations\n    for (const candidat of candidats) {\n      const resultat = this.evaluer({ [variable]: candidat })\n      evaluations.push({ valeur: candidat, resultat })\n      if (resultat.num === 0) {\n        racines.push(candidat)\n      }\n    }\n\n    // Construire le tableau LaTeX sans en-tête\n    const nbLignes = Math.ceil(evaluations.length / nbColonnes)\n    let tableauLatex = '\\\\begin{array}{'\n\n    // Colonnes alignées à gauche\n    for (let i = 0; i < nbColonnes; i++) {\n      tableauLatex += 'l'\n      if (i < nbColonnes - 1) tableauLatex += ' '\n    }\n    tableauLatex += '}\\n'\n\n    // Lignes de données\n    for (let ligne = 0; ligne < nbLignes; ligne++) {\n      for (let col = 0; col < nbColonnes; col++) {\n        const index = ligne * nbColonnes + col\n        if (index < evaluations.length) {\n          const { valeur, resultat } = evaluations[index]\n          tableauLatex += `P\\\\left(${valeur.toLatex()}\\\\right)=${resultat.toLatex()}`\n        }\n        if (col < nbColonnes - 1) tableauLatex += ' & '\n      }\n      tableauLatex += ' \\\\\\\\\\n'\n    }\n\n    tableauLatex += '\\\\end{array}'\n\n    return { tableauLatex, racines }\n  }\n\n  termes(): FractionEtendue[] {\n    return this.reduire().monomes.map((m) => m.coefficient.simplifie())\n  }\n\n  // should do the same as to string, but with the values of the variables replaced by the values in the object valeurs\n  toStringEvaluate(valeurs: { [key: string]: FractionEtendue }): string {\n    if (this.monomes.length === 0) return '0'\n    let result = ''\n    this.monomes.forEach((monome, index) => {\n      const monomeStr = monome.toStringEvaluate(valeurs) // Gets the string representation of the monomial\n\n      if (monome.coefficient.num === 0) {\n        return // Ignore zero terms\n      }\n      // Handle the first term separately\n      if (index === 0) {\n        result += monomeStr\n      } else {\n        if (monome.coefficient.signe === 1) {\n          result += ' + ' + monomeStr\n        } else {\n          result += monomeStr\n        }\n      }\n    })\n\n    return result\n  }\n\n  // Convertit le polynome en une chaîne de caractères\n  toString(avcParentheses: boolean = false): string {\n    if (this.monomes.length === 0) return '0'\n    let result = ''\n    this.monomes.forEach((monome, index) => {\n      const monomeStr = monome.toString() // Gets the string representation of the monomial\n\n      if (monome.coefficient.num === 0) {\n        return // Ignore zero terms\n      }\n      // Handle the first term separately\n      if (index === 0) {\n        result += monomeStr\n      } else {\n        if (monome.coefficient.signe === 1) {\n          result += ' + ' + monomeStr\n        } else {\n          result += monomeStr\n        }\n      }\n    })\n    if (this.monomes.length > 1 && avcParentheses) {\n      result = `\\\\left(${result}\\\\right)`\n    }\n    return result\n  }\n\n  toStringAlgebrique(): string {\n    let result = this.toString(false)\n    if (this.coefficients[0].signe !== -1 && this.coefficients[0].num !== 0) {\n      result = `+${result}`\n    }\n    return result\n  }\n\n  /**\n   * Converts the polynomial to a pgfplots-compatible expression using decimal coefficients\n   * Only works for single-variable polynomials in x\n   * @returns A string like \"2.5*x^3 - 1.333*x^2 + 4*x - 2\"\n   */\n  toPgfplots(): string {\n    if (this.monomes.length === 0) return '0'\n\n    let result = ''\n    const polyOrdonne = this.reduire().ordonner()\n\n    polyOrdonne.monomes.forEach((monome, index) => {\n      if (monome.coefficient.num === 0) return // Skip zero terms\n\n      const coeff = monome.coefficient.valeurDecimale\n      const exposantX = monome.partieLitterale.exposants[0] || 0\n\n      // Build the term\n      let term = ''\n\n      // Handle coefficient\n      if (exposantX === 0) {\n        // Constant term\n        term = Math.abs(coeff).toString()\n      } else if (Math.abs(coeff) === 1) {\n        // Coefficient is ±1\n        if (exposantX === 1) {\n          term = 'x'\n        } else {\n          term = `x^${exposantX}`\n        }\n      } else {\n        // General case\n        if (exposantX === 1) {\n          term = `${Math.abs(coeff)}*x`\n        } else {\n          term = `${Math.abs(coeff)}*x^${exposantX}`\n        }\n      }\n\n      // Handle sign\n      if (index === 0) {\n        // First term\n        if (coeff < 0) {\n          result += '-' + term\n        } else {\n          result += term\n        }\n      } else {\n        // Subsequent terms\n        if (coeff < 0) {\n          result += ' - ' + term\n        } else {\n          result += ' + ' + term\n        }\n      }\n    })\n\n    return result\n  }\n\n  // Note : KaTeX ne permet pas d'utiliser cline, donc l'affichage ne peut pas être aussi joli que dans LaTeX\n\n  /**\n   * Convertit le polynôme en chaîne avec espacement phantom pour alignement\n   * @param degreMax - Le degré maximum pour l'alignement\n   * @returns Le polynôme avec espacement\n   */\n  private toStringAvecEspacement(degreMax: number): string {\n    if (this.monomes.length === 0) return '0'\n\n    let result = ''\n    const polyOrdonne = this.reduire().ordonner()\n\n    polyOrdonne.monomes.forEach((monome, index) => {\n      if (monome.coefficient.num === 0) return\n\n      const monomeStr = monome.toString()\n\n      if (index === 0) {\n        result += monomeStr\n      } else {\n        if (monome.coefficient.signe === 1) {\n          result += ' + ' + monomeStr\n        } else {\n          result += ' ' + monomeStr\n        }\n      }\n    })\n\n    return result\n  }\n\n  /**\n   * Affiche la division euclidienne de ce polynôme par un diviseur\n   * Utilise \\polylongdiv pour LaTeX, ou un affichage manuel pour HTML\n   * @param diviseur - Le polynôme diviseur\n   * @returns Le code LaTeX de la division\n   */\n  afficherDivision(diviseur: PolynomePlusieursVariables): string {\n    // Si le contexte est LaTeX, utiliser la commande \\polylongdiv\n    if (!context.isHtml) {\n      const dividendeStr = this.toString().replace(/\\\\dfrac/g, '\\\\frac')\n      const diviseurStr = diviseur.toString().replace(/\\\\dfrac/g, '\\\\frac')\n      return `\\\\polylongdiv[style=D]{${dividendeStr}}{${diviseurStr}}`\n    }\n\n    // Pour HTML, construire l'affichage manuel avec un tableau LaTeX\n    // D'abord, effectuer la division pour obtenir le quotient\n    const dividende = this.reduire().ordonner()\n    const div = diviseur.reduire().ordonner()\n\n    // Vérifier que le diviseur n'est pas nul\n    if (\n      div.monomes.length === 0 ||\n      div.monomes.every((m) => m.coefficient.num === 0)\n    ) {\n      return 'Division par zéro impossible'\n    }\n\n    // Algorithme de division euclidienne de polynômes\n    let reste = dividende\n    const quotientMonomes: MonomePlusieursVariables[] = []\n    const etapes: Array<{\n      quotientPartiel: MonomePlusieursVariables\n      produit: PolynomePlusieursVariables\n      nouveauReste: PolynomePlusieursVariables\n    }> = []\n\n    const degreDiv = Math.max(...div.monomes.map((m) => m.degre))\n    const monomeLeadingDiv = div.monomes.find((m) => m.degre === degreDiv)!\n\n    while (reste.monomes.length > 0) {\n      const resteOrdonne = reste.reduire().ordonner()\n      if (resteOrdonne.monomes.length === 0) break\n\n      const degreReste = Math.max(...resteOrdonne.monomes.map((m) => m.degre))\n      if (degreReste < degreDiv) break\n\n      const monomeLeadingReste = resteOrdonne.monomes.find(\n        (m) => m.degre === degreReste,\n      )!\n\n      // Calculer le monôme du quotient\n      const monomeQuotient = monomeLeadingReste.diviserPar(monomeLeadingDiv)\n      quotientMonomes.push(monomeQuotient)\n\n      // Calculer le produit monomeQuotient * diviseur\n      const produit = div.produit(monomeQuotient).reduire()\n\n      // Soustraire ce produit du reste\n      const nouveauReste = reste.difference(produit).reduire()\n\n      etapes.push({\n        quotientPartiel: monomeQuotient,\n        produit,\n        nouveauReste,\n      })\n\n      reste = nouveauReste\n    }\n\n    const quotient = PolynomePlusieursVariables.PolynomeReduit(quotientMonomes)\n\n    // Déterminer le degré maximum pour l'alignement\n    const degreMax = Math.max(...dividende.monomes.map((m) => m.degre))\n\n    // Construire l'affichage LaTeX style phantom (like HPC100)\n    let texte = `$\\\\begin{array}{r|l}`\n\n    // Première ligne: dividende et diviseur\n    texte += `${dividende.toStringAvecEspacement(degreMax)} & ${div.toString()}\\\\\\\\`\n\n    // Construire les phantoms progressifs\n    let phantomAccumule = ''\n\n    // Déterminer la longueur de l'overline (max entre diviseur et quotient)\n    const diviseurStr = div.toString()\n    const quotientStr = quotient.toString()\n    // Compare visual lengths and pad the shorter one\n    let overlineContent = quotientStr\n    // Simple heuristic: if quotient appears shorter, pad it to match divisor width\n    if (quotientStr.length < diviseurStr.length) {\n      overlineContent = `${quotientStr}\\\\phantom{\\\\qquad}`\n    }\n\n    // Pour chaque étape de division\n    etapes.forEach((etape, index) => {\n      // Ligne de soustraction avec underline\n      const produitAvecEspacement =\n        etape.produit.toStringAvecEspacement(degreMax)\n\n      if (index === 0) {\n        texte += `${phantomAccumule}\\\\underline{-(${produitAvecEspacement})} & \\\\overline{${overlineContent}}\\\\\\\\`\n      } else {\n        texte += `${phantomAccumule}\\\\underline{-(${produitAvecEspacement})} & \\\\\\\\`\n      }\n\n      // Ligne du reste\n      const resteNonNul =\n        etape.nouveauReste.monomes.length > 0 &&\n        !etape.nouveauReste.monomes.every((m) => m.coefficient.num === 0)\n\n      if (index === etapes.length - 1) {\n        // Dernière étape - toujours afficher le reste (ou 0)\n        if (resteNonNul) {\n          const resteStr = etape.nouveauReste.toStringAvecEspacement(degreMax)\n          texte += `${phantomAccumule}\\\\phantom{-(}${resteStr} & \\\\\\\\`\n        } else {\n          // Division exacte - afficher 0\n          texte += `${phantomAccumule}\\\\phantom{-(}0 & \\\\\\\\`\n        }\n      } else if (resteNonNul) {\n        // Pas la dernière étape - afficher le reste\n        const resteStr = etape.nouveauReste.toStringAvecEspacement(degreMax)\n        texte += `${phantomAccumule}\\\\phantom{-(}${resteStr} & \\\\\\\\`\n\n        // Accumuler phantom pour la prochaine ligne basé sur le premier terme du produit\n        if (etape.produit.monomes.length > 0) {\n          const premierMonome = etape.produit.monomes[0]\n          phantomAccumule += `\\\\phantom{-(${premierMonome.toString()})}`\n        }\n      }\n    })\n\n    texte += `\\\\end{array}$`\n\n    return texte\n  }\n}\n\nexport default PolynomePlusieursVariables\n"],"names":["PolynomePlusieursVariables","monomes","__publicField","m","ppcmListe","monomesNew","monome","ajouterMonome","index","a","b","degMin","degMax","nbTermes","typeCoeff","variables","coeffMax","monomesListe","MonomePlusieursVariables","randint","isSemblable","j","shuffle","racines","coeffDominant","FractionEtendue","polynome","racine","polynomeSimple","p","nouveauxMonomes","melange","result","firstPieceAdded","i","monomeStr","miseEnEvidence","pgcdMonome","diviseur","dividende","div","reste","quotientMonomes","degreDiv","monomeLeadingDiv","resteOrdonne","degreReste","monomeQuotient","produit","negatedMonome","monome1","monome2","valeurs","acc","candidats","variable","nbColonnes","evaluations","candidat","resultat","nbLignes","tableauLatex","ligne","col","valeur","avcParentheses","coeff","exposantX","term","degreMax","context","dividendeStr","diviseurStr","etapes","nouveauReste","quotient","texte","phantomAccumule","quotientStr","overlineContent","etape","produitAvecEspacement","resteNonNul","resteStr","premierMonome"],"mappings":"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"}