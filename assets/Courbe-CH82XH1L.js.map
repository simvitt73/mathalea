{"version":3,"file":"Courbe-CH82XH1L.js","sources":["../../src/lib/2d/Courbe.ts"],"sourcesContent":["import { inferieurouegal } from '../../modules/outils'\nimport { colorToLatexOrHTML } from './colorToLatexOrHtml'\nimport type { IRepere } from './Interfaces'\nimport { ObjetMathalea2D } from './ObjetMathalea2D'\nimport { point } from './PointAbstrait'\nimport { polyline } from './Polyline'\n\n/**\n * Trace la courbe d'une fonction dans un repère\n * @param {function} f fonction à tracer comme par exemple : const f = x => a * x ** 2 + b * x + c\n * @param {Object} parametres À saisir entre accolades\n * @param {Repere} [parametres.repere  = {}]  Repère dans lequel le tracé de la fonction se fait\n * @param {string} [parametres.color = 'black']  Couleur du tracé de la courbe : du type 'blue' ou du type '#f15929'\n * @param {number} [parametres.epaisseur = 2]  Epaisseur du tracé de la courbe\n * @param {number} [parametres.xMin]  Abscisse minimale du tracé de la courbe\n * @param {number} [parametres.xMax]  Abscisse maximale du tracé de la courbe\n * @param {number} [parametres.yMin]  Ordonnée minimale du tracé de la courbe\n * @param {number} [parametres.yMax]  Ordonnée maximale du tracé de la courbe\n * @param {boolean|number} [parametres.step = false] Si false, le pas entre deux abscisses du tracé de la fonction est 0.2/xUnite. Sinon, ce pas vaut la valeur indiquée.\n * @param {number} [parametres.xUnite = 1]  Abscisse minimale du tracé de la courbe\n * @param {number} [parametres.yUnite = 1]  Abscisse maximale du tracé de la courbe\n * @property {string} svg Sortie au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} svgml Sortie, à main levée, au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} tikz Sortie au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @property {string} tikzml Sortie, à main levée, au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @property {string} color Couleur du tracé de la courbe. À associer obligatoirement à colorToLatexOrHTML().\n * @author Rémi Angot\n * @class\n */\n// JSDOC Validee par EE Aout 2022\n\nexport class Courbe extends ObjetMathalea2D {\n  stringColor: string\n  f?: (x: number) => number\n  usePgfplots: boolean\n  xmin: number\n  xmax: number\n  ymin: number\n  ymax: number\n  samples: number = 100\n  xunite: number\n  yunite: number\n  epaisseur: number\n  fLatex?: string\n  constructor(\n    f: (x: number) => number,\n    {\n      repere,\n      color = 'black',\n      epaisseur = 2,\n      step = false,\n      xMin,\n      xMax,\n      yMin,\n      yMax,\n      xUnite = 1,\n      yUnite = 1,\n      usePgfplots = false,\n      fLatex,\n    }: {\n      repere?: IRepere\n      color?: string\n      epaisseur?: number\n      step?: boolean | number\n      xMin?: number\n      xMax?: number\n      yMin?: number\n      yMax?: number\n      xUnite?: number\n      yUnite?: number\n      usePgfplots?: boolean\n      fLatex?: string\n    } = {},\n  ) {\n    super()\n    this.objets = []\n    this.usePgfplots = usePgfplots\n    this.epaisseur = epaisseur\n    this.fLatex = fLatex\n\n    if (repere == null) {\n      throw Error(\n        'Erreur dans Courbe : Il faut préciser le repère dans lequel tracer la courbe',\n      )\n    }\n    const xmin = xMin == null ? (xMin = repere.xMin ?? 0) : xMin\n    const xmax = xMax == null ? (xMax = repere.xMax ?? 0) : xMax\n    const ymin = yMin == null ? (yMin = repere.yMin ?? 0) : yMin\n    const ymax = yMax == null ? (yMax = repere.yMax ?? 0) : yMax\n\n    this.xmin = xmin\n    this.xmax = xmax\n    this.ymin = ymin\n    this.ymax = ymax\n\n    this.bordures = (repere?.bordures ?? [0, 0, 0, 0]) as unknown as [\n      number,\n      number,\n      number,\n      number,\n    ]\n\n    this.stringColor = color\n    let xunite, yunite // Tout en minuscule pour les différencier des paramètres de la fonction\n    xunite = repere.xUnite\n    yunite = repere.yUnite\n\n    if (isNaN(xunite)) {\n      xunite = xUnite\n    }\n\n    if (isNaN(yunite)) {\n      yunite = yUnite\n    }\n\n    this.xunite = xunite\n    this.yunite = yunite\n\n    let points = []\n    let pas: number\n    let p\n    if (!step) {\n      pas = 0.2 / xUnite\n    } else {\n      pas = Number(step)\n    }\n    let lastFiniteX: number | null = null // Dernier x ayant fourni une valeur finie\n    let lastOutOfBoundsX: number | null = null // Dernier x hors cadre mais fini\n\n    for (let x = xmin; inferieurouegal(x, xMax ?? 10); x += pas) {\n      if (x > xmax) x = xmax // normalement x<xmax... mais inférieurouegal ne compare qu'à 0.0000001 près, on peut donc avoir xmax+epsilon qui sort de l'intervalle de déf\n      const y = Number(f(x))\n      if (isFinite(y)) {\n        if (y < ymax + 10 && y > ymin - 10) {\n          points.push(point(x * xunite, y * yunite))\n          lastFiniteX = x\n          lastOutOfBoundsX = null // Réinitialiser car on est revenu dans les limites\n        } else {\n          // Valeur finie mais hors des limites affichées\n          lastOutOfBoundsX = x\n          if (points.length > 1) {\n            p = polyline([...points], color)\n            p.epaisseur = epaisseur\n            this.objets.push(p)\n            points = []\n          }\n        }\n      } else {\n        // Valeur infinie détectée\n        if (lastFiniteX !== null) {\n          // Créer des points supplémentaires entre le dernier point valide et l'infini\n          const smallStep = pas / 100\n          let xSmall: number = lastFiniteX + smallStep\n\n          while (xSmall < x) {\n            const ySmall = Number(f(xSmall))\n            if (isFinite(ySmall) && ySmall < ymax + 10 && ySmall > ymin - 10) {\n              points.push(point(xSmall * xunite, ySmall * yunite))\n              lastFiniteX = xSmall\n            } else if (isFinite(ySmall)) {\n              // Hors cadre mais fini\n              lastOutOfBoundsX = xSmall\n            } else {\n              // Infini rencontré avant x\n              break\n            }\n            xSmall += smallStep\n          }\n\n          // Sauvegarder la polyligne actuellement en cours\n          if (points.length > 1) {\n            p = polyline([...points], color)\n            p.epaisseur = epaisseur\n            this.objets.push(p)\n            points = []\n          }\n        }\n\n        // Calculer le nouveau point de départ après l'infini\n        if (lastOutOfBoundsX !== null && lastFiniteX !== null) {\n          // dx entre le x ayant produit l'infini et le dernier x hors cadre mais fini\n          const dx = x - lastOutOfBoundsX\n          // Redémarrer à partir de x + dx\n          x = x + dx\n        } else {\n          x += pas\n        }\n      }\n    }\n    if (points.length > 1) {\n      p = polyline([...points], color)\n      p.epaisseur = epaisseur\n      this.objets.push(p)\n    }\n  }\n\n  svg(coeff: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz(\n    axisYMin?: number,\n    axisYMax?: number,\n    _axisXMin?: number,\n    _axisXMax?: number,\n  ) {\n    if (this.usePgfplots && this.fLatex) {\n      // Use pgfplots with function expression\n      let colorLatex = colorToLatexOrHTML(this.stringColor)[1] || 'black'\n      // Remove braces from color if present\n      colorLatex = colorLatex.replace(/[{}]/g, '')\n      const domainMin = (this.xmin * this.xunite).toFixed(3)\n      const domainMax = (this.xmax * this.xunite).toFixed(3)\n\n      // Use axis bounds if provided, otherwise use curve's ymin/ymax\n      const yDomainMin = (\n        axisYMin !== undefined ? axisYMin * 20 : this.ymin * this.yunite * 20\n      ).toFixed(3)\n      const yDomainMax = (\n        axisYMax !== undefined ? axisYMax * 20 : this.ymax * this.yunite * 20\n      ).toFixed(3)\n\n      const code = `\\\\addplot[color=${colorLatex},line width=${this.epaisseur / 2}pt,domain=${domainMin}:${domainMax},restrict y to domain=${yDomainMin}:${yDomainMax},samples=${this.samples}] {${this.fLatex}};\\n`\n\n      return code\n    } else {\n      // Legacy behavior: use polylines\n      let code = ''\n      if (this.objets == null) return code\n      for (const objet of this.objets) {\n        code += '\\n\\t' + objet.tikz()\n      }\n      return code\n    }\n  }\n\n  svgml(coeff: number, amp: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      if (typeof objet.svgml === 'undefined') code += '\\n\\t' + objet.svg(coeff)\n      else code += '\\n\\t' + objet.svgml(coeff, amp)\n    }\n    return code\n  }\n\n  tikzml(amp: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      if (typeof objet.tikzml === 'undefined') code += '\\n\\t' + objet.tikz()\n      else code += '\\n\\t' + objet.tikzml(amp)\n    }\n    return code\n  }\n}\n/**\n * Trace la courbe d'une fonction dans un repère\n * @param {function} f Fonction à tracer comme par exemple : const f = x => a * x ** 2 + b * x + c\n * @param {Object} parametres À saisir entre accolades\n * @param {Repere} [parametres.repere = {}] Repère dans lequel le tracé de la fonction se fait\n * @param {string} [parametres.color = 'black']  Couleur du tracé de la courbe : du type 'blue' ou du type '#f15929'\n * @param {number} [parametres.epaisseur = 2]  Epaisseur du tracé de la courbe\n * @param {number} [parametres.xMin = repere.xMin]  Abscisse minimale du tracé de la courbe\n * @param {number} [parametres.xMax = repere.xMax]  Abscisse maximale du tracé de la courbe\n * @param {number} [parametres.yMin = repere.yMin]  Ordonnée minimale du tracé de la courbe\n * @param {number} [parametres.yMax = repere.yMax]  Ordonnée maximale du tracé de la courbe\n * @param {boolean|number} [parametres.step = false] Si false, le pas entre deux abscisses du tracé de la fonction est 0.2/xUnite. Sinon, ce pas vaut la valeur indiquée.\n * @param {number} [parametres.xUnite = 1]  Abscisse minimale du tracé de la courbe\n * @param {number} [parametres.yUnite = 1]  Abscisse maximale du tracé de la courbe\n * @param {boolean} [parametres.usePgfplots = false] Si true, utilise pgfplots pour la sortie LaTeX au lieu de tracés polylignes\n * @param {string} [parametres.fLatex] Expression LaTeX de la fonction (requis si usePgfplots = true)\n * @example courbe(g, {repere: r})\n * // Trace, en noir avec une épaisseur de 2, la courbe g dans le repère r, tous deux précédemment définis.\n * @example courbe(g, {repere: r, epaisseur: 5, color: 'blue'})\n * // Trace la courbe g dans le repère r, tous deux précédemment définis, en bleu, avec une épaisseur de 5.\n * @example courbe(g, {repere: r, usePgfplots: true, fLatex: 'x^2 - 2*x + 1'})\n * // Trace la courbe g dans le repère r en utilisant pgfplots (sortie LaTeX plus compacte).\n * @author Rémi Angot\n * @return {Courbe}\n */\n// JSDOC Validee par EE Aout 2022\n\nexport function courbe(\n  f: (x: number) => number,\n  {\n    repere,\n    color = 'black',\n    epaisseur = 2,\n    step = false,\n    xMin,\n    xMax,\n    yMin,\n    yMax,\n    xUnite = 1,\n    yUnite = 1,\n    usePgfplots = false,\n    fLatex,\n  }: {\n    repere?: IRepere\n    color?: string\n    epaisseur?: number\n    step?: boolean | number\n    xMin?: number\n    xMax?: number\n    yMin?: number\n    yMax?: number\n    xUnite?: number\n    yUnite?: number\n    usePgfplots?: boolean\n    fLatex?: string\n  } = {},\n) {\n  return new Courbe(f, {\n    repere,\n    color,\n    epaisseur,\n    step,\n    xMin,\n    xMax,\n    yMin,\n    yMax,\n    xUnite,\n    yUnite,\n    usePgfplots,\n    fLatex,\n  })\n}\n"],"names":["Courbe","ObjetMathalea2D","f","repere","color","epaisseur","step","xMin","xMax","yMin","yMax","xUnite","yUnite","usePgfplots","fLatex","__publicField","xmin","xmax","ymin","ymax","xunite","yunite","points","pas","p","lastFiniteX","lastOutOfBoundsX","x","inferieurouegal","y","point","polyline","smallStep","xSmall","ySmall","dx","coeff","code","objet","axisYMin","axisYMax","_axisXMin","_axisXMax","colorLatex","colorToLatexOrHTML","domainMin","domainMax","yDomainMin","yDomainMax","amp","courbe"],"mappings":"mZA+BO,MAAMA,UAAeC,CAAgB,CAa1C,YACEC,EACA,CACE,OAAAC,EACA,MAAAC,EAAQ,QACR,UAAAC,EAAY,EACZ,KAAAC,EAAO,GACP,KAAAC,EACA,KAAAC,EACA,KAAAC,EACA,KAAAC,EACA,OAAAC,EAAS,EACT,OAAAC,EAAS,EACT,YAAAC,EAAc,GACd,OAAAC,CAAA,EAcE,GACJ,CACA,MAAA,EA1CFC,EAAA,oBACAA,EAAA,UACAA,EAAA,oBACAA,EAAA,aACAA,EAAA,aACAA,EAAA,aACAA,EAAA,aACAA,EAAA,eAAkB,KAClBA,EAAA,eACAA,EAAA,eACAA,EAAA,kBACAA,EAAA,eAgCE,QAAK,OAAS,CAAA,EACd,KAAK,YAAcF,EACnB,KAAK,UAAYR,EACjB,KAAK,OAASS,EAEVX,GAAU,KACZ,MAAM,MACJ,8EAAA,EAGJ,MAAMa,EAAOT,IAAgBA,EAAOJ,EAAO,MAAQ,GAC7Cc,EAAOT,IAAgBA,EAAOL,EAAO,MAAQ,GAC7Ce,EAAOT,IAAgBA,EAAON,EAAO,MAAQ,GAC7CgB,EAAOT,IAAgBA,EAAOP,EAAO,MAAQ,GAEnD,KAAK,KAAOa,EACZ,KAAK,KAAOC,EACZ,KAAK,KAAOC,EACZ,KAAK,KAAOC,EAEZ,KAAK,UAAYhB,GAAA,YAAAA,EAAQ,WAAY,CAAC,EAAG,EAAG,EAAG,CAAC,EAOhD,KAAK,YAAcC,EACnB,IAAIgB,EAAQC,EACZD,EAASjB,EAAO,OAChBkB,EAASlB,EAAO,OAEZ,MAAMiB,CAAM,IACdA,EAAST,GAGP,MAAMU,CAAM,IACdA,EAAST,GAGX,KAAK,OAASQ,EACd,KAAK,OAASC,EAEd,IAAIC,EAAS,CAAA,EACTC,EACAC,EACClB,EAGHiB,EAAM,OAAOjB,CAAI,EAFjBiB,EAAM,GAAMZ,EAId,IAAIc,EAA6B,KAC7BC,EAAkC,KAEtC,QAASC,EAAIX,EAAMY,EAAgBD,EAAGnB,GAAQ,EAAE,EAAGmB,GAAKJ,EAAK,CACvDI,EAAIV,IAAMU,EAAIV,GAClB,MAAMY,EAAI,OAAO3B,EAAEyB,CAAC,CAAC,EACrB,GAAI,SAASE,CAAC,EACRA,EAAIV,EAAO,IAAMU,EAAIX,EAAO,IAC9BI,EAAO,KAAKQ,EAAMH,EAAIP,EAAQS,EAAIR,CAAM,CAAC,EACzCI,EAAcE,EACdD,EAAmB,OAGnBA,EAAmBC,EACfL,EAAO,OAAS,IAClBE,EAAIO,EAAS,CAAC,GAAGT,CAAM,EAAGlB,CAAK,EAC/BoB,EAAE,UAAYnB,EACd,KAAK,OAAO,KAAKmB,CAAC,EAClBF,EAAS,CAAA,QAGR,CAEL,GAAIG,IAAgB,KAAM,CAExB,MAAMO,EAAYT,EAAM,IACxB,IAAIU,EAAiBR,EAAcO,EAEnC,KAAOC,EAASN,GAAG,CACjB,MAAMO,EAAS,OAAOhC,EAAE+B,CAAM,CAAC,EAC/B,GAAI,SAASC,CAAM,GAAKA,EAASf,EAAO,IAAMe,EAAShB,EAAO,GAC5DI,EAAO,KAAKQ,EAAMG,EAASb,EAAQc,EAASb,CAAM,CAAC,EACnDI,EAAcQ,UACL,SAASC,CAAM,EAExBR,EAAmBO,MAGnB,OAEFA,GAAUD,CACZ,CAGIV,EAAO,OAAS,IAClBE,EAAIO,EAAS,CAAC,GAAGT,CAAM,EAAGlB,CAAK,EAC/BoB,EAAE,UAAYnB,EACd,KAAK,OAAO,KAAKmB,CAAC,EAClBF,EAAS,CAAA,EAEb,CAGA,GAAII,IAAqB,MAAQD,IAAgB,KAAM,CAErD,MAAMU,EAAKR,EAAID,EAEfC,EAAIA,EAAIQ,CACV,MACER,GAAKJ,CAET,CACF,CACID,EAAO,OAAS,IAClBE,EAAIO,EAAS,CAAC,GAAGT,CAAM,EAAGlB,CAAK,EAC/BoB,EAAE,UAAYnB,EACd,KAAK,OAAO,KAAKmB,CAAC,EAEtB,CAEA,IAAIY,EAAe,CACjB,IAAIC,EAAO,GACX,GAAI,KAAK,QAAU,KAAM,OAAOA,EAChC,UAAWC,KAAS,KAAK,OACvBD,GAAQ;AAAA,GAASC,EAAM,IAAIF,CAAK,EAElC,OAAOC,CACT,CAEA,KACEE,EACAC,EACAC,EACAC,EACA,CACA,GAAI,KAAK,aAAe,KAAK,OAAQ,CAEnC,IAAIC,EAAaC,EAAmB,KAAK,WAAW,EAAE,CAAC,GAAK,QAE5DD,EAAaA,EAAW,QAAQ,QAAS,EAAE,EAC3C,MAAME,GAAa,KAAK,KAAO,KAAK,QAAQ,QAAQ,CAAC,EAC/CC,GAAa,KAAK,KAAO,KAAK,QAAQ,QAAQ,CAAC,EAG/CC,GACJR,IAAa,OAAYA,EAAW,GAAK,KAAK,KAAO,KAAK,OAAS,IACnE,QAAQ,CAAC,EACLS,GACJR,IAAa,OAAYA,EAAW,GAAK,KAAK,KAAO,KAAK,OAAS,IACnE,QAAQ,CAAC,EAIX,MAFa,mBAAmBG,CAAU,eAAe,KAAK,UAAY,CAAC,aAAaE,CAAS,IAAIC,CAAS,yBAAyBC,CAAU,IAAIC,CAAU,YAAY,KAAK,OAAO,MAAM,KAAK,MAAM;AAAA,CAG1M,KAAO,CAEL,IAAIX,EAAO,GACX,GAAI,KAAK,QAAU,KAAM,OAAOA,EAChC,UAAWC,KAAS,KAAK,OACvBD,GAAQ;AAAA,GAASC,EAAM,KAAA,EAEzB,OAAOD,CACT,CACF,CAEA,MAAMD,EAAea,EAAa,CAChC,IAAIZ,EAAO,GACX,GAAI,KAAK,QAAU,KAAM,OAAOA,EAChC,UAAWC,KAAS,KAAK,OACnB,OAAOA,EAAM,MAAU,OAAqB;AAAA,GAASA,EAAM,IAAIF,CAAK,EACnEC,GAAQ;AAAA,GAASC,EAAM,MAAMF,EAAOa,CAAG,EAE9C,OAAOZ,CACT,CAEA,OAAOY,EAAa,CAClB,IAAIZ,EAAO,GACX,GAAI,KAAK,QAAU,KAAM,OAAOA,EAChC,UAAWC,KAAS,KAAK,OACnB,OAAOA,EAAM,OAAW,IAAaD,GAAQ;AAAA,GAASC,EAAM,KAAA,EAC3DD,GAAQ;AAAA,GAASC,EAAM,OAAOW,CAAG,EAExC,OAAOZ,CACT,CACF,CA4BO,SAASa,EACdhD,EACA,CACE,OAAAC,EACA,MAAAC,EAAQ,QACR,UAAAC,EAAY,EACZ,KAAAC,EAAO,GACP,KAAAC,EACA,KAAAC,EACA,KAAAC,EACA,KAAAC,EACA,OAAAC,EAAS,EACT,OAAAC,EAAS,EACT,YAAAC,EAAc,GACd,OAAAC,CACF,EAaI,GACJ,CACA,OAAO,IAAId,EAAOE,EAAG,CACnB,OAAAC,EACA,MAAAC,EACA,UAAAC,EACA,KAAAC,EACA,KAAAC,EACA,KAAAC,EACA,KAAAC,EACA,KAAAC,EACA,OAAAC,EACA,OAAAC,EACA,YAAAC,EACA,OAAAC,CAAA,CACD,CACH"}