{"version":3,"file":"6G3C-rWXh7icG.js","sources":["../../src/exercices/6e/6G3C.ts"],"sourcesContent":["import { afficheLongueurSegment } from '../../lib/2d/afficheLongueurSegment'\nimport { cercle } from '../../lib/2d/cercle'\nimport { codageAngleDroit } from '../../lib/2d/CodageAngleDroit'\nimport { codageMilieu } from '../../lib/2d/CodageMilieu'\nimport { Droite, droite } from '../../lib/2d/droites'\nimport { mediatrice } from '../../lib/2d/Mediatrice'\nimport { PointAbstrait, pointAbstrait } from '../../lib/2d/PointAbstrait'\nimport { segment } from '../../lib/2d/segmentsVecteurs'\nimport { labelPoint } from '../../lib/2d/textes'\nimport { tracePoint } from '../../lib/2d/TracePoint'\nimport { longueur } from '../../lib/2d/utilitairesGeometriques'\nimport {\n  pointAdistance,\n  pointIntersectionDD,\n  pointIntersectionLC,\n} from '../../lib/2d/utilitairesPoint'\nimport { combinaisonListes, shuffle } from '../../lib/outils/arrayOutils'\nimport { arrondi } from '../../lib/outils/nombres'\nimport { creerNomDePolygone } from '../../lib/outils/outilString'\nimport { texNombre } from '../../lib/outils/texNombre'\nimport { mathalea2d } from '../../modules/mathalea2d'\nimport { listeQuestionsToContenu, randint } from '../../modules/outils'\nimport Exercice from '../Exercice'\nexport const titre = \"Utiliser les propriétés de la médiatrice d'un segment\"\nexport const dateDePublication = '05/08/2021' // La date de publication initiale au format 'jj/mm/aaaa' pour affichage temporaire d'un tag\nexport const dateDeModifImportante = '17/08/2023'\n\n/**\n * Utiliser les propriétés de la médiatrice d'un segment\n * @author Guillaume Valmont\n */\n\nexport const uuid = '3acc1'\n\nexport const refs = {\n  'fr-fr': ['6G3C'],\n  'fr-2016': ['5G22-1'],\n  'fr-ch': ['9ES3-10'],\n}\nexport default class ProprietesMediatrice extends Exercice {\n  constructor() {\n    super()\n\n    this.nbQuestions = 4\n\n    this.besoinFormulaireNumerique = [\n      'Situation',\n      3,\n      '1 : Liée à une médiatrice (ou pas)\\n2 : Liée à une équidistance (ou pas)\\n3 : Mélange',\n    ]\n    this.sup = 3\n    this.besoinFormulaire2CaseACocher = [\n      \"Inclure des situations où aucun point n'appartient pas à la médiatrice\",\n    ]\n    this.sup2 = true\n  }\n\n  nouvelleVersion() {\n    let typesDeQuestionsDisponibles, listeSurLaMediatrice\n    if (this.sup === 1) {\n      typesDeQuestionsDisponibles = ['appartient']\n    } else if (this.sup === 2) {\n      typesDeQuestionsDisponibles = ['equidistant']\n    } else {\n      typesDeQuestionsDisponibles = ['appartient', 'equidistant']\n    }\n    const listeTypeDeQuestions = combinaisonListes(\n      typesDeQuestionsDisponibles,\n      this.nbQuestions,\n    )\n    if (this.sup2 === true) {\n      listeSurLaMediatrice = combinaisonListes([true, false], this.nbQuestions)\n    } else {\n      listeSurLaMediatrice = combinaisonListes([true], this.nbQuestions)\n    }\n    let A = pointAbstrait(0, 0)\n    let B = pointAbstrait(0, 0)\n    let C = pointAbstrait(0, 0)\n    let D = pointAbstrait(0, 0)\n    let segmentAB,\n      segmentAC,\n      segmentBC,\n      mediatriceAB,\n      affLongueurAC,\n      affLongueurBC\n    let objetsEnonce, objetsCorrection, paramsEnonce, paramsCorrection\n    for (\n      let i = 0, texte, texteCorr, cpt = 0;\n      i < this.nbQuestions && cpt < 50;\n\n    ) {\n      // Construction des objets\n      objetsEnonce = []\n      objetsCorrection = []\n      const nomDesPoints = shuffle(\n        Array.from(creerNomDePolygone(22, ['O', 'Q', 'W', 'X'])),\n      )\n      do {\n        A = pointAbstrait(0, 0, nomDesPoints[0], 'below')\n        B = pointAdistance(\n          A,\n          randint(30, 60) / 10,\n          randint(0, 45),\n          nomDesPoints[1],\n        )\n        mediatriceAB = mediatrice(A, B, '', 'red')\n        // Le point C est au dessus ou en dessous une fois sur deux\n\n        if (randint(0, 99) > 50) {\n          C = pointIntersectionLC(\n            mediatriceAB as Droite,\n            cercle(A, randint(30, 60) / 10),\n            nomDesPoints[2],\n            1,\n          )\n        } else {\n          C = pointIntersectionLC(\n            mediatriceAB as Droite,\n            cercle(A, randint(30, 60) / 10),\n            nomDesPoints[2],\n            2,\n          )\n        }\n        if (!listeSurLaMediatrice[i])\n          C = pointAbstrait(\n            C.x + randint(-5, 5, 0) / 10,\n            C.y + randint(-5, 5, 0) / 10,\n            nomDesPoints[2],\n            'above',\n          ) // s'il ne doit pas être sur la médiatrice, on l'en éloigne\n      } while (\n        C.constructor !== PointAbstrait ||\n        A.constructor !== PointAbstrait ||\n        B.constructor !== PointAbstrait\n      )\n      segmentAB = segment(A, B)\n      segmentAC = segment(A, C)\n      segmentBC = segment(B, C)\n      segmentAC.pointilles = 2\n      segmentBC.pointilles = 2\n      // Affiche les longueurs au-dessous ou en dessous selon si C est au-dessus ou en dessous de A\n      if (C.y > A.y) {\n        affLongueurAC = afficheLongueurSegment(A, C, 'black', 0.5)\n        affLongueurBC = afficheLongueurSegment(C, B, 'black', 0.5)\n      } else {\n        affLongueurAC = afficheLongueurSegment(C, A, 'black', 0.5)\n        affLongueurBC = afficheLongueurSegment(B, C, 'black', 0.5)\n      }\n      // Construction des énoncés et des corrections\n      if (listeTypeDeQuestions[i] === 'appartient') {\n        objetsEnonce.push(segmentAC, segmentBC, affLongueurAC, affLongueurBC) // On affiche les longueurs dans l'énoncé\n        texte = `Le point $${nomDesPoints[2]}$ appartient-il à la médiatrice du segment [$${nomDesPoints[0]}${nomDesPoints[1]}$] ? Justifier.<br>`\n        // On construit et code la médiatrice puis on la push dans la correction\n        D = pointIntersectionDD(mediatriceAB as Droite, droite(A, B))\n        if (C.x > A.x) {\n          objetsCorrection.push(codageAngleDroit(A, D, C, 'red', 0.4))\n        } else {\n          objetsCorrection.push(codageAngleDroit(C, D, A, 'red', 0.4))\n        }\n        objetsCorrection.push(\n          codageMilieu(A, B, 'red', '||', false),\n          mediatriceAB,\n        )\n        if (listeSurLaMediatrice[i]) {\n          // S'il est sur la médiatrice\n          texteCorr = `$${nomDesPoints[2]}${nomDesPoints[0]} = ${nomDesPoints[2]}${nomDesPoints[1]} = ${texNombre(arrondi(longueur(C, A), 1))}$ $cm$ donc le point $${nomDesPoints[2]}$ est équidistant de $${nomDesPoints[0]}$ et de $${nomDesPoints[1]}$.<br>`\n          texteCorr += `Comme tout point équidistant de $${nomDesPoints[0]}$ et de $${nomDesPoints[1]}$ appartient à la médiatrice du segment [$${nomDesPoints[0]}${nomDesPoints[1]}$], `\n          texteCorr += `alors le point $${nomDesPoints[2]}$ appartient à la médiatrice du segment [$${nomDesPoints[0]}${nomDesPoints[1]}$].`\n        } else {\n          // Si le point C doit ne pas être sur la médiatrice,\n          texteCorr = `$${nomDesPoints[2]}${nomDesPoints[0]} = ${texNombre(arrondi(longueur(C, A), 1))}$ alors que $${nomDesPoints[2]}${nomDesPoints[1]} = ${texNombre(arrondi(longueur(C, B), 1))}$ donc le point $${nomDesPoints[2]}$ n'est pas équidistant de $${nomDesPoints[0]}$ et de $${nomDesPoints[1]}$.<br>`\n          texteCorr += `Comme tout point qui n'est pas équidistant de $${nomDesPoints[0]}$ et de $${nomDesPoints[1]}$ n'appartient pas à la médiatrice du segment [$${nomDesPoints[0]}${nomDesPoints[1]}$], `\n          texteCorr += `alors le point $${nomDesPoints[2]}$ n'appartient pas à la médiatrice du segment [$${nomDesPoints[0]}${nomDesPoints[1]}$].`\n        }\n      } else {\n        objetsCorrection.push(\n          segmentAC,\n          segmentBC,\n          affLongueurAC,\n          affLongueurBC,\n        ) // On affiche les longueurs dans la correction\n        texte = `Le point $${nomDesPoints[2]}$ est-il équidistant de $${nomDesPoints[0]}$ et de $${nomDesPoints[1]}$ ? Justifier.<br>`\n        // On construit et code la médiatrice puis on la push dans l'énoncé\n        D = pointIntersectionDD(mediatriceAB as Droite, droite(A, B))\n        if (C.x > A.x) {\n          objetsEnonce.push(codageAngleDroit(A, D, C, 'red', 0.4))\n        } else {\n          objetsEnonce.push(codageAngleDroit(C, D, A, 'red', 0.4))\n        }\n        objetsEnonce.push(codageMilieu(A, B, 'red', '||', false), mediatriceAB)\n        if (listeSurLaMediatrice[i]) {\n          // S'il est sur la médiatrice\n          texteCorr = `Le point $${nomDesPoints[2]}$ appartient à la médiatrice du segment [$${nomDesPoints[0]}${nomDesPoints[1]}$].<br>`\n          texteCorr +=\n            \"Comme tout point qui appartient à la médiatrice d'un segment est équidistant des extrémités de ce segment, \"\n          texteCorr += `alors le point $${nomDesPoints[2]}$ est équidistant de $${nomDesPoints[0]}$ et de $${nomDesPoints[1]}$.`\n        } else {\n          // Si le point $${nomDesPoints[2]}$ doit ne pas être sur la médiatrice,\n          texteCorr = `Le point $${nomDesPoints[2]}$ n'appartient pas à la médiatrice du segment [$${nomDesPoints[0]}${nomDesPoints[1]}$].<br>`\n          texteCorr +=\n            \"Comme tout point qui n'appartient pas à la médiatrice d'un segment n'est pas équidistant des extrémités de ce segment, \"\n          texteCorr += `alors le point $${nomDesPoints[2]}$ n'est pas équidistant de $${nomDesPoints[0]}$ et de $${nomDesPoints[1]}$.`\n        }\n      }\n      // On push les objets\n      objetsEnonce.push(tracePoint(A, B, C), labelPoint(A, B, C), segmentAB)\n      objetsEnonce.forEach((obj) => {\n        objetsCorrection.push(obj)\n      })\n      const xmin = Math.min(A.x, B.x, C.x) - 2\n      const xmax = Math.max(A.x, B.x, C.x) + 2\n      const ymin = Math.min(A.y, B.y, C.y) - 2\n      const ymax = Math.max(A.y, B.y, C.y) + 2\n      // paramètres de la fenêtre Mathalea2d pour l'énoncé normal\n      paramsEnonce = { xmin, ymin, xmax, ymax, pixelsParCm: 20, scale: 1 }\n      // paramètres de la fenêtre Mathalea2d pour la correction\n      paramsCorrection = paramsEnonce\n      // On ajoute au texte de l'énoncé, la figure à main levée et la figure de l'enoncé.\n      texte += mathalea2d(paramsEnonce, objetsEnonce)\n      // On ajoute au texte de la correction, la figure de la correction\n      texteCorr += mathalea2d(paramsCorrection, objetsCorrection)\n      if (this.questionJamaisPosee(i, texteCorr)) {\n        this.listeQuestions[i] = texte\n        this.listeCorrections[i] = texteCorr\n        i++\n      }\n      cpt++\n    }\n    listeQuestionsToContenu(this)\n  }\n}\n"],"names":["titre","dateDePublication","dateDeModifImportante","uuid","refs","ProprietesMediatrice","Exercice","typesDeQuestionsDisponibles","listeSurLaMediatrice","listeTypeDeQuestions","combinaisonListes","A","pointAbstrait","B","C","D","segmentAB","segmentAC","segmentBC","mediatriceAB","affLongueurAC","affLongueurBC","objetsEnonce","objetsCorrection","paramsEnonce","paramsCorrection","i","texte","texteCorr","cpt","nomDesPoints","shuffle","creerNomDePolygone","pointAdistance","randint","mediatrice","pointIntersectionLC","cercle","PointAbstrait","segment","afficheLongueurSegment","pointIntersectionDD","droite","codageAngleDroit","codageMilieu","texNombre","arrondi","longueur","tracePoint","labelPoint","obj","xmin","xmax","ymin","ymax","mathalea2d","listeQuestionsToContenu"],"mappings":"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"}