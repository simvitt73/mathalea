{"version":3,"file":"_Shikaku-Q9OF8FwC.js","sources":["../../src/exercices/6e/_Shikaku.ts"],"sourcesContent":["import { BoiteBuilder } from '../../lib/2d/BoiteBuilder'\nimport { fixeBordures } from '../../lib/2d/fixeBordures'\nimport { grille } from '../../lib/2d/Grille'\nimport { point } from '../../lib/2d/PointAbstrait'\nimport { nommePolygone, polygone } from '../../lib/2d/polygones'\nimport { texteParPosition } from '../../lib/2d/textes'\nimport { shuffle } from '../../lib/outils/arrayOutils'\nimport { mathalea2d } from '../../modules/mathalea2d'\nimport { randint } from '../../modules/outils'\n\n/**\n * Cette fonction permet de créer un polygone rapidement à partir d'une liste des coordonnées de ses sommets et éventuellement de leur noms\n * @param {array} flat\n * @param {string} noms\n * @return {Polygone}\n * @author Jean-Claude Lhote\n */\nexport function flatArrayToPolygone(\n  flat: number[],\n  noms: string | string[] = '',\n) {\n  const sommets = []\n  for (let i = 0; i < flat.length; i += 2) {\n    sommets.push(point(flat[i], flat[i + 1]))\n  }\n  const pol = polygone(...sommets)\n  if (typeof noms === 'string') {\n    if (noms.length >= sommets.length) {\n      nommePolygone(pol, noms)\n    }\n  }\n  return pol\n}\n\n/**\n * Générateur aléatoire de Shikaku : il suffit de donner la largeur et la hauteur globale, le générateur fait le reste\n * pour créer un Shikaku de largeur 12 et de hauteur 6, on utilise : const myShikaku = new Shikaku(12,6)\n */\nexport default class Shikaku {\n  /**\n   *\n   * @param {number} largeur\n   * @param {number} hauteur\n   */\n  largeur: number\n  hauteur: number\n  aireTotale: number\n  marqueurs: boolean[][]\n  dimMax: { xMax: number; yMax: number }\n  pavage: { aireTotale: number; rectangles: any[] }\n  dimPossibles: number[][]\n\n  constructor(largeur: number, hauteur: number) {\n    this.largeur = largeur\n    this.hauteur = hauteur\n    this.aireTotale = largeur * hauteur\n    this.marqueurs = [] // Un tableau qui me sert à marquer les cases 'déjà occupées'\n    for (let i = 0; i < largeur; i++) {\n      this.marqueurs[i] = []\n      for (let j = 0; j < hauteur; j++) {\n        this.marqueurs[i][j] = false\n      }\n    }\n    this.dimMax = {\n      // une propriété qui permet de limiter la largeur max et la hauteur max d'un rectangle en fonction de celles de la grille\n      xMax: Math.min(largeur, Math.ceil(Math.sqrt(this.aireTotale))),\n      yMax: Math.min(hauteur, Math.ceil(Math.sqrt(this.aireTotale))),\n    }\n    // this.pavage.aireTotale contient l'aire recalculée à chaque ajout de rectangle\n    // this.pavage.rectangles est un tableau des objets 'rectangle' ajoutés\n    this.pavage = { aireTotale: 0, rectangles: [] } // La propriété vide au départ qui contient la description du pavage au fur et à mesure de sa construction\n    this.dimPossibles = [] // un tableau qui va contenir les différents modèles [largeur,hauteur] possibles pour le choix des rectangles (dépend de dimMax)\n    const aireMax = Math.ceil(2 * Math.sqrt(this.aireTotale)) // Une propriété qui limite l'aire max des rectangles\n    // on initialise les dimensions possibles\n    for (let i = 1; i <= this.dimMax.xMax; i++) {\n      for (let j = 1; j <= this.dimMax.yMax; j++) {\n        if (i * j < aireMax) this.dimPossibles.push([i, j])\n      }\n    }\n    this.paver()\n  }\n\n  // la méthode récursive du Shikaku qui va progressivement remplir les trous laissés jusqu'à ce que l'aire du pavage soit égale à celle de la grille\n  paver() {\n    if (this.pavage.aireTotale < this.aireTotale) {\n      // Le pavage est incomplet\n      this.ajouteUnRectangle()\n      this.paver()\n    }\n  }\n\n  // la méthode qui fournit (en Html ou en Latex) la représentation graphique du Shikaku\n  // si type === 'solution', alors les rectangles sont tracés.\n  represente(type: string) {\n    const objets = []\n    objets.push(grille(0, 0, this.largeur, this.hauteur))\n    for (let i = 0; i < this.pavage.rectangles.length; i++) {\n      const rectangle = this.pavage.rectangles[i]\n      objets.push(\n        texteParPosition(\n          rectangle.aire,\n          rectangle.placeNom.x + rectangle.x + 0.5,\n          rectangle.placeNom.y + rectangle.y + 0.5,\n        ),\n      )\n      if (type === 'solution') {\n        /* const box = boite({ Xmin: rectangle.x, Ymin: rectangle.y, Xmax: rectangle.x + rectangle.largeur, Ymax: rectangle.y + rectangle.hauteur, color: 'blue' })\n         */\n        const box = new BoiteBuilder({\n          xMin: rectangle.x,\n          yMin: rectangle.y,\n          xMax: rectangle.x + rectangle.largeur,\n          yMax: rectangle.y + rectangle.hauteur,\n        }).addColor({ color: 'blue' })\n        objets.push(box.render())\n      }\n    }\n    const cadre = flatArrayToPolygone([\n      0,\n      0,\n      this.largeur,\n      0,\n      this.largeur,\n      this.hauteur,\n      0,\n      this.hauteur,\n    ])\n    objets.push(cadre)\n    return mathalea2d(\n      Object.assign({}, fixeBordures(objets), { scale: 0.75 }),\n      objets,\n    )\n  }\n\n  // la méthode appelée par Shikaku.paver() pour ajouter un rectangle au pavage\n  ajouteUnRectangle() {\n    this.dimPossibles = shuffle(this.dimPossibles) // On brasse les dimensions possibles et on les teste du premier au dernier afin de ne pas toujours avoir des rectangles 1x1\n    let trouvé:\n      | boolean\n      | {\n          x: number\n          y: number\n          largeur: any\n          hauteur: any\n          aire: number\n          placeNom: { x: number; y: number }\n        } = false\n\n    let choix = 0\n    do {\n      const largeur = this.dimPossibles[choix][0]\n      const hauteur = this.dimPossibles[choix][1]\n      trouvé = this.trouvePlace(largeur, hauteur)\n      choix++\n    } while (!trouvé && choix < this.dimPossibles.length)\n    if (trouvé) {\n      this.pavage.rectangles.push(trouvé)\n      for (let i = 0; i < trouvé.largeur; i++) {\n        for (let j = 0; j < trouvé.hauteur; j++) {\n          this.marqueurs[trouvé.x + i][trouvé.y + j] = true\n        }\n      }\n      this.pavage.aireTotale += trouvé.aire\n    }\n  }\n\n  // la méthode qui essaye de trouver une place au rectangle choisi (ce n'est pas parce que la différence d'aire le permet, que ça rentre dans un trou restant !)\n  // C'est sans doute la partie du code la plus compliquée !\n  trouvePlace(largeur: number, hauteur: number) {\n    let x = 0\n    let y\n    let empiete\n\n    do {\n      if (x + largeur <= this.largeur) {\n        y = 0\n        do {\n          if (y + hauteur <= this.hauteur) {\n            if (!this.marqueurs[x][y]) {\n              empiete = false\n              for (let i = 0; i < largeur; i++) {\n                for (let j = 0; j < hauteur; j++) {\n                  if (\n                    this.marqueurs[x + i][y + j] ||\n                    x + i >= this.largeur ||\n                    y + j >= this.hauteur\n                  )\n                    empiete = true\n                }\n              }\n              if (!empiete) {\n                // C'est bon ! ça rentre dans un trou, on retourne l'objet rectangle.\n                const placeNom = this.choisitPlaceNom(largeur, hauteur)\n                return {\n                  x,\n                  y,\n                  largeur,\n                  hauteur,\n                  aire: largeur * hauteur,\n                  placeNom,\n                }\n              }\n            }\n            y++\n          } else y++\n        } while (y < this.hauteur)\n        x++\n      } else x++\n    } while (x < this.largeur)\n    return false // on n'a pas trouvé de place pour un tel rectangle, dans ce cas, on essayera les dimensions suivantes\n  }\n\n  // une fonction qui choisit aléatoirement la position du nombre dans le rectangle pour ne pas qu'il soit systématiquement en bas à droite.\n  choisitPlaceNom(largeur: number, hauteur: number) {\n    if (largeur < 1 || hauteur < 1) {\n      window.notify(\n        'erreur de largeur ou de hauteur dans choisitPlaceNom(Shikaku)',\n        {\n          largeur,\n          hauteur,\n        },\n      )\n    }\n    const x = largeur <= 1 ? 0 : randint(0, largeur - 1)\n    const y = hauteur <= 1 ? 0 : randint(0, hauteur - 1)\n    return { x, y }\n  }\n}\n"],"names":["flatArrayToPolygone","flat","noms","sommets","i","point","pol","polygone","nommePolygone","Shikaku","largeur","hauteur","__publicField","j","aireMax","type","objets","grille","rectangle","texteParPosition","box","BoiteBuilder","cadre","mathalea2d","fixeBordures","shuffle","trouvé","choix","x","y","empiete","placeNom","randint"],"mappings":"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"}