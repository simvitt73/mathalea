{"version":3,"file":"6N3D-CJ_JDa0F.js","sources":["../../src/exercices/6e/6N3D.ts"],"sourcesContent":["import Figure from 'apigeom'\nimport GraduatedLine from 'apigeom/src/elements/grid/GraduatedLine'\nimport { bleuMathalea } from '../../lib/colors'\nimport { KeyboardType } from '../../lib/interactif/claviers/keyboard'\nimport { handleAnswers } from '../../lib/interactif/gestionInteractif'\nimport { ajouteChampTexteMathLive } from '../../lib/interactif/questionMathLive'\nimport { miseEnEvidence } from '../../lib/outils/embellissements'\nimport { arrondi } from '../../lib/outils/nombres'\nimport { lettreIndiceeDepuisChiffre } from '../../lib/outils/outilString'\nimport { context } from '../../modules/context'\nimport FractionEtendue from '../../modules/FractionEtendue'\nimport {\n  contraindreValeur,\n  listeQuestionsToContenu,\n  randint,\n} from '../../modules/outils'\nimport Exercice from '../Exercice'\n\nexport const dateDePublication = '09/07/2025'\nexport const titre =\n  'Lire une abscisse fractionnaire grâce à des graduations régulièrement espacées'\nexport const interactifReady = true\nexport const interactifType = 'mathLive'\nexport const amcReady = true\nexport const amcType = 'AMCHybride'\n\n/** Lire une abscisse fractionnaire grâce à des graduations régulièrement espacées\n * @author Eric Elter\n */\nexport const uuid = 'cff03'\n\nexport const refs = {\n  'fr-fr': ['6N3D'],\n  'fr-2016': ['6N21-4'],\n  'fr-ch': [''],\n}\n\nexport default class DonnerSensDefinitionQuotient extends Exercice {\n  figuresApiGeom!: Figure[]\n  constructor() {\n    super()\n\n    this.nbQuestions = 5\n    this.exoCustomResultat = true\n\n    this.besoinFormulaireNumerique = [\n      \"Nombre d'abscisses présentes (autres que l'origine)\",\n      20,\n    ]\n    this.sup = 1\n    this.comment =\n      \"Un paramètre permet de choisir si on complique ou pas l'exercice, par l'augmentation du nombre d'abscisses présentes.\"\n    this.correctionDetaillee = true\n    this.correctionDetailleeDisponible = true\n  }\n\n  nouvelleVersion() {\n    this.figuresApiGeom = []\n\n    const NbAbscissesAutreQueOrigine = contraindreValeur(1, 20, this.sup, 1)\n\n    for (let i = 0, cpt = 0; i < this.nbQuestions && cpt < 50; ) {\n      this.consigne = this.nbQuestions\n        ? 'Sur cette droite, '\n        : 'Sur chaque droite, '\n      this.consigne += 'les graduations sont régulièrement espacées.'\n      let texte = ''\n      let texteCorr = ''\n      const den = randint(2, 7)\n      const num = randint(2, den * 2 - 1, [den])\n\n      const label = lettreIndiceeDepuisChiffre(i * 3 + 1)\n\n      const reponse = new FractionEtendue(num, den).texFraction\n      texte = `Par quel nombre, le point $${label}$, sur cette droite graduée, est-il repéré ?`\n      texte +=\n        ajouteChampTexteMathLive(\n          this,\n          i,\n          KeyboardType.clavierDeBaseAvecFraction,\n        ) + '<br>'\n      handleAnswers(this, i, { reponse: { value: reponse } })\n\n      const xMax = NbAbscissesAutreQueOrigine * num\n      const stepBis = arrondi(num / den, 4)\n\n      const figureEnonce = apigeomGraduatedLineEE({\n        xMin: 0,\n        xMax,\n        step: num,\n        stepBis,\n        points: [{ x: stepBis, label }],\n      })\n      figureEnonce.figure.create('Point', {\n        label: miseEnEvidence('?', 'black'),\n        x: stepBis,\n        y: -1.25,\n        shape: '',\n        labelDxInPixels: 0,\n      })\n      figureEnonce.figure.create('Point', {\n        label,\n        x: stepBis,\n        y: 0.15,\n        shape: '',\n        labelDxInPixels: 0,\n      })\n\n      figureEnonce.figure.options.labelAutomaticBeginsWith = label\n      figureEnonce.figure.options.pointDescriptionWithCoordinates = false\n      figureEnonce.figure.options.labelIsVisible = false\n      this.figuresApiGeom[i] = figureEnonce.figure\n\n      if (this.correctionDetaillee) {\n        texteCorr = `Entre l'origine (repérée par $0$) et le point repéré par $${miseEnEvidence(num, bleuMathalea)}$, il y a $${miseEnEvidence(den, bleuMathalea)}$ intervalles de taille identique.<br>`\n        texteCorr += `Or, on sait que le quotient $${miseEnEvidence(reponse)}$ est le nombre qui, multiplié par $${miseEnEvidence(den, bleuMathalea)}$, donne $${miseEnEvidence(num, bleuMathalea)}$, soit $${miseEnEvidence(reponse)}\\\\times${miseEnEvidence(den, bleuMathalea)}=${miseEnEvidence(num, bleuMathalea)}$.<br>`\n        texteCorr += `Le point $${label}$ est donc repéré par $${miseEnEvidence(reponse)}$.`\n\n        if (NbAbscissesAutreQueOrigine > 1) {\n          texteCorr += `<br>On peut aussi remarquer qu'entre l'origine et le point repéré par $${miseEnEvidence(2 * num, bleuMathalea)}$, il y a $${miseEnEvidence(2 * den, bleuMathalea)}$ intervalles de taille identique.<br>`\n          texteCorr += `Le point $${label}$ est donc aussi repéré par $${miseEnEvidence(new FractionEtendue(2 * num, 2 * den).texFraction, bleuMathalea)}$.`\n        }\n      }\n\n      const figureCorrection = apigeomGraduatedLineEE({\n        xMin: 0,\n        xMax,\n        step: num,\n        stepBis: num / den,\n        points: [{ x: stepBis, label }],\n        correction: [\n          {\n            x: stepBis,\n            label: `$${miseEnEvidence(new FractionEtendue(num, den).texFraction)}$`,\n          },\n        ],\n      })\n      /*\n      label: context.isHtml\n          ? miseEnEvidence(new FractionEtendue(num, den).texFraction)\n          : `$${miseEnEvidence(new FractionEtendue(num, den).texFraction)}$`,\n          */\n      figureCorrection.figure.create('Point', {\n        label: context.isHtml\n          ? miseEnEvidence(new FractionEtendue(num, den).texFraction)\n          : `$${miseEnEvidence(new FractionEtendue(num, den).texFraction)}$`,\n        x: stepBis,\n        y: -1.4,\n        shape: '',\n        labelDxInPixels: 0,\n      })\n      figureCorrection.figure.create('Point', {\n        label,\n        x: stepBis,\n        y: 0.15,\n        shape: '',\n        labelDxInPixels: 0,\n      })\n\n      if (context.isHtml) {\n        texte += '<br>' + figureEnonce.figure.getStaticHtml()\n        texteCorr += figureCorrection.figure.getStaticHtml()\n      } else {\n        texte += '\\n\\n' + figureEnonce.latex\n        texteCorr += '\\\\;\\n' + figureCorrection.latex\n      }\n\n      if (context.isAmc) {\n        this.autoCorrection[i] = {\n          enonce: 'ici la (ou les) question(s) est(sont) posée(s)',\n          enonceAvant: false, // EE : ce champ est facultatif et permet (si false) de supprimer l'énoncé ci-dessus avant la numérotation de chaque question.\n          enonceAvantUneFois: false, // EE : ce champ est facultatif et permet (si true) d'afficher l'énoncé ci-dessus une seule fois avant la numérotation de la première question de l'exercice. Ne fonctionne correctement que si l'option melange est à false.\n          propositions: [\n            {\n              type: 'AMCOpen', // on donne le type de la première question-réponse qcmMono, qcmMult, AMCNum, AMCOpen\n              propositions: [\n                {\n                  texte: texteCorr,\n                  statut: 3, // OBLIGATOIRE (ici c'est le nombre de lignes du cadre pour la réponse de l'élève sur AMC)\n                  enonce: texte,\n                  sanscadre: true, // EE : ce champ est facultatif et permet (si true) de cacher le cadre et les lignes acceptant la réponse de l'élève\n                },\n              ],\n            },\n          ],\n        }\n      }\n      if (this.questionJamaisPosee(i, num, den)) {\n        // Si la question n'a jamais été posée, on en crée une autre\n        this.listeQuestions[i] = texte\n        this.listeCorrections[i] = texteCorr\n        i++\n      }\n      cpt++\n    }\n\n    listeQuestionsToContenu(this)\n  }\n}\n\nfunction apigeomGraduatedLineEE({\n  xMin,\n  xMax,\n  points,\n  step = 1,\n  stepBis = 0.25,\n  correction,\n}: {\n  xMin: number\n  xMax: number\n  step?: number\n  stepBis?: number\n  snapGrid?: boolean\n  points?: Array<{ x: number; label: string }>\n  correction?: Array<{ x: number; label: string }>\n}): { figure: Figure; latex: string } {\n  const width = 750\n  const height = 80\n  const scale = xMax < 9 ? 1 : 8 / xMax // Permet que l'échelle soit la plus grande (sans dépasser) pour tout xMax >= 9.\n  const figure = new Figure({\n    xMin: xMin - 0.2 / scale,\n    yMin: -1.5,\n    width,\n    height,\n    dy: 10,\n    dx: stepBis,\n    xScale: 3 * scale,\n    snapGrid: false,\n  })\n  const d = new GraduatedLine(figure, { min: xMin, max: xMax, step, stepBis })\n  d.draw()\n  let latex = `\\n\\\\bigskip\n  \\\\begin{tikzpicture}[x=2.5mm]\n  \\\\draw[-{Latex[round]},thick] (0,0) -- (65,0);\n  \\\\foreach \\\\x [count=\\\\i from 0] in {0,${(60 * stepBis) / xMax},...,60} \\\\draw[thick] ([yshift=-0.8mm]\\\\x,0) -- ([yshift=0.8mm]\\\\x,0);\n  \\\\foreach \\\\x [count=\\\\i from 0] in {0,${(60 * step) / xMax},...,60} \\\\draw[ultra thick] ([yshift=-1.5mm]\\\\x,0) coordinate (a\\\\i) -- ([yshift=1.5mm]\\\\x,0);\n  \\\\foreach \\\\x [count=\\\\i from 0] in {${xMin},${step},...,${xMax}} {\n    \\\\node[below=2mm of a\\\\i,inner sep=0pt,font=\\\\small] {$\\\\num{\\\\x}$};\n}`\n  if (points !== undefined) {\n    const xA = (60 * arrondi(points[0].x - xMin)) / xMax\n    const labelA = points[0].label\n    latex += `\\n\\\\tkzText[above=2mm](${xA},0){${labelA}}`\n    // latex += ` \\n\\\\tkzDrawPoint[shape=cross out, size=5pt, thick](${xA},0)`\n  }\n  if (correction !== undefined) {\n    const xA = (60 * arrondi(correction[0].x - xMin)) / xMax\n    const labelA = correction[0].label\n    latex += `\\n\\\\tkzText[above=2mm](${xA},-1.5){${labelA}}`\n  }\n  latex += '\\n\\\\end{tikzpicture}'\n  return { figure, latex }\n}\n"],"names":["dateDePublication","titre","interactifReady","interactifType","amcReady","amcType","uuid","refs","DonnerSensDefinitionQuotient","Exercice","__publicField","NbAbscissesAutreQueOrigine","contraindreValeur","i","cpt","texte","texteCorr","den","randint","num","label","lettreIndiceeDepuisChiffre","reponse","FractionEtendue","ajouteChampTexteMathLive","KeyboardType","handleAnswers","xMax","stepBis","arrondi","figureEnonce","apigeomGraduatedLineEE","miseEnEvidence","bleuMathalea","figureCorrection","context","listeQuestionsToContenu","xMin","points","step","correction","scale","figure","Figure","GraduatedLine","latex","xA","labelA"],"mappings":"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"}