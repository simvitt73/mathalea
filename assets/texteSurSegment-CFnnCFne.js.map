{"version":3,"file":"texteSurSegment-CFnnCFne.js","sources":["../../src/lib/2d/texteSurSegment.ts"],"sourcesContent":["import { context } from '../../modules/context'\nimport { colorToLatexOrHTML } from './colorToLatexOrHtml'\nimport { ObjetMathalea2D } from './ObjetMathalea2D'\nimport { placeLatexSurSegment } from './placeLatexSurSegment'\nimport type { PointAbstrait } from './PointAbstrait'\nimport { segment } from './segmentsVecteurs'\nimport { texteParPoint } from './textes'\nimport { rotation } from './transformations'\nimport { longueur } from './utilitairesGeometriques'\nimport { milieu, pointSurSegment } from './utilitairesPoint'\n\n/**\n * texteSurSegment('mon texte',A,B) // Écrit un texte au milieu de [AB] au dessus si A est le point le plus à gauche sinon en dessous, ou alors horizontalement\n *\n * @author Rémi Angot\n */\n\nexport class TexteSurSegment extends ObjetMathalea2D {\n  stringColor: string\n  extremite1: PointAbstrait\n  extremite2: PointAbstrait\n  distance: number\n  texte: string\n  scale: number\n  mathOn: boolean\n  angle: number\n  O: PointAbstrait\n  M: PointAbstrait\n\n  constructor(\n    texte: string,\n    A: PointAbstrait,\n    B: PointAbstrait,\n    color = 'black',\n    d = 0.5,\n    horizontal = false,\n  ) {\n    super()\n    if (typeof texte === 'number') texte = String(texte)\n    if (longueur(A, B) < 0.1)\n      window.notify(\n        'TexteSurSegment : Points trop proches pour cette fonction',\n        { A, B },\n      )\n    this.color = colorToLatexOrHTML(color)\n    this.stringColor = color\n    this.extremite1 = A\n    this.extremite2 = B\n    this.texte = String(texte)\n    this.scale = 1\n    this.mathOn = true\n    this.distance = horizontal ? d - 0.1 + this.texte.length / 10 : d\n    this.O = milieu(this.extremite1, this.extremite2)\n    this.M = rotation(this.extremite1, this.O, -90)\n    const s = segment(this.extremite1, this.extremite2)\n    const pos = pointSurSegment(this.O, this.M, this.distance)\n    const space = 0.2 * (this.texte.length ?? 2)\n    this.bordures = [pos.x - space, pos.y - space, pos.x + space, pos.y + space]\n    if (horizontal) {\n      this.angle = 0\n    } else if (this.extremite2.x > this.extremite1.x) {\n      this.angle = -s.angleAvecHorizontale\n      this.angle = -s.angleAvecHorizontale\n    } else {\n      this.angle = 180 - s.angleAvecHorizontale\n      this.angle = 180 - s.angleAvecHorizontale\n    }\n  }\n\n  svg(coeff: number) {\n    const N = pointSurSegment(this.O, this.M, (this.distance * 20) / coeff)\n    return texteParPoint(\n      this.texte,\n      N,\n      this.angle,\n      this.stringColor,\n      this.scale,\n      'milieu',\n      this.mathOn,\n    ).svg(coeff)\n  }\n\n  tikz() {\n    const N = pointSurSegment(this.O, this.M, this.distance / context.scale)\n    return texteParPoint(\n      this.texte,\n      N,\n      this.angle,\n      this.stringColor,\n      this.scale,\n      'milieu',\n      this.mathOn,\n    ).tikz()\n  }\n}\n/**\n * Écrit un texte au milieu de [AB] au dessus si A est le point le plus à gauche sinon au dessous ou bien horizontal\n * @param {string} texte\n * @param {PointAbstrait} A\n * @param {PointAbstrait} B\n * @param {string} [color='black'] Code couleur HTML accepté\n * @param {number} [distance=0.5] Distance à la droite.\n * @param {boolean} [horizontal=false] Si true, alors le texte est horizontal, sinon le texte est parallèle au segment\n * @return {object} LatexParCoordonnees si le premier caractère est '$', TexteParPoint sinon\n * @author Rémi Angot\n */\n\nexport function texteSurSegment(\n  texte = '',\n  A: PointAbstrait,\n  B: PointAbstrait,\n  color = 'black',\n  distance = 0.5,\n  horizontal = false,\n) {\n  if (texte[0] === '$') {\n    return placeLatexSurSegment(texte.replaceAll('$', ''), A, B, {\n      color,\n      distance,\n      horizontal,\n    })\n  }\n  return new TexteSurSegment(texte, A, B, color, distance, horizontal)\n}\n"],"names":["TexteSurSegment","ObjetMathalea2D","texte","A","B","color","d","horizontal","__publicField","longueur","colorToLatexOrHTML","milieu","rotation","s","segment","pos","pointSurSegment","space","coeff","N","texteParPoint","context","texteSurSegment","distance","placeLatexSurSegment"],"mappings":"khBAiBO,MAAMA,UAAwBC,CAAgB,CAYnD,YACEC,EACAC,EACAC,EACAC,EAAQ,QACRC,EAAI,GACJC,EAAa,GACb,CACA,MAAA,EAnBFC,EAAA,oBACAA,EAAA,mBACAA,EAAA,mBACAA,EAAA,iBACAA,EAAA,cACAA,EAAA,cACAA,EAAA,eACAA,EAAA,cACAA,EAAA,UACAA,EAAA,UAWM,OAAON,GAAU,WAAUA,EAAQ,OAAOA,CAAK,GAC/CO,EAASN,EAAGC,CAAC,EAAI,IACnB,OAAO,OACL,4DACA,CAAE,EAAAD,EAAG,EAAAC,CAAA,CAAE,EAEX,KAAK,MAAQM,EAAmBL,CAAK,EACrC,KAAK,YAAcA,EACnB,KAAK,WAAaF,EAClB,KAAK,WAAaC,EAClB,KAAK,MAAQ,OAAOF,CAAK,EACzB,KAAK,MAAQ,EACb,KAAK,OAAS,GACd,KAAK,SAAWK,EAAaD,EAAI,GAAM,KAAK,MAAM,OAAS,GAAKA,EAChE,KAAK,EAAIK,EAAO,KAAK,WAAY,KAAK,UAAU,EAChD,KAAK,EAAIC,EAAS,KAAK,WAAY,KAAK,EAAG,GAAG,EAC9C,MAAMC,EAAIC,EAAQ,KAAK,WAAY,KAAK,UAAU,EAC5CC,EAAMC,EAAgB,KAAK,EAAG,KAAK,EAAG,KAAK,QAAQ,EACnDC,EAAQ,IAAO,KAAK,MAAM,QAAU,GAC1C,KAAK,SAAW,CAACF,EAAI,EAAIE,EAAOF,EAAI,EAAIE,EAAOF,EAAI,EAAIE,EAAOF,EAAI,EAAIE,CAAK,EACvEV,EACF,KAAK,MAAQ,EACJ,KAAK,WAAW,EAAI,KAAK,WAAW,GAC7C,KAAK,MAAQ,CAACM,EAAE,qBAChB,KAAK,MAAQ,CAACA,EAAE,uBAEhB,KAAK,MAAQ,IAAMA,EAAE,qBACrB,KAAK,MAAQ,IAAMA,EAAE,qBAEzB,CAEA,IAAIK,EAAe,CACjB,MAAMC,EAAIH,EAAgB,KAAK,EAAG,KAAK,EAAI,KAAK,SAAW,GAAME,CAAK,EACtE,OAAOE,EACL,KAAK,MACLD,EACA,KAAK,MACL,KAAK,YACL,KAAK,MACL,SACA,KAAK,MAAA,EACL,IAAID,CAAK,CACb,CAEA,MAAO,CACL,MAAMC,EAAIH,EAAgB,KAAK,EAAG,KAAK,EAAG,KAAK,SAAWK,EAAQ,KAAK,EACvE,OAAOD,EACL,KAAK,MACLD,EACA,KAAK,MACL,KAAK,YACL,KAAK,MACL,SACA,KAAK,MAAA,EACL,KAAA,CACJ,CACF,CAaO,SAASG,EACdpB,EAAQ,GACRC,EACAC,EACAC,EAAQ,QACRkB,EAAW,GACXhB,EAAa,GACb,CACA,OAAIL,EAAM,CAAC,IAAM,IACRsB,EAAqBtB,EAAM,WAAW,IAAK,EAAE,EAAGC,EAAGC,EAAG,CAC3D,MAAAC,EACA,SAAAkB,EACA,WAAAhB,CAAA,CACD,EAEI,IAAIP,EAAgBE,EAAOC,EAAGC,EAAGC,EAAOkB,EAAUhB,CAAU,CACrE"}