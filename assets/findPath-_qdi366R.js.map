{"version":3,"file":"findPath-_qdi366R.js","sources":["../../src/modules/findPath.ts"],"sourcesContent":["class Node2d {\n  x: number\n  y: number\n  walkable: boolean\n  gCost: number\n  hCost: number\n  parent: Node2d | null\n\n  constructor(x: number, y: number, walkable = true) {\n    this.x = x\n    this.y = y\n    this.walkable = walkable\n    this.gCost = Infinity\n    this.hCost = 0\n    this.parent = null\n  }\n\n  get fCost() {\n    return this.gCost + this.hCost\n  }\n}\n\nfunction heuristic(nodeA: Node2d, nodeB: Node2d) {\n  const dx = Math.abs(nodeA.x - nodeB.x)\n  const dy = Math.abs(nodeA.y - nodeB.y)\n  return 14 * Math.min(dx, dy) + 10 * Math.abs(dx - dy)\n}\n\nfunction findPath(\n  startNode: Node2d,\n  endNode: Node2d,\n  grid: Node2d[][],\n  modifiedNodes = new Set(),\n) {\n  const openSet = [startNode]\n  const closedSet = new Set<Node2d>()\n  startNode.gCost = 0\n\n  while (openSet.length > 0) {\n    openSet.sort((a, b) => a.fCost - b.fCost)\n    let currentNode = openSet.shift()\n    if (!currentNode) break\n    closedSet.add(currentNode)\n\n    if (currentNode === endNode) {\n      const path = []\n      while (currentNode !== startNode) {\n        path.push(currentNode)\n        if (currentNode.parent) {\n          currentNode = currentNode.parent\n        } else {\n          break\n        }\n      }\n      return path\n    }\n\n    for (const neighbor of getNeighbors(currentNode, grid)) {\n      if (\n        !neighbor.walkable ||\n        closedSet.has(neighbor) ||\n        modifiedNodes.has(neighbor)\n      )\n        continue\n      const cost = currentNode.gCost + heuristic(currentNode, neighbor)\n      if (cost < neighbor.gCost || !openSet.includes(neighbor)) {\n        neighbor.gCost = cost\n        neighbor.hCost = heuristic(neighbor, endNode)\n        neighbor.parent = currentNode\n        if (!openSet.includes(neighbor)) openSet.push(neighbor)\n      }\n    }\n  }\n  return null\n}\n\nfunction getNeighbors(node: Node2d, grid: Node2d[][]) {\n  const neighbors = []\n  const { x, y } = node\n  const directions = [\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n  ]\n  for (const [dx, dy] of directions) {\n    const nx = x + dx\n    const ny = y + dy\n    if (grid[ny] && grid[ny][nx] && grid[ny][nx].walkable)\n      neighbors.push(grid[ny][nx])\n  }\n  return neighbors\n}\n\nfunction createGrid(rows: number, cols: number, rate: number) {\n  const grid = []\n  for (let y = 0; y < rows; y++) {\n    const row = []\n    for (let x = 0; x < cols; x++) {\n      const walkable = Math.random() > rate && x + 1 !== cols // 20% de cases non accessibles\n      row.push(new Node2d(x, y, walkable))\n    }\n    grid.push(row)\n  }\n  return grid\n}\n\n/**\n * MGu trouve des chemins ebtres deux points dans une grille de taille rows * cols.\n * Il y a 20% de cases non accessibles.\n * @param rows le nombre de lignes de la grille\n * @param cols le nombre de colonnes de la grille\n * @param rowsStart le numéro de la ligne de départ\n * @param colsStart le  numéro de la colonne de départ\n * @param rowsEnd le numéro de la ligne d'arrivée\n * @param colsEnd le numéro de la colonne d'arrivée\n * @returns les chemins trouvés entre le point de départ et le point d'arrivée\n */\nexport function runAStar(\n  rows: number,\n  cols: number,\n  rowsStart: number,\n  colsStart: number,\n  rowsEnd: number,\n  colsEnd: number,\n): Node2d[][] {\n  const rate = rows * cols > 25 ? 0.2 : 0 // 20% de cases non accessibles\n  const grid = createGrid(rows, cols, rate)\n  const start = grid[rowsStart][colsStart]\n  const end = grid[rowsEnd][colsEnd]\n  start.walkable = true\n  end.walkable = true\n  const paths: Node2d[][] = []\n  const modifiedNodes = new Set()\n  const path1 = findPath(start, end, grid, modifiedNodes)\n  if (path1) {\n    paths.push([start, ...path1.slice().reverse()])\n    modifiedNodes.add(path1[Math.floor(path1.length * 0.5)])\n  }\n\n  const path2 = findPath(start, end, grid, modifiedNodes)\n  if (path2) {\n    paths.push([start, ...path2.slice().reverse()])\n    paths[paths.length - 1]\n      .slice(Math.floor(path2.length * 0.4), Math.floor(path2.length * 0.6))\n      .forEach((node) => modifiedNodes.add(node))\n  }\n\n  const path3 = findPath(start, end, grid, modifiedNodes)\n  if (path3) {\n    paths.push([start, ...path3.slice().reverse()])\n  }\n  return paths\n}\n"],"names":["Node2d","x","y","walkable","__publicField","heuristic","nodeA","nodeB","dx","dy","findPath","startNode","endNode","grid","modifiedNodes","openSet","closedSet","a","b","currentNode","path","neighbor","getNeighbors","cost","node","neighbors","directions","nx","ny","createGrid","rows","cols","rate","row","runAStar","rowsStart","colsStart","rowsEnd","colsEnd","start","end","paths","path1","path2","path3"],"mappings":"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"}