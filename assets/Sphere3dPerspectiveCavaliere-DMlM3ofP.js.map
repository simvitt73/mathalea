{"version":3,"file":"Sphere3dPerspectiveCavaliere-DMlM3ofP.js","sources":["../../src/lib/3d/3dProjectionMathalea2d/Sphere3dPerspectiveCavaliere.ts"],"sourcesContent":["import {\n  assombrirOuEclaircir,\n  colorToLatexOrHTML,\n} from '../../2d/colorToLatexOrHtml'\nimport { droite } from '../../2d/droites'\nimport { ObjetMathalea2D } from '../../2d/ObjetMathalea2D'\nimport { PointAbstrait, pointAbstrait } from '../../2d/PointAbstrait'\nimport { polygone } from '../../2d/polygones'\nimport { polyline } from '../../2d/Polyline'\nimport { segment } from '../../2d/segmentsVecteurs'\nimport { tracePoint } from '../../2d/TracePoint'\nimport { estDansPolygone } from '../../2d/utilitairesGeometriques'\nimport { pointIntersectionDD, pointSurSegment } from '../../2d/utilitairesPoint'\nimport { vide2d } from '../../2d/Vide2d'\nimport { choisitLettresDifferentes } from '../../outils/aleatoires'\nimport {\n  Point3d,\n  Vecteur3d,\n  cercle3d,\n  droite3d,\n  point3d,\n  rotation3d,\n  vecteur3d,\n} from './elementsEtTransformations3d'\n\nconst longueur = (A: PointAbstrait, B: PointAbstrait): number =>\n  Math.sqrt((B.x - A.x) ** 2 + (B.y - A.y) ** 2)\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS COMPLEXES %%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n/**\n * LA SPHERE - ANCIENNE FONCTION\n *\n * @author Jean-Claude Lhote\n * Produit une sphère : choisir un nombre de parallèles impair pour avoir l'équateur. normal défini l'axe Nord-Sud.\n * rayon est le rayon de la sphère. l'équateur est dans le plan xy l'axe Nord-Sud est sur z\n * @param {Point3d} centre\n * @param {Number} rayon\n * @param {Number} nbParalleles\n * @param {Number} nbMeridiens\n * @param {string} color\n */\n/**\n * Classe de la sphère\n * @param {Point3d} centre Centre de la sphère\n * @param {number} rayon Rayon de la sphère\n * @param {string} [colorEquateur = 'red'] Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @param {string} [colorEnveloppe = 'blue'] Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbParalleles = 0]  Le nombre de parallèles au total\n * @param {string} [colorParalleles = 'gray'] Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbMeridiens = 0]  Le nombre de méridiens au total\n * @param {string} [colorMeridiens = 'gray'] Couleur des méridiens de la sphère : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe de la sphère.\n * @param {string} [colorAxe = 'black'] Couleur de l'axe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} inclinaison angle d'inclinaison de l'axe N-S\n * @param {boolean} faceCachee Si false on économise tout ce qui est en pointillé à l'arrière.\n * @property {Point3d} centre Centre de la sphère\n * @property {Vecteur3d} rayon Rayon de la sphère\n * @property {string} colorEquateur Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @property {string} colorEnveloppe Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbParalleles Le nombre de parallèles au total\n * @property {string} colorParalleles Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbMeridiens Le nombre de méridiens au total\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS COMPLEXES %%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n/**\n * LA SPHERE - ANCIENNE FONCTION\n *\n * @author Jean-Claude Lhote\n * Produit une sphère : choisir un nombre de parallèles impair pour avoir l'équateur. normal défini l'axe Nord-Sud.\n * rayon est le rayon de la sphère. l'équateur est dans le plan xy l'axe Nord-Sud est sur z\n * @param {Point3d} centre\n * @param {Number} rayon\n * @param {Number} nbParalleles\n * @param {Number} nbMeridiens\n * @param {string} color\n */\n/**\n * Classe de la sphère\n * @param {Point3d} centre Centre de la sphère\n * @param {number} rayon Rayon de la sphère\n * @param {string} [colorEquateur = 'red'] Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @param {string} [colorEnveloppe = 'blue'] Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbParalleles = 0]  Le nombre de parallèles au total\n * @param {string} [colorParalleles = 'gray'] Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbMeridiens = 0]  Le nombre de méridiens au total\n * @param {string} [colorMeridiens = 'gray'] Couleur des méridiens de la sphère : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe de la sphère.\n * @param {string} [colorAxe = 'black'] Couleur de l'axe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} inclinaison angle d'inclinaison de l'axe N-S\n * @param {boolean} faceCachee Si false on économise tout ce qui est en pointillé à l'arrière.\n * @property {Point3d} centre Centre de la sphère\n * @property {Vecteur3d} rayon Rayon de la sphère\n * @property {string} colorEquateur Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @property {string} colorEnveloppe Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbParalleles Le nombre de parallèles au total\n * @property {string} colorParalleles Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbMeridiens Le nombre de méridiens au total\n * @property {string} colorMeridiens Couleur des méridiens de la sphère : du type 'blue' ou du type '#f15929'\n * @property {boolean} affichageAxe Permet (ou pas) l'affichage de l'axe de la sphère.\n * @property {string} colorAxe Couleur de l'axe de la sphère : du type 'blue' ou du type '#f15929'\n * @property {Array} c2d Contient les commandes à tracer en 2d de cette fonction\n * @author Eric Elter (d'après version précédente de Jean-Claude Lhote)\n * @class\n */\n\nexport class Sphere3d extends ObjetMathalea2D {\n  constructor(\n    centre: Point3d,\n    rayon: Vecteur3d | number,\n    colorEquateur = 'red',\n    colorEnveloppe = 'blue',\n    nbParalleles = 0,\n    colorParalleles = 'gray',\n    nbMeridiens = 0,\n    colorMeridiens = 'gray',\n    affichageAxe = false,\n    colorAxe = 'black',\n    inclinaison = 0,\n    faceCachee = true,\n  ) {\n    super()\n    this.centre = centre\n    this.rayon = typeof rayon === 'number' ? rayon : rayon.norme\n    this.objets = []\n    this.colorEquateur = colorEquateur\n    this.colorEnveloppe = colorEnveloppe\n    this.nbParalleles = nbParalleles\n    this.colorParalleles = colorParalleles\n    this.nbMeridiens = nbMeridiens\n    this.colorMeridiens = colorMeridiens\n    this.affichageAxe = affichageAxe\n    this.colorAxe = colorAxe\n    const droiteRot = droite3d(\n      point3d(this.centre.x, this.centre.y, this.centre.z),\n      vecteur3d(0, 1, 0),\n    )\n    const poleNord = rotation3d(\n      point3d(\n        this.centre.x,\n        this.centre.y,\n        this.centre.z + this.rayon,\n        true,\n        choisitLettresDifferentes(1, 'OQWX' + this.centre.label)[0],\n        'left',\n      ),\n      droiteRot,\n      inclinaison,\n    )\n    const poleSud = rotation3d(\n      point3d(\n        this.centre.x,\n        this.centre.y,\n        this.centre.z - this.rayon,\n        true,\n        choisitLettresDifferentes(\n          1,\n          'OQWX' + this.centre.label + poleNord.label,\n        )[0],\n        'left',\n      ),\n      droiteRot,\n      inclinaison,\n    )\n    const nbParallelesDeConstruction = 36 // Ce nb de paralleles permet de construire l'enveloppe de la sphère (le \"cercle\" apparent de la sphère)\n    const divisionParalleles =\n      this.nbParalleles !== 0\n        ? Math.round((2 * nbParallelesDeConstruction) / this.nbParalleles)\n        : 1\n    let unDesParalleles\n    let centreParallele\n    let rayonDuParallele\n    let normal\n    const paralleles: {\n      listePoints3d: Point3d[][]\n      ptCachePremier: PointAbstrait[]\n      indicePtCachePremier: number[]\n      ptCacheDernier: PointAbstrait[]\n      indicePtCacheDernier: number[]\n    } = {\n      listePoints3d: [],\n      ptCachePremier: [],\n      indicePtCachePremier: [],\n      ptCacheDernier: [],\n      indicePtCacheDernier: [],\n    }\n    const enveloppeSphere1: PointAbstrait[] = []\n    let enveloppeSphere2: PointAbstrait[] = []\n    let premierParallele = 100\n    let indicePremier = 0\n    let indiceDernier = 0\n    this.c2d = []\n\n    // Construction de tous les paralleles\n    // Construction du parallèle le plus proche du pôle nord\n    centreParallele = rotation3d(\n      point3d(\n        this.centre.x,\n        this.centre.y,\n        this.centre.z +\n          this.rayon *\n            Math.sin(\n              (((nbParallelesDeConstruction - 1) / nbParallelesDeConstruction) *\n                Math.PI) /\n                2,\n            ),\n      ),\n      droiteRot,\n      inclinaison,\n    )\n    rayonDuParallele = rotation3d(\n      vecteur3d(\n        this.rayon *\n          Math.cos(\n            (((nbParallelesDeConstruction - 1) / nbParallelesDeConstruction) *\n              Math.PI) /\n              2,\n          ),\n        0,\n        0,\n      ),\n      droiteRot,\n      inclinaison,\n    )\n    normal = rotation3d(vecteur3d(0, 0, 1), droiteRot, inclinaison)\n    unDesParalleles = cercle3d(centreParallele, normal, rayonDuParallele)\n    paralleles.listePoints3d.push(unDesParalleles[1])\n    paralleles.ptCachePremier.push(pointAbstrait(0, 0))\n    paralleles.indicePtCachePremier.push(0)\n    paralleles.ptCacheDernier.push(pointAbstrait(0, 0))\n    paralleles.indicePtCacheDernier.push(0)\n\n    // Construction de tous les autres parallèles jusqu'au plus proche du pôle sud\n    for (\n      let k = nbParallelesDeConstruction - 2, poly, j = 1;\n      k > -nbParallelesDeConstruction;\n      k -= 1\n    ) {\n      centreParallele = rotation3d(\n        point3d(\n          this.centre.x,\n          this.centre.y,\n          this.centre.z +\n            this.rayon *\n              Math.sin(((k / nbParallelesDeConstruction) * Math.PI) / 2),\n        ),\n        droiteRot,\n        inclinaison,\n      )\n      rayonDuParallele = rotation3d(\n        vecteur3d(\n          this.rayon *\n            Math.cos(((k / nbParallelesDeConstruction) * Math.PI) / 2),\n          0,\n          0,\n        ),\n        droiteRot,\n        inclinaison,\n      )\n\n      normal = rotation3d(vecteur3d(0, 0, 1), droiteRot, inclinaison)\n      poly = polygone(unDesParalleles[2])\n      unDesParalleles = cercle3d(\n        centreParallele,\n        normal,\n        rayonDuParallele,\n        false,\n      )\n      paralleles.listePoints3d.push(unDesParalleles[1])\n      for (let ee = 0; ee < paralleles.listePoints3d[0].length; ee++) {\n        paralleles.listePoints3d[j][ee].isVisible = !estDansPolygone(\n          paralleles.listePoints3d[j][ee].c2d,\n          poly,\n        )\n      }\n      paralleles.ptCachePremier.push(pointAbstrait(0, 0))\n      paralleles.indicePtCachePremier.push(0)\n      paralleles.ptCacheDernier.push(pointAbstrait(0, 0))\n      paralleles.indicePtCacheDernier.push(0)\n\n      for (\n        let ee = 0, s, s1, d1, d2, jj, pt;\n        ee < paralleles.listePoints3d[0].length;\n        ee++\n      ) {\n        const extremite1 = paralleles.listePoints3d[j][ee].c2d\n        const extremite2 =\n          paralleles.listePoints3d[j][\n            (ee + 1) % paralleles.listePoints3d[0].length\n          ].c2d\n        s =\n          longueur(extremite1, extremite2) < 0.001\n            ? vide2d()\n            : segment(extremite1, extremite2)\n        // Recherche du point d'intersection entre le parallèle actuel et le précédent.\n        if (\n          !paralleles.listePoints3d[j][ee].isVisible &&\n          paralleles.listePoints3d[j][\n            (ee + 1) % paralleles.listePoints3d[0].length\n          ].isVisible\n        ) {\n          jj = ee - 3\n          s1 = droite(\n            paralleles.listePoints3d[j - 1][\n              (paralleles.listePoints3d[0].length + jj) %\n                paralleles.listePoints3d[0].length\n            ].c2d,\n            paralleles.listePoints3d[j - 1][\n              (paralleles.listePoints3d[0].length + jj - 1) %\n                paralleles.listePoints3d[0].length\n            ].c2d,\n          )\n          // Le point d'intersection avec ce segment précis du parallèle actuel est avec l'un des 7 (nombre totalement empirique) segments les plus proches du parallèle précédent.\n          let cptBoucleInfinie = 0\n          while (!s.estSecant(s1) && cptBoucleInfinie < 7) {\n            jj++\n            s1 = droite(\n              paralleles.listePoints3d[j - 1][\n                (paralleles.listePoints3d[0].length + jj) %\n                  paralleles.listePoints3d[0].length\n              ].c2d,\n              paralleles.listePoints3d[j - 1][\n                (paralleles.listePoints3d[0].length + jj - 1) %\n                  paralleles.listePoints3d[0].length\n              ].c2d,\n            )\n            cptBoucleInfinie++\n          }\n          if (cptBoucleInfinie === 7) {\n            // console.info('Boucle infinie')\n          } else {\n            // s étant secant avec s1, on mène plusieurs actions :\n            d1 = droite(\n              paralleles.listePoints3d[j][ee].c2d,\n              paralleles.listePoints3d[j][\n                (ee + 1) % paralleles.listePoints3d[0].length\n              ].c2d,\n            )\n            d2 = droite(\n              paralleles.listePoints3d[j - 1][\n                (paralleles.listePoints3d[0].length + jj) %\n                  paralleles.listePoints3d[0].length\n              ].c2d,\n              paralleles.listePoints3d[j - 1][\n                (paralleles.listePoints3d[0].length + jj - 1) %\n                  paralleles.listePoints3d[0].length\n              ].c2d,\n            )\n            pt = pointIntersectionDD(d1, d2) // 1) Tout d'abord, ce point d'intersection est donc la frontière entre le visible et le caché et on l'enregistre comme élément de l'enveloppe de la sphère\n            if (!pt) {\n              window.notify(\n                \"Erreur dans le calcul du point d'intersection entre d1 et d2\",\n                { d1, d2 },\n              )\n              continue\n            }\n            enveloppeSphere1.push(pt)\n            //  2) Ensuite, si pt est le tout premier point d'intersection trouvé, on enregistre quel est le premier parallèle et quel est son indice\n            // Ces informmations serviront pour le tracé de l'enveloppe près du pôle Nord.\n            if (premierParallele >= j) {\n              premierParallele = j\n              indicePremier = jj % paralleles.listePoints3d[0].length\n            }\n            // 3) On note ce point pour le futur tracé du parallèle, si besoin\n            paralleles.ptCachePremier[j] = pt\n            paralleles.indicePtCachePremier[j] = ee\n          }\n        } else if (\n          paralleles.listePoints3d[j][ee].isVisible &&\n          !paralleles.listePoints3d[j][\n            (ee + 1) % paralleles.listePoints3d[0].length\n          ].isVisible\n        ) {\n          // Si le point précédent était l'entrée dans la partie cachée, alors celui-ci sera celui de l'entrée dans la partie visible (ou inversement)\n          // car pour chaque parallèle intersecté avec le précédent, il y a \"forcément\" deux points sauf tangence mais ce n'est pas un pb.\n          jj = ee - 3\n          s1 = droite(\n            paralleles.listePoints3d[j - 1][\n              (paralleles.listePoints3d[0].length + jj) %\n                paralleles.listePoints3d[0].length\n            ].c2d,\n            paralleles.listePoints3d[j - 1][\n              (paralleles.listePoints3d[0].length + jj - 1) %\n                paralleles.listePoints3d[0].length\n            ].c2d,\n          )\n          // On recherche le point d'intersection\n          let cptBoucleInfinie = 0\n          while (!s.estSecant(s1) && cptBoucleInfinie < 7) {\n            jj++\n            s1 = droite(\n              paralleles.listePoints3d[j - 1][\n                (paralleles.listePoints3d[0].length + jj) %\n                  paralleles.listePoints3d[0].length\n              ].c2d,\n              paralleles.listePoints3d[j - 1][\n                (paralleles.listePoints3d[0].length + jj - 1) %\n                  paralleles.listePoints3d[0].length\n              ].c2d,\n            )\n            cptBoucleInfinie++\n          }\n          if (cptBoucleInfinie === 7) {\n            // console.info('Boucle infinie')\n          } else {\n            // s étant secant avec s1, on mène plusieurs actions :\n            d1 = droite(\n              paralleles.listePoints3d[j][ee].c2d,\n              paralleles.listePoints3d[j][\n                (ee + 1) % paralleles.listePoints3d[0].length\n              ].c2d,\n            )\n            d2 = droite(\n              paralleles.listePoints3d[j - 1][\n                (paralleles.listePoints3d[0].length + jj) %\n                  paralleles.listePoints3d[0].length\n              ].c2d,\n              paralleles.listePoints3d[j - 1][\n                (paralleles.listePoints3d[0].length + jj - 1) %\n                  paralleles.listePoints3d[0].length\n              ].c2d,\n            )\n            pt = pointIntersectionDD(d1, d2)\n            if (!pt) {\n              window.notify(\n                \"Erreur dans le calcul du point d'intersection entre d1 et d2\",\n                { d1, d2 },\n              )\n              continue\n            }\n            // 1) Tout d'abord, ce point d'intersection est donc la frontière entre le visible et le caché et on l'enregistre comme élément de l'enveloppe de la sphère\n            enveloppeSphere2.push(pt)\n            // 2) Ensuite, si pt est le tout premier point d'intersection trouvé, on enregistre quel est le premier parallèle et quel est son indice\n            // Ces informmations serviront pour le tracé de l'enveloppe près du pôle Sud.\n            if (premierParallele >= j) {\n              premierParallele = j\n              indiceDernier = jj\n            }\n            // 3) On note ce point pour le futur tracé du parallèle, si besoin\n            paralleles.ptCacheDernier[j] = pt\n            paralleles.indicePtCacheDernier[j] = ee\n          }\n        }\n      }\n      j++\n    }\n\n    if (this.nbParalleles !== 0) {\n      let t = tracePoint(poleNord.c2d, this.colorParalleles)\n      t.style = 'o'\n      t.taille = 0.5\n      this.c2d.push(t)\n      t = tracePoint(\n        poleSud.c2d,\n        assombrirOuEclaircir(this.colorParalleles, 50),\n      )\n      t.style = 'o'\n      t.taille = 0.5\n      this.c2d.push(t)\n    }\n\n    // Construction des parallèles demandés\n    for (\n      let k = nbParallelesDeConstruction, j = -1;\n      k > -nbParallelesDeConstruction;\n      k -= 1\n    ) {\n      const polyLineVisible = [] // Contient l'ensemble des points du parallèle contenus dans la partie visible\n      let polyLineCachee = [] // Idem pour la partie cachée.\n      if (\n        (this.nbParalleles !== 0 || k === 0) &&\n        k !== nbParallelesDeConstruction &&\n        k % divisionParalleles === 0\n      ) {\n        // k=0 : C'est l'équateur\n        for (let ee = 0; ee < paralleles.listePoints3d[0].length; ee++) {\n          if (paralleles.indicePtCachePremier[j] === ee) {\n            polyLineCachee.push(paralleles.ptCachePremier[j])\n          } else if (paralleles.indicePtCacheDernier[j] === ee) {\n            polyLineCachee.push(paralleles.ptCacheDernier[j])\n          } else {\n            // Tracé des pointilles ou pas des parallèles\n            if (\n              !paralleles.listePoints3d[j][ee].isVisible &&\n              !paralleles.listePoints3d[j][\n                (ee + 1) % paralleles.listePoints3d[0].length\n              ].isVisible\n            ) {\n              polyLineCachee.push(paralleles.listePoints3d[j][ee].c2d)\n            } else {\n              polyLineVisible.push(\n                paralleles.listePoints3d[j][\n                  (ee + 1) % paralleles.listePoints3d[0].length\n                ].c2d,\n              )\n            }\n          }\n        }\n        if (k < 36 && k > -30) {\n          // uniquement à bonne distance des pôles pour éviter les points trop proches\n          let securite = 0\n          if (polyLineCachee.length > 4) {\n            // une précaution au cas où la liste de points est courte ça pourrait boucler à l'infini\n            while (\n              securite < 10 &&\n              longueur(\n                polyLineCachee[polyLineCachee.length - 1],\n                polyLineCachee[0],\n              ) < 1\n            ) {\n              const dernierPoint = polyLineCachee.pop()\n              if (dernierPoint)\n                polyLineCachee = [\n                  pointAbstrait(dernierPoint.x, dernierPoint.y),\n                  ...polyLineCachee,\n                ]\n              securite++\n            }\n          }\n          if (polyLineVisible.length > 4) {\n            while (\n              securite < 20 &&\n              longueur(\n                polyLineVisible[polyLineVisible.length - 1],\n                polyLineVisible[0],\n              ) < 1\n            ) {\n              const premierPoint = polyLineVisible.shift()\n              if (premierPoint)\n                polyLineVisible.push(\n                  pointAbstrait(premierPoint.x, premierPoint.y),\n                )\n              securite++\n            }\n          }\n        }\n        if (faceCachee) {\n          const ligneCachee =\n            polyLineCachee.length > 0 ? polyline(...polyLineCachee) : null // parfois, il n'y a rien à cacher près du pôle nord\n          if (ligneCachee && k === 0) {\n            // là on est certain qu'il y a du monde à cacher\n            ligneCachee.color = colorToLatexOrHTML(this.colorEquateur)\n            ligneCachee.epaisseur = 1.5\n          } else {\n            if (ligneCachee)\n              ligneCachee.color = colorToLatexOrHTML(this.colorParalleles)\n          }\n          if (faceCachee && ligneCachee) {\n            ligneCachee.pointilles = 4\n            ligneCachee.opacite = 0.5\n            this.c2d.push(ligneCachee)\n          }\n        }\n        const ligneVisible =\n          polyLineVisible.length > 0 ? polyline(...polyLineVisible) : null // et rien non plus à montrer près du pôle sud.\n        if (ligneVisible && k === 0) {\n          // là on est certain qu'il y a du monde à montrer\n          ligneVisible.color = colorToLatexOrHTML(this.colorEquateur)\n          ligneVisible.epaisseur = 1.5\n        } else {\n          if (ligneVisible)\n            ligneVisible.color = colorToLatexOrHTML(this.colorParalleles)\n        }\n        if (ligneVisible) {\n          this.c2d.push(ligneVisible)\n        }\n      }\n      j++\n    }\n\n    // Construction des méridiens demandés\n    if (this.nbMeridiens !== 0) {\n      const divisionMeridiens = Math.round(36 / this.nbMeridiens)\n      for (let k = 0, s; k < 18; k += divisionMeridiens) {\n        const polyLineCachee1 = []\n        const polyLineVisible1 = []\n        const polyLineCachee2 = []\n        const polyLineVisible2 = []\n\n        for (let ee = 1; ee < paralleles.listePoints3d.length - 1; ee++) {\n          // Affichage des méridiens sans le dernier segment relié aux pôles\n          if (\n            !paralleles.listePoints3d[ee][k].isVisible &&\n            !paralleles.listePoints3d[\n              (ee + 1) % paralleles.listePoints3d.length\n            ][k].isVisible\n          ) {\n            //  s.pointilles = 4 // Laisser 4 car sinon les pointilles ne se voient dans les petits cercles\n            //  s.opacite = 0.5\n            polyLineCachee1.push(paralleles.listePoints3d[ee][k].c2d)\n          } else {\n            polyLineVisible1.push(paralleles.listePoints3d[ee][k].c2d)\n          }\n          if (\n            !paralleles.listePoints3d[ee][k + 18].isVisible &&\n            !paralleles.listePoints3d[\n              (ee + 1) % paralleles.listePoints3d.length\n            ][k + 18].isVisible\n          ) {\n            //   s.pointilles = 4 // Laisser 4 car sinon les pointilles ne se voient dans les petits cercles\n            //   s.opacite = 0.5\n            polyLineCachee2.push(paralleles.listePoints3d[ee][k + 18].c2d)\n          } else {\n            polyLineVisible2.push(paralleles.listePoints3d[ee][k + 18].c2d)\n          }\n        }\n        // Affichage de la partie reliée au pôle Nord\n        let extremite1 = poleNord.c2d\n        let extremite2 = paralleles.listePoints3d[1][k].c2d\n        s =\n          longueur(extremite1, extremite2) < 0.001\n            ? vide2d()\n            : segment(\n                poleNord.c2d,\n                paralleles.listePoints3d[1][k].c2d,\n                this.colorMeridiens,\n              )\n        this.c2d.push(s)\n        extremite1 = paralleles.listePoints3d[1][k + 18].c2d\n        extremite2 = poleNord.c2d\n        s =\n          longueur(extremite1, extremite2) < 0.001\n            ? vide2d()\n            : segment(\n                paralleles.listePoints3d[1][k + 18].c2d,\n                poleNord.c2d,\n                this.colorMeridiens,\n              )\n        this.c2d.push(s)\n        // Affichage de la partie reliée au pôle Sud\n        extremite1 = poleSud.c2d\n        extremite2 =\n          paralleles.listePoints3d[paralleles.listePoints3d.length - 1][k].c2d\n        s =\n          longueur(extremite1, extremite2) < 0.001\n            ? vide2d()\n            : segment(\n                poleSud.c2d,\n                paralleles.listePoints3d[paralleles.listePoints3d.length - 1][k]\n                  .c2d,\n                this.colorMeridiens,\n              )\n        if (\n          faceCachee &&\n          !paralleles.listePoints3d[paralleles.listePoints3d.length - 1][0]\n            .isVisible\n        ) {\n          s.pointilles = 4 // Laisser 4 car sinon les pointilles ne se voient dans les petits cercles\n          s.opacite = 0.5\n          this.c2d.push(s)\n        } else {\n          if (faceCachee) this.c2d.push(s)\n        }\n        extremite1 =\n          paralleles.listePoints3d[paralleles.listePoints3d.length - 1][k + 18]\n            .c2d\n        extremite2 = poleSud.c2d\n        s =\n          longueur(extremite1, extremite2) < 0.001\n            ? vide2d()\n            : segment(\n                paralleles.listePoints3d[paralleles.listePoints3d.length - 1][\n                  k + 18\n                ].c2d,\n                poleSud.c2d,\n                this.colorMeridiens,\n              )\n        if (\n          faceCachee &&\n          !paralleles.listePoints3d[paralleles.listePoints3d.length - 1][k]\n            .isVisible\n        ) {\n          s.pointilles = 4 // Laisser 4 car sinon les pointilles ne se voient dans les petits cercles\n          s.opacite = 0.5\n          this.c2d.push(s)\n        } else {\n          if (faceCachee) this.c2d.push(s)\n        }\n\n        const ligneVisible1 = polyline(...polyLineVisible1)\n        const ligneVisible2 = polyline(...polyLineVisible2)\n\n        if (faceCachee) {\n          const ligneCachee1 = polyline(...polyLineCachee1)\n          const ligneCachee2 = polyline(...polyLineCachee2)\n          ligneCachee1.pointilles = 4\n          ligneCachee1.opacite = 0.5\n          ligneCachee2.pointilles = 4\n          ligneCachee2.opacite = 0.5\n          this.c2d.push(ligneCachee1, ligneCachee2)\n        }\n        this.c2d.push(ligneVisible1, ligneVisible2)\n      }\n    }\n\n    // L'enveloppe finale contiendra les points de l'enveloppe 1 + les points de l'enveloppe 2 inversée (sinon le polygone serait croisé)\n    // A cela, il faut ajouter les points autour des pôles car les premiers parallèles ne s'intersectent pas forcément.\n    enveloppeSphere2 = enveloppeSphere2.reverse()\n    const enveloppeSphere = [...enveloppeSphere1]\n\n    // Pour trouver les points du cercle apparent près du pôle sud\n    // On va prendre les points du premier parallèle intersecté entre l'indice du premier point d'intersection et l'indice du dernier point d'intersection.\n    let ii = 1\n    while (\n      (indiceDernier + paralleles.listePoints3d[0].length / 2 + ii) %\n        paralleles.listePoints3d[0].length <\n      (indicePremier + paralleles.listePoints3d[0].length / 2) %\n        paralleles.listePoints3d[0].length\n    ) {\n      enveloppeSphere.push(\n        paralleles.listePoints3d[\n          2 * nbParallelesDeConstruction - 1 - premierParallele\n        ][\n          (indiceDernier + paralleles.listePoints3d[0].length / 2 + ii) %\n            paralleles.listePoints3d[0].length\n        ].c2d,\n      )\n      ii++\n    }\n    enveloppeSphere.push(...enveloppeSphere2)\n    // Pour trouver les points du cercle apparent près du pôle nord\n    // On va prendre les points du premier parallèle intersecté entre l'indice du premier point d'intersection et l'indice du dernier point d'intersection.\n    // La gestion des indices est plus compliquée car il arrive de repasser de 35 à 0 (36 modulo 36) d'où cette double gestion.\n    if (indiceDernier > indicePremier) {\n      ii = 1\n      while (\n        indiceDernier + ii <\n        indicePremier + paralleles.listePoints3d[0].length\n      ) {\n        enveloppeSphere.push(\n          paralleles.listePoints3d[premierParallele][\n            (indiceDernier + ii) % paralleles.listePoints3d[0].length\n          ].c2d,\n        )\n        ii++\n      }\n    } else {\n      ii = 1\n      while (indiceDernier + ii < indicePremier) {\n        enveloppeSphere.push(\n          paralleles.listePoints3d[premierParallele][indiceDernier + ii].c2d,\n        )\n        ii++\n      }\n    }\n    const p = polygone(enveloppeSphere, this.colorEnveloppe)\n    p.epaisseur = 1.5\n\n    this.c2d.push(p)\n\n    if (this.affichageAxe) {\n      const l = longueur(poleNord.c2d, poleSud.c2d)\n      let ee = 1\n      const poly = polygone(enveloppeSphere)\n      // poly.isVisible = false\n      while (\n        ee < 2 &&\n        estDansPolygone(\n          pointSurSegment(poleNord.c2d, poleSud.c2d, ee * l),\n          poly,\n        )\n      ) {\n        ee += 0.01\n      }\n      let extremite1 = pointSurSegment(\n        poleNord.c2d,\n        poleSud.c2d,\n        Math.max(ee - 0.01, 1) * l,\n      )\n      let extremite2 = poleNord.c2d\n      let s =\n        longueur(extremite1, extremite2) < 0.001\n          ? vide2d()\n          : segment(extremite2, extremite1, this.colorAxe)\n\n      s.pointilles = 2\n      this.c2d.push(s)\n      extremite1 = poleSud.c2d\n      extremite2 = pointSurSegment(poleNord.c2d, poleSud.c2d, 1.1 * l)\n      s =\n        longueur(extremite1, extremite2) < 0.001\n          ? vide2d()\n          : segment(extremite1, extremite2, this.colorAxe)\n\n      this.c2d.push(s)\n      extremite1 = poleNord.c2d\n      extremite2 = pointSurSegment(poleNord.c2d, poleSud.c2d, -0.1 * l)\n      s =\n        longueur(extremite1, extremite2) < 0.001\n          ? vide2d()\n          : segment(extremite1, extremite2, this.colorAxe)\n\n      this.c2d.push(s)\n    }\n    this.objets = this.c2d\n  }\n}\n/**\n * Crée une sphère\n * @param {Point3d} centre Centre de la sphère\n * @param {Vecteur3d} rayon Vecteur correspondant au rayon de la sphère\n * @param {string} [colorEquateur = 'red'] Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @param {string} [colorEnveloppe = 'blue'] Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbParalleles = 0]  Le nombre de parallèles au total\n * @param {string} [colorParalleles = 'gray'] Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbMeridiens = 0]  Le nombre de méridiens au total\n * @param {string} [colorMeridiens = 'gray'] Couleur des méridiens de la sphère : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe de la sphère.\n * @param {string} [colorAxe = 'black'] Couleur de l'axe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} inclinaison Angle d'inclinaison de l'axe N-S\n * @example sphere3d(A,v) // Crée une sphère de centre A et dont le rayon correspond au vecteur v, l'équateur rouge et l'enveloppe bleue\n * @example sphere3d(A,v,'green','pink') // Crée une sphère de centre A et dont le rayon correspond au vecteur v, l'équateur vert et l'enveloppe rose\n * @example sphere3d(A,v,'green','pink',18,'red') // Crée une sphère de centre A et dont le rayon correspond au vecteur v, l'équateur vert, l'enveloppe rose, avec 18 parallèles rouges\n * @example sphere3d(A,v,'green','pink',18,'red',36,'blue') // Crée une sphère de centre A et dont le rayon correspond au vecteur v, l'équateur vert, l'enveloppe rose, avec 18 parallèles rouges et 36 méridiens verts\n * @example sphere3d(A,v,'green','pink',18,'red',36,'blue',true,'#f15929') // Crée une sphère de centre A et dont le rayon correspond au vecteur v, l'équateur vert, l'enveloppe rose, avec 18 parallèles rouges, 36 méridiens verts et un axe affiché orange\n * @author Eric Elter (d'après version précédente de Jean-Claude Lhote)\n * @return {Sphere3d}\n */\nexport function sphere3d(\n  centre: Point3d,\n  rayon: Vecteur3d | number,\n  colorEquateur = 'red',\n  colorEnveloppe = 'blue',\n  nbParalleles = 0,\n  colorParalleles = 'gray',\n  nbMeridiens = 0,\n  colorMeridiens = 'black',\n  affichageAxe = false,\n  colorAxe = 'black',\n  inclinaison = 0,\n  faceCachee = true,\n) {\n  return new Sphere3d(\n    centre,\n    rayon,\n    colorEquateur,\n    colorEnveloppe,\n    nbParalleles,\n    colorParalleles,\n    nbMeridiens,\n    colorMeridiens,\n    affichageAxe,\n    colorAxe,\n    inclinaison,\n    faceCachee,\n  )\n}\n"],"names":["longueur","A","B","Sphere3d","ObjetMathalea2D","centre","rayon","colorEquateur","colorEnveloppe","nbParalleles","colorParalleles","nbMeridiens","colorMeridiens","affichageAxe","colorAxe","inclinaison","faceCachee","droiteRot","droite3d","point3d","vecteur3d","poleNord","rotation3d","choisitLettresDifferentes","poleSud","nbParallelesDeConstruction","divisionParalleles","unDesParalleles","centreParallele","rayonDuParallele","normal","paralleles","enveloppeSphere1","enveloppeSphere2","premierParallele","indicePremier","indiceDernier","cercle3d","pointAbstrait","k","poly","j","polygone","ee","estDansPolygone","s","s1","d1","d2","jj","pt","extremite1","extremite2","vide2d","segment","droite","cptBoucleInfinie","pointIntersectionDD","t","tracePoint","assombrirOuEclaircir","polyLineVisible","polyLineCachee","securite","dernierPoint","premierPoint","ligneCachee","polyline","colorToLatexOrHTML","ligneVisible","divisionMeridiens","polyLineCachee1","polyLineVisible1","polyLineCachee2","polyLineVisible2","ligneVisible1","ligneVisible2","ligneCachee1","ligneCachee2","enveloppeSphere","ii","p","l","pointSurSegment","sphere3d"],"mappings":"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"}