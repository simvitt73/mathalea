{"version":3,"file":"ExerciceQcm-Cgcpcs4G.js","sources":["../../src/exercices/ExerciceQcm.ts"],"sourcesContent":["/* eslint-disable no-template-curly-in-string */\nimport { qcmCamExport } from '../lib/amc/qcmCam'\nimport { createList } from '../lib/format/lists'\nimport { propositionsQcm } from '../lib/interactif/qcm'\nimport { texteEnCouleurEtGras } from '../lib/outils/embellissements'\nimport type { IExerciceQcm, IExerciceQcmOptions } from '../lib/types'\nimport { context } from '../modules/context'\nimport Exercice from './Exercice'\n\n// export const uuid = 'UUID à modifier'\n// export const titre = 'Titre de l'exercice à modifier'\n// export const refs = [{'fr-fr',['ref française à renseigner']},{'fr-ch', ['ref suisse à renseigner']}]\n\nexport const interactifReady = true\nexport const interactifType = 'qcm'\nexport const amcReady = 'true'\nexport const amcType = 'qcmMono'\n\nexport const nombreElementsDifferents = (liste: string[]) => {\n  const elements = new Set(liste)\n  return elements.size\n}\n\n// class à utiliser pour fabriquer des Qcms sans aléatoirisation (en cas d'aléatoirisation, on utilisera ExerciceQcmA à la place)\nexport default class ExerciceQcm extends Exercice implements IExerciceQcm {\n  versionQcm?: boolean\n  versionQcmDisponible = true\n\n  enonce!: string\n  reponses!: string[]\n  bonnesReponses?: boolean[]\n  corrections?: string[]\n  options: IExerciceQcmOptions\n  ajouteQcmCorr = false // Pour savoir si on ajoute le qcm corrigé à la fin de la correction.\n  versionAleatoire?: () => void\n  versionOriginale?: () => void = undefined\n  constructor() {\n    super()\n    this.besoinFormulaire2CaseACocher = ['Consigne augmentée', false]\n    this.sup2 = false\n    // Il n'est pas prévu d'avoir plus d'une question car ceci est prévu pour un seul énoncé statique à la base même si on pourra changer les valeurs et prévoir une aléatoirisation\n    this.nbQuestions = 1\n    this.nbQuestionsModifiable = false\n\n    this.spacingCorr = 2 // idem pour la correction\n    // Les options pour le qcm à modifier éventuellement (vertical à true pour les longues réponses par exemple)\n    this.options = { vertical: false, ordered: false, lastChoice: 8 }\n    this.enonce = ''\n    this.reponses = []\n    this.correction = ''\n  }\n\n  nouvelleVersion() {\n    if (this.sup2) {\n      this.consigne =\n        this.bonnesReponses == null\n          ? `Parmi les ${this.reponses.length} réponses ci-dessous, une seule est correcte.<br>\n${this.interactif || context.isAmc ? 'Cocher la case correspondante' : 'Donner la lettre correspondante'}${this.sup4 ? ', ou choisir « Je ne sais pas ».' : '.'}`\n          : `Parmi les ${this.reponses.length} réponses ci-dessous, il peut y avoir plusieurs bonnes réponses.<br>\n${this.interactif || context.isAmc ? 'Cocher la (ou les) case(s) correspondante(s)' : 'Donner la (ou les) lettre(s) correspondante(s)'}${this.sup4 ? ', ou choisir « Je ne sais pas ».' : '.'}`\n    } else {\n      this.consigne = ''\n    }\n    const statuts: boolean[] = []\n    if (this.bonnesReponses == null) {\n      statuts.fill(false, 0, this.reponses.length - 1)\n      statuts[0] = true\n    } else {\n      for (let k = 0; k < this.reponses.length; k++) {\n        statuts[k] = this.bonnesReponses[k] ?? false\n      }\n    }\n    if (this.versionAleatoire != null) {\n      for (let i = 0, cpt = 0; i < this.nbQuestions && cpt < 30; ) {\n        if (this.sup && this.versionOriginale != null) this.versionOriginale()\n        else this.versionAleatoire()\n\n        const bonneReponse = this.reponses[0]\n        if (this.questionJamaisPosee(i, bonneReponse)) {\n          let texte = this.enonce\n          this.autoCorrection[i] = {}\n          if (this.options != null) {\n            this.autoCorrection[i].options = { ...this.options }\n          }\n          const autoCorr = this.autoCorrection[i]\n          autoCorr.propositions = []\n          for (let j = 0; j < this.reponses.length; j++) {\n            autoCorr.propositions.push({\n              texte: this.reponses[j],\n              statut: statuts[j],\n            })\n          }\n          if (this.sup4) {\n            autoCorr.propositions.push({\n              texte: 'Je ne sais pas',\n              statut: false,\n            })\n            if (autoCorr.options) {\n              autoCorr.options.lastChoice = this.reponses.length - 1\n            }\n          }\n          const lettres = [\n            'A',\n            'B',\n            'C',\n            'D',\n            'E',\n            'F',\n            'G',\n            'H',\n            'I',\n            'J',\n          ].slice(0, this.reponses.length)\n          const monQcm = propositionsQcm(this, i, {\n            style: 'margin:0 3px 0 3px;',\n            format: this.interactif ? 'case' : 'lettre',\n          })\n          texte += `<br>${monQcm.texte}`\n          let messageBonnesReponses: string\n          if (this.corrections && autoCorr.propositions != null) {\n            this.correction = ''\n            const correctionsList: string[] = new Array(this.reponses.length)\n            const props = autoCorr.propositions\n            for (let n = 0; n < this.reponses.length; n++) {\n              const index = this.reponses.findIndex(\n                (el) => el === props[n].texte,\n              )\n              if (\n                this.corrections[index] != null &&\n                this.corrections[index] !== ''\n              ) {\n                correctionsList[n] =\n                  `réponse ${lettres[n]} : ${this.corrections[index]}${\n                    context.isHtml\n                      ? props[n].statut\n                        ? '\\u2705' // ✅\n                        : '\\u274C' // ❌\n                      : props[n].statut\n                        ? '${\\\\bf \\\\color[cmyk]{.63,.23,.93,.06}\\\\boldsymbol{\\\\checkmark}}$' // ✅\n                        : '${\\\\bf \\\\color[rgb]{1,.1,.1}\\\\boldsymbol{\\\\times}}$' // ❌\n                  }<br>`\n              }\n            }\n            const listeAffichable = correctionsList.filter(\n              (el) => el != null && el !== '',\n            )\n            if (listeAffichable.length !== 0) {\n              this.correction = createList({\n                items: listeAffichable,\n                style: 'fleches',\n              })\n            } else {\n              this.correction += this.correction.endsWith('\\\\end{tikzpicture}')\n                ? '\\n\\n'\n                : this.correction !== ''\n                  ? '<br>'\n                  : ''\n            }\n          } else {\n            this.correction += this.correction?.endsWith('\\\\end{tikzpicture}')\n              ? '\\n\\n'\n              : this.correction !== ''\n                ? '<br>'\n                : ''\n          }\n          if (this.ajouteQcmCorr) {\n            this.correction += `<br>${monQcm.texteCorr}`\n          }\n          if (this.bonnesReponses) {\n            const lesBonnesLettres = autoCorr.propositions\n              .map((el, i) => Object.assign({}, { prop: el, index: i }))\n              .filter((obj) => obj.prop.statut)\n              .map((obj) => lettres[obj.index])\n            messageBonnesReponses = `Les bonnes réponses sont les réponses ${texteEnCouleurEtGras(lesBonnesLettres.join(' ; '))}.`\n          } else {\n            const laBonneLettre =\n              lettres[autoCorr.propositions.findIndex((el) => el.statut)]\n            messageBonnesReponses = `La bonne réponse est la réponse ${texteEnCouleurEtGras(laBonneLettre)}.`\n          }\n          // Ici on colle le texte de la correction à partir du latex d'origine (vérifier la compatibilité Katex et doubler les \\)s\n          const texteCorr = `${this.correction}${this.interactif ? '' : messageBonnesReponses}`\n\n          this.listeQuestions[i] = texte\n          this.listeCorrections[i] = texteCorr\n          i++\n        }\n        cpt++\n        if (this.sup) break // Si on a coché pour la version originale, il n'y aura qu'une seule question\n      }\n    } else {\n      if (this.versionOriginale != null) this.versionOriginale()\n      let texte = this.enonce\n      this.autoCorrection[0] = {}\n      if (this.options != null) {\n        this.autoCorrection[0].options = { ...this.options }\n      }\n      const autoCorr = this.autoCorrection[0]\n      autoCorr.propositions = []\n      for (let j = 0; j < this.reponses.length; j++) {\n        autoCorr.propositions.push({\n          texte: this.reponses[j],\n          statut: statuts[j],\n        })\n      }\n      const lettres = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'].slice(\n        0,\n        this.reponses.length,\n      )\n      const monQcm = propositionsQcm(this, 0, {\n        style: 'margin:0 3px 0 3px;',\n        format: this.interactif ? 'case' : 'lettre',\n      })\n      texte += `<br>${monQcm.texte}`\n      if (this.ajouteQcmCorr) {\n        this.correction += `<br>${monQcm.texteCorr}`\n      }\n      const laBonneLettre =\n        lettres[autoCorr.propositions.findIndex((el) => el.statut)]\n      // Ici on colle le texte de la correction à partir du latex d'origine (vérifier la compatibilité Katex et doubler les \\)s\n      const texteCorr = `${this.correction}<br>${this.interactif ? '' : `La bonne réponse est la réponse ${texteEnCouleurEtGras(laBonneLettre)}.`}`\n\n      this.listeQuestions[0] = texte\n      this.listeCorrections[0] = texteCorr\n    }\n  }\n\n  // Pour permettre d'exporter tous les qcm pour en faire des séries de questions pour QcmCam. Ne pas y toucher\n  qcmCamExport(): { question: string; reponse: string }[] {\n    return qcmCamExport(this)\n  }\n}\n"],"names":["nombreElementsDifferents","liste","ExerciceQcm","Exercice","__publicField","context","statuts","k","i","cpt","bonneReponse","texte","autoCorr","j","lettres","monQcm","propositionsQcm","messageBonnesReponses","correctionsList","props","n","index","el","listeAffichable","createList","_a","lesBonnesLettres","obj","texteEnCouleurEtGras","laBonneLettre","texteCorr","qcmCamExport"],"mappings":"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"}