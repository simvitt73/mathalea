{"version":3,"file":"arbres-aL5R9411.js","sources":["../../src/modules/arbres.ts"],"sourcesContent":["import { point } from '../lib/2d/PointAbstrait'\nimport { segment } from '../lib/2d/segmentsVecteurs'\nimport { latex2d } from '../lib/2d/textes'\nimport { homothetie, translation } from '../lib/2d/transformations'\nimport { vecteur } from '../lib/2d/Vecteur'\nimport { vide2d } from '../lib/2d/Vide2d'\nimport { texNombre } from '../lib/outils/texNombre'\nimport type { NestedObjetMathalea2dArray } from '../types/2d'\nimport FractionEtendue from './FractionEtendue'\nimport { fraction } from './fractions'\n\nfunction isFraction(obj: any): obj is FractionEtendue {\n  return typeof obj === 'object' && obj instanceof FractionEtendue\n}\nexport function texProba(proba: number | FractionEtendue): string {\n  return isFraction(proba)\n    ? proba.simplifie().toLatex()\n    : fraction(proba, 1).toLatex()\n}\n\n/**\n * classe pour faire des arbres de probabilités\n * @author Jean-Claude Lhote\n * la classe Arbre permet de définir un arbre de probabilité.\n * à son sommet, il y a un Arbre dont la proba est 1 et qui a la propriété racine = true (c'est le seul)\n * Ses enfants sont eux-mêmes Arbre(s).\n * Une terminaison de l'arbre est un arbre qui a pour enfants []\n * Un Arbre possède un nom (de type string) qui l'identifie de façon unique (c'est important si on veut éviter des proba aléatoires)\n * chaque Arbre possède une proba. C'est la probabilité qu'on a d'atteindre cet arbre à partir de son parent.\n * exemple : const pins = new Arbre({nom: 'pins',proba: 1, rationnel: true, racine: true) définit la racine de l'arbre\n * pins.enfants[0] = new Arbre(nom: 'malade', proba: 0.3, rationnel: true)\n * pins.enfants[1] = new Arbre(nom: 'sain', rationnel: true, proba: 0.7)\n * Note : on peut aussi utiliser la méthode setFils()\n * par exemple, la dernière assertions peut être remplacée par\n * pins.setFils('sain', 0.7, true)\n */\nexport class Arbre {\n  nom: string\n  proba: FractionEtendue\n  enfants: Arbre[]\n  rationnel: boolean\n  visible: boolean\n  alter: string\n  racine: boolean\n  taille: number\n  pos: number\n\n  /**\n   * @param {object} parametres\n   * @param {string} [parametres.nom]\n   * @param {numberparametres.rationnel | FractionEtendue} [parametres.proba]\n   * @param {Arbre[]} [parametres.enfants]\n   * @param {boolean} [parametres.rationnel]\n   * @param {boolean} [parametres.visible]\n   * @param {string} [parametres.alter]\n   * @param {boolean} [parametres.racine]\n   */\n  constructor({\n    nom,\n    proba,\n    enfants,\n    rationnel,\n    visible,\n    alter,\n    racine,\n  }: {\n    nom?: string\n    proba?: number | FractionEtendue\n    enfants?: Arbre[]\n    rationnel?: boolean\n    visible?: boolean\n    alter?: string\n    racine?: boolean\n  }) {\n    this.racine = racine !== undefined ? Boolean(racine) : false\n    this.enfants = enfants !== undefined ? [...enfants] : []\n    this.nom = nom !== undefined ? String(nom) : ''\n    this.rationnel = rationnel !== undefined ? Boolean(rationnel) : true\n    this.proba =\n      proba !== undefined\n        ? isFraction(proba)\n          ? proba.simplifie()\n          : fraction(proba, 1)\n        : fraction(0, 1)\n    this.visible = visible !== undefined ? visible : true\n    this.alter = alter !== undefined ? String(alter) : ''\n    this.taille = 0\n    this.pos = 0\n  }\n\n  // questionnement : est-ce qu'on vérifie à chaque ajout que la somme des probabilités ne dépasse pas 1 ?\n  /**\n   * @param {String} nom Le nom de cet Arbre-fils\n   * @param {Number} proba La probabilité d'aller à ce fils depuis le père.\n   * @returns l'Arbre-fils créé\n   * Exemple : const sylvestre = pin.setFils('sylvestre', 0.8) un 'pin' a une probabilité de 0.8 d'être 'sylvestre'.\n   */\n  setFils(\n    nom: string,\n    proba: number | FractionEtendue,\n    rationnel: boolean,\n  ): Arbre {\n    const arbre = new Arbre({\n      nom,\n      proba,\n      rationnel: rationnel || this.rationnel,\n    })\n    this.enfants.push(arbre)\n    return arbre\n  }\n\n  /**\n   * Fonction récursive qui cherche dans la descendance complète un arbre nommé.\n   * @param {String} nom Le nom de l'Arbre recherché dans les fils\n   * @returns l'Arbre descendant portant ce nom.\n   * Exemple : const unArbre = pin.getFils('sylvestre')\n   */\n  getFils(nom: string): Arbre | null {\n    if (this.nom === nom) return this\n    for (const arbre of this.enfants) {\n      if (arbre.nom === nom) return arbre\n      const fils = arbre.getFils(nom)\n      if (fils) return fils\n    }\n    return null\n  }\n\n  // est-ce qu'on vérifie si la somme des probabilités ne dépasse pas 1 ?\n  /**\n   *\n   * @param {String} nom Le nom de l'Arbre recherché dans les fils\n   * @param {Number} proba La probabilité du fils pour le père.\n   * @param {boolean} rationnel true si la proba doit être mise sous la forme d'une fraction\n   * @returns l'Arbre-fils.\n   */\n  setFilsProba(\n    nom: string,\n    proba: number | FractionEtendue,\n    rationnel: boolean,\n  ) {\n    // si le fils nommé nom existe, on fixe sa proba (en gros, on la modifie)\n    let arbre = this.getFils(nom)\n    if (arbre) {\n      arbre.proba = isFraction(proba) ? proba : fraction(proba, 1)\n    } else {\n      // sinon on ajoute ce fils.\n      arbre = new Arbre({ nom, proba, rationnel: rationnel || this.rationnel })\n      this.enfants.push(arbre)\n    }\n    return arbre\n  }\n\n  /**\n   * fonction récursive pour calculer la probabilité d'atteindre un enfant à partir de l'arbre courant.\n   * exemple : pin.getProba('malade', true)\n   * @param {String} nom Le nom d'un descendant ou pas\n   * @param {boolean} rationnel si true alors on retourne une fraction\n   * @returns Probabilité conditionnelle ou pas d'atteindre l'arbre nommé à partir du père.\n   * Exemple : si pin.getFilsProba('sylvestre')===0.8 et si sylvestre.getFilsProba('malade')===0.5\n   * alors pin.getProba('malade')===0.4 et sylvestre.getProba('malade')===0.4 aussi ! par contre\n   * sylvestre.getProba('malade', 1)= 0.5\n   */\n  getProba(nom: string) {\n    let p = fraction(0, 1)\n    let probaArbre = fraction(0, 1)\n    let getPro\n    if (this.nom === nom)\n      return isFraction(this.proba)\n        ? this.proba.simplifie()\n        : fraction(this.proba * 100, 100)\n    else {\n      for (const arbre of this.enfants) {\n        if (arbre.nom === nom) {\n          const term2 = arbre.proba\n          p = p.sommeFraction(term2)\n        } else {\n          getPro = arbre.getProba(nom)\n          const term1 = isFraction(probaArbre)\n            ? probaArbre\n            : fraction(probaArbre, 1)\n          const facteur1 = isFraction(arbre.proba)\n            ? arbre.proba\n            : fraction(arbre.proba, 1)\n          const facteur2 = isFraction(getPro) ? getPro : fraction(getPro, 1)\n          probaArbre = term1.sommeFraction(facteur1.produitFraction(facteur2))\n        }\n      }\n      p = p.sommeFraction(\n        isFraction(probaArbre) ? probaArbre : fraction(probaArbre, 1),\n      )\n    }\n    return isFraction(p) ? p.simplifie() : fraction(p, 1)\n  }\n\n  // méthode pour compter les descendants de l'arbre (le nombre de feuilles terminales).\n  branches() {\n    let nbBranches = 0\n    if (this.enfants.length === 0) return 1\n    else {\n      for (const enfant of this.enfants) {\n        nbBranches += enfant.branches()\n      }\n    }\n    return nbBranches\n  }\n\n  // Methode à appeler avant de représenter l'arbre car elle va récursivement définir toutes les tailles...\n  setTailles() {\n    try {\n      this.taille = this.branches()\n      for (const arbre of this.enfants) {\n        arbre.setTailles()\n      }\n    } catch (error) {\n      console.error(error)\n      return false\n    }\n    return true\n  }\n\n  /**\n   * @param {number} xOrigine\n   * @param {number} yOrigine\n   * @param {number} decalage\n   * @param {number} echelle\n   * @param {boolean} vertical true : vertical, false : horizontal\n   * @param {number} sens -1 ou 1 définit le sens de l'arbre gauche/droite ou haut/bas\n   * @param {number} tailleCaracteres définit la taille pour ce qui est écrit.\n   * xOrigine et yOrigine définissent le point de référence de l'arbre... c'est un angle du cadre dans lequel l'arbre est construit par la position de la racine\n   * decalage vaut 0 lors de l'appel initial... cette valeur est modifiée pendant le parcours de l'arbre.\n   * echelle est à fixé à 3 si on utilise des fractions et peut être déscendu à 2 si on utilise des nombres décimaux... echelle peut être décimal.\n   * vertical est un booléen. Si true, alors l'arbre sera construit de bas en haut ou de haut en bas, sinon, il sera construit de gauche à droite ou de droite à gauche.\n   * sens indique la direction de pousse : 1 positif, -1 négatif.\n   */\n  represente(\n    xOrigine = 0,\n    yOrigine = 0,\n    decalage = 0,\n    echelle = 1,\n    vertical = false,\n    sens = -1,\n    tailleCaracteres: number,\n  ): NestedObjetMathalea2dArray {\n    tailleCaracteres = tailleCaracteres || 5\n    const objets = []\n    const A = point(\n      vertical ? xOrigine : xOrigine + decalage + (this.taille * echelle) / 2,\n      vertical ? yOrigine + decalage - (this.taille * echelle) / 2 : yOrigine,\n      '',\n      'center',\n    )\n    const B = point(\n      vertical ? xOrigine - sens * 5 : xOrigine,\n      vertical ? yOrigine : yOrigine - sens * 5,\n    )\n\n    const labelA = latex2d(\n      this.nom,\n      A.x + (vertical ? 0.1 * sens : 0),\n      A.y + (vertical ? 0 : 0.5 * sens),\n      {\n        color: 'black',\n        letterSize: 'normalsize',\n        backgroundColor: 'white',\n        opacity: 0.8,\n      },\n    )\n\n    const positionProba = vertical\n      ? homothetie(A, B, 0.5)\n      : translation(homothetie(A, B, 0.5), vecteur(A.x > B.x ? 0.5 : -0.5, 0)) // Proba au 2/5 de [AB] en partant de A.\n    const probaA = this.visible\n      ? latex2d(\n          this.rationnel\n            ? texProba(this.proba)\n            : texNombre(this.proba.valueOf(), 4),\n          positionProba.x,\n          positionProba.y,\n          {\n            color: 'black',\n            letterSize: 'scriptsize',\n            backgroundColor: 'white',\n            opacity: 0.7,\n          },\n        )\n      : this.alter\n        ? latex2d(this.alter, positionProba.x, positionProba.y, {\n            color: 'black',\n            letterSize: 'scriptsize',\n            backgroundColor: 'white',\n            opacity: 0.7,\n          })\n        : vide2d()\n\n    if (this.enfants.length === 0) {\n      return [segment(B, A), labelA, probaA]\n    } else {\n      for (let i = 0; i < this.enfants.length; i++) {\n        objets.push(\n          ...this.enfants[i].represente(\n            vertical\n              ? xOrigine + sens * 5\n              : xOrigine + decalage + (this.taille * echelle) / 2,\n            vertical\n              ? yOrigine + decalage - (this.taille * echelle) / 2\n              : yOrigine + sens * 5,\n            vertical\n              ? echelle *\n                  ((this.enfants.length / 2 - i) * this.enfants[i].taille)\n              : echelle *\n                  ((i - this.enfants.length / 2) * this.enfants[i].taille),\n            echelle,\n            vertical,\n            sens,\n            tailleCaracteres,\n          ),\n        )\n      }\n      if (this.racine) {\n        objets.push(labelA)\n      } else {\n        objets.push(segment(B, A), labelA, probaA)\n      }\n    }\n    return objets\n  }\n}\n"],"names":["isFraction","obj","FractionEtendue","texProba","proba","fraction","Arbre","nom","enfants","rationnel","visible","alter","racine","__publicField","arbre","fils","p","probaArbre","getPro","term2","term1","facteur1","facteur2","nbBranches","enfant","error","xOrigine","yOrigine","decalage","echelle","vertical","sens","tailleCaracteres","objets","A","point","B","labelA","latex2d","positionProba","homothetie","translation","vecteur","probaA","texNombre","vide2d","segment","i"],"mappings":"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"}