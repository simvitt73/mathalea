import{E,F as v,Y as w,$ as P,r as g,x as F,o as k}from"./index-CMKaCP9B.js";import{P as D}from"./PolynomePlusieursVariables-DzpitrWU.js";import{E as b}from"./EquationSecondDegre-CyodgO0i.js";/* empty css                         */import"./vendors/svelte-BrkG1v2Q.js";import"./vendors/clsx-B-dksMZM.js";import"./vendors/esm-env-rsSWfq8L.js";import"./vendors/ua-parser-js-D4W63oil.js";import"./vendors/three-q_6hD11P.js";import"./vendors/decimal.js-BceHFVC1.js";import"./vendors/katex-BISJkeK-.js";import"./vendors/seedrandom-Cz-2rAdY.js";import"./vendors/apigeom-CvUqzk7F.js";import"./vendors/mathjs-DKCMnljp.js";import"./vendors/babel_runtime-BFeZ_VDU.js";import"./vendors/javascript-natural-sort-QZS4Fyws.js";import"./vendors/escape-latex-BegatI0j.js";import"./vendors/complex.js-C1JbXRlX.js";import"./vendors/typed-function-CVM02vEe.js";import"./vendors/fraction.js-CYLvagDM.js";import"./vendors/tiny-emitter-DbO2P2s3.js";import"./vendors/xstate-BSXD3zxA.js";import"./vendors/crypto-js-DElKCTCw.js";import"./json/referentielStaticCH-DrWiqhRe.js";import"./json/referentielStaticFR-DTeSOhOd.js";import"./json/uuidsToUrlFR-Cc7zu7XX.js";import"./vendors/cortex-js_compute-engine-Bo_2zfG3.js";import"./vendors/jspreadsheet-ce-kKqtlqR-.js";import"./vendors/jsuites-D-TmSgJs.js";import"./vendors/jspreadsheet_formula-CXu1m5Ak.js";import"./vendors/mathlive-2YgxEGya.js";import"./vendors/bugsnag_js-B7oJ4uO9.js";import"./vendors/bugsnag_browser-CBi0d3dm.js";import"./vendors/big-integer-RrBdqg8C.js";import"./vendors/mixer_postmessage-rpc-JyZjM7pP.js";import"./vendors/eventemitter3-COjgItKg.js";import"./vendors/scratchblocks-BVPCj2Ee.js";import"./json/scratchFr-BNITwCy2.js";import"./json/refToUuidFR-qEtoRB--.js";import"./json/refToUuidCH-DNJKehD0.js";import"./json/codeToLevelList-BfkorBF2.js";import"./json/codeToThemeList-B4uzTsqe.js";import"./vendors/loadjs-Dy50zFDn.js";import"./json/referentielProfs-BdpwqI3j.js";import"./json/uuidsRessources-jdCgFfXb.js";import"./json/referentielBibliotheque-sQm1j5fm.js";import"./vendors/file-saver-Cqu1O8xU.js";import"./vendors/jszip-BuNf6wCF.js";import"./vendors/jszip-utils-DhFX1KUq.js";import"./vendors/copy-image-clipboard-Cf9y-QAU.js";import"./vendors/qrcode-BsrOgw3n.js";import"./vendors/dijkstrajs-COg3n3zL.js";import"./vendors/brace-DEOAbY2S.js";import"./json/referentielAppsTierce-SxU58PZT.js";import"./vendors/sortablejs-DdTU3J9A.js";import"./json/carouselContent-Bjt6Yxr-.js";import"./json/levelsThemesList-CXNnIZKX.js";import"./json/levelsThemesListCH-BErSids0.js";import"./json/referentiel2022CH-hGgYBJeX.js";import"./json/referentiel2022FR-DRcEqmJS.js";import"./json/referentielGeometrieDynamique-BJ2PHXsv.js";import"./json/referentielRessources-BU2QQoSD.js";import"./json/referentielsActivation-CpD_hoec.js";import"./MonomePlusieursVariables-Cy7cMp1x.js";const _e="Déterminer le domaine de définition d'une fonction inverse ou racine",Ue=!1,Be="mathLive",Ne="14/03/2025",Ye="6ea62",Ge={"fr-fr":[],"fr-ch":["1mF1-12"]};class He extends E{constructor(){super(),this.consigne="",this.nbQuestions=1,this.besoinFormulaireNumerique=["Type de questions",8,`1 : 1/q(x)
2 : p(x)/q(x)
3 : √p(x)
4 : √p(x)/q(x)
5 : p(x)/√q(x)
6 : √p(x)/√q(x)
7 : √p(x)+√q(x)
8 : Mélange`],this.besoinFormulaire2Numerique=["Degrés des polynômes",3,`1 : 1er degré
2 : 2e degré
3 : Mélange`],this.sup2=3,this.sup=1}solutionEq(s){if(s.monomes.length===1)return new v(0,1);{const l=s.monomes.find(e=>e.degre===0),i=s.monomes.find(e=>e.degre===1);return l.coefficient.oppose().diviseFraction(i.coefficient).simplifie()}}computeDomainePolynome(s,l,i){var e,n,t,m,c,h;if(s==="sqrt"){if(i.length===1)return((e=l.monomes.find(f=>f.degre===1))==null?void 0:e.coefficient.signe)===1?[["f",i[0].texFractionSimplifiee,"o","+infty"]]:[["o","-infty","f",i[0].texFractionSimplifiee]];if(i.length===2){if(((n=l.monomes.find(f=>f.degre===2))==null?void 0:n.coefficient.signe)===1)return[["o","-infty","f",i[0].texFractionSimplifiee],["f",i[1].texFractionSimplifiee,"o","+infty"]];if(((t=l.monomes.find(f=>f.degre===2))==null?void 0:t.coefficient.signe)===-1)return[["f",i[0].texFractionSimplifiee,"f",i[1].texFractionSimplifiee]]}}else if(s==="invSqrt"){if(i.length===1)return((m=l.monomes.find(f=>f.degre===1))==null?void 0:m.coefficient.signe)===1?[["o",i[0].texFractionSimplifiee,"o","+infty"]]:[["o","-infty","o",i[0].texFractionSimplifiee]];if(i.length===2){if(((c=l.monomes.find(f=>f.degre===2))==null?void 0:c.coefficient.signe)===1)return[["o","-infty","o",i[0].texFractionSimplifiee],["o",i[1].texFractionSimplifiee,"o","+infty"]];if(((h=l.monomes.find(f=>f.degre===2))==null?void 0:h.coefficient.signe)===-1)return[["o",i[0].texFractionSimplifiee,"o",i[1].texFractionSimplifiee]]}}else if(s==="inverse"){if(i.length===1)return[["R",i[0].texFractionSimplifiee]];if(i.length===2)return[["R",i[0].texFractionSimplifiee,i[1].texFractionSimplifiee]]}return[[""]]}parseEndpoint(s){if(s==="+infty")return 1/0;if(s==="-infty")return-1/0;const l=/\\dfrac\{([^}]+)\}\{([^}]+)\}/,i=s.match(l);if(i){const e=parseFloat(i[1].replace(",",".")),n=parseFloat(i[2].replace(",","."));return s.match(/-/)?-e/n:e/n}return parseFloat(s)}intersectTwoIntervals(s,l){if(s[0]==="R"&&l[0]==="R"){const x=Array.from(new Set([...s.slice(1),...l.slice(1)]));return x.sort((d,q)=>this.parseEndpoint(d)-this.parseEndpoint(q)),[["R",...x]]}if(s[0]==="R"&&l[0]!=="R")return this.intersectSqrtAndR(l,s);if(l[0]==="R"&&s[0]!=="R")return this.intersectSqrtAndR(s,l);const i=this.parseEndpoint(s[1]),e=this.parseEndpoint(s[3]),n=this.parseEndpoint(l[1]),t=this.parseEndpoint(l[3]);let m,c;i>n?(m=s[1],c=s[0]):n>i?(m=l[1],c=l[0]):(m=s[1],c=s[0]==="o"||l[0]==="o"?"o":"f");let h,f;e<t?(h=s[3],f=s[2]):t<e?(h=l[3],f=l[2]):(h=s[3],f=s[2]==="o"||l[2]==="o"?"o":"f");const o=this.parseEndpoint(m),r=this.parseEndpoint(h);return o>r||o===r&&(c==="o"||f==="o")?[]:[[c,m,f,h]]}intersectSqrtAndR(s,l){const i=l.slice(1);let e=[s];return i.forEach(n=>{const t=this.parseEndpoint(n),m=[];e.forEach(c=>{const h=this.parseEndpoint(c[1]),f=this.parseEndpoint(c[3]);if(t<=h||t>=f)m.push(c);else{const o=[c[0],c[1],"o",n],r=["o",n,c[2],c[3]];this.parseEndpoint(o[1])<this.parseEndpoint(o[3])&&m.push(o),this.parseEndpoint(r[1])<this.parseEndpoint(r[3])&&m.push(r)}}),e=m}),e}reduceUnionSqrt(s){const l=s.map(e=>({left:this.parseEndpoint(e[1]),right:this.parseEndpoint(e[3]),leftMarker:e[0],rightMarker:e[2],leftStr:e[1],rightStr:e[3]}));l.sort((e,n)=>e.left!==n.left?e.left-n.left:e.leftMarker===n.leftMarker?0:e.leftMarker==="f"?-1:1);const i=[];for(const e of l)if(i.length===0)i.push({...e});else{const n=i[i.length-1];e.left<n.right||e.left===n.right&&(n.rightMarker==="f"||e.leftMarker==="f")?e.right>n.right?(n.right=e.right,n.rightMarker=e.rightMarker,n.rightStr=e.rightStr):e.right===n.right&&n.rightMarker==="o"&&e.rightMarker==="f"&&(n.rightMarker="f"):i.push({...e})}return i.length===1&&i[0].left===-1/0&&i[0].right===1/0?[["R"]]:i.length===0?[[]]:i.map(e=>[e.leftMarker,e.leftStr,e.rightMarker,e.rightStr])}intersectDomains(s,l){let i=[];return s.forEach(n=>{l.forEach(t=>{const m=this.intersectTwoIntervals(n,t);i.push(...m)})}),i.every(n=>n.length===4&&n[0]!=="R")&&(i=this.reduceUnionSqrt(i)),i}convertDomainToLatex(s){function l(e){return e==="+infty"?"+\\infty":e==="-infty"?"-\\infty":e}const i=[];for(const e of s)if(e.length===0)i.push("\\emptyset");else if(e[0]==="R"){const n=e.slice(1).map(l).join("\\,;\\,");i.push(`\\mathbb{R}\\setminus\\left\\{${n}\\right\\}`)}else if(e.length===4){const[n,t,m,c]=e,h=n==="f"?"\\left[":"\\left]",f=m==="f"?"\\right]":"\\right[",o=l(t),r=l(c);i.push(`${h}${o}\\,;\\,${r}${f}`)}else i.push(e.join("\\,;\\,"));return i.join(" \\cup ")}nouvelleVersion(){this.listeQuestions=[],this.listeCorrections=[],this.autoCorrection=[];const s=w({saisie:this.sup,min:1,max:7,melange:8,defaut:1,listeOfCase:["1/q","p/q","racineP","racineP/q","p/racineQ","racineP/racineQ","racineP+racineQ"],nbQuestions:this.nbQuestions,shuffle:!0}),l=P(s,this.nbQuestions);for(let i=0,e=0;i<this.nbQuestions&&e<50;){let n="",t="";n="Déterminer le domaine de définition de la fonction $f$ définie par $f(x) = ";let m,c,h,f,o="",r="",x,d,q,S;if(this.sup2===3?(q=g(1,2),S=g(1,2)):this.sup2===2?(q=2,S=2):(q=1,S=1),q===2&&S===2){do{const $=new v(g(-10,10,[0]),g(-10,10,[0])).simplifie(),a=new v(g(-10,10,[0]),g(-10,10,[0])).simplifie(),u=new v(g(-10,10,[0]),g(-10,10,[0])).simplifie(),y=new v(g(-10,10,[0]),g(-10,10,[0])).simplifie();h=b.aPartirDesSolutions($,a,new v($.den*a.den,1),{variable:"x",format:"reduit"}),f=b.aPartirDesSolutions(u,y,new v(u.den*y.den,1),{variable:"x",format:"reduit"})}while(h.equationTex===f.equationTex&&h.delta.signe!==1&&f.delta.signe!==1);m=h.polynomeFormeReduite(),c=f.polynomeFormeReduite(),x=h.solutionFrac(),d=f.solutionFrac()}else if(q===1&&S===2){do{const $=new v(g(-10,10,[0]),g(-10,10,[0])).simplifie(),a=new v(g(-10,10,[0]),g(-10,10,[0])).simplifie();h=b.aPartirDesSolutions($,a,new v($.den*a.den,1),{variable:"x",format:"reduit"})}while(h.delta.signe!==1);m=h.polynomeFormeReduite(),x=h.solutionFrac(),c=D.createRandomPolynome(1,1,2,"entier",["x"]),d=[this.solutionEq(c)]}else if(q===2&&S===1){do{const $=new v(g(-10,10,[0]),g(-10,10,[0])).simplifie(),a=new v(g(-10,10,[0]),g(-10,10,[0])).simplifie();f=b.aPartirDesSolutions($,a,new v($.den*a.den,1),{variable:"x",format:"reduit"})}while(f.delta.signe!==1);c=f.polynomeFormeReduite(),d=f.solutionFrac(),m=D.createRandomPolynome(1,1,2,"entier",["x"]),x=[this.solutionEq(m)]}else m=D.createRandomPolynome(1,1,2,"entier",["x"]),c=D.createRandomPolynome(1,1,2,"entier",["x"]),x=[this.solutionEq(m)],d=[this.solutionEq(c)];r=m.toString(),o=c.toString();const p=m.ordonner().monomes[0].coefficient,L=c.ordonner().monomes[0].coefficient;switch(l[i]){case"1/q":{const $=this.convertDomainToLatex(this.computeDomainePolynome("inverse",c,d));n+=`\\dfrac{1}{${o}}$`,t+=`La condition sur le domaine de définition est la suivante \\[${o}\\neq 0,\\] car le dénominateur d'une fraction ne peut pas valoir $0$. `,S===2?t+=`On détermine les valeurs qui annulent $${o}$. On obtient que ces valeurs sont $\\left\\{${d.map(a=>a.texFractionSimplifiee).join(",")}\\right\\}.$ `:t+=`La valeur qui annule $${o}$ est $${d.map(a=>a.texFractionSimplifiee).join(",")}.$ `,t+=`Ainsi, le domaine de définition est donné par
          \\[D_f=${F($)}\\]`}break;case"p/q":{const $=this.convertDomainToLatex(this.computeDomainePolynome("inverse",c,d));n+=`\\dfrac{${r}}{${o}}$`,t+=`La condition sur le domaine de définition est la suivante \\[${o}\\neq 0,\\] car le dénominateur d'une fraction ne peut pas valoir $0$. <br> Le numérateur n'influence pas le domaine de définition dans ce cas.`,S===2?t+=`On détermine les valeurs qui annulent $${o}$. On obtient que ces valeurs sont $\\left\\{${d.map(a=>a.texFractionSimplifiee).join(",")}\\right\\}.$ `:t+=`La valeur qui annule $${o}$ est $${d.map(a=>a.texFractionSimplifiee).join(",")}.$ `,t+=`Ainsi, le domaine de définition est donné par
          \\[D_f=${F($)}\\]`}break;case"racineP":{n+=`\\sqrt{${r}}$`;const $=this.convertDomainToLatex(this.computeDomainePolynome("sqrt",m,x));t+=`La condition sur le domaine de définition est la suivante : \\[${r}\\geq 0,\\] car la racine est définie sur les nombres positifs.
          <br>`,q===2?t+=`On détermine les valeurs qui annulent $${r}$. On obtient que ces valeurs sont $\\left\\{${x.map(a=>a.texFractionSimplifiee).join(",")}\\right\\}.$ Le coefficient dominant de $${r}$ est $${p.texFractionSimplifiee}${p.signe===1?">0":"<0"}$, donc la parabole associée est ${p.signe===1?"convexe":"concave"}. `:t+=`Le zéro de $${r}$ est $${x.map(a=>a.texFractionSimplifiee).join(",")}.$ La pente de $${r}$ est $${p.texFractionSimplifiee}${p.signe===1?">0":"<0"}$, donc la droite associée est ${p.signe===1?"croissante":"décroissante"}. `,t+=`Ainsi, $${r}$ est positif sur l'intervalle sur l'intervalle $${$}$, c'est également l'intervalle qui vérifie la première condition.<br> Le domaine de définition de $f$ correspond à l'intervalle déterminé '
          \\[D_f=${F($)}\\]`}break;case"racineP/q":{n+=`\\dfrac{\\sqrt{${r}}}{${o}}$`;const $=this.convertDomainToLatex(this.computeDomainePolynome("sqrt",m,x)),a=this.convertDomainToLatex(this.computeDomainePolynome("inverse",c,d));t+=`Les conditions sur le domaine de définition sont les suivantes : \\[\\text{Première condition : }${r}\\geq 0,\\] car la racine est définie sur les nombres positifs. \\[\\text{Deuxième condition : }${o}\\neq 0,\\] car le dénominateur ne peut pas valoir $0$.
          <br>`,q===2?t+=`On détermine les valeurs qui annulent $${r}$. On obtient que ces valeurs sont $\\left\\{${x.map(u=>u.texFractionSimplifiee).join(",")}\\right\\}.$ Le coefficient dominant de $${r}$ est $${p.texFractionSimplifiee}${p.signe===1?">0":"<0"}$, donc la parabole associée est ${p.signe===1?"convexe":"concave"}. `:t+=`Le zéro de $${r}$ est $${x.map(u=>u.texFractionSimplifiee).join(",")}.$ La pente de $${r}$ est $${p.texFractionSimplifiee}${p.signe===1?">0":"<0"}$, donc la droite associée est ${p.signe===1?"croissante":"décroissante"}. `,t+=`Ainsi, $${r}$ est positif sur l'intervalle sur l'intervalle $${$}$, c'est également l'intervalle qui vérifie la première condition.<br> On s'occupe à présent de la deuxième condition.   `,S===2?t+=`On détermine les valeurs qui annulent $${o}$. On obtient que ces valeurs sont $\\left\\{${d.map(u=>u.texFractionSimplifiee).join(",")}\\right\\}.$ `:t+=`Le zéro de $${o}$ est $${d.map(u=>u.texFractionSimplifiee).join(",")}.$ `,t+=`Ainsi, $${o}$ est différent de zéro sur l'intervalle $${a}$, c'est également l'intervalle qui vérifie la deuxième condition.<br> Le domaine de définition de $f$ correspond à l'intersection des deux intervalles 
          \\[D_f=${$.match("cup")?"\\left (\\,":""}${$}${$.match("cup")?"\\,\\right )":""}\\cap ${a.match("cup")?"\\left (\\,":""}${a}${a.match("cup")?"\\,\\right )":""}=${F(this.convertDomainToLatex(this.intersectDomains(this.computeDomainePolynome("inverse",c,d),this.computeDomainePolynome("sqrt",m,x))))}\\]`}break;case"p/racineQ":{n+=`\\dfrac{${r}}{\\sqrt{${o}}}$`;const $=this.convertDomainToLatex(this.computeDomainePolynome("invSqrt",c,d));t+=`La condition sur le domaine de définition est la suivante\\[${o}> 0,\\] car la racine est définie sur les nombres positifs et le dénominateur ne peut pas valoir $0$. Le numérateur n'influence pas le domaine de définition dans ce cas.
          <br>`,S===2?t+=`On détermine les valeurs qui annulent $${o}$. On obtient que ces valeurs sont $\\left\\{${d.map(a=>a.texFractionSimplifiee).join(",")}\\right\\}.$ Le coefficient dominant de $${o}$ est $${L.texFractionSimplifiee}${p.signe===1?">0":"<0"}$, donc la parabole associée est ${L.signe===1?"convexe":"concave"}. `:t+=`Le zéro de $${o}$ est $${d.map(a=>a.texFractionSimplifiee).join(",")}.$ La pente de $${o}$ est $${L.texFractionSimplifiee}${p.signe===1?">0":"<0"}$, donc la droite associée est ${L.signe===1?"croissante":"décroissante"}. `,t+=`Ainsi, $${o}$ est strictement positif sur l'intervalle $${$}$, c'est également l'intervalle qui vérifie la deuxième condition.<br> Le domaine de définition de $f$ est donc
          \\[D_f=${F($)}\\]`}break;case"racineP/racineQ":{const $=this.convertDomainToLatex(this.computeDomainePolynome("sqrt",m,x)),a=this.convertDomainToLatex(this.computeDomainePolynome("invSqrt",c,d));n+=`\\dfrac{\\sqrt{${r}}}{\\sqrt{${o}}}$`,t+=`Les conditions sur le domaine de définition sont les suivantes : \\[\\text{Première condition : }${r}\\geq 0,\\] car la racine est définie sur les nombres positifs. \\[\\text{Deuxième condition : }${o}> 0,\\] car la racine est définie sur les nombres positifs et le dénominateur ne peut pas valoir $0$.
          <br>`,q===2?t+=`On détermine les valeurs qui annulent $${r}$. On obtient que ces valeurs sont $\\left\\{${x.map(u=>u.texFractionSimplifiee).join(",")}\\right\\}.$ Le coefficient dominant de $${r}$ est $${p.texFractionSimplifiee}${p.signe===1?">0":"<0"}$, donc la parabole associée est ${p.signe===1?"convexe":"concave"}. `:t+=`Le zéro de $${r}$ est $${x.map(u=>u.texFractionSimplifiee).join(",")}.$ La pente de $${r}$ est $${p.texFractionSimplifiee}${p.signe===1?">0":"<0"}$, donc la droite associée est ${p.signe===1?"croissante":"décroissante"}. `,t+=`Ainsi, $${r}$ est positif sur l'intervalle sur l'intervalle $${$}$, c'est également l'intervalle qui vérifie la première condition.<br> On fait de même avec $${o}$.   `,S===2?t+=`On détermine les valeurs qui annulent $${o}$. On obtient que ces valeurs sont $\\left\\{${d.map(u=>u.texFractionSimplifiee).join(",")}\\right\\}.$ Le coefficient dominant de $${o}$ est $${L.texFractionSimplifiee}${p.signe===1?">0":"<0"}$, donc la parabole associée est ${L.signe===1?"convexe":"concave"}. `:t+=`Le zéro de $${o}$ est $${d.map(u=>u.texFractionSimplifiee).join(",")}.$ La pente de $${o}$ est $${L.texFractionSimplifiee}${p.signe===1?">0":"<0"}$, donc la droite associée est ${L.signe===1?"croissante":"décroissante"}. `,t+=`Ainsi, $${o}$ est strictement positif sur l'intervalle $${a}$, c'est également l'intervalle qui vérifie la deuxième condition.<br> Le domaine de définition de $f$ correspond à l'intersection des deux intervalles 
          \\[D_f=${$.match("cup")?"\\left (\\,":""}${$}${$.match("cup")?"\\,\\right )":""}\\cap ${a.match("cup")?"\\left (\\,":""}${a}${a.match("cup")?"\\,\\right )":""}=${F(this.convertDomainToLatex(this.intersectDomains(this.computeDomainePolynome("invSqrt",c,d),this.computeDomainePolynome("sqrt",m,x))))}\\]`}break;case"racineP+racineQ":{n+=`\\sqrt{${r}}+\\sqrt{${o}}$`;const $=this.convertDomainToLatex(this.computeDomainePolynome("sqrt",m,x)),a=this.convertDomainToLatex(this.computeDomainePolynome("sqrt",c,d));t+=`Les conditions sur le domaine de définition sont les suivantes : \\[\\text{Première condition : }${r}\\geq 0\\] \\[\\text{Deuxième condition : }${o}\\geq 0,\\] car la racine est définie sur les nombres positifs.
          <br>`,q===2?t+=`On détermine les valeurs qui annulent $${r}$. On obtient que ces valeurs sont $\\left\\{${x.map(u=>u.texFractionSimplifiee).join(",")}\\right\\}.$ Le coefficient dominant de $${r}$ est $${p.texFractionSimplifiee}${p.signe===1?">0":"<0"}$, donc la parabole associée est ${p.signe===1?"convexe":"concave"}. `:t+=`Le zéro de $${r}$ est $${x.map(u=>u.texFractionSimplifiee).join(",")}.$ La pente de $${r}$ est $${p.texFractionSimplifiee}${p.signe===1?">0":"<0"}$, donc la droite associée est ${p.signe===1?"croissante":"décroissante"}. `,t+=`Ainsi, $${r}$ est positif sur l'intervalle sur l'intervalle $${$}$, c'est également l'intervalle qui vérifie la première condition.<br> On fait de même avec $${o}$.   `,S===2?t+=`On détermine les valeurs qui annulent $${o}$. On obtient que ces valeurs sont $\\left\\{${d.map(u=>u.texFractionSimplifiee).join(",")}\\right\\}.$ Le coefficient dominant de $${o}$ est $${L.texFractionSimplifiee}${p.signe===1?">0":"<0"}$, donc la parabole associée est ${L.signe===1?"convexe":"concave"}. `:t+=`Le zéro de $${o}$ est $${d.map(u=>u.texFractionSimplifiee).join(",")}.$ La pente de $${o}$ est $${L.texFractionSimplifiee}${p.signe===1?">0":"<0"}$, donc la droite associée est ${L.signe===1?"croissante":"décroissante"}. `,t+=`Ainsi, $${o}$ est positif sur l'intervalle $${a}$, c'est également l'intervalle qui vérifie la deuxième condition.<br> Le domaine de définition de $f$ correspond à l'intersection des deux intervalles 
          \\[D_f=${$.match("cup")?"\\left (\\,":""}${$}${$.match("cup")?"\\,\\right )":""}\\cap ${a.match("cup")?"\\left (\\,":""}${a}${a.match("cup")?"\\,\\right )":""}=${F(this.convertDomainToLatex(this.intersectDomains(this.computeDomainePolynome("sqrt",c,d),this.computeDomainePolynome("sqrt",m,x))))}\\]`}break}this.listeQuestions.indexOf(n)===-1&&(this.listeQuestions.push(n),this.listeCorrections.push(t),i++),e++,k(this)}}}export{Ne as dateDePublication,He as default,Ue as interactifReady,Be as interactifType,Ge as refs,_e as titre,Ye as uuid};
//# sourceMappingURL=1mF1-12-d8CrbGOq.js.map
