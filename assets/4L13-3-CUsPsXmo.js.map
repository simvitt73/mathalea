{"version":3,"file":"4L13-3-CUsPsXmo.js","sources":["../../src/exercices/4e/4L13-3.ts"],"sourcesContent":["import { listeShapes2DInfos } from '../../lib/2d/figures2d/shapes2d'\nimport { fixeBordures } from '../../lib/2d/fixeBordures'\nimport {\n  listePatternsSansRatioNiFraction,\n  type PatternRiche,\n  type PatternRiche3D,\n} from '../../lib/2d/patterns/patternsPreDef'\nimport { point } from '../../lib/2d/PointAbstrait'\nimport { polygone } from '../../lib/2d/polygones'\nimport { texteParPosition } from '../../lib/2d/textes'\nimport { createList } from '../../lib/format/lists'\nimport { ajouteQuestionMathlive } from '../../lib/interactif/questionMathLive'\nimport { enleveDoublonNum, shuffle } from '../../lib/outils/arrayOutils'\nimport { miseEnEvidence } from '../../lib/outils/embellissements'\nimport { texNombre } from '../../lib/outils/texNombre'\nimport { mathalea2d } from '../../modules/mathalea2d'\nimport { gestionnaireFormulaireTexte, randint } from '../../modules/outils'\nimport type { NestedObjetMathalea2dArray } from '../../types/2d'\nimport Exercice from '../Exercice'\n// import type { VisualPattern } from '../../lib/2d/patterns/VisualPattern'\nimport {\n  cubeDef,\n  project3dIso,\n  shapeCubeIso,\n  updateCubeIso,\n} from '../../lib/2d/figures2d/Shape3d'\nimport { VisualPattern } from '../../lib/2d/patterns/VisualPattern'\nimport { VisualPattern3D } from '../../lib/2d/patterns/VisualPattern3D'\nimport { bleuMathalea } from '../../lib/colors'\nimport { range1 } from '../../lib/outils/nombres'\nimport { context } from '../../modules/context'\n\nexport const titre = 'Comprendre un algorithme itératif'\nexport const interactifReady = true\nexport const interactifType = 'mathLive'\n\n// Gestion de la date de publication initiale\nexport const dateDePublication = '10/06/2025'\nexport const dateDeModifImportante = '22/11/2025'\n\n/**\n * Étudier les premiers termes d'une série de motifs afin de donner le nombre de formes ${['e','a','é','i','o','u','y','è','ê'].includes(pattern.shapes[0][0]) ? 'd\\'':'de'}${pattern.shapes[0]} du motif suivant.\n * Les patterns sont des motifs figuratifs qui évoluent selon des règles définies.\n * Cet exercice contient des patterns issus de l'excellent site : https://www.visualpatterns.org/\n * @author Jean-Claude Lhote\n */\nexport const uuid = '328b3'\n\nexport const refs = {\n  'fr-fr': ['4L13-3'],\n  'fr-2016': ['6I13'],\n  'fr-ch': ['autres-14'],\n}\n\nexport default class PaternNum0 extends Exercice {\n  destroyers: (() => void)[] = []\n\n  constructor() {\n    super()\n    this.nbQuestions = 3\n    this.comment = `Étudier les premiers termes d'une série de motifs afin de donner le nombre de formes du motif suivant.\\n\n Les patterns sont des motifs figuratifs qui évoluent selon des règles définies.\\n\n Cet exercice contient des patterns issus de l'excellent site : https://www.visualpatterns.org/.<br>\nGrâce au dernier paramètre, on peut imposer des patterns choisis dans cette <a href=\"https://coopmaths.fr/alea/?uuid=71ff5&s=6\" target=\"_blank\" style=\"color: blue\">liste de patterns</a>.<br>\nSi le nombre de questions est supérieur au nombre de patterns choisis, alors l'exercice sera complété par des patterns choisis au hasard.`\n    this.besoinFormulaireNumerique = ['Nombre de figures par question', 4]\n    this.sup = 3\n    this.besoinFormulaire4Texte = [\n      'Types de questions',\n      'Nombres séparés par des tirets :\\n1: Motif suivant à dessiner\\n2 : Motif suivant (nombre)\\n3 : Motif 10 (nombre)\\n4 : Numéro du motif\\n5 : Motif 100 (nombre)\\n6 : Question au hasard parmi les 5 précédentes',\n    ]\n    this.sup4 = '6'\n    const nbDePattern = listePatternsSansRatioNiFraction.length\n    this.besoinFormulaire5Texte = [\n      'Numéros des pattern désirés :',\n      [\n        'Nombres séparés par des tirets  :',\n        `Mettre des nombres entre 1 et ${nbDePattern}.`,\n        `Mettre ${nbDePattern + 1} pour laisser le hasard faire.`,\n      ].join('\\n'),\n    ]\n    this.sup5 = `${nbDePattern + 1}`\n  }\n\n  destroy() {\n    // MGu quan l'exercice est supprimé par svelte : bouton supprimé\n    this.destroyers.forEach((destroy) => destroy())\n    this.destroyers.length = 0\n  }\n\n  nouvelleVersion(): void {\n    // MGu quand l'exercice est modifié, on détruit les anciens listeners\n    this.destroyers.forEach((destroy) => destroy())\n    this.destroyers.length = 0\n    const nbDePattern = listePatternsSansRatioNiFraction.length\n\n    let typesPattern = gestionnaireFormulaireTexte({\n      saisie: this.sup5,\n      max: nbDePattern,\n      defaut: nbDePattern + 1,\n      melange: nbDePattern + 1,\n      nbQuestions: this.nbQuestions,\n    }).map(Number)\n\n    typesPattern = [...typesPattern, ...shuffle(range1(nbDePattern))]\n    typesPattern = enleveDoublonNum(typesPattern)\n    typesPattern = typesPattern.slice(0, 25)\n    typesPattern = typesPattern.reverse()\n\n    const listePreDef = typesPattern.map(\n      (i) => listePatternsSansRatioNiFraction[i - 1],\n    )\n    const nbFigures = Math.max(2, this.sup)\n    const typesQuestions = Array.from(\n      new Set(\n        gestionnaireFormulaireTexte({\n          saisie: this.sup4,\n          min: 1,\n          max: 5,\n          defaut: 1,\n          melange: 6,\n          nbQuestions: 5,\n          shuffle: false,\n        }).map(Number),\n      ),\n    )\n    let indexInteractif = 0\n    for (let i = 0, cpt = 0; i < this.nbQuestions && cpt < 50; ) {\n      const objetsCorr: NestedObjetMathalea2dArray = []\n      const popped = listePreDef.pop()\n      if (!popped) {\n        continue\n      }\n      const pat = popped\n      const delta = pat.fonctionNb(2) - pat.fonctionNb(1)\n      const b = pat.fonctionNb(1) - delta\n      const explain =\n        pat.type === 'linéaire'\n          ? `On constate que le nombre de formes augmente de $${delta}$ à chaque étape.<br>\n        Et que c'est aussi le nombre de formes à l'étape 1. Par conséquent, pour trouver le nombre de formes d'un motif il faut simplement multiplier par ${delta} le numéro du motif.`\n          : `On constate que le nombre de formes augmente de $${delta}$ à chaque étape.<br>\n        Cependant, il n'y a pas ${delta} formes sur le motif 1, mais ${pat.fonctionNb(1)}. Par conséquent, il faut multiplier le numéro du motif par ${delta} et ${b < 0 ? `retirer ${-b}` : `ajouter ${b}`}.`\n      const pattern =\n        'iterate3d' in pat\n          ? new VisualPattern3D({\n              initialCells: [],\n              type: 'iso',\n              prefixId: `Ex${this.numeroExercice}Q${i}`,\n              shapes: ['cube'],\n            })\n          : new VisualPattern([])\n\n      //  patterns.push(pattern)\n      const figureCorr = []\n      let xmin = Infinity\n      let ymin = Infinity\n      let xmax = -Infinity\n      let ymax = -Infinity\n      if (pattern instanceof VisualPattern3D) {\n        pattern.shape = shapeCubeIso()\n        pattern.iterate3d = (pat as PatternRiche3D).iterate3d\n        objetsCorr.push(cubeDef(`cubeIsoQ${i}F${nbFigures}`))\n\n        const angle = Math.PI / 6\n        if (context.isHtml) {\n          const listeners = updateCubeIso({\n            pattern,\n            i,\n            j: nbFigures,\n            angle,\n            inCorrectionMode: true,\n          })\n          if (listeners) this.destroyers.push(listeners)\n          pattern.shape.codeSvg = `<use href=\"#cubeIsoQ${i}F${nbFigures}\"></use>`\n          // Ajouter les SVG générés par svg() de chaque objet\n          const cells = (pattern as VisualPattern3D).update3DCells(nbFigures)\n          cells.forEach((cell) => {\n            const [px, py] = project3dIso(cell[0], cell[1], cell[2], angle)\n            const obj = shapeCubeIso(`cubeIsoQ${i}F${nbFigures}`, px, py)\n            figureCorr.push(obj)\n            ymin = Math.min(ymin, -py / 20)\n            ymax = Math.max(ymax, -py / 20)\n            xmin = Math.min(xmin, px / 20)\n            xmax = Math.max(xmax, px / 20)\n          })\n          xmin -= 5\n          xmax += 5\n          ymin -= 5\n          ymax += 5\n        } else {\n          figureCorr.push(\n            ...(pattern as VisualPattern3D).render(\n              nbFigures,\n              0,\n              0,\n              Math.PI / 6,\n            ),\n          )\n          ;({ xmin, ymin, xmax, ymax } = fixeBordures(figureCorr))\n        }\n        objetsCorr.push(...figureCorr)\n      } else {\n        const pat2D = pat as PatternRiche\n        pattern.iterate = (pat as PatternRiche).iterate\n        pattern.shapes = pat2D.shapes || ['carré', 'carré']\n        for (const shape of pattern.shapes) {\n          if (shape in listeShapes2DInfos) {\n            objetsCorr.push(listeShapes2DInfos[shape].shapeDef)\n          } else {\n            throw new Error(\n              `Shape ${shape} not found in listeShapes2DInfos or emojis.`,\n            )\n          }\n        }\n        objetsCorr.push(...pattern.render(nbFigures + 1, 0, 0))\n        ;({ xmin, ymin, xmax, ymax } = fixeBordures(objetsCorr))\n      }\n      const xminCorr = xmin\n      const xmaxCorr = xmax\n      const yminCorr = ymin\n      const ymaxCorr = ymax\n\n      let yMax = 0\n      let yMin = 0\n      const angle = Math.PI / 6\n      let texte = `Voici les ${nbFigures} premiers motifs d'une série de motifs figuratifs. Ils évoluent selon des règles définies.<br>`\n      const figures: NestedObjetMathalea2dArray[] = []\n      for (let j = 0; j < nbFigures; j++) {\n        figures[j] = []\n        if (pattern instanceof VisualPattern3D) {\n          figures[j].push(cubeDef(`cubeIsoQ${i}F${j}`))\n        } else {\n          for (const shape of pattern.shapes) {\n            if (shape in listeShapes2DInfos) {\n              figures[j].push(listeShapes2DInfos[shape].shapeDef)\n            } else {\n              throw new Error(\n                `Shape ${shape} not found in listeShapes2DInfos or emojis.`,\n              )\n            }\n          }\n        }\n\n        let xmin = Infinity\n        let ymin = Infinity\n        let xmax = -Infinity\n        let ymax = -Infinity\n        if (pattern instanceof VisualPattern3D) {\n          if (context.isHtml) {\n            const listeners = updateCubeIso({\n              pattern,\n              i,\n              j,\n              angle,\n              inCorrectionMode: false,\n            })\n            if (listeners) this.destroyers.push(listeners)\n            if (pattern.shape)\n              pattern.shape.codeSvg = `<use href=\"#cubeIsoQ${i}F${j}\"></use>`\n            const cells = (pattern as VisualPattern3D).update3DCells(j + 1)\n            // Ajouter les SVG générés par svg() de chaque objet\n            cells.forEach((cell) => {\n              const [px, py] = project3dIso(cell[0], cell[1], cell[2], angle)\n              const obj = shapeCubeIso(`cubeIsoQ${i}F${j}`, px, py)\n              figures[j].push(obj)\n              ymin = Math.min(ymin, -py / 20)\n              ymax = Math.max(ymax, -py / 20)\n              xmin = Math.min(xmin, px / 20)\n              xmax = Math.max(xmax, px / 20)\n            })\n            xmin -= 1\n            xmax += 1\n          } else {\n            figures[j].push(\n              ...(pattern as VisualPattern3D).render(j + 1, 0, 0, Math.PI / 6),\n            )\n            ;({ xmin, ymin, xmax, ymax } = fixeBordures(figures[j]))\n          }\n        } else {\n          figures[j].push(...pattern.render(j + 1, 0, 0))\n          ;({ xmin, ymin, xmax, ymax } = fixeBordures(figures[j]))\n        }\n        figures[j].push(\n          texteParPosition(\n            `Motif ${j + 1}`,\n            (xmax + xmin + 1) / 2,\n            ymin - 1.5,\n            0,\n            'black',\n            0.8,\n            'milieu',\n          ),\n        )\n        const cadre = polygone(\n          point(xmin - 1, ymin - 2),\n          point(xmax + 2, ymin - 2),\n          point(xmax + 2, ymax + 2),\n          point(xmin - 1, ymax + 2),\n        )\n        cadre.pointilles = 4\n        figures[j].push(cadre)\n        yMax = Math.max(yMax, ymax)\n        yMin = Math.min(yMin, ymin)\n      }\n      texte += figures\n        .map((fig, index) =>\n          mathalea2d(\n            Object.assign(\n              fixeBordures(fig, { rxmin: 0, rymin: -1, rxmax: 0, rymax: 1 }),\n              {\n                id: `Motif${i}F${index}`,\n                pixelsParCm: 20,\n                yMax,\n                yMin,\n                scale: 0.4,\n                style: 'display: inline-block',\n                optionsTikz: 'transform shape',\n              },\n            ),\n            fig,\n          ),\n        )\n        .join('\\n')\n      texte += '<br><br>'\n      let texteCorr = ''\n      const listeQuestions: string[] = []\n      const listeCorrections: string[] = []\n      const infosShape =\n        pattern.shapes[0] in listeShapes2DInfos\n          ? listeShapes2DInfos[pattern.shapes[0]]\n          : { articleCourt: 'de ', nomPluriel: 'cubes' }\n      for (const q of typesQuestions) {\n        switch (q) {\n          case 1:\n            listeQuestions.push(`\\nDessiner le motif $${nbFigures + 1}$.<br>`)\n            listeCorrections.push(`Voici le motif $${nbFigures + 1}$ :<br>\n              ${mathalea2d(Object.assign({ scale: 0.4, optionsTikz: 'transform shape', id: `Motif${i}F${nbFigures}` }, { xmin: xminCorr, ymin: yminCorr, xmax: xmaxCorr, ymax: ymaxCorr }), objetsCorr)}`)\n            break\n          case 2:\n            {\n              const nbFormes = pat.fonctionNb(nbFigures + 1)\n              const nbTex = texNombre(nbFormes, 0)\n\n              listeQuestions.push(\n                `\\nQuel sera le nombre ${infosShape.articleCourt}${infosShape.nomPluriel} dans le motif $${nbFigures + 1}$ ?<br>${ajouteQuestionMathlive(\n                  {\n                    exercice: this,\n                    question: indexInteractif++,\n                    objetReponse: { reponse: { value: nbTex } },\n                    typeInteractivite: 'mathlive',\n                  },\n                )}`,\n              )\n              listeCorrections.push(`Le motif $${nbFigures + 1}$ contient $${miseEnEvidence(texNombre(nbFormes, 0))}$ ${infosShape.nomPluriel}.<br>\n          ${!typesQuestions.includes(1) ? mathalea2d(Object.assign(fixeBordures(objetsCorr, { rxmin: -1, rymin: 0, rxmax: 0, rymax: 1 }), { scale: 0.4, optionsTikz: 'transform shape' }), objetsCorr) : ''}`)\n            }\n            break\n          case 3:\n            {\n              const nbFormes = pat.fonctionNb(10)\n              const nbTex = texNombre(nbFormes, 0)\n              listeQuestions.push(`\\nQuel sera le nombre ${infosShape.articleCourt}${infosShape.nomPluriel} pour le motif $10$ ?<br>${ajouteQuestionMathlive(\n                {\n                  exercice: this,\n                  question: indexInteractif++,\n                  objetReponse: { reponse: { value: nbTex } },\n                  typeInteractivite: 'mathlive',\n                },\n              )}\n            `)\n              listeCorrections.push(`Le motif $10$ contient $${miseEnEvidence(nbTex)}$ ${infosShape.nomPluriel}.<br>\n            En effet, la formule pour trouver le nombre ${infosShape.articleCourt}${infosShape.nomPluriel} est : $${miseEnEvidence(pat.formule.replaceAll('n', '10'), bleuMathalea)}$.<br>\n            ${explain}`)\n            }\n            break\n          case 4:\n            {\n              const etape = randint(20, 80)\n              const nbFormes = pat.fonctionNb(etape)\n              const nbTex = texNombre(nbFormes, 0)\n              listeQuestions.push(`\\nUn motif de cette série contient $${nbTex}$ ${infosShape.nomPluriel}. À quel numéro de motif cela correspond-il ?<br>${ajouteQuestionMathlive(\n                {\n                  exercice: this,\n                  question: indexInteractif++,\n                  objetReponse: { reponse: { value: etape.toString() } },\n                  typeInteractivite: 'mathlive',\n                },\n              )}\n            `)\n\n              const explain2 =\n                pat.type === 'linéaire'\n                  ? `On constate que le nombre de formes  augmente de $${delta}$ à chaque étape.<br>\n        Et que c'est aussi le nombre de formes à l'étape 1. Par conséquent, pour trouver le numéro d'un motif dont on connait le nombre de formes, il faut simplement diviser ce nombre par ${delta} pour trouver le numéro.`\n                  : `On constate que le nombre de formes augmente de $${delta}$ à chaque étape.<br>\n        Cependant, il n'y a pas ${delta} formes sur le motif 1, mais ${pat.fonctionNb(1)}. Par conséquent, il faut ${b < 0 ? `ajouter ${-b}` : `retirer ${b}`} au nombre de formes puis diviser le résultat par ${delta} : <br>\n        $\\\\dfrac{${nbTex} ${b < 0 ? '+' : '-'} ${Math.abs(b)}}{${delta}}=${miseEnEvidence(etape)}$.`\n              listeCorrections.push(`C'est le motif numéro $${miseEnEvidence(etape.toString())}$ qui contient $${miseEnEvidence(texNombre(nbFormes, 0), bleuMathalea)}$ ${pattern.shapes[0]}s.<br>\n            ${explain2}`)\n            }\n            break\n          case 5:\n            {\n              const nbFormes = pat.fonctionNb(100)\n              const nbTex = texNombre(nbFormes, 0)\n              listeQuestions.push(`\\nQuel sera le nombre ${infosShape.articleCourt}${infosShape.nomPluriel} pour le motif $100$ ?<br>${ajouteQuestionMathlive(\n                {\n                  exercice: this,\n                  question: indexInteractif++,\n                  objetReponse: { reponse: { value: nbTex } },\n                  typeInteractivite: 'mathlive',\n                },\n              )}\n            `)\n              listeCorrections.push(`Le motif $100$ contient $${miseEnEvidence(nbTex)}$ ${infosShape.nomPluriel}.<br>\n            En effet, la formule pour trouver le nombre ${infosShape.articleCourt}${infosShape.nomPluriel} est : $${miseEnEvidence(pat.formule.replaceAll('n', '100'), bleuMathalea)}$.<br>\n            ${explain}`)\n            }\n            break\n        }\n      }\n      texte +=\n        listeQuestions.length === 1\n          ? listeQuestions[0]\n          : createList({\n              items: listeQuestions,\n              style: 'alpha',\n            })\n      texteCorr +=\n        listeCorrections.length === 1\n          ? listeCorrections[0]\n          : createList({\n              items: listeCorrections,\n              style: 'alpha',\n            })\n      if (this.questionJamaisPosee(i, typesQuestions.join(''), pat.numero)) {\n        this.listeQuestions.push(texte)\n        this.listeCorrections.push(texteCorr)\n        i++\n      }\n      cpt++\n    }\n  }\n}\n"],"names":["titre","interactifReady","interactifType","dateDePublication","dateDeModifImportante","uuid","refs","PaternNum0","Exercice","__publicField","nbDePattern","listePatternsSansRatioNiFraction","destroy","typesPattern","gestionnaireFormulaireTexte","shuffle","range1","enleveDoublonNum","listePreDef","i","nbFigures","typesQuestions","indexInteractif","cpt","objetsCorr","popped","pat","delta","explain","pattern","VisualPattern3D","VisualPattern","figureCorr","xmin","ymin","xmax","ymax","shapeCubeIso","cubeDef","angle","context","listeners","updateCubeIso","cell","px","py","project3dIso","obj","fixeBordures","pat2D","shape","listeShapes2DInfos","xminCorr","xmaxCorr","yminCorr","ymaxCorr","yMax","yMin","texte","figures","j","texteParPosition","cadre","polygone","point","fig","index","mathalea2d","texteCorr","listeQuestions","listeCorrections","infosShape","q","nbFormes","nbTex","texNombre","ajouteQuestionMathlive","miseEnEvidence","bleuMathalea","etape","randint","explain2","createList"],"mappings":"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"}