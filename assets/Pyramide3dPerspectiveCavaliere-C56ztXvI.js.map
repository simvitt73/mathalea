{"version":3,"file":"Pyramide3dPerspectiveCavaliere-C56ztXvI.js","sources":["../../src/lib/3d/3dProjectionMathalea2d/Pyramide3dPerspectiveCavaliere.ts"],"sourcesContent":["import { colorToLatexOrHTML } from '../../2d/colorToLatexOrHtml'\nimport { droite } from '../../2d/droites'\nimport { ObjetMathalea2D } from '../../2d/ObjetMathalea2D'\nimport type { PointAbstrait } from '../../2d/PointAbstrait'\nimport { polygone, renommePolygone } from '../../2d/polygones'\nimport { segment } from '../../2d/segmentsVecteurs'\nimport { labelPoint } from '../../2d/textes'\nimport { tracePoint } from '../../2d/TracePoint'\nimport { translation } from '../../2d/transformations'\nimport {\n  estDansPolygone,\n  longueur,\n  norme,\n} from '../../2d/utilitairesGeometriques'\nimport { pointIntersectionDD, pointSurSegment } from '../../2d/utilitairesPoint'\nimport { vecteur } from '../../2d/Vecteur'\nimport { choisitLettresDifferentes } from '../../outils/aleatoires'\nimport { Point3d, Polygone3d, arete3d } from './elementsEtTransformations3d'\n\n/**\n * Classe de la pyramide\n * (optimisée au niveau des pointillés pour une base sur le plan xOy et un sommet plus haut ou plus bas que la base)\n * @param {Polygone3d} base Base de la pyramide\n * @param {Point3d} sommet Sommet de la pyramide\n * @param {string} [color = 'black'] Couleur des arêtes du prisme droit : du type 'blue' ou du type '#f15929'\n * @param {Point3d} [centre] Centre de la pyramide... Entraine l'affichage de ce centre\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe de la pyramide. Ne fonctionne que si centre est défini.\n * @param {string} [colorAxe = 'black'] Couleur de l'axe et du centre de la base de la pyramide : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageNom = false] Permet (ou pas) l'affichage du nom des sommets de la pyramide.\n * @param {boolean} [estCone = false] Permet (ou pas) de considérer la pyramide comme un cône... dans le cas où la base est un disque.\n * @param {string} [colorCone = 'gray'] Couleur du cône : du type 'blue' ou du type '#f15929'\n * @property {Polygone3d} base Base de la pyramide\n * @property {Point3d} sommet Sommet de la pyramide\n * @property {string} color Couleur des arêtes de la pyramide : du type 'blue' ou du type '#f15929'\n * @property {Point3d} centre Centre de la pyramide... Entraine l'affichage de ce centre\n * @property {boolean} affichageAxe Permet (ou pas) l'affichage de l'axe de la pyramide. Ne fonctionne que si centre est défini.\n * @property {string} colorAxe Couleur de l'axe et du centre de la base de la pyramide : du type 'blue' ou du type '#f15929'\n * @property {boolean} affichageNom Permet (ou pas) l'affichage du nom des sommets de la pyramide.\n * @property {string} nom Nom de la pyramide (si affichageNom = true)\n * @property {string} colorCone Couleur du cône : du type 'blue' ou du type '#f15929'\n * @property {arete3d[]} aretesSommet Ce tableau contient les arêtes liant le sommet de la pyramide aux sommets de la base\n * @property {Array} c2d Contient les commandes à tracer en 2d de cette fonction\n * @author Eric Elter (d'après version précédente de Jean-Claude Lhote)\n * @class\n */\n\nexport class Pyramide3d extends ObjetMathalea2D {\n  constructor(\n    base: Polygone3d,\n    sommet: Point3d,\n    color: string = 'black',\n    centre?: Point3d,\n    affichageAxe = false,\n    colorAxe = 'black',\n    affichageNom = false,\n    estCone = false,\n    colorCone = 'gray',\n    affichageBase = true,\n  ) {\n    super()\n    base.color = color\n    this.base = base\n    this.sommet = sommet\n    this.color = colorToLatexOrHTML(color)\n    this.centre = centre\n    this.affichageAxe = affichageAxe\n    this.colorAxe = colorAxe\n    this.affichageNom = affichageNom\n    this.estCone = estCone\n    this.colorCone = colorCone\n    this.c2d = []\n    this.nom = ''\n    let s\n\n    // Stockage de toutes les arêtes issues du sommet\n    this.aretesSommet = []\n\n    for (let i = 0; i < this.base.listePoints.length; i++) {\n      s = arete3d(this.base.listePoints[i], this.sommet, color, true)\n      // s.c2d.isVisible = false\n      this.aretesSommet.push(s)\n    }\n\n    // Stockage de toutes les arêtes de la base\n    const aretesBase = []\n    for (let i = 0; i < this.base.listePoints.length; i++) {\n      s = arete3d(\n        this.base.listePoints[i],\n        this.base.listePoints[(i + 1) % this.base.listePoints.length],\n        color,\n        true,\n      )\n      aretesBase.push(s)\n    }\n\n    // Recherche des sommets arrières (donc toutes les arêtes issues de ce point sont cachées)\n    let sommetCache = false\n    let sommetCacheAvant\n    const angleReference = [0, 0]\n    const sommetGeneratriceCone = []\n\n    for (let i = 0; i < this.base.listePoints.length; i++) {\n      sommetCacheAvant = sommetCache\n      sommetCache = false\n      for (let j = 1; j < this.base.listePoints.length - 1; j++) {\n        const poly = polygone([\n          this.sommet.c2d,\n          this.base.listePoints[(i + j) % this.base.listePoints.length].c2d,\n          this.base.listePoints[(i + j + 1) % this.base.listePoints.length].c2d,\n        ])\n        poly.isVisible = false\n        sommetCache =\n          sommetCache || estDansPolygone(this.base.listePoints[i].c2d, poly)\n      }\n      if (this.estCone && sommetCacheAvant !== sommetCache && i !== 0) {\n        if (sommetCache)\n          sommetGeneratriceCone.push(\n            this.aretesSommet[\n              (this.aretesSommet.length + i - 1) % this.aretesSommet.length\n            ],\n          )\n        else sommetGeneratriceCone.push(this.aretesSommet[i])\n        if (sommetCache) angleReference[1] = i\n        else angleReference[0] = i\n      }\n      if (sommetCache) {\n        if (sommet.z > this.base.listePoints[0].z) {\n          // Si le sommet est au-dessus de la base\n          this.aretesSommet[i].isVisible = false\n          this.aretesSommet[i].c2d.pointilles = 2\n          aretesBase[i].c2d.pointilles = 2\n          aretesBase[\n            (this.base.listePoints.length + i - 1) %\n              this.base.listePoints.length\n          ].c2d.pointilles = 2\n        }\n      }\n    }\n\n    if (this.estCone && angleReference[1] <= angleReference[0]) {\n      angleReference[1] += this.base.listePoints.length\n    }\n\n    if (this.estCone && sommetGeneratriceCone.length === 1) {\n      sommetGeneratriceCone.push(\n        this.aretesSommet[this.aretesSommet.length - 1],\n      )\n      angleReference[1] = this.aretesSommet.length - 1\n    }\n    if (this.estCone) {\n      const premierPlan = [this.sommet.c2d]\n      for (let i = angleReference[0]; i < angleReference[1]; i++) {\n        premierPlan.push(\n          this.base.listePoints[i % this.base.listePoints.length].c2d,\n        )\n        // ok\n      }\n      const faceAv = polygone(premierPlan, this.colorCone)\n      faceAv.couleurDeRemplissage = colorToLatexOrHTML(this.colorCone)\n      this.c2d.push(faceAv)\n    }\n\n    if (!this.estCone) {\n      let longueurSegment\n      if (this.sommet.z > this.base.listePoints[0].z) {\n        // Si le sommet est au-dessus de la base\n        // Recherche de l'arête cachée possible issue de deux sommets non cachés.\n        for (let i = 0; i < this.base.listePoints.length; i++) {\n          sommetCache = false\n          longueurSegment = longueur(\n            this.base.listePoints[i].c2d,\n            this.base.listePoints[(i + 1) % this.base.listePoints.length].c2d,\n          )\n          s = segment(\n            pointSurSegment(\n              this.base.listePoints[i].c2d,\n              this.base.listePoints[(i + 1) % this.base.listePoints.length].c2d,\n              longueurSegment / 20,\n            ),\n            pointSurSegment(\n              this.base.listePoints[i].c2d,\n              this.base.listePoints[(i + 1) % this.base.listePoints.length].c2d,\n              (19 * longueurSegment) / 20,\n            ),\n          )\n          s.isVisible = false\n          for (let j = 0; j < this.aretesSommet.length; j++) {\n            sommetCache = sommetCache || !!s.estSecant(this.aretesSommet[j].c2d)\n          }\n          if (sommetCache) aretesBase[i].c2d.pointilles = 2\n        }\n      } else {\n        // Si le sommet est en-dessous de la base\n        for (let i = 0; i < this.base.listePoints.length; i++) {\n          longueurSegment = longueur(\n            this.base.listePoints[i].c2d,\n            this.sommet.c2d,\n          )\n          s = segment(\n            pointSurSegment(\n              this.base.listePoints[i].c2d,\n              this.sommet.c2d,\n              longueurSegment / 20,\n            ),\n            this.sommet.c2d,\n          )\n          s.isVisible = false\n          let j = 0\n          while (j < aretesBase.length && !s.estSecant(aretesBase[j].c2d)) {\n            j++\n          }\n          if (j < aretesBase.length) this.aretesSommet[i].c2d.pointilles = 2\n        }\n      }\n      for (let i = 0; i < this.base.listePoints.length; i++) {\n        this.c2d.push(this.aretesSommet[i].c2d)\n      }\n    } else {\n      for (let i = 0; i < sommetGeneratriceCone.length; i++) {\n        this.c2d.push(sommetGeneratriceCone[i].c2d)\n      }\n    }\n\n    if (affichageBase) {\n      for (let i = 0; i < this.base.listePoints.length; i++) {\n        this.c2d.push(aretesBase[i].c2d)\n      }\n    }\n\n    if (this.centre !== undefined && this.centre.constructor === Point3d) {\n      this.c2d.push(tracePoint(this.centre.c2d, this.colorAxe))\n      if (this.centre.label === '')\n        this.centre.label = choisitLettresDifferentes(1, 'OQWX')[0]\n      this.c2d.push(...labelPoint(this.centre.c2d))\n\n      if (this.affichageAxe) {\n        // Axe affiché que si centre précisé\n        if (this.sommet.z > 0) {\n          let intersectionTrouvee = false\n          let ee = 0\n          // Recherche du point d'intersection visuelle entre l'axe et une arête visible de la base\n          while (!intersectionTrouvee && ee < aretesBase.length) {\n            s = aretesBase[ee].c2d\n            if (s.pointilles !== 2) {\n              // L'arête coupée doit être visible\n              const d1 = droite(this.centre.c2d, this.sommet.c2d)\n              d1.isVisible = false\n              intersectionTrouvee = !!s.estSecant(d1)\n            }\n            ee++\n          }\n          if (intersectionTrouvee) {\n            ee--\n            const d1 = droite(\n              this.base.listePoints[ee].c2d,\n              this.base.listePoints[(ee + 1) % this.base.listePoints.length]\n                .c2d,\n            )\n            d1.isVisible = false\n            const d2 = droite(this.centre.c2d, this.sommet.c2d)\n            d2.isVisible = false\n            const ptBase = pointIntersectionDD(d1, d2)\n            if (!ptBase) {\n              window.notify('Axe de la pyramide non défini correctement', {\n                d1,\n                d2,\n              })\n              return\n            }\n            s = segment(ptBase, this.sommet.c2d, this.colorAxe)\n            s.pointilles = 2\n            this.c2d.push(s)\n            s = segment(\n              ptBase,\n              translation(ptBase, vecteur(this.centre.c2d, ptBase)),\n              this.colorAxe,\n            )\n            this.c2d.push(s)\n            s = segment(\n              this.sommet.c2d as PointAbstrait,\n              translation(\n                this.sommet.c2d as PointAbstrait,\n                vecteur(ptBase, this.centre.c2d),\n              ),\n              this.colorAxe,\n            )\n            this.c2d.push(s)\n          }\n        } else {\n          s = segment(this.centre.c2d, this.sommet.c2d, this.colorAxe)\n          s.pointilles = 2\n          this.c2d.push(s)\n          const v = vecteur(this.centre.c2d, this.sommet.c2d)\n          const L = longueur(this.base.listePoints[0].c2d, this.centre.c2d)\n          const h = 2 * norme(v)\n          s = segment(\n            this.sommet.c2d as PointAbstrait,\n            translation(\n              this.sommet.c2d as PointAbstrait,\n              vecteur((L * v.x) / h, (L * v.y) / h),\n            ),\n            this.colorAxe,\n          )\n          this.c2d.push(s)\n          s = segment(\n            this.centre.c2d,\n            translation(\n              this.centre.c2d,\n              vecteur((-L * v.x) / h, (-L * v.y) / h),\n            ),\n            this.colorAxe,\n          )\n          this.c2d.push(s)\n        }\n      }\n    }\n\n    if (this.affichageNom) {\n      const p = polygone(this.base.listePoints2d)\n      p.isVisible = false\n      if (this.centre.label === '' || this.centre.label === this.sommet.label)\n        this.sommet.label = choisitLettresDifferentes(1, 'OQWX')[0]\n      const labelsRenseignes = p.listePoints.map((pt) => pt.nom).join('')\n      const nomBase =\n        labelsRenseignes === ''\n          ? choisitLettresDifferentes(\n              this.base.listePoints.length,\n              'OQWX' + this.sommet.label + this.centre.label,\n            )\n          : Array.from(labelsRenseignes)\n      renommePolygone(p, nomBase)\n      for (let ee = 0; ee < this.base.listePoints2d.length; ee++) {\n        this.base.listePoints2d[ee].positionLabel =\n          this.sommet.z > 0 ? 'below' : 'above'\n      }\n      this.c2d.push(labelPoint(...p.listePoints))\n      this.c2d.push(labelPoint(this.sommet.c2d))\n      this.nom = nomBase.join('') + this.sommet.label\n    }\n  }\n}\n/**\n * Crée une pyramide\n * @param {Polygone3d} base Base de la pyramide\n * @param {Point3d} sommet Sommet de la pyramide\n * @param {string} [color = 'black'] Couleur des arêtes de la pyramide : du type 'blue' ou du type '#f15929'\n * @param {Point3d} [centre] Centre de la pyramide... Entraine l'affichage de ce centre\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe de la pyramide. Ne fonctionne que si centre est défini.\n * @param {string} [colorAxe = 'black'] Couleur de l'axe et du centre de la base de la pyramide : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageNom = false] Permet (ou pas) l'affichage du nom des sommets de la pyramide.\n * @param {boolean} [estCone = false] Permet (ou pas) de considérer la pyramide comme un cône\n * @param {string} [colorCone = 'gray'] Couleur du cône : du type 'blue' ou du type '#f15929'\n * @author Eric Elter (d'après version précédente de Jean-Claude Lhote)\n * @example pyramide3d(p,A) // Créé une pyramide de base p et de sommet A\n * @example pyramide3d(p,A,'red') // Créé une pyramide de base p et de sommet A et dont les arêtes sont rouges\n * @example pyramide3d(p,A,'red',B) // Créé une pyramide de base p et de sommet A et dont les arêtes sont rouges, le centre affiché est B\n * @example pyramide3d(p,A,'red',B,true,'green') // Créé une pyramide de base p et de sommet A et dont les arêtes sont rouges, le centre affiché est B, l'axe affiché est vert\n * @example pyramide3d(p,A,'red',B,true,'green',true) // Créé une pyramide de base p et de sommet A et dont les arêtes sont rouges, le centre affiché est B, l'axe affiché est vert, les sommets sont nommés\n * @example pyramide3d(c,A,'red',B,true,'green',false,true) // Créé un CONE de cercle c et de sommet A et dont les \"arêtes\" sont rouges, le centre affiché est B, l'axe affiché est vert\n * @example pyramide3d(c,A,'red',B,true,'green',false,true,'blue') // Créé un CONE de cercle c et de sommet A et dont les \"arêtes\" sont rouges, le centre affiché est B, l'axe affiché est vert et le cône est peint en vert\n * @return {Pyramide3d}\n */\nexport function pyramide3d(\n  base: Polygone3d,\n  sommet: Point3d,\n  color = 'black',\n  centre?: Point3d,\n  affichageAxe = false,\n  colorAxe = 'black',\n  affichageNom = false,\n  estCone = false,\n  colorCone = 'gray',\n  affichageBase = true,\n) {\n  return new Pyramide3d(\n    base,\n    sommet,\n    color,\n    centre,\n    affichageAxe,\n    colorAxe,\n    affichageNom,\n    estCone,\n    colorCone,\n    affichageBase,\n  )\n}\n"],"names":["Pyramide3d","ObjetMathalea2D","base","sommet","color","centre","affichageAxe","colorAxe","affichageNom","estCone","colorCone","affichageBase","colorToLatexOrHTML","s","i","arete3d","aretesBase","sommetCache","sommetCacheAvant","angleReference","sommetGeneratriceCone","j","poly","polygone","estDansPolygone","premierPlan","faceAv","longueurSegment","longueur","segment","pointSurSegment","Point3d","tracePoint","choisitLettresDifferentes","labelPoint","intersectionTrouvee","ee","d1","droite","d2","ptBase","pointIntersectionDD","translation","vecteur","v","L","h","norme","p","labelsRenseignes","pt","nomBase","renommePolygone","pyramide3d"],"mappings":"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"}