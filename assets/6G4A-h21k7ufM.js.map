{"version":3,"file":"6G4A-h21k7ufM.js","sources":["../../src/exercices/6e/6G4A.ts"],"sourcesContent":["import { PointAbstrait, pointAbstrait } from '../../lib/2d/PointAbstrait'\nimport { polyline } from '../../lib/2d/Polyline'\nimport { codageAngle } from '../../lib/2d/angles'\nimport { droite } from '../../lib/2d/droites'\nimport { polygoneAvecNom } from '../../lib/2d/polygones'\nimport { segment } from '../../lib/2d/segmentsVecteurs'\nimport { labelPoint } from '../../lib/2d/textes'\nimport { angleOriente } from '../../lib/2d/utilitairesGeometriques'\nimport {\n  pointIntersectionDD,\n  pointSurSegment,\n} from '../../lib/2d/utilitairesPoint'\nimport { couleurTab } from '../../lib/format/style'\nimport { KeyboardType } from '../../lib/interactif/claviers/keyboard'\nimport { setReponse } from '../../lib/interactif/gestionInteractif'\nimport { propositionsQcm } from '../../lib/interactif/qcm'\nimport { ajouteChampTexteMathLive } from '../../lib/interactif/questionMathLive'\nimport {\n  choice,\n  combinaisonListes,\n  enleveElement,\n} from '../../lib/outils/arrayOutils'\nimport { miseEnEvidence } from '../../lib/outils/embellissements'\nimport { rangeMinMax } from '../../lib/outils/nombres'\nimport { lettreDepuisChiffre, numAlpha, sp } from '../../lib/outils/outilString'\nimport { context } from '../../modules/context'\nimport { mathalea2d } from '../../modules/mathalea2d'\nimport { listeQuestionsToContenu, randint } from '../../modules/outils'\nimport Exercice from '../Exercice'\n\nexport const titre = 'Nommer un angle'\nexport const interactifType = ['qcm', 'mathLive']\nexport const interactifReady = true\nexport const amcType = 'AMCHybride'\nexport const amcReady = true\n\nexport const dateDePublication = '13/04/2022'\nexport const dateDeModifImportante = '27/03/2024'\n\n/**\n * Nommer un angle\n * @author Eric Elter\n */\nexport const uuid = 'e10d1'\n\nexport const refs = {\n  'fr-fr': ['6G4A'],\n  'fr-2016': ['6G22'],\n  'fr-ch': ['9ES5-1'],\n}\nexport default class NommerUnAngle extends Exercice {\n  constructor() {\n    super()\n    this.besoinFormulaireNumerique = [\n      \"Nombre d'angles à trouver (entre 1 et 3) :\",\n      3,\n    ]\n    if (context.isHtml)\n      this.besoinFormulaire2Numerique = [\n        'Exercice interactif',\n        2,\n        '1 : QCM\\n2 : Texte',\n      ]\n    this.besoinFormulaire3CaseACocher = ['Figure en noir et blanc']\n    this.nbQuestions = 2\n    this.sup = 2\n    this.sup2 = 1\n    this.sup3 = false\n  }\n\n  nouvelleVersion() {\n    this.interactifType = this.sup2 === 2 ? 'mathLive' : 'qcm'\n    let propositionsDuQcm = []\n    for (\n      let i = 0,\n        texteAMC,\n        troisBonnesReponses,\n        resultatOK1,\n        resultatOK2,\n        resultat3,\n        resultatPasOK1,\n        resultatPasOK2,\n        choixAngle,\n        pt1,\n        pt2,\n        pt3,\n        tailleAngle,\n        aleaChoixCouleurRemplissage,\n        couleurRemplissageAngle,\n        couleurAngle,\n        segmentsCorrection,\n        resultat;\n      i < this.nbQuestions;\n      i++\n    ) {\n      const propositionsAMC = []\n      let listePt1: PointAbstrait[] = []\n      let listePt3: PointAbstrait[] = []\n      // let figureExo\n      // On prépare la figure...\n      const marquageAngle = this.sup3\n        ? combinaisonListes(['X', 'OO', '|||'], 3)\n        : ['', '', '']\n\n      const ChoixHorizontal = choice([-1, 1])\n\n      const numB = randint(1, 26, [4, 5, 15, 23, 24, 25])\n      const numA = randint(1, 26, [4, 5, 15, 23, 24, 25, numB])\n      const numC = randint(1, 26, [4, 5, 15, 23, 24, 25, numB, numA])\n      const numM = randint(1, 26, [4, 5, 15, 23, 24, 25, numB, numA, numC])\n      const numN = randint(1, 26, [\n        4,\n        5,\n        15,\n        23,\n        24,\n        25,\n        numB,\n        numA,\n        numC,\n        numM,\n      ])\n      const numI = randint(1, 26, [\n        4,\n        5,\n        15,\n        23,\n        24,\n        25,\n        numB,\n        numA,\n        numC,\n        numM,\n        numN,\n      ])\n\n      /* A décommenter pour débugguer (et commenter les 6 lignes du dessus)\n            const numA = 1\n            const numB = 2\n            const numC = 3\n            const numI = 9\n            const numM = 13\n            const numN = 14\n            */\n\n      const ordB = randint(0, 2)\n      const B = pointAbstrait(0, ordB, lettreDepuisChiffre(numB))\n\n      const absA = ChoixHorizontal * randint(7, 12)\n      const ordA = randint(4, 8)\n      const A = pointAbstrait(absA, ordA, lettreDepuisChiffre(numA))\n\n      const absC = ChoixHorizontal * randint(7, 12, [absA])\n      const ordC = -1 * randint(2, 5)\n      const C = pointAbstrait(absC, ordC, lettreDepuisChiffre(numC))\n      const fractionSegmentAB = this.sup === 1 ? randint(2, 8) : randint(4, 6)\n      const fractionSegmentBC =\n        this.sup === 1\n          ? randint(2, 8, [fractionSegmentAB])\n          : randint(4, 6, [fractionSegmentAB])\n      const AB = segment(A, B).longueur\n      const BC = segment(B, C).longueur\n      const M = pointSurSegment(\n        B,\n        A,\n        (AB * fractionSegmentAB) / 10,\n        lettreDepuisChiffre(numM),\n      )\n      const N = pointSurSegment(\n        B,\n        C,\n        (BC * fractionSegmentBC) / 10,\n        lettreDepuisChiffre(numN),\n        'below',\n      )\n      const p1 = polygoneAvecNom(B, A, C)\n      const I = pointIntersectionDD(\n        droite(A, N),\n        droite(C, M),\n        lettreDepuisChiffre(numI),\n        'left',\n      )\n      const listePoints = [numA, numB, numC, numM, numN, numI]\n      const objetsEnonce = []\n      const objetsCorrection = []\n      const sommetsDejaTrouves: number[] = []\n      const choixCouleurRemplissage = rangeMinMax(0, 7)\n      //  couleurRemplissageAngle = ['none'] // Correction J-C : on définira ces couleurs en testant this.sup3\n      // couleurAngle = 'black'\n      let texte = ''\n      const O = pointAbstrait(0, 0) // Sert à construire les symboles pour les questions\n      const M1 = pointAbstrait(4, 0) // Sert à construire les symboles pour les questions\n      let texteCorr = ''\n      let positionIbis = ChoixHorizontal === -1 ? 'right' : 'left'\n      const Ibis = pointAbstrait(\n        I.x,\n        I.y,\n        lettreDepuisChiffre(numI),\n        positionIbis,\n      )\n\n      for (let jj = 0, marquageAngleConsigne; jj < this.sup; jj++) {\n        marquageAngleConsigne = []\n        const choixSommet: number = choice(listePoints, sommetsDejaTrouves)\n        if (!this.sup3) {\n          aleaChoixCouleurRemplissage = choice(choixCouleurRemplissage)\n          couleurRemplissageAngle = couleurTab(aleaChoixCouleurRemplissage)\n          couleurAngle = couleurRemplissageAngle[0]\n          enleveElement(choixCouleurRemplissage, aleaChoixCouleurRemplissage)\n        } else {\n          couleurRemplissageAngle = ['none']\n          couleurAngle = 'black'\n        }\n        sommetsDejaTrouves[jj] = choixSommet\n        switch (choixSommet) {\n          case numA: // Si le sommet est A, alors il y a 3 choix possibles d'angles\n            pt2 = A\n            tailleAngle =\n              (Math.min(\n                segment(pt2, M).longueur,\n                segment(pt2, N).longueur,\n                segment(pt2, I).longueur,\n                4,\n              ) /\n                2) *\n              0.9\n            choixAngle = 1\n            switch (choixAngle) {\n              case 1:\n                listePt1 = [B, M]\n                listePt3 = [N, I]\n                break\n              case 2:\n                listePt1 = [C]\n                listePt3 = [N, I]\n                break\n              case 3:\n                listePt3 = [B, M]\n                listePt1 = [C]\n                break\n            }\n            break\n          case numC: // Si le sommet est C, alors il y a 3 choix possibles d'angles\n            pt2 = C\n            choixAngle = randint(1, 3)\n            tailleAngle =\n              (Math.min(\n                segment(pt2, M).longueur,\n                segment(pt2, N).longueur,\n                segment(pt2, I).longueur,\n                4,\n              ) /\n                2) *\n              0.9\n            switch (choixAngle) {\n              case 1:\n                listePt1 = [B, N]\n                listePt3 = [M, I]\n                break\n              case 2:\n                listePt3 = [M, I]\n                listePt1 = [A]\n                break\n              case 3:\n                listePt3 = [B, N]\n                listePt1 = [A]\n                break\n            }\n            break\n          case numB:\n            pt2 = B\n            tailleAngle =\n              (Math.min(\n                segment(pt2, M).longueur,\n                segment(pt2, N).longueur,\n                segment(pt2, I).longueur,\n                4,\n              ) /\n                2) *\n              0.9\n            listePt1 = [C, N]\n            listePt3 = [A, M]\n            break\n          case numM: // Si le sommet est M, alors il y a 2 choix possibles d'angles\n            pt2 = M\n            tailleAngle =\n              (Math.min(\n                segment(pt2, A).longueur,\n                segment(pt2, C).longueur,\n                segment(pt2, I).longueur,\n                4,\n              ) /\n                2) *\n              0.9\n            listePt1 = [C, I]\n            listePt3 = [randint(1, 2) === 1 ? A : B]\n            positionIbis = ChoixHorizontal === -1 ? 'left' : 'right'\n            break\n          case numN: // Si le sommet est N, alors il y a 2 choix possibles d'angles\n            pt2 = N\n            tailleAngle =\n              (Math.min(\n                segment(pt2, A).longueur,\n                segment(pt2, C).longueur,\n                segment(pt2, I).longueur,\n                4,\n              ) /\n                2) *\n              0.9\n            listePt1 = [A, I]\n            listePt3 = [randint(1, 2) === 1 ? C : B]\n            break\n          case numI:\n          default:\n            pt2 = I\n            choixAngle = randint(1, 4)\n            switch (choixAngle) {\n              case 1:\n                listePt1 = [M]\n                listePt3 = [A]\n                break\n              case 2:\n                listePt1 = [C]\n                listePt3 = [A]\n                positionIbis = ChoixHorizontal === -1 ? 'right' : 'left'\n                break\n              case 3:\n                listePt1 = [N]\n                listePt3 = [C]\n                break\n              case 4:\n              default:\n                listePt1 = [N]\n                listePt3 = [M]\n                positionIbis = ChoixHorizontal === -1 ? 'left' : 'right'\n                break\n            }\n            tailleAngle =\n              (Math.min(\n                segment(pt2, listePt1[0]).longueur,\n                segment(pt2, listePt3[0]).longueur,\n                4,\n              ) /\n                2) *\n              0.9\n        }\n\n        pt1 = choice(listePt1) // Une fois la possibilité d'angle choisie, il y a deux points possibles.\n        pt3 = choice(listePt3)\n        segmentsCorrection = polyline(\n          [listePt1[0], pt2, listePt3[0]],\n          this.sup3 ? 'black' : couleurRemplissageAngle[0],\n        )\n        resultat = []\n        for (const item1 in listePt1) {\n          for (const item3 in listePt3) {\n            resultat.push(\n              `\\\\widehat{${listePt1[item1].nom}${pt2.nom}${listePt3[item3].nom}}`,\n            )\n            resultat.push(\n              `\\\\widehat{${listePt3[item3].nom}${pt2.nom}${listePt1[item1].nom}}`,\n            )\n          }\n        }\n        // Les 5 résultats suivants sont pour le QCM\n        // 2 résultats corrects, 2 résultats faux et un 5e résultat faux ou vrai, selon l'exercice.\n        resultatOK1 = choice(resultat)\n        resultatOK2 = choice(resultat, [resultatOK1])\n        resultatPasOK1 = `\\\\widehat{${pt2.nom}${listePt1[randint(0, listePt1.length - 1)].nom}${listePt3[randint(0, listePt3.length - 1)].nom}}`\n        resultatPasOK2 = `\\\\widehat{${listePt1[randint(0, listePt1.length - 1)].nom}${listePt3[randint(0, listePt3.length - 1)].nom}${pt2.nom}}`\n        troisBonnesReponses = false\n        if (choixSommet === numI) {\n          // Si I est le sommet, que deux bonnes réponses.\n          resultat3 = choice([\n            `\\\\widehat{${listePt3[0].nom}${listePt1[0].nom}${pt2.nom}}`,\n            `\\\\widehat{${pt2.nom}${listePt3[0].nom}${listePt1[0].nom}}`,\n          ])\n        } else {\n          troisBonnesReponses = choice([true, false])\n          if (troisBonnesReponses) {\n            // Une 3e réponse vraie\n            resultat3 = choice(resultat, [resultatOK1, resultatOK2])\n          } else if (choice([true, false])) {\n            // Une 3e réponse fausse\n            resultat3 = `\\\\widehat{${pt2.nom}${listePt1[randint(0, listePt1.length - 1)].nom}${listePt3[randint(0, listePt3.length - 1)].nom}}`\n            while (resultat3 === resultatPasOK1)\n              resultat3 = `\\\\widehat{${pt2.nom}${listePt1[randint(0, listePt1.length - 1)].nom}${listePt3[randint(0, listePt3.length - 1)].nom}}`\n          } else {\n            resultat3 = `\\\\widehat{${listePt1[randint(0, listePt1.length - 1)].nom}${listePt3[randint(0, listePt3.length - 1)].nom}${pt2.nom}}`\n            while (resultat3 === resultatPasOK2)\n              resultat3 = `\\\\widehat{${listePt1[randint(0, listePt1.length - 1)].nom}${listePt3[randint(0, listePt3.length - 1)].nom}${pt2.nom}}`\n          }\n        }\n        segmentsCorrection.epaisseur = 3\n        const ang = angleOriente(pt1, pt2, pt3)\n\n        objetsEnonce.push(\n          codageAngle(\n            pt1,\n            pt2,\n            ang,\n            tailleAngle,\n            marquageAngle[jj],\n            couleurAngle,\n            2,\n            1,\n            couleurRemplissageAngle[0],\n            1,\n            false,\n            true,\n          ),\n        )\n        if (\n          (this.interactif || context.isAmc) &&\n          this.interactifType === 'qcm'\n        ) {\n          texteAMC = 'Choisir tous les angles qui peuvent nommer'\n        } else {\n          texteAMC = 'Comment peut-on nommer'\n        }\n        texteAMC += \" l'angle \"\n        marquageAngleConsigne.push(codageAngle(M1, O, 79, 1, marquageAngle[jj]))\n        texteAMC += this.sup3\n          ? 'marqué par le symbole' +\n            mathalea2d(\n              {\n                xmin: 0,\n                ymin: 0,\n                xmax: 1.2,\n                ymax: 1.2,\n                pixelsParCm: 20,\n                scale: 0.5,\n                style: 'display:inline-block',\n              },\n              marquageAngleConsigne,\n            )\n          : `${couleurRemplissageAngle[1]}`\n        texteAMC +=\n          (this.interactif || context.isAmc) && this.interactifType === 'qcm'\n            ? '.'\n            : `${sp()}?`\n        texte += this.sup > 1 ? `${jj === 0 ? '' : '<br>'}${numAlpha(jj)}` : ''\n        texte += texteAMC\n        if (this.interactif && this.interactifType === 'mathLive') {\n          texte += ajouteChampTexteMathLive(\n            this,\n            i * this.sup + jj,\n            KeyboardType.angles,\n          )\n        }\n        setReponse(this, i * this.sup + jj, resultat, {\n          formatInteractif: 'texte',\n        })\n        objetsCorrection.push(\n          codageAngle(\n            pt1,\n            pt2,\n            ang,\n            tailleAngle,\n            marquageAngle[jj],\n            couleurAngle,\n            2,\n            1,\n            couleurRemplissageAngle[0],\n            1,\n            false,\n            true,\n          ),\n          segmentsCorrection,\n        )\n        texteCorr +=\n          this.sup > 1 ? `${jj === 0 ? '' : '<br>'}${numAlpha(jj)}` : ''\n        texteCorr += \"L'angle \"\n        texteCorr += this.sup3\n          ? 'marqué par le symbole' +\n            mathalea2d(\n              {\n                xmin: 0,\n                ymin: 0,\n                xmax: 1.2,\n                ymax: 1.2,\n                pixelsParCm: 20,\n                scale: 0.5,\n                style: 'display:inline-block',\n              },\n              marquageAngleConsigne,\n            )\n          : `${couleurRemplissageAngle[1]}`\n        texteCorr += ` se nomme, au choix : $${this.sup3 ? miseEnEvidence(resultat[0], 'black') : miseEnEvidence(resultat[0], couleurRemplissageAngle[0])}$`\n        for (let ee = 1; ee < resultat.length; ee++) {\n          texteCorr += `, $${this.sup3 ? miseEnEvidence(resultat[ee], 'black') : miseEnEvidence(resultat[ee], couleurRemplissageAngle[0])}$`\n        }\n        texteCorr += '.'\n        propositionsDuQcm = [\n          {\n            texte: `$${resultatOK1}$`,\n            statut: true,\n          },\n          {\n            texte: `$${resultatOK2}$`,\n            statut: true,\n          },\n          {\n            texte: `$${resultat3}$`,\n            statut: troisBonnesReponses,\n          },\n          {\n            texte: `$${resultatPasOK1}$`,\n            statut: false,\n          },\n          {\n            texte: `$${resultatPasOK2}$`,\n            statut: false,\n          },\n        ]\n        if (this.interactifType === 'qcm') {\n          this.autoCorrection[i * this.sup + jj].enonce = `${texte}\\n`\n          this.autoCorrection[i * this.sup + jj].propositions =\n            propositionsDuQcm\n          this.autoCorrection[i * this.sup + jj].options = {}\n          const props = propositionsQcm(this, i * this.sup + jj)\n          if (this.interactif) texte += props.texte\n        }\n        if (context.isAmc) {\n          propositionsAMC[jj] = {\n            type: 'qcmMult', // on donne le type de la première question-réponse qcmMono, qcmMult, AMCNum, AMCOpen\n            enonce: texteAMC,\n            propositions: propositionsDuQcm,\n          }\n        }\n      }\n      const params = {\n        xmin: Math.min(0, absA, absC) - 1,\n        ymin: ordC - 1,\n        xmax: Math.max(0, absA, absC) + 1,\n        ymax: ordA + 1,\n        pixelsParCm: 20,\n        scale: 0.5,\n      }\n      objetsEnonce.push(\n        p1[0],\n        p1[1],\n        segment(A, N),\n        segment(C, M),\n        labelPoint(M, N, Ibis),\n      )\n      objetsCorrection.push(\n        p1[0],\n        p1[1],\n        segment(A, N),\n        segment(C, M),\n        labelPoint(M, N, Ibis),\n      )\n      const figureExo = mathalea2d(params, objetsEnonce)\n      texte += '<br>' + figureExo\n      texteCorr += '<br>' + mathalea2d(params, objetsCorrection)\n      if (context.isAmc) {\n        this.autoCorrection[i] = {\n          enonce: figureExo,\n          enonceAvant: true, // EE : ce champ est facultatif et permet (si false) de supprimer l'énoncé ci-dessus avant la numérotation de chaque question.\n          enonceCentre: true, // EE : ce champ est facultatif et permet (si true) de centrer le champ 'enonce' ci-dessus.\n          melange: true, // EE : ce champ est facultatif et permet (si false) de ne pas provoquer le mélange des questions.\n          options: { avecSymboleMult: true }, // facultatif. Par défaut, multicols est à false. Ce paramètre provoque un multicolonnage (sur 2 colonnes par défaut) des propositions : pratique quand on met plusieurs AMCNum. !!! Attention, cela ne fonctionne pas, nativement, pour AMCOpen. !!!\n          propositions: propositionsAMC,\n        }\n      }\n      this.listeQuestions.push(texte)\n      this.listeCorrections.push(texteCorr)\n      listeQuestionsToContenu(this)\n    }\n  }\n}\n"],"names":["titre","interactifType","interactifReady","amcType","amcReady","dateDePublication","dateDeModifImportante","uuid","refs","NommerUnAngle","Exercice","context","propositionsDuQcm","i","texteAMC","troisBonnesReponses","resultatOK1","resultatOK2","resultat3","resultatPasOK1","resultatPasOK2","choixAngle","pt1","pt2","pt3","tailleAngle","aleaChoixCouleurRemplissage","couleurRemplissageAngle","couleurAngle","segmentsCorrection","resultat","propositionsAMC","listePt1","listePt3","marquageAngle","combinaisonListes","ChoixHorizontal","choice","numB","randint","numA","numC","numM","numN","numI","ordB","B","pointAbstrait","lettreDepuisChiffre","absA","ordA","A","absC","ordC","C","fractionSegmentAB","fractionSegmentBC","AB","segment","BC","M","pointSurSegment","N","p1","polygoneAvecNom","I","pointIntersectionDD","droite","listePoints","objetsEnonce","objetsCorrection","sommetsDejaTrouves","choixCouleurRemplissage","rangeMinMax","texte","O","M1","texteCorr","positionIbis","Ibis","jj","marquageAngleConsigne","choixSommet","couleurTab","enleveElement","polyline","item1","item3","ang","angleOriente","codageAngle","mathalea2d","sp","numAlpha","ajouteChampTexteMathLive","KeyboardType","setReponse","miseEnEvidence","ee","props","propositionsQcm","params","labelPoint","figureExo","listeQuestionsToContenu"],"mappings":"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"}