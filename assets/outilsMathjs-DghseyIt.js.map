{"version":3,"file":"outilsMathjs-DghseyIt.js","sources":["../../src/modules/NodeType.js","../../src/modules/Change.js","../../src/modules/MathjsInstance.ts","../../src/modules/outilsMathjs.ts"],"sourcesContent":["/*\n  For determining the type of a mathJS node.\n */\n\nexport const NodeType = {}\n\nNodeType.isOperator = function (node, operator = null) {\n  return (\n    node.type === 'OperatorNode' &&\n    node.fn !== 'unaryMinus' &&\n    '*+-/^'.includes(node.op) &&\n    (operator ? node.op === operator : true)\n  )\n}\n\nNodeType.isParenthesis = function (node) {\n  return node.type === 'ParenthesisNode'\n}\n\nNodeType.isUnaryMinus = function (node) {\n  return node.type === 'OperatorNode' && node.fn === 'unaryMinus'\n}\n\nNodeType.isFunction = function (node, functionName = null) {\n  if (node.type !== 'FunctionNode') {\n    return false\n  }\n  if (functionName && node.fn.name !== functionName) {\n    return false\n  }\n  return true\n}\n\nNodeType.isSymbol = function (node, allowUnaryMinus = false) {\n  if (node.type === 'SymbolNode') {\n    return true\n  } else if (allowUnaryMinus && NodeType.isUnaryMinus(node)) {\n    return NodeType.isSymbol(node.args[0], false)\n  } else {\n    return false\n  }\n}\n\nNodeType.isConstant = function (node, allowUnaryMinus = false) {\n  if (node.type === 'ConstantNode') {\n    return true\n  } else if (allowUnaryMinus && NodeType.isUnaryMinus(node)) {\n    if (NodeType.isConstant(node.args[0], false)) {\n      const value = parseFloat(node.args[0].value)\n      return value >= 0\n    } else {\n      return false\n    }\n  } else {\n    return false\n  }\n}\n\nNodeType.isConstantFraction = function (node, allowUnaryMinus = false) {\n  if (NodeType.isOperator(node, '/')) {\n    return node.args.every((n) => NodeType.isConstant(n, allowUnaryMinus))\n  } else {\n    return false\n  }\n}\n\nNodeType.isConstantOrConstantFraction = function (\n  node,\n  allowUnaryMinus = false,\n) {\n  if (\n    NodeType.isConstant(node, allowUnaryMinus) ||\n    NodeType.isConstantFraction(node, allowUnaryMinus)\n  ) {\n    return true\n  } else {\n    return false\n  }\n}\n\nNodeType.isIntegerFraction = function (node, allowUnaryMinus = false) {\n  if (!NodeType.isConstantFraction(node, allowUnaryMinus)) {\n    return false\n  }\n  let numerator = node.args[0]\n  let denominator = node.args[1]\n  if (allowUnaryMinus) {\n    if (NodeType.isUnaryMinus(numerator)) {\n      numerator = numerator.args[0]\n    }\n    if (NodeType.isUnaryMinus(denominator)) {\n      denominator = denominator.args[0]\n    }\n  }\n  return (\n    Number.isInteger(parseFloat(numerator.value)) &&\n    Number.isInteger(parseFloat(denominator.value))\n  )\n}\n","import { ChangeTypes } from 'mathsteps'\nimport { NodeType } from './NodeType'\n\nconst Change = {\n  changeFormatFunctionMap: {},\n}\n\nconst OP_TO_STRING = {\n  '+': 'Combine',\n  '-': 'Combine',\n  '*': 'Multiply',\n  '/': 'Divide',\n}\n\nconst COMPARATOR_TO_STRING = {\n  '=': 'equal to',\n  '>': 'greater than',\n  '>=': 'greater than or equal to',\n  '<': 'less than',\n  '<=': 'less than or equal to',\n}\n\n// Given a step, will return the change and explanation for the change\n// from the oldNode, newNode, and changeType\nChange.formatChange = function (step) {\n  if (!(step.changeType in Change.changeFormatFunctionMap)) {\n    // TODO: add tests that will alert us when a new change type doesn't\n    // have a change function yet\n    console.error(step.changeType + ' does not have a change function!')\n    return step.changeType\n  }\n\n  const changeFormatFunctionMap =\n    Change.changeFormatFunctionMap[step.changeType]\n  const changeDescription = changeFormatFunctionMap(step)\n  if (!changeDescription) {\n    return `\\\\text{${Change.ChangeText[step.changeType]}}`\n  }\n\n  return changeDescription\n}\n\nfunction getChangeNodes(node) {\n  return node.filter((node) => node.changeGroup)\n}\n\nfunction getOldChangeNodes(step) {\n  if (step.oldNode) {\n    return getChangeNodes(step.oldNode)\n  } else if (step.oldEquation) {\n    const leftChangeNodeStrings = getChangeNodes(step.oldEquation.leftNode)\n    const rightChangeNodeStrings = getChangeNodes(step.oldEquation.rightNode)\n    return [...leftChangeNodeStrings, ...rightChangeNodeStrings]\n  }\n  return null\n}\n\nexport function getNewChangeNodes(step) {\n  if (step.newNode) {\n    return getChangeNodes(step.newNode)\n  } else if (step.newEquation) {\n    const leftChangeNodeStrings = getChangeNodes(step.newEquation.leftNode)\n    const rightChangeNodeStrings = getChangeNodes(step.newEquation.rightNode)\n    return [...leftChangeNodeStrings, ...rightChangeNodeStrings]\n  }\n  return null\n}\n\nfunction nodesToString(nodes, duplicates = false) {\n  // get rid of changeGroup so we can find duplicates\n  nodes.forEach((node) => {\n    node.changeGroup = undefined\n  })\n\n  let strings = nodes.map((node) => node.toTex())\n  if (!duplicates) {\n    strings = [...new Set(strings)]\n  }\n\n  if (strings.length === 0) {\n    return ''\n  } else if (strings.length === 1) {\n    return strings[0]\n  } else {\n    return `${strings.slice(0, -1).join(', ')} \\\\text{ and } ${strings.slice(-1)}`\n  }\n}\n\n// e.g. |-3| -> 3\nChange.changeFormatFunctionMap[ChangeTypes.ABSOLUTE_VALUE] = function (step) {\n  const oldNodes = getOldChangeNodes(step)\n  if (oldNodes.length !== 1) {\n    return null\n  }\n\n  const absNode = oldNodes[0]\n  if (!NodeType.isFunction(absNode, 'abs')) {\n    return null\n  }\n\n  const string = absNode.args[0].toTex()\n  return `\\\\text{Take the absolute value of } ${string}`\n}\n\n// e.g. 2x + x -> 2x + 1x\nChange.changeFormatFunctionMap[ChangeTypes.ADD_COEFFICIENT_OF_ONE] = function (\n  step,\n) {\n  const oldNodes = getOldChangeNodes(step)\n  const newNodes = getNewChangeNodes(step)\n  if (oldNodes.length === 0 || newNodes.length !== oldNodes.length) {\n    return null\n  }\n\n  const before = nodesToString(oldNodes)\n  const after = nodesToString(newNodes)\n  return `\\\\text{Rewrite } ${before} \\\\text{ as } ${after}`\n}\n\n// e.g. x^2 * x -> x^2 * x^1\nChange.changeFormatFunctionMap[ChangeTypes.ADD_EXPONENT_OF_ONE] = function (\n  step,\n) {\n  const oldNodes = getOldChangeNodes(step)\n  const newNodes = getNewChangeNodes(step)\n  if (oldNodes.length === 0 || newNodes.length !== oldNodes.length) {\n    return null\n  }\n\n  const before = nodesToString(oldNodes)\n  const after = nodesToString(newNodes)\n  return `\\\\text{Rewrite } ${before} \\\\text{ as } ${after}`\n}\n\n// e.g. 1/2 + 1/3 -> 5/6\nChange.changeFormatFunctionMap[ChangeTypes.ADD_FRACTIONS] = function (step) {\n  const oldNodes = getOldChangeNodes(step)\n  const newNodes = getNewChangeNodes(step)\n  if (oldNodes.length !== 1 || newNodes.length !== 1) {\n    return null\n  }\n\n  const opNode = oldNodes[0]\n  if (\n    !NodeType.isOperator(opNode) ||\n    opNode.op !== '+' ||\n    opNode.args.length > 3\n  ) {\n    return null\n  }\n\n  const before = nodesToString(opNode.args, true)\n  const after = newNodes[0].toTex()\n  return `\\\\text{Add } ${before} \\\\text{ to get } ${after}`\n}\n\n// e.g. (1 + 2)/3 -> 3/3\nChange.changeFormatFunctionMap[ChangeTypes.ADD_NUMERATORS] = function (step) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. x^2 + x^2 -> 2x^2\nChange.changeFormatFunctionMap[ChangeTypes.ADD_POLYNOMIAL_TERMS] = function (\n  step,\n) {\n  const oldNodes = getOldChangeNodes(step)\n  const newNodes = getNewChangeNodes(step)\n  if (oldNodes.length !== 1 || newNodes.length !== 1) {\n    return null\n  }\n\n  const opNode = oldNodes[0]\n  if (!NodeType.isOperator(opNode) || opNode.op !== '+') {\n    return null\n  }\n\n  const before = nodesToString(opNode.args, true)\n  const after = newNodes[0].toTex()\n  return `\\\\text{Add } ${before} \\\\text{ to get } ${after}`\n}\n\n// e.g. x - 3 = 2 -> x - 3 + 3 = 2 + 3\nChange.changeFormatFunctionMap[ChangeTypes.ADD_TO_BOTH_SIDES] = function (\n  step,\n) {\n  // there is a term node on each side of the equation\n  const termNodes = getNewChangeNodes(step)\n  if (termNodes.length !== 2) {\n    return null\n  }\n\n  const term = termNodes[0].toTex()\n  return `\\\\text{Add } ${term} \\\\text{ to both sides}`\n}\n\n// e.g. (x + 2)/2 -> x/2 + 2/2\nChange.changeFormatFunctionMap[ChangeTypes.BREAK_UP_FRACTION] = function (\n  step,\n) {\n  const oldNodes = getOldChangeNodes(step)\n  if (oldNodes.length !== 1) {\n    return null\n  }\n\n  const before = nodesToString(oldNodes)\n  return `\\\\text{Break up the fraction } ${before}`\n}\n\n// e.g. nthRoot(x ^ 2, 4) -> nthRoot(x, 2)\nChange.changeFormatFunctionMap[ChangeTypes.CANCEL_EXPONENT] = function (step) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. nthRoot(x ^ 2, 2) -> x\nChange.changeFormatFunctionMap[ChangeTypes.CANCEL_EXPONENT_AND_ROOT] =\n  function (step) {\n    return `\\\\text{${Change.ChangeText[step.changeType]}}`\n  }\n\n// e.g. nthRoot(x ^ 2, 2) -> x\nChange.changeFormatFunctionMap[ChangeTypes.CANCEL_MINUSES] = function (step) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. nthRoot(x ^ 4, 2) -> x ^ 2\nChange.changeFormatFunctionMap[ChangeTypes.CANCEL_ROOT] = function (step) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. 2x/2 -> x\nChange.changeFormatFunctionMap[ChangeTypes.CANCEL_TERMS] = function (step) {\n  const oldNodes = getOldChangeNodes(step)\n  if (oldNodes.length !== 1) {\n    return null\n  }\n\n  const before = nodesToString(oldNodes)\n  return `\\\\text{Cancel } ${before} \\\\text{ from the numerator and denominator}`\n}\n\n// e.g. 2 + x + 3 + x -> 5 + 2x\nChange.changeFormatFunctionMap[ChangeTypes.COLLECT_AND_COMBINE_LIKE_TERMS] =\n  function (step) {\n    return `\\\\text{${Change.ChangeText[step.changeType]}}`\n  }\n\n// e.g. x^2 * x^3 * x^1 -> x^(2 + 3 + 1)\nChange.changeFormatFunctionMap[ChangeTypes.COLLECT_EXPONENTS] = function (\n  step,\n) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. x + 2 + x^2 + x + 4 -> x^2 + (x + x) + (4 + 2)\nChange.changeFormatFunctionMap[ChangeTypes.COLLECT_LIKE_TERMS] = function (\n  step,\n) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. 2/5 + 1/5 -> (2+1)/5\nChange.changeFormatFunctionMap[ChangeTypes.COMBINE_NUMERATORS] = function (\n  step,\n) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. nthRoot(2, 2) * nthRoot(3, 2) -> nthRoot(2 * 3, 2)\nChange.changeFormatFunctionMap[ChangeTypes.COMBINE_UNDER_ROOT] = function (\n  step,\n) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. 2/6 + 1/4 -> (2*2)/(6*2) + (1*3)/(4*3)\nChange.changeFormatFunctionMap[ChangeTypes.COMMON_DENOMINATOR] = function (\n  step,\n) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. 3 + 1/2 -> 6/2 + 1/2\nChange.changeFormatFunctionMap[ChangeTypes.CONVERT_INTEGER_TO_FRACTION] =\n  function (step) {\n    const oldNodes = getOldChangeNodes(step)\n    const newNodes = getNewChangeNodes(step)\n    if (oldNodes.length !== 1 || newNodes.length !== 1) {\n      return null\n    }\n\n    const before = nodesToString(oldNodes)\n    const after = nodesToString(newNodes)\n    return `\\\\text{Change } ${before} \\\\text{ to } ${after} \\\\text{ so that it has a shared denominator}`\n  }\n\n// e.g. 2 * 2 * 2 -> 2 ^ 3\nChange.changeFormatFunctionMap[ChangeTypes.CONVERT_MULTIPLICATION_TO_EXPONENT] =\n  function (step) {\n    const oldNodes = getOldChangeNodes(step)\n    const newNodes = getNewChangeNodes(step)\n    if (oldNodes.length !== 1 || newNodes.length !== 1) {\n      return null\n    }\n\n    const before = nodesToString(oldNodes)\n    const after = nodesToString(newNodes)\n    return `\\\\text{Rewrite } ${before} \\\\text{ as } ${after}`\n  }\n\n// e.g. 2(x + y) -> 2x + 2y\nChange.changeFormatFunctionMap[ChangeTypes.DISTRIBUTE] = function (step) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. -(2 + x) -> -2 - x\nChange.changeFormatFunctionMap[ChangeTypes.DISTRIBUTE_NEGATIVE_ONE] = function (\n  step,\n) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. nthRoot(2 * x) -> nthRoot(2) * nthRoot(x)\nChange.changeFormatFunctionMap[ChangeTypes.DISTRIBUTE_NTH_ROOT] = function (\n  step,\n) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// 1.2 + 1/2 -> 1.2 + 0.5\nChange.changeFormatFunctionMap[ChangeTypes.DIVIDE_FRACTION_FOR_ADDITION] =\n  function (step) {\n    const oldNodes = getOldChangeNodes(step)\n    const newNodes = getNewChangeNodes(step)\n    if (oldNodes.length !== 1 || newNodes.length !== 1) {\n      return null\n    }\n\n    const before = nodesToString(oldNodes)\n    const after = nodesToString(newNodes)\n    return `\\\\text{Divide } ${before} \\\\text{ so it's in the decimal form } ${after}`\n  }\n\n// e.g. 2x = 1 -> (2x)/2 = 1/2\nChange.changeFormatFunctionMap[ChangeTypes.DIVIDE_FROM_BOTH_SIDES] = function (\n  step,\n) {\n  const termNodes = getNewChangeNodes(step)\n  if (termNodes.length !== 2) {\n    return null\n  }\n\n  const term = termNodes[0].toTex()\n  return `\\\\text{Divide both sides by } ${term}`\n}\n\n// e.g. 2/-1 -> -2\nChange.changeFormatFunctionMap[ChangeTypes.DIVISION_BY_NEGATIVE_ONE] =\n  function (step) {\n    const oldNodes = getOldChangeNodes(step)\n    const newNodes = getNewChangeNodes(step)\n    if (oldNodes.length !== 1 || newNodes.length !== 1) {\n      return null\n    }\n\n    const before = nodesToString(oldNodes)\n    const after = nodesToString(newNodes)\n    return `${before} \\\\text{ divided by -1 is } ${after}`\n  }\n\n// e.g. 2/1 -> 2\nChange.changeFormatFunctionMap[ChangeTypes.DIVISION_BY_ONE] = function (step) {\n  const oldNodes = getOldChangeNodes(step)\n  const newNodes = getNewChangeNodes(step)\n  if (oldNodes.length !== 1 || newNodes.length !== 1) {\n    return null\n  }\n\n  const before = nodesToString(oldNodes)\n  const after = nodesToString(newNodes)\n  return `${before} \\\\text{ divided by 1 is } ${after}`\n}\n\n// e.g. nthRoot(4) * nthRoot(x^2) -> 2 * x\nChange.changeFormatFunctionMap[ChangeTypes.EVALUATE_DISTRIBUTED_NTH_ROOT] =\n  function (step) {\n    return `\\\\text{${Change.ChangeText[step.changeType]}}`\n  }\n\n// e.g. 12 -> 2 * 2 * 3\nChange.changeFormatFunctionMap[ChangeTypes.FACTOR_INTO_PRIMES] = function (\n  step,\n) {\n  const oldNodes = getOldChangeNodes(step)\n  const newNodes = getNewChangeNodes(step)\n  if (\n    oldNodes.length !== 1 ||\n    newNodes.length < oldNodes.length ||\n    newNodes.length > 5\n  ) {\n    return null\n  }\n\n  const before = nodesToString(oldNodes)\n  const after = nodesToString(newNodes)\n  return `\\\\text{Factor } ${before} \\\\text{ into its prime factors: } ${after}`\n}\n\n// e.g. 2x^2 + 3x^2 + 5x^2 -> (2+3+5)x^2\nChange.changeFormatFunctionMap[ChangeTypes.GROUP_COEFFICIENTS] = function (\n  step,\n) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. nthRoot(2 * 2 * 2, 2) -> nthRoot((2 * 2) * 2)\nChange.changeFormatFunctionMap[ChangeTypes.GROUP_TERMS_BY_ROOT] = function (\n  step,\n) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. (2/3)x = 1 -> (2/3)x * (3/2) = 1 * (3/2)\nChange.changeFormatFunctionMap[\n  ChangeTypes.MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION\n] = function (step) {\n  const termNodes = getNewChangeNodes(step)\n  if (termNodes.length !== 2) {\n    return null\n  }\n\n  const term = termNodes[0].toTex()\n  return `\\\\text{Multiply both sides by the inverse } ${term}`\n}\n\n// e.g. -x = 2 -> -1 * -x = -1 * 2\nChange.changeFormatFunctionMap[\n  ChangeTypes.MULTIPLY_BOTH_SIDES_BY_NEGATIVE_ONE\n] = function (step) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. x/(2/3) -> x * 3/2\nChange.changeFormatFunctionMap[ChangeTypes.MULTIPLY_BY_INVERSE] = function (\n  step,\n) {\n  const oldNodes = getOldChangeNodes(step)\n  const newNodes = getNewChangeNodes(step)\n  if (oldNodes.length !== 1 || newNodes.length !== 1) {\n    return null\n  }\n\n  const before = nodesToString(oldNodes, true)\n  const after = nodesToString(newNodes)\n  return `\\\\text{Rewrite } ${before} \\\\text{ as } ${after}`\n}\n\n// e.g. x * 0 -> 0\nChange.changeFormatFunctionMap[ChangeTypes.MULTIPLY_BY_ZERO] = function (step) {\n  const oldNodes = getOldChangeNodes(step)\n  const newNodes = getNewChangeNodes(step)\n  if (oldNodes.length !== 1 || newNodes.length !== 1) {\n    return null\n  }\n\n  const before = nodesToString(oldNodes)\n  const after = nodesToString(newNodes)\n  return `\\\\text{Rewrite } ${before} \\\\text{ as } ${after}`\n}\n\n// e.g. (2 * 3)(x * x) -> 6(x*x)\nChange.changeFormatFunctionMap[ChangeTypes.MULTIPLY_COEFFICIENTS] = function (\n  step,\n) {\n  const oldNodes = getOldChangeNodes(step)\n  const newNodes = getNewChangeNodes(step)\n  if (oldNodes.length !== 1 || newNodes.length !== 1) {\n    return null\n  }\n\n  const opNode = oldNodes[0]\n  if (!NodeType.isOperator(opNode) || opNode.op !== '*') {\n    return null\n  }\n\n  const before = nodesToString(oldNodes, true)\n  const after = newNodes[0].toTex()\n  return `\\\\text{Multiply the coefficients } ${before} \\\\text{ to get } ${after}`\n}\n\n// e.g. (2*2)/(6*2) + (1*3)/(4*3) -> (2*2)/12 + (1*3)/12\nChange.changeFormatFunctionMap[ChangeTypes.MULTIPLY_DENOMINATORS] = function (\n  step,\n) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. 1/2 * 2/3 -> 2/6\nChange.changeFormatFunctionMap[ChangeTypes.MULTIPLY_FRACTIONS] = function (\n  step,\n) {\n  const oldNodes = getOldChangeNodes(step)\n  const newNodes = getNewChangeNodes(step)\n  if (oldNodes.length !== 1 || newNodes.length !== 1) {\n    return null\n  }\n\n  const opNode = oldNodes[0]\n  if (!NodeType.isOperator(opNode) || opNode.op !== '*') {\n    return null\n  }\n\n  const before = nodesToString(opNode.args, true)\n  const after = newNodes[0].toTex()\n  return `\\\\text{Multiply } ${before} \\\\text{ to get } ${after}`\n}\n\n// e.g. (2*2)/12 + (1*3)/12 -> 4/12 + 3/12\nChange.changeFormatFunctionMap[ChangeTypes.MULTIPLY_NUMERATORS] = function (\n  step,\n) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. 2x * x -> 2x ^ 2\nChange.changeFormatFunctionMap[ChangeTypes.MULTIPLY_POLYNOMIAL_TERMS] =\n  function (step) {\n    const oldNodes = getOldChangeNodes(step)\n    const newNodes = getNewChangeNodes(step)\n    if (oldNodes.length !== 1 || newNodes.length !== 1) {\n      return null\n    }\n\n    const opNode = oldNodes[0]\n    if (!NodeType.isOperator(opNode) || opNode.op !== '*') {\n      return null\n    }\n\n    const before = nodesToString(opNode.args, true)\n    const after = newNodes[0].toTex()\n    return `\\\\text{Multiply } ${before} \\\\text{ to get } ${after}`\n  }\n\n// e.g. x/2 = 1 -> (x/2) * 2 = 1 * 2\nChange.changeFormatFunctionMap[ChangeTypes.MULTIPLY_TO_BOTH_SIDES] = function (\n  step,\n) {\n  const termNodes = getNewChangeNodes(step)\n  if (termNodes.length !== 2) {\n    return null\n  }\n\n  const term = termNodes[0].toTex()\n  return `\\\\text{Multiply both sides by } ${term}`\n}\n\n// This should never happen\nChange.changeFormatFunctionMap[ChangeTypes.NO_CHANGE] = function () {\n  return null\n}\n\n// e.g. nthRoot(4) -> 2\nChange.changeFormatFunctionMap[ChangeTypes.NTH_ROOT_VALUE] = function (step) {\n  const oldNodes = getOldChangeNodes(step)\n  if (oldNodes.length !== 1) {\n    return null\n  }\n\n  const before = nodesToString(oldNodes)\n  return `\\\\text{Take the root of } ${before}`\n}\n\n// e.g. x * 2 -> 2x\nChange.changeFormatFunctionMap[ChangeTypes.REARRANGE_COEFF] = function (step) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. x ^ 0 -> 1\nChange.changeFormatFunctionMap[ChangeTypes.REDUCE_EXPONENT_BY_ZERO] = function (\n  step,\n) {\n  const oldNodes = getOldChangeNodes(step)\n  const newNodes = getNewChangeNodes(step)\n  if (oldNodes.length !== 1 || newNodes.length !== 1) {\n    return null\n  }\n\n  const before = nodesToString(oldNodes)\n  const after = nodesToString(newNodes)\n  return `\\\\text{Rewrite } ${before} \\\\text{ as } ${after}`\n}\n\n// e.g. 0/1 -> 0\nChange.changeFormatFunctionMap[ChangeTypes.REDUCE_ZERO_NUMERATOR] = function (\n  step,\n) {\n  const oldNodes = getOldChangeNodes(step)\n  const newNodes = getNewChangeNodes(step)\n  if (oldNodes.length !== 1 || newNodes.length !== 1) {\n    return null\n  }\n\n  const before = nodesToString(oldNodes)\n  const after = nodesToString(newNodes)\n  return `\\\\text{Rewrite } ${before} \\\\text{ as } ${after}`\n}\n\n// e.g. 2 + 0 -> 2\nChange.changeFormatFunctionMap[ChangeTypes.REMOVE_ADDING_ZERO] = function (\n  step,\n) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. x ^ 1 -> x\nChange.changeFormatFunctionMap[ChangeTypes.REMOVE_EXPONENT_BY_ONE] = function (\n  step,\n) {\n  const oldNodes = getOldChangeNodes(step)\n  const newNodes = getNewChangeNodes(step)\n  if (oldNodes.length !== 1 || newNodes.length !== 1) {\n    return null\n  }\n\n  const before = nodesToString(oldNodes)\n  const after = nodesToString(newNodes)\n  return `\\\\text{Rewrite } ${before} \\\\text{ as } ${after}`\n}\n\n// e.g. x * -1 -> -x\nChange.changeFormatFunctionMap[ChangeTypes.REMOVE_MULTIPLYING_BY_NEGATIVE_ONE] =\n  function (step) {\n    const oldNodes = getOldChangeNodes(step)\n    const newNodes = getNewChangeNodes(step)\n    if (oldNodes.length !== 1 || newNodes.length !== 1) {\n      return null\n    }\n\n    const before = nodesToString(oldNodes)\n    const after = nodesToString(newNodes)\n    return `\\\\text{Rewrite } ${before} \\\\text{ as } ${after}`\n  }\n\n// e.g. x * 1 -> x\nChange.changeFormatFunctionMap[ChangeTypes.REMOVE_MULTIPLYING_BY_ONE] =\n  function (step) {\n    const oldNodes = getOldChangeNodes(step)\n    const newNodes = getNewChangeNodes(step)\n    if (oldNodes.length !== 1 || newNodes.length !== 1) {\n      return null\n    }\n\n    const before = nodesToString(oldNodes)\n    const after = nodesToString(newNodes)\n    return `\\\\text{Rewrite } ${before} \\\\text{ as } ${after}`\n  }\n\n// e.g. 2 - - 3 -> 2 + 3\nChange.changeFormatFunctionMap[ChangeTypes.RESOLVE_DOUBLE_MINUS] = function (\n  step,\n) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. 2 + 2 -> 4 or 2 * 2 -> 4\nChange.changeFormatFunctionMap[ChangeTypes.SIMPLIFY_ARITHMETIC] = function (\n  step,\n) {\n  const oldNodes = getOldChangeNodes(step)\n  const newNodes = getNewChangeNodes(step)\n  if (oldNodes.length !== 1 || newNodes.length !== 1) {\n    return null\n  }\n\n  const opNode = oldNodes[0]\n  if (!NodeType.isOperator(opNode) || '+-*/^'.indexOf(opNode.op) === -1) {\n    return null\n  }\n\n  const before = nodesToString(opNode.args, true)\n  const after = newNodes[0].toTex()\n  return `\\\\text{${OP_TO_STRING[opNode.op]} } ${before} \\\\text{ to get } ${after}`\n}\n\n// e.g. 2/3/4 -> 2/(3*4)\nChange.changeFormatFunctionMap[ChangeTypes.SIMPLIFY_DIVISION] = function (\n  step,\n) {\n  const oldNodes = getOldChangeNodes(step)\n  const newNodes = getNewChangeNodes(step)\n  if (oldNodes.length !== 1 || newNodes.length !== 1) {\n    return null\n  }\n\n  const before = nodesToString(oldNodes)\n  const after = nodesToString(newNodes)\n  return `\\\\text{Rewrite } ${before} \\\\text{ as } ${after}`\n}\n\n// e.g. 2/6 -> 1/3\nChange.changeFormatFunctionMap[ChangeTypes.SIMPLIFY_FRACTION] = function (\n  step,\n) {\n  const oldNodes = getOldChangeNodes(step)\n  const newNodes = getNewChangeNodes(step)\n  if (oldNodes.length !== 1 || newNodes.length !== 1) {\n    return null\n  }\n\n  const before = nodesToString(oldNodes)\n  const after = nodesToString(newNodes)\n  return `\\\\text{Simplify } ${before} \\\\text{ to } ${after}`\n}\n\n// e.g. x + 2 - 1 = 3 -> x + 1 = 3\nChange.changeFormatFunctionMap[ChangeTypes.SIMPLIFY_LEFT_SIDE] = function (\n  step,\n) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. x = 3 - 1 -> x = 2\nChange.changeFormatFunctionMap[ChangeTypes.SIMPLIFY_RIGHT_SIDE] = function (\n  step,\n) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. 2/-3 -> -2/3\nChange.changeFormatFunctionMap[ChangeTypes.SIMPLIFY_SIGNS] = function (step) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. 2 * 4x + 2*5 --> 8x + 10\nChange.changeFormatFunctionMap[ChangeTypes.SIMPLIFY_TERMS] = function (step) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. 2 = 2\nChange.changeFormatFunctionMap[ChangeTypes.STATEMENT_IS_FALSE] = function (\n  step,\n) {\n  const comparator = step.newEquation.comparator\n  return `\\\\text{The left side is not ${COMPARATOR_TO_STRING[comparator]} the right side}`\n}\n\n// e.g. 2 = 3\nChange.changeFormatFunctionMap[ChangeTypes.STATEMENT_IS_TRUE] = function (\n  step,\n) {\n  const comparator = step.newEquation.comparator\n  return `\\\\text{The left side is ${COMPARATOR_TO_STRING[comparator]} the right side}`\n}\n\n// e.g. x + 3 = 2 -> x + 3 - 3 = 2 - 3\nChange.changeFormatFunctionMap[ChangeTypes.SUBTRACT_FROM_BOTH_SIDES] =\n  function (step) {\n    const termNodes = getNewChangeNodes(step)\n    if (termNodes.length !== 2) {\n      return null\n    }\n\n    const term = termNodes[0].toTex()\n    return `\\\\text{Subtract } ${term} \\\\text{ from both sides}`\n  }\n\n// e.g. 2 = x -> x = 2\nChange.changeFormatFunctionMap[ChangeTypes.SWAP_SIDES] = function (step) {\n  return `\\\\text{${Change.ChangeText[step.changeType]}}`\n}\n\n// e.g. 2x - x -> 2x - 1x\nChange.changeFormatFunctionMap[ChangeTypes.UNARY_MINUS_TO_NEGATIVE_ONE] =\n  function (step) {\n    const oldNodes = getOldChangeNodes(step)\n    const newNodes = getNewChangeNodes(step)\n    if (oldNodes.length === 0 || newNodes.length !== oldNodes.length) {\n      return null\n    }\n\n    const before = nodesToString(oldNodes)\n    const after = nodesToString(newNodes)\n    return `\\\\text{Rewrite } ${before} \\\\text{ as } ${after}`\n  }\n\nChange.ChangeText = {\n  ABSOLUTE_VALUE: 'Take the absolute value',\n  ADD_COEFFICIENT_OF_ONE: 'Rewrite term to have a coefficient of 1',\n  ADD_EXPONENT_OF_ONE: 'Rewrite term to have an exponent of 1',\n  ADD_FRACTIONS: 'Add the fractions together',\n  ADD_NUMERATORS: 'Add the terms in the numerator',\n  ADD_POLYNOMIAL_TERMS: 'Add the polynomial terms together',\n  ADD_TO_BOTH_SIDES: 'Add the term to both sides',\n  BREAK_UP_FRACTION: 'Break up the fraction',\n  CANCEL_EXPONENT: 'Cancel the exponent',\n  CANCEL_EXPONENT_AND_ROOT: 'Cancel the exponent and the root',\n  CANCEL_MINUSES: 'Cancel the negatives in the numerator and denominator',\n  CANCEL_ROOT: 'Cancel the root',\n  CANCEL_TERMS: 'Cancel like terms in the numerator and denominator',\n  COLLECT_AND_COMBINE_LIKE_TERMS: 'Collect and combine like terms',\n  COLLECT_EXPONENTS: 'Collect the exponents',\n  COLLECT_LIKE_TERMS: 'Identify the like terms and group them together',\n  COMBINE_NUMERATORS: 'Combine the numerators with a shared denominator',\n  COMMON_DENOMINATOR: 'Multiply the terms so they share a common denominator',\n  COMBINE_UNDER_ROOT: 'Combine terms with the same root',\n  CONVERT_INTEGER_TO_FRACTION:\n    'Change the number to a fraction with the same denominator',\n  CONVERT_MULTIPLICATION_TO_EXPONENT:\n    'Change repeatedly multiplying a term to an exponent',\n  DISTRIBUTE: 'Distribute into the parentheses',\n  DISTRIBUTE_NEGATIVE_ONE: 'Distribute -1 into the parentheses',\n  DISTRIBUTE_NTH_ROOT: 'Distribute the root into each term',\n  DIVIDE_FRACTION_FOR_ADDITION:\n    'Divide any fractions to convert it to decimal form',\n  DIVIDE_FROM_BOTH_SIDES: 'Divide the term from both sides',\n  DIVISION_BY_NEGATIVE_ONE:\n    'Rewrite any term divided by -1 as the negative of the term',\n  DIVISION_BY_ONE: 'Rewrite any term divided by 1 as just the term',\n  EVALUATE_DISTRIBUTED_NTH_ROOT: 'Take the root of all the terms',\n  FACTOR_INTO_PRIMES: 'Factor the number into its prime factors',\n  GROUP_COEFFICIENTS: 'Group the coefficients together',\n  GROUP_TERMS_BY_ROOT: 'Group repeating factors',\n  MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION:\n    'Multiply both sides by the inverse of the fraction',\n  MULTIPLY_BOTH_SIDES_BY_NEGATIVE_ONE: 'Multiply both sides by -1',\n  MULTIPLY_BY_INVERSE: 'Rewrite division as multiplication by the inverse',\n  MULTIPLY_BY_ZERO: 'Rewrite any term multiplied by 0 as 0',\n  MULTIPLY_COEFFICIENTS: 'Multiply the coefficients together',\n  MULTIPLY_DENOMINATORS: 'Multiply the terms in the denominators',\n  MULTIPLY_FRACTIONS: 'Multiply the fractions together',\n  MULTIPLY_NUMERATORS: 'Multiply the terms in the numerators',\n  MULTIPLY_POLYNOMIAL_TERMS: 'Multiply the polynomial terms together',\n  MULTIPLY_TO_BOTH_SIDES: 'Multiply the term to both sides',\n  NTH_ROOT_VALUE: 'Take the root of the number',\n  NO_CHANGE: 'No change',\n  REARRANGE_COEFF: 'Move the coefficient to the front of the term',\n  REDUCE_ZERO_NUMERATOR: 'Rewrite zero divided by anything as zero',\n  REMOVE_EXPONENT_BY_ONE: 'Rewrite any term to the power of 1 as itself',\n  REDUCE_EXPONENT_BY_ZERO: 'Rewrite any term to the power of 0 as 1',\n  REMOVE_ADDING_ZERO: 'Remove zero when adding',\n  REMOVE_MULTIPLYING_BY_NEGATIVE_ONE:\n    'Rewrite any term multiplied by -1 as the negative of the term',\n  REMOVE_MULTIPLYING_BY_ONE: 'Rewrite any term multiplied 1 as just the term',\n  RESOLVE_DOUBLE_MINUS: 'Change subtracting a negative to addition',\n  SIMPLIFY_ARITHMETIC: 'Evaluate the arithmetic',\n  SIMPLIFY_DIVISION: 'Rewrite the chain of division',\n  SIMPLIFY_FRACTION:\n    'Simplify by dividing the top and bottom by the greatest common denominator',\n  SIMPLIFY_LEFT_SIDE: 'Simplify the left hand side',\n  SIMPLIFY_RIGHT_SIDE: 'Simplify the right hand side',\n  SIMPLIFY_SIGNS: 'Move the negative sign to the numerator',\n  SIMPLIFY_TERMS: 'Simplify after distributing',\n  STATEMENT_IS_FALSE: 'The statement is False',\n  STATEMENT_IS_TRUE: 'The statement is True',\n  SUBTRACT_FROM_BOTH_SIDES: 'Subtract the term from both sides',\n  SWAP_SIDES: 'Swap sides',\n  UNARY_MINUS_TO_NEGATIVE_ONE: 'Rewrite minus as a coefficient of -1',\n}\n\nexport default Change\n","import {\n  create,\n  evaluateDependencies,\n  formatDependencies,\n  fractionDependencies,\n  gcdDependencies,\n  largerDependencies,\n  largerEqDependencies,\n  lcmDependencies,\n  NodeDependencies,\n  nthRootDependencies,\n  OperatorNode,\n  ParenthesisNode,\n  parseDependencies,\n  pickRandomDependencies,\n  randomDependencies,\n  randomIntDependencies,\n  simplifyDependencies,\n  smallerDependencies,\n  smallerEqDependencies,\n  SymbolNode,\n  type Fraction,\n  type MathNode,\n} from 'mathjs'\n\nconst config = {\n  // optionally, you can specify configuration\n}\n\n// Create just the functions we need\nexport const math = create(\n  {\n    fractionDependencies,\n    lcmDependencies,\n    gcdDependencies,\n    nthRootDependencies,\n    NodeDependencies,\n    formatDependencies,\n    parseDependencies,\n    evaluateDependencies,\n    simplifyDependencies,\n    randomDependencies,\n    pickRandomDependencies,\n    smallerDependencies,\n    largerDependencies,\n    smallerEqDependencies,\n    largerEqDependencies,\n    randomIntDependencies,\n  },\n  config,\n)\n\n// ---- exporter les types ----\nexport { OperatorNode, ParenthesisNode, SymbolNode }\nexport type { Fraction, MathNode }\n","import Decimal from 'decimal.js'\nimport {\n  Equation,\n  factor,\n  Negative,\n  Node,\n  printMS,\n  SIMPLIFICATION_FUNCTIONS,\n  simplifyExpression,\n  solveEquation,\n  TreeSearch,\n} from 'mathsteps'\nimport { choice } from '../lib/outils/arrayOutils'\nimport { obtenirListeFacteursPremiers } from '../lib/outils/primalite'\nimport { texNombre2 } from '../lib/outils/texNombre'\nimport { randint } from '../modules/outils'\nimport { getNewChangeNodes } from './Change'\nimport { context } from './context'\nimport {\n  math,\n  OperatorNode,\n  ParenthesisNode,\n  SymbolNode,\n  type Fraction,\n  type MathNode,\n} from './MathjsInstance'\n\ntype ListeVariable =\n  | 'a'\n  | 'b'\n  | 'c'\n  | 'd'\n  | 'e'\n  | 'f'\n  | 'g'\n  | 'h'\n  | 'i'\n  | 'j'\n  | 'k'\n  | 'l'\n  | 'm'\n  | 'n'\n  | 'o'\n  | 'p'\n  | 'q'\n  | 'r'\n  | 's'\n  | 't'\n  | 'u'\n  | 'v'\n  | 'w'\n  | 'x'\n  | 'y'\n  | 'z'\n  | 'test'\n\nexport type Variables = Partial<\n  Record<ListeVariable, string | number | boolean | Fraction | object>\n>\n\nfunction searchFirstNode(node: MathNode): MathNode {\n  if (node.type === 'OperatorNode') {\n    return searchFirstNode((node as OperatorNode).args[0])\n  } else if (node.type === 'ParenthesisNode') {\n    return searchFirstNode((node as ParenthesisNode).content)\n  }\n  return node\n}\n\nfunction searchLastNode(node: MathNode): MathNode {\n  if (node.type === 'OperatorNode') {\n    return searchLastNode(\n      (node as OperatorNode).args[(node as OperatorNode).args.length - 1],\n    )\n  } else if (node.type === 'ParenthesisNode') {\n    return searchLastNode((node as ParenthesisNode).content)\n  } else {\n    return node\n  }\n}\n\n/**\n * Assignation de variables\n * @param {string} expression\n * @param {Object} variables\n * @returns {string}\n */\nexport function assignVariables(expression: string, variables: Variables) {\n  let node = math.parse(expression)\n  node = node.transform((node: MathNode) => {\n    if (node.type === 'SymbolNode') {\n      const nodeName = (node as SymbolNode).name\n      const variable = variables[nodeName as keyof Variables]\n      if (variable !== undefined) {\n        return new math.ConstantNode(Number(variable))\n      }\n    }\n    return node\n  })\n  return node?.toString({ parenthesis: 'keep' })\n}\n\nfunction transformNode(\n  node: Node,\n  parent: Node,\n  oldNode: Node,\n  params = { suppr1: true, suppr0: true, supprPlusMoins: true },\n) {\n  params = Object.assign(\n    { suppr1: true, suppr0: true, supprPlusMoins: true },\n    params,\n  )\n  if (parent === null && node.isParenthesisNode) node = node.content\n  if (oldNode === undefined || node.toString() !== oldNode.toString()) {\n    oldNode = node.clone()\n    /*\n     * Retirer les parenthèses au dividende et diviseur d'un quotient\n     * (n1)/(n2) devient n1/n2\n     */\n    if (node.isOperatorNode && node.op === '/') {\n      if (node.args[0].isParenthesisNode) {\n        node.args[0] = node.args[0].content\n      }\n      if (node.args[1].isParenthesisNode) {\n        node.args[1] = node.args[1].content\n      }\n    }\n    /*\n     * Transformer -2/n en -(2/n)\n     * Ne touche pas à (-2)/(-n)\n     */\n    if (node.isOperatorNode && node.op === '/') {\n      if (\n        node.args[0].type === 'OperatorNode' &&\n        node.args[0].fn === 'unaryMinus' &&\n        (node.args[0].args[0].type === 'ConstantNode' ||\n          node.args[0].args[0].type === 'SymbolNode') &&\n        !(\n          node.args[1].type === 'OperatorNode' &&\n          node.args[1].fn === 'unaryMinus'\n        )\n      ) {\n        let frac = Node.Creator.operator('/', [\n          node.args[0].args[0],\n          node.args[1],\n        ])\n        frac = Node.Creator.parenthesis(frac)\n        node = math.parse('-' + frac.toString())\n      }\n    }\n    /* (Flatten divisions comme dans Mathsteps)\n     * Transformer (1/2*3)/4 en 1/2*(3/4)\n     */\n    if (node.isOperatorNode && node.op === '/') {\n      if (node.args[0].isOperatorNode && node.args[0].op === '*') {\n        if (\n          node.args[0].args[0].isOperatorNode &&\n          node.args[0].args[0].op === '/'\n        ) {\n          const frac1 = Node.Creator.operator('/', node.args[0].args[0].args)\n          const frac2 = Node.Creator.operator('/', [\n            node.args[0].args[1],\n            node.args[1],\n          ])\n          node = Node.Creator.operator('*', [frac1, frac2])\n        }\n      }\n    }\n    /*\n     * Transformer (n1)+(n2) en n1+n2\n     * Utile si n1 et/ou n2 sont des unaryMinus ou des fractions\n     */\n    if (node.isOperatorNode && node.op === '+') {\n      if (params.supprPlusMoins) {\n        if (node.args[0].isParenthesisNode) node.args[0] = node.args[0].content\n        if (node.args.length > 1 && node.args[1].isParenthesisNode) {\n          node.args[1] = node.args[1].content\n        }\n      } else {\n        if (\n          node.args[0].isParenthesisNode &&\n          node.args[0].content.toString()[0] !== '-' &&\n          node.args[0].content.toString()[0] !== '+'\n        ) {\n          node.args[0] = node.args[0].content\n        }\n        if (\n          node.args.length > 1 &&\n          node.args[1].isParenthesisNode &&\n          node.args[1].content.toString()[0] !== '-' &&\n          node.args[1].content.toString()[0] !== '+'\n        ) {\n          node.args[1] = node.args[1].content\n        }\n      }\n    }\n    /*\n     * Transformer n+0 en n\n     */\n    if (\n      params.suppr0 &&\n      node.isOperatorNode &&\n      node.op === '+' &&\n      node.fn !== 'unaryPlus'\n    ) {\n      if (node.args[1].toString() === '0') {\n        node = node.args[0]\n      }\n    }\n    /*\n     * Transformer n1+0*n2 en n1\n     */\n    if (\n      params.suppr0 &&\n      node.isOperatorNode &&\n      node.op === '+' &&\n      node.fn !== 'unaryPlus'\n    ) {\n      if (\n        node.args[1].isOperatorNode &&\n        node.args[1].op === '*' &&\n        node.args[1].args[0].toString() === '0'\n      ) {\n        node = node.args[0]\n      }\n    }\n    /*\n     * Transformer 1*n en n et -1*n en -n\n     */\n    if (\n      params.suppr1 &&\n      node.isOperatorNode &&\n      node.op === '*' &&\n      searchFirstNode(node.args[1]).type !== 'ConstantNode'\n    ) {\n      if (node.args[0].toString() === '1') {\n        node = node.args[1]\n      } else if (node.args[0].toString() === '-1') {\n        node = math.parse('-' + node.args[1].toString())\n      }\n    }\n    /*\n     * Transformer n/1 en n et n/-1 en -n\n     */\n    if (params.suppr1 && node.type === 'OperatorNode' && node.op === '/') {\n      if (node.args[1].toString() === '1') {\n        node = node.args[0]\n      } else if (node.args[1].toString() === '-1') {\n        node = math.parse('-' + node.args[0].toString())\n      }\n    }\n    /*\n     * Transformer (n1)-n2 en n1-n2\n     * Transformer --c en -(-c)\n     * transformer n1-(n2/n3) en n1-n2/n3\n     */\n    if (node.isOperatorNode && node.op === '-') {\n      // Enlève les parenthèses au premier terme d'une soustraction et au second sous condition d'une /\n      if (node.args[0].isParenthesisNode) node.args[0] = node.args[0].content\n      if (\n        node.args.length === 1 &&\n        node.args[0].isConstantNode &&\n        node.args[0].value < 0\n      ) {\n        // Pour corriger --3 en -(-3)\n        node.args[0] = Node.Creator.parenthesis(node.args[0])\n      }\n      if (\n        node.args.length === 2 &&\n        node.args[1].isConstantNode &&\n        node.args[1].value < 0\n      ) {\n        // Pour corriger 7--3 en 7-(-3)\n        node.args[1] = Node.Creator.parenthesis(node.args[1])\n      }\n      if (\n        node.args.length === 2 &&\n        node.args[1].isParenthesisNode &&\n        node.args[1].content.toString()[0] !== '-'\n      ) {\n        node.args[1] = node.args[1].content\n      }\n      /*\n       * Code à simplifier ?\n       */\n      if (\n        node.fn !== 'unaryMinus' && // On vérifie si c'est une vraie soustraction (avec deux termes)\n        node.args[1].isParenthesisNode && // On vérifie que le second terme possède une parenthèse\n        node.args[1].content.isOperatorNode && // On vérifie que le second terme contient une opération\n        (node.args[1].content.op === '/' || // On teste si cette opération est une division\n          (node.args[1].content.op === '*' && // On teste si c'est une multiplication\n            (!node.args[1].content.args[0].isOperatorNode || // Si le premier facteur n'est pas une opération\n              (node.args[1].content.args[0].isOperatorNode && // Ou si c'est une opération\n                node.args[1].content.args[0].fn !== 'unaryMinus')))) // mais que le premier argument n'est pas -blabla\n      ) {\n        node.args[1] = node.args[1].content\n      }\n    }\n    if (node.isOperatorNode && node.op === '*') {\n      // Enlève les parenthèses aux deux facteurs d'une multiplication\n      if (\n        node.args[0].isParenthesisNode && // On cherche à l'intérieur d'une parenthèse\n        (!node.args[0].content.isOperatorNode || // Il ne faut pas d'opération\n          (node.args[0].content.isOperatorNode &&\n            node.args[0].content.op === '/') || // ou alors une divisions\n          (node.args[0].content.isOperatorNode &&\n            node.args[0].content.fn === 'unaryMinus' &&\n            params.supprPlusMoins)) // ou alors un -n\n      ) {\n        // Si l'une des conditions est vérifiée alors :\n        node.args[0] = node.args[0].content // on enlève la parenthèse\n        node.implicit = false // on fait en sorte que la multiplication soit visible\n      }\n      if (\n        node.args[1].isParenthesisNode &&\n        (!node.args[1].content.isOperatorNode ||\n          (node.args[1].content.isOperatorNode &&\n            node.args[1].content.op === '/' &&\n            !(\n              node.args[1].content.args[0].type === 'OperatorNode' &&\n              node.args[1].content.args[0].fn === 'unaryMinus' &&\n              node.args[1].content.args[0].args[0].type === 'ConstantNode' &&\n              !(\n                node.args[1].content.args[1].type === 'OperatorNode' &&\n                node.args[1].content.args[1].fn === 'unaryMinus'\n              )\n            )))\n      ) {\n        node.args[1] = node.args[1].content\n        node.implicit = false\n      }\n    }\n    if (node.type === 'OperatorNode' && node.op === '*') {\n      // Corrige n*-c en n*(-c)\n      if (node.args[1].toString()[0] === '-') {\n        node.args[1] = Node.Creator.parenthesis(node.args[1])\n      }\n    }\n    // Peut-être faut-il mettre à jour le mathjs de mathsteps car il semble que le code suivant ne fonctionne pas\n    // dans mathsteps lorsqu'il est placé dans print de mathsteps\n    // alors qu'il fonctionne avec la version mathjs de mathalea\n    if (node.isOperatorNode && node.op === '*') {\n      // Multiplication implicite 2*x devient 2x et 2*(x+3) devient 2(x+3)\n      if (\n        (node.args[1].type === 'ParenthesisNode' ||\n          node.args[1].type === 'SymbolNode') &&\n        !(searchLastNode(node.args[0]).type === 'SymbolNode')\n      ) {\n        node.implicit = true\n      }\n      if (\n        node.args[1].isOperatorNode &&\n        node.args[1].op === '^' &&\n        node.args[1].args[0].isSymbolNode\n      ) {\n        node.implicit = true\n      }\n    }\n    if (node.isOperatorNode && node.op === '*') {\n      // Multiplication explicite x*2 ou x*2/3\n      if (node.args[1].isConstantNode) node.implicit = false\n      if (node.args[1].isOperatorNode && node.args[1].args[0].isConstantNode) {\n        node.implicit = false\n      }\n      if (node.args[1].isOperatorNode && node.args[1].op === '/') {\n        node.implicit = false\n      }\n      if (\n        node.args[1].isOperatorNode &&\n        node.args[1].args[0].isOperatorNode &&\n        node.args[1].args[0].op === '/'\n      ) {\n        node.implicit = false\n      }\n      if (\n        node.args[1].isParenthesisNode &&\n        node.args[1].content.isOperatorNode &&\n        node.args[1].content.fn === 'unaryMinus'\n      ) {\n        node.implicit = false\n      }\n    }\n    if (\n      node.isParenthesisNode &&\n      node.content.isOperatorNode &&\n      (node.content.op === '*' || node.content.op === '^') &&\n      node.content.toString()[0] !== '-'\n    ) {\n      node = node.content\n    }\n    if (\n      node.isParenthesisNode &&\n      node.content.isOperatorNode &&\n      node.content.op === '/'\n    ) {\n      node = node.content\n    }\n    if (\n      node.isOperatorNode &&\n      node.fn === 'unaryMinus' &&\n      node.args[0].isParenthesisNode &&\n      node.args[0].content.isOperatorNode &&\n      node.args[0].content.op === '*'\n    ) {\n      node.args[0] = node.args[0].content\n    }\n    if (\n      node.isOperatorNode &&\n      node.fn === 'unaryMinus' &&\n      node.args[0].isOperatorNode &&\n      node.args[0].op === '*'\n    ) {\n      node = Node.Creator.operator('*', [\n        Negative.negate(node.args[0].args[0]),\n        node.args[0].args[1],\n      ])\n    }\n    // n(c*n) = n*(c*n) Je ne sais plus pourquoi !\n    if (node.isOperatorNode && node.op === '*') {\n      const firstNode = searchFirstNode(node.args[1])\n      if (firstNode.type === 'ConstantNode') {\n        node.implicit = false\n      }\n    }\n    return transformNode(node, parent, oldNode, params)\n  } else {\n    return node\n  }\n}\n\n/**\n * Retourne le format Latex d'un node mathjs ou mathsteps ou d'une expression ascii\n * Supprime les parenthèses inutiles, les 1 et les 0 inutiles, transforme les +- en -\n * @param {string|Object} node // Chaine de caractères décrivant une expression mathématique, une équation, une inéquation ou bien node mathjs\n * @param {Object} params // Paramètres\n * @returns {string} // Format latex\n * @example\n * toTex('3/2+4*x') -> \\dfrac{3}{2}+4x\n * toTex('1*x+-3=6*x+0') -> x-3=6x\n * toTex('-3/4') -> -\\dfrac{3}{4}\n * toTex('OA/OM=OB/ON',{OA: 1.2, OM: 1.5, OB: 1.7}) -> \\dfrac{1{.}2}{1{.}5}=\\dfrac{1{.}7}{OB}\n */\nexport function toTex(\n  node: MathNode | string,\n  params: {\n    suppr1?: boolean\n    suppr0?: boolean\n    supprPlusMoins?: boolean\n    variables?: Variables\n    removeImplicit?: boolean\n    rearrangeCoefficient?: boolean\n    removeMultiplicationByNegativeOne?: boolean\n  } = {\n    suppr1: true,\n    suppr0: true,\n    supprPlusMoins: true,\n    variables: undefined,\n    removeImplicit: true,\n    rearrangeCoefficient: true,\n    removeMultiplicationByNegativeOne: true,\n  },\n): string {\n  params = Object.assign(\n    { suppr1: true, suppr0: true, supprPlusMoins: true },\n    params,\n  )\n\n  // On commence par convertir l'expression en arbre au format mathjs\n  let comparator\n  let sides: string[] = []\n  const comparators = ['=', '<', '>', '<=', '>=']\n  if (typeof node === 'string') {\n    for (let i = 0; i < comparators.length; i++) {\n      sides = node.split(comparators[i])\n      if (sides.length > 1) {\n        comparator = comparators[i]\n      }\n    }\n    if (comparator !== undefined) {\n      sides = node.split(comparator)\n      if (sides.length > 1) {\n        const members = []\n        for (let i = 0; i < sides.length; i++) {\n          members.push(toTex(sides[i], params))\n        }\n        return members.join(\n          comparator\n            ?.replaceAll('>=', '\\\\geqslant')\n            .replaceAll('<=', '\\\\leqslant'),\n        )\n      }\n    }\n  }\n\n  // On commence par convertir l'expression en arbre au format mathjs\n  let nodeCopy: MathNode\n  if (typeof node === 'string') {\n    nodeCopy = math.parse(node)\n  } else {\n    nodeCopy = node.cloneDeep()\n  }\n  if (params.variables) {\n    nodeCopy = math.parse(\n      assignVariables(printMS.ascii(nodeCopy, false, true), params.variables),\n    )\n  }\n\n  // Look for basic step(s) to perform on a node. Returns a Node.Status object.\n  function basics(node: MathNode) {\n    const removeAdditionOfZero = SIMPLIFICATION_FUNCTIONS.removeAdditionOfZero\n    const removeMultiplicationByOne =\n      SIMPLIFICATION_FUNCTIONS.removeMultiplicationByOne\n    const reduceMultiplicationByZero =\n      SIMPLIFICATION_FUNCTIONS.reduceMultiplicationByZero\n    const removeDivisionByOne = SIMPLIFICATION_FUNCTIONS.removeDivisionByOne\n    const rearrangeCoefficient = SIMPLIFICATION_FUNCTIONS.rearrangeCoefficient\n    const reduceZeroDividedByAnything =\n      SIMPLIFICATION_FUNCTIONS.reduceZeroDividedByAnything\n    const removeExponentByOne = SIMPLIFICATION_FUNCTIONS.removeExponentByOne\n    const removeExponentBaseOne = SIMPLIFICATION_FUNCTIONS.removeExponentBaseOne\n    const reduceExponentByZero = SIMPLIFICATION_FUNCTIONS.reduceExponentByZero\n    const removeMultiplicationByNegativeOne =\n      SIMPLIFICATION_FUNCTIONS.removeMultiplicationByNegativeOne\n    const functionsToTest = [\n      removeAdditionOfZero,\n      removeMultiplicationByOne,\n      removeDivisionByOne,\n      params.rearrangeCoefficient ? rearrangeCoefficient : null,\n      reduceZeroDividedByAnything,\n      removeExponentByOne,\n      removeExponentBaseOne,\n      reduceExponentByZero,\n      params.removeMultiplicationByNegativeOne\n        ? removeMultiplicationByNegativeOne\n        : null,\n      reduceMultiplicationByZero,\n    ]\n    for (let i = 0; i < functionsToTest.length; i++) {\n      if (functionsToTest[i] === null) continue\n      const nodeStatus = functionsToTest[i](node)\n      if (nodeStatus.hasChanged()) {\n        return nodeStatus\n      } else {\n        node = nodeStatus.newNode\n      }\n    }\n    return Node.Status.noChange(node)\n  }\n\n  const searchBasics = TreeSearch.preOrder(basics)\n\n  let nodeClone\n  let iter = 0\n  const MAX_STEP_COUNT = 20\n  do {\n    // À étudier, pour 79 et 85 et 50 cette boucle doit être maintenue\n    nodeClone = nodeCopy.cloneDeep() // Vérifier le fonctionnement de .clone() et .cloneDeep() (peut-être y a-t-il un problème avec implicit avec cloneDeep())\n    const result = searchBasics(nodeCopy)\n    if (result.changeType !== 'NO_CHANGE') {\n      nodeCopy = result.newNode\n    }\n    nodeCopy = SIMPLIFICATION_FUNCTIONS.removeUnnecessaryParens(nodeCopy, true)\n    iter++\n    if (iter++ === MAX_STEP_COUNT) {\n      // eslint-disable-next-line\n      console.error(\n        'Math error: Potential infinite loop for toTex: ' +\n          node.toString() +\n          ', returning no steps',\n      )\n      break\n    }\n  } while (nodeCopy.toString() !== nodeClone.toString())\n\n  // le problème est due certains sympboles sont déclarer comme des unités et donc il réajoute mathrm\n  const showPlusMinus = false\n  const forceMultiplySign = params.removeImplicit === false || false\n  const flattenUsed = true\n  const forceAddParenthesis = true\n  const postAction = [\n    (node: MathNode) => {\n      const resuNode = node.transform((nodeChild) => {\n        const resultStatus =\n          SIMPLIFICATION_FUNCTIONS.simplifyFractionSignsBefore(nodeChild)\n        if (resultStatus.hasChanged()) {\n          return resultStatus.newNode\n        }\n        return nodeChild\n      })\n      return resuNode\n    },\n  ]\n  const resu = printMS\n    .latex(\n      nodeCopy,\n      showPlusMinus,\n      forceMultiplySign,\n      flattenUsed,\n      forceAddParenthesis,\n      [],\n    )\n    .replaceAll('\\\\mathrm', '')\n    .replaceAll(\n      '\\\\times \\\\dfrac',\n      `${forceMultiplySign ? '\\\\times \\\\dfrac' : '\\\\dfrac'}`,\n    )\n    .replace('undefined', '')\n\n  return resu\n}\n\nexport function toString(\n  node: MathNode | string,\n  params = {\n    suppr1: true,\n    suppr0: true,\n    supprPlusMoins: true,\n    variables: undefined,\n  },\n) {\n  params = Object.assign(\n    { suppr1: true, suppr0: true, supprPlusMoins: true },\n    params,\n  )\n  // On commence par convertir l'expression en arbre au format mathjs\n  let nodeCopy: MathNode\n  if (typeof node === 'string') {\n    nodeCopy = math.parse(node)\n  } else {\n    nodeCopy = node.cloneDeep()\n  }\n\n  if (params.variables) {\n    nodeCopy = math.parse(aleaExpression(nodeCopy.toString(), params.variables))\n  }\n  printMS.ascii(nodeCopy)\n  let nodeClone\n  do {\n    // À étudier, pour 79 et 85 et 50 cette boucle doit être maintenue\n    nodeClone = nodeCopy.cloneDeep() // Vérifier le fonctionnement de .clone() et .cloneDeep() (peut-être y a-t-il un problème avec implicit avec cloneDeep())\n    nodeCopy = nodeCopy.transform(function (nodeTree, path, parent) {\n      return transformNode(nodeTree, parent, undefined, params)\n    })\n  } while (nodeCopy.toString() !== nodeClone.toString())\n\n  // if (node.isConstantNode && node.value === undefined) nodeTex = ''\n  return nodeCopy\n    .toString({ implicit: 'show', parenthesis: 'keep' })\n    .replace(/\\s*?\\+\\s*?-\\s*?/g, ' - ')\n}\n\nexport function expressionLitterale(\n  expression = '(a*x+b)*(c*x-d)',\n  assignations: Variables = { a: 1, b: 2, c: 3, d: -6 },\n  rules?: { l: string; r: string }[],\n) {\n  // Ne pas oublier le signe de la multiplication\n  return math.simplify(\n    expression,\n    rules ?? [\n      { l: '1*n', r: 'n' },\n      { l: '-1*n', r: '-n' },\n      { l: 'n/1', r: 'n' },\n      { l: 'c/c', r: '1' },\n      { l: '0*v', r: '0' },\n      { l: '0+v', r: 'v' },\n    ],\n    assignations,\n  )\n}\n\n/**\n * @deprecated // A cause de l'utilisation dépréciée de aleaVariables\n */\nexport function aleaExpression(\n  expression: string = '(a*x+b)*(c*x-d)',\n  assignations: Variables = { a: 1, b: 2, c: 3, d: -6 },\n) {\n  // const assignationsDecimales = Object.assign({}, assignations)\n  const assignationsDecimales = Object.assign({}, aleaVariables(assignations))\n  for (const [assignation, value] of Object.entries(assignationsDecimales)) {\n    if (typeof value !== 'number') {\n      assignationsDecimales[assignation as keyof Variables] = value.valueOf()\n    }\n  }\n  return assignVariables(expression, assignationsDecimales)\n}\n\n/**\n * @deprecated // A cause de la génération d'une graine, cette fonction crée des différences entre la sortie HTML et la sortie PDF.\n * @description Retourne des valeurs aléatoires sous certaines contraintes données.\n * Les calculs se font si possible avec mathjs au format fraction\n * @param {Object} variables // Propriété réservée : test\n * @param {Object} params // valueOf à true pour avoir les valeurs décimales, format à true pour appliquer texNombre2\n * // type à 'decimal' et valueOf à true pour obtenir des instances de Decimal()\n * @returns {Object}\n * @see {@link https://mathjs.org/docs/expressions/syntax.html|Mathjs}\n * @see {@link https://coopmaths.fr/documentation/tutorial-Outils_Mathjs.html|Mathjs}\n * @example\n * aleaVariable({a: true}, {valueOf: true}) --> {a: -3} // Génère un entier non nul entre -10 et 10\n * aleaVariable({a: true, b: true}, {valueOf: true}) --> {a: 5, b: -7}\n * aleaVariable({a: false, b: false}, {valueOf: true}) --> {a: 4, b: 1} // false => entier entre 1 et 10\n * aleaVariable({a: true, b: true, test: 'a>b'}, {valueOf: true}) --> {a: 3, b: 1}\n * aleaVariable({a: true, b: true, test: 'a+b>2'}, {valueOf: true}) --> {a: 10, b: -6}\n * aleaVariables({a: true}) --> {a: Fraction} // Fraction est un objet de mathjs\n * @author Frédéric PIOU\n */\nexport function aleaVariables(\n  variables: Variables = { a: true, b: true, c: true, d: true },\n  params = { valueOf: true, format: false, type: 'number' },\n): Variables {\n  // Conservation de la graine aléatoire\n  math.config({ randomSeed: context.graine })\n  // Placer dans cet objet chacune des variables après calcul\n  const assignations: Variables = {}\n  // Un compteur pour vérifier que les contraintes ne sont pas excessives\n  let cpt = 0\n  // Le test pour vérifier que les contraintes sont respectées\n  // Remarque : Il serait plus pratique de pouvoir écrire le test en plusieurs lignes\n  let test = true\n  do {\n    // Une boucle tant que les contraintes ne sont pas vérifiées et tant qu'on ne dépasse pas 1000 essais.\n    cpt++\n    for (const v of Object.keys(variables)) {\n      // On parcourt chaque variable\n      switch (typeof variables[v as keyof Variables]) {\n        case 'object':\n          break\n        case 'boolean': // On génère un nombre aléatoire non nul entre 1 et 10 si false et entre -10 et 10 si true\n          const n = variables[v as keyof Variables] ? 1 : 0\n\n          // Choix aléatoire entre -1 et +1\n          const sign = choice<number>([-1, 1])\n\n          // Valeur de base (aléatoire entre 1 et 9 inclus)\n          const value = randint(1, 10)\n\n          // Si n = 0 -> pas de signe (car sign 1), sinon on garde le signe\n          const result = (n === 0 ? 1 : sign) * value\n\n          assignations[v as keyof Variables] = math.fraction(result)\n          break\n        case 'number': // On ne fait que le convertir en fraction\n          if (params.type === 'decimal') {\n            assignations[v as keyof Variables] = math.bignumber(\n              String(variables[v as keyof Variables]),\n            )\n          } else {\n            assignations[v as keyof Variables] = math.fraction(\n              Number(variables[v as keyof Variables]),\n            )\n          }\n          break\n        case 'string':\n          // Parser l'expression\n          // Parcourir le noeud et repérer les points sensibles (division, décimaux)\n          try {\n            // On tente les calculs exacts avec mathjs\n            if (params.type === 'decimal') {\n              math.config({ number: 'BigNumber' })\n              assignations[v as keyof Variables] = math.evaluate(\n                String(variables[v as keyof Variables]),\n                assignations,\n              )\n              math.config({ number: 'number' })\n            } else if (params.type === 'fraction') {\n              math.config({ number: 'Fraction' })\n              assignations[v as keyof Variables] = math.evaluate(\n                String(variables[v as keyof Variables]),\n                assignations,\n              )\n              math.config({ number: 'number' })\n            } else {\n              assignations[v as keyof Variables] = math.evaluate(\n                String(variables[v as keyof Variables]),\n                assignations,\n              )\n            }\n          } catch {\n            // Sinon on cherche à la transformer en fraction après coup\n            try {\n              if (params.type === 'decimal') {\n                assignations[v as keyof Variables] = math.bignumber(\n                  math.evaluate(\n                    String(variables[v as keyof Variables]),\n                    assignations,\n                  ),\n                )\n              } else {\n                assignations[v as keyof Variables] = math.fraction(\n                  math.evaluate(\n                    String(variables[v as keyof Variables]),\n                    assignations,\n                  ),\n                )\n              }\n            } catch {\n              // Sinon on fait sans mais on revient à des nombres de type 'number'\n              const values = Object.assign({}, assignations)\n              for (const v of Object.keys(values)) {\n                values[v as keyof Variables] =\n                  values[v as keyof Variables]?.valueOf()\n              }\n              if (params.type === 'decimal') {\n                math.config({ number: 'BigNumber' })\n                assignations[v as keyof Variables] = math.evaluate(\n                  String(variables[v as keyof Variables]),\n                  values,\n                )\n                math.config({ number: 'number' })\n              } else {\n                assignations[v as keyof Variables] = math.evaluate(\n                  String(variables[v as keyof Variables]),\n                  values,\n                )\n              }\n            }\n          }\n          break\n      }\n    }\n    // On teste maintenant si les contraintes sont vérifiées\n    if (variables.test !== undefined) {\n      test = math.evaluate(String(variables.test), assignations)\n    }\n  } while (!test && cpt < 1000)\n  if (cpt === 1000) {\n    window.notify(\n      'Attention ! 1000 essais dépassés.\\n Trop de contraintes.\\n Le résultat ne vérifiera pas le test.',\n      { test: variables.test },\n    )\n  }\n  if (params.valueOf) {\n    for (const v of Object.keys(assignations)) {\n      if (typeof assignations[v as keyof Variables] !== 'number') {\n        if (!(assignations[v as keyof Variables] instanceof Decimal)) {\n          assignations[v as keyof Variables] =\n            assignations[v as keyof Variables]?.valueOf()\n        }\n      }\n    }\n  }\n  if (params.format) {\n    for (const v of Object.keys(assignations)) {\n      assignations[v as keyof Variables] = texNombre2(\n        Number(assignations[v as keyof Variables]),\n      )\n    }\n  }\n  return assignations\n}\n\n/*\n * Objet mathsteps : Permet de traverser toutes les étapes et sous-étapes\n */\nexport function traverserEtapes<\n  T extends { changeType: string; substeps: any[] },\n>(\n  steps: T[],\n\n  changeType: string[] = [],\n  result: T[] = [],\n) {\n  steps.forEach(function (step) {\n    if (changeType.length === 0) {\n      // on récupère toutes les substeps s'il y en a\n      if (step.substeps.length === 0) {\n        result.push(step)\n      } else {\n        traverserEtapes(step.substeps, changeType, result)\n      }\n    } else {\n      if (\n        changeType.some((x) =>\n          step.substeps.some((substep) => substep.changeType === x),\n        )\n      ) {\n        // si sous step contient un changement de type\n        traverserEtapes(step.substeps, changeType, result)\n      } else if (\n        changeType.some((x) => step.changeType === x) &&\n        step.substeps.length > 0\n      ) {\n        // si step contient un changement de type\n        traverserEtapes(step.substeps, changeType, result)\n      } else {\n        result.push(step)\n      }\n    }\n  })\n  return result\n}\n\n/**\n * @description Retourne toutes les étapes de calculs d'une expression numérique ou de développement-réduction d'une expression littérale\n * @param {string} expression // Une expression à calculer ou à développer\n * @param {object} params // Les paramètres (commentaires visibles , sous-étapes visibles, fraction-solution au format MixedNumber)\n */\ninterface CalculerResult {\n  result: any\n  printResult: string\n  netapes: number\n  texteDebug: string\n  texte: string\n  texteCorr: string\n  stepsLatex: string[]\n  steps: any\n  commentaires: any[]\n  printExpression: string\n  name: any\n}\n\nexport function calculer(\n  expression: string,\n  params?: {\n    comment?: boolean\n    comments?: Record<string, string>\n    substeps?: boolean\n    mixed?: boolean\n    name?: string\n    suppr1?: boolean\n    removeImplicit?: boolean\n    removeMultiplicationByNegativeOne?: boolean\n    variables?: Variables\n    totex?: any\n  },\n): CalculerResult {\n  params = Object.assign(\n    {\n      comment: false,\n      comments: {},\n      substeps: false,\n      mixed: false,\n      name: undefined,\n      suppr1: true,\n      removeImplicit: true,\n    },\n    params,\n  )\n  // La fonction simplifyExpression est une fonction mathsteps\n  // Elle renvoie toutes les étapes d'un calcul numérique ou d'un développement-réduction\n  // L'addition de deux fractions est classée dans les sous-étapes bizarrement\n  // Les calculs se font de la gauche vers la droite et dès que c'est possible dans le respect des priorités\n  // Les termes de même nature sont regroupés avant d'effectuer les calculs :\n  // Les SymbolNode par exposant décroissant, puis Les constantes et enfin les fractions\n  // Parfois les COLLECT LIKE TERMS ne donnent pas de changement ???\n  // A faire : Virer l'étape précédent un REMOVE MULTIPLYING BY ONE et lui prendre son commentaire\n  // A faire : Même chose pour REMOVE ADDING ZERO\n  // La suite de CANCEL TERMS peut être applanie\n  // Refaire la méthode transform() pour qu'elle ne modifie rien d'autre de notre noeud que ce qu'on souhaite\n  // Si ça fonctionne on peut régler le problème des implicit qui disparaissent ? des (-3)² qui deviennent -3² ?\n  // A faire : Ajouter un paramètre parenthesis à chaque noeud, ou il faudrait le faire dans Mathjs ?\n  // BUG : http://localhost:8080/mathalea.html?ex=betaEquations,s=125\n  if (params.variables !== undefined) {\n    expression = aleaExpression(expression, params.variables)\n  }\n  const expressionPrint = toTex(expression, params)\n  const steps: {\n    oldNode: any\n    newNode: any\n    changeType: string\n  }[] = params.substeps\n    ? traverserEtapes(simplifyExpression(expression))\n    : simplifyExpression(expression)\n  const stepsExpression: string[] = []\n  // const commentaires = []\n  const comments: any[] = []\n  steps.forEach(function (step, i: number) {\n    const oldNode = step.oldNode !== null ? toTex(step.oldNode, params) : ''\n    const newNode = toTex(step.newNode, params)\n    if (newNode === oldNode) stepsExpression.pop()\n    if (params.comment) {\n      const comment = commentStep(step, params.comments)\n      // const commentaire = `\\\\text{${step.changeType}}`.replaceAll('_', ' ')\n      // commentaires.push(commentaire)\n      comments.push(comment)\n      if (stepsExpression.length === 0 || i === steps.length - 1) {\n        if (params.name === undefined) {\n          stepsExpression.push(`${expressionPrint}&=${newNode}&&${comment}`)\n        } else {\n          if (stepsExpression.length === 0) {\n            stepsExpression.push(\n              `${params.name}&=${expressionPrint}&&${comment}`,\n            )\n            stepsExpression.push(`&=${newNode}&&${comment}`)\n          } else {\n            stepsExpression.push(`${params.name}&=${newNode}&&${comment}`)\n          }\n        }\n      } else {\n        stepsExpression.push(`&=${newNode}&&${comment}`)\n      }\n    } else {\n      if (stepsExpression.length === 0 || i === steps.length - 1) {\n        if (params.name === undefined) {\n          stepsExpression.push(`${expressionPrint}&=${newNode}`)\n        } else {\n          if (stepsExpression.length === 0) {\n            stepsExpression.push(`${params.name}&=${expressionPrint}`)\n            stepsExpression.push(`&=${newNode}`)\n          } else {\n            stepsExpression.push(`${params.name}&=${newNode}`)\n          }\n        }\n      } else {\n        stepsExpression.push(`&=${newNode}`)\n      }\n    }\n  })\n  if (\n    params.mixed === true &&\n    steps[steps.length - 1].newNode.type === 'OperatorNode' &&\n    steps[steps.length - 1].newNode.op === '/' &&\n    steps[steps.length - 1].newNode.args[0].type === 'ConstantNode' &&\n    steps[steps.length - 1].newNode.args[1].type === 'ConstantNode' &&\n    (Math.abs(steps[steps.length - 1].newNode.args[0].value) >\n      steps[steps.length - 1].newNode.args[1].value ||\n      steps[steps.length - 1].newNode.args[0].value < 0)\n  ) {\n    const plus = steps[steps.length - 1].newNode.args[0].value < 0 ? '-' : '+'\n    stepsExpression.push(\n      '&=' +\n        toTex(\n          math.parse(\n            math\n              .fraction(\n                steps[steps.length - 1].newNode.args[0].value,\n                steps[steps.length - 1].newNode.args[1].value,\n              )\n              .toFraction(true)\n              .replace(' ', plus),\n          ),\n          params,\n        ),\n    )\n  }\n  const texte = `Calculer $${expressionPrint}$.`\n  const texteCorr = `$\\\\begin{aligned}\\n${stepsExpression.join('\\\\\\\\\\n')}\\n\\\\end{aligned}$`\n  return {\n    result:\n      steps.length > 0\n        ? steps[steps.length - 1].newNode.toString()\n        : expressionPrint,\n    printResult:\n      steps.length > 0\n        ? toTex(steps[steps.length - 1].newNode, params.totex)\n        : expressionPrint,\n    netapes: stepsExpression.length,\n    texteDebug: texte + texteCorr,\n    texte,\n    texteCorr,\n    stepsLatex: stepsExpression,\n    steps,\n    commentaires: comments,\n    printExpression: expressionPrint,\n    name: params.name,\n  }\n}\n\nexport function aleaEquation(\n  equation = 'a*x+b=c*x-d',\n  variables: Variables = {\n    a: false,\n    b: false,\n    c: false,\n    d: false,\n    test: 'a>b or true',\n  },\n) {\n  // Ne pas oublier le signe de la multiplication\n  const comparators = ['<=', '>=', '=', '<', '>']\n  const assignations = aleaVariables(variables)\n  for (const v of Object.keys(assignations)) {\n    assignations[v as keyof Variables] = math.number(\n      String(assignations[v as keyof Variables]),\n    )\n  }\n\n  if (Object.keys(assignations).length === 0) {\n    // Si aucune assignation n'a été faite, on arrête le traitement\n    return equation\n  }\n  let sides\n  let comparator = null\n  for (let i = 0; i < comparators.length; i++) {\n    const comparatorSearch = comparators[i]\n    sides = equation.split(comparatorSearch)\n    if (sides.length === 2) {\n      comparator = comparatorSearch\n    }\n  }\n  if (comparator == null) throw Error('Une équation doit avoir un comparateur')\n  sides = equation.split(comparator)\n  const leftNode = expressionLitterale(sides[0], assignations).toString()\n  const rightNode = expressionLitterale(sides[1], assignations).toString()\n  return `${leftNode}${comparator}${rightNode}`\n}\n\nexport function resoudreEquation(equation = '5(x-7)=3(x+1)', debug = false) {\n  const comparators = ['<=', '>=', '=', '<', '>']\n  let comparator\n  let sides\n  for (let i = 0; i < comparators.length; i++) {\n    const comparatorSearch = comparators[i]\n    sides = equation.split(comparatorSearch)\n    if (sides.length === 2) {\n      comparator = comparatorSearch\n    }\n  }\n  if (comparator == null) throw Error('Une équation doit avoir un comparateur')\n  sides = equation.split(comparator)\n  let equationPrint\n  const steps: {\n    oldEquation: Equation\n    newEquation: Equation\n    changeType: string\n  }[] = solveEquation(equation)\n  if (debug) {\n    console.log('* steps :')\n    console.log(steps)\n  }\n  const stepsNewEquation: string[] = []\n  let repetition = 0\n  steps.forEach(function (step, i: number) {\n    const changement = step.changeType\n    if (step.oldEquation !== null) {\n      if (\n        step.oldEquation.leftNode.toString() ===\n          step.newEquation.leftNode.toString() ||\n        step.oldEquation.rightNode.toString() ===\n          step.newEquation.rightNode.toString()\n      ) {\n        if (changement !== 'REMOVE_ADDING_ZEROS') {\n          repetition = (repetition + 1) % 3\n        }\n      } else {\n        repetition = 0\n      }\n    }\n    const oldLeftNode =\n      step.oldEquation !== null ? toTex(step.oldEquation.leftNode) : ''\n    let newLeftNode = toTex(step.newEquation.leftNode)\n    const oldRightNode =\n      step.oldEquation !== null ? toTex(step.oldEquation.rightNode) : ''\n    let newRightNode = toTex(step.newEquation.rightNode)\n\n    if (debug) {\n      console.log(changement)\n      console.log(\n        newLeftNode.toString() +\n          step.newEquation.comparator +\n          newRightNode.toString(),\n      )\n    }\n    if (i === 0) {\n      equationPrint = `${oldLeftNode}${step.newEquation.comparator}${oldRightNode}`\n    }\n    const color = repetition === 2 ? 'black' : 'red'\n    newLeftNode = `{\\\\color{${color}}${newLeftNode.replace(oldLeftNode, `{\\\\color{black}${oldLeftNode}}`)}}`\n    newRightNode = `{\\\\color{${color}}${newRightNode.replace(oldRightNode, `{\\\\color{black}${oldRightNode}}`)}}`\n    if (debug) {\n      console.log(newLeftNode + step.newEquation.comparator + newRightNode)\n    }\n    const stepChange =\n      getNewChangeNodes(step).length > 0\n        ? toTex(math.parse(getNewChangeNodes(step)[0].toString()))\n        : ''\n    let commentaires: { [key: string]: string } = {\n      MULTIPLY_BOTH_SIDES_BY_NEGATIVE_ONE: String.raw`\\text{Multiplier les deux membres par }-1`,\n      SUBTRACT_FROM_BOTH_SIDES: String.raw`\\text{Soustraire }${stepChange}\\text{ à chaque membre}`,\n      ADD_TO_BOTH_SIDES: String.raw`\\text{Ajouter }${stepChange}\\text{ à chaque membre}`,\n      MULTIPLY_TO_BOTH_SIDES: String.raw`\\text{Multiplier chaque membre par }${stepChange}`,\n      DIVIDE_FROM_BOTH_SIDES: String.raw`\\text{Diviser chaque membre par }${stepChange}`,\n      MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION: String.raw`\\text{Multiplier chaque membre par }${stepChange}`,\n    }\n    if (debug) {\n      commentaires = Object.assign(commentaires, {\n        STATEMENT_IS_FALSE: String.raw`\\text{L'égalité est fausse}`,\n        STATEMENT_IS_TRUE: String.raw`\\text{L'égalité est vraie}`,\n        DISTRIBUTE: String.raw`\\text{Distribution}`,\n        SIMPLIFY_RIGHT_SIDE: String.raw`\\text{Simplifier le membre de droite}`,\n        SIMPLIFY_LEFT_SIDE: String.raw`\\text{Simplifier le membre de gauche}`,\n        COLLECT_AND_COMBINE_LIKE_TERMS: String.raw`\\text{Regrouper et réduire les termes de même nature}`,\n        SIMPLIFY_ARITHMETIC: String.raw`\\text{Calcul arithmétique}`,\n        SIMPLIFY_FRACTION: String.raw`\\text{Simplifier une fraction}`,\n        REMOVE_MULTIPLYING_BY_NEGATIVE_ONE: String.raw`\\text{Calculer la multiplication par }-1`,\n        REMOVE_ADDING_ZERO: String.raw`\\text{Enlever des zéros}`,\n        SWAP_SIDES: String.raw`\\text{Echanger les deux membres}`,\n        CANCEL_MINUSES: String.raw`\\text{Annuler les signes moins}`,\n        FIND_ROOTS: String.raw`\\text{Trouver la (ou les) solution(s)}`,\n        SIMPLIFY_SIGNS: String.raw`\\text{Simplifier le signe}`,\n        MULTIPLY_BY_ZERO: String.raw`\\text{Multiplication par zéro}`,\n        ADD_FRACTIONS: String.raw`\\text{Additionner des fractions}`,\n        BREAK_UP_FRACTION: String.raw`\\text{Séparer une fraction}`,\n        CANCEL_TERMS: String.raw`\\text{Annuler les termes}`,\n        REMOVE_MULTIPLYING_BY_ONE: String.raw`\\text{Retirer la multiplication par } 1`,\n      })\n    }\n    if (commentaires[changement] === undefined) commentaires[changement] = ''\n    if (repetition === 2) {\n      repetition = 0\n      stepsNewEquation.pop()\n      if (changement !== 'REMOVE_ADDING_ZERO') {\n        stepsNewEquation.push(\n          String.raw`${newLeftNode}&${step.newEquation.comparator}${newRightNode}&&${commentaires[changement]}`,\n        )\n      }\n    } else {\n      if (changement !== 'REMOVE_ADDING_ZERO') {\n        stepsNewEquation.push(\n          String.raw`${newLeftNode}&${step.newEquation.comparator}${newRightNode}&&${commentaires[changement]}`,\n        )\n      }\n    }\n    if (debug) console.log('changement', commentaires[changement])\n  })\n  let texte = String.raw`Résoudre $${equationPrint}$`\n  const texteCorr = String.raw`\n  $\\begin{aligned}\n  ${stepsNewEquation.join('\\\\\\\\')}\n  \\end{aligned}$\n  `\n  if (debug) texte = texteCorr\n  return { texte, texteCorr, equation: equationPrint }\n}\n\nexport function commentStep(\n  step: {\n    changeType: string\n    stepChange?: string\n  },\n  comments: Record<string, string> | undefined,\n) {\n  const changement = step.changeType\n  const stepChange = step.stepChange\n\n  const defaultComments = {\n    CROSS_PRODUCT_EQUALITY: `Egalité des produits en croix si $${stepChange} \\\\neq 0$.`,\n    MULTIPLY_BOTH_SIDES_BY_NEGATIVE_ONE:\n      'Multiplier les deux membres par $-1$.',\n    SUBTRACT_FROM_BOTH_SIDES: `Soustraire $${stepChange}$ à chaque membre.`,\n    ADD_TO_BOTH_SIDES: `Ajouter $${stepChange}$ à chaque membre`,\n    MULTIPLY_TO_BOTH_SIDES: `Multiplier chaque membre par $${stepChange}$.`,\n    DIVIDE_FROM_BOTH_SIDES: `Diviser chaque membre par $${stepChange}$.`,\n    MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION: `Multiplier chaque membre par $${stepChange}$.`,\n    SWAP_SIDES: 'Echanger les deux membres.',\n    STATEMENT_IS_FALSE: \"L'égalité est fausse.\",\n    STATEMENT_IS_TRUE: \"L'égalité est vraie.\",\n    DISTRIBUTE: 'Distribution.',\n    SIMPLIFY_RIGHT_SIDE: 'Simplifier le membre de droite.',\n    SIMPLIFY_LEFT_SIDE: 'Simplifier le membre de gauche.',\n    COLLECT_AND_COMBINE_LIKE_TERMS: 'Regrouper et réduire les termes.',\n    SIMPLIFY_ARITHMETIC: 'Calcul arithmétique.',\n    SIMPLIFY_TERMS: 'Simplifier les termes.',\n    SIMPLIFY_FRACTION: 'Simplifier une fraction.',\n    REMOVE_MULTIPLYING_BY_NEGATIVE_ONE: 'Calculer la multiplication par $-1$.',\n    REMOVE_ADDING_ZERO: 'Enlever des zéros.',\n    CANCEL_MINUSES: 'Annuler les signes moins.',\n    FIND_ROOTS: 'Trouver la (ou les) solution(s).',\n    SIMPLIFY_SIGNS: 'Simplifier le signe.',\n    MULTIPLY_BY_ZERO: 'Multiplication par zéro.',\n    ADD_FRACTIONS: 'Additionner des fractions.',\n    BREAK_UP_FRACTION: 'Séparer une fraction.',\n    CANCEL_TERMS: 'Annuler les termes.',\n    REMOVE_MULTIPLYING_BY_ONE: 'Retirer la multiplication par $1$.',\n    COLLECT_LIKE_TERMS: 'Regrouper les termes.',\n    MULTIPLY_DENOMINATORS: 'Calculer les dénominateurs.',\n    ADD_EXPONENT_OF_ONE: \"Ajouter l'exposant 1.\",\n    COLLECT_POLYNOMIAL_EXPONENTS: \"Ajouter l'exposant 1.\",\n    COMMON_DENOMINATOR: 'Obtenir le même dénominateur.',\n    MULTIPLY_NUMERATORS: 'Calculer.',\n    COMBINE_NUMERATORS: 'Combiner les numérateurs.',\n    ADD_NUMERATORS: 'Additionner les numérateurs.',\n    ADD_COEFFICIENT_OF_ONE: 'Ajouter le coefficient $1$',\n    GROUP_COEFFICIENTS: 'Regrouper les coefficients.',\n    FIND_GCD: 'Trouver le plus grand diviseur commun.',\n    CANCEL_GCD: 'Simplifier par le PGCD.',\n    MULTIPLY_FRACTIONS: 'Multiplier deux fractions.',\n  }\n  comments = Object.assign(defaultComments, comments)\n  return comments[changement] !== undefined\n    ? `\\\\text{${comments[changement].replaceAll('{stepChange}', `$${stepChange}$`)}}`\n    : ''\n}\n\n/**\n * Check if x is a decimal number\n * @param {Object} x // Object type = Fraction (mathjs)\n * @returns {boolean}\n */\nexport function isDecimal(value: number | string | Fraction): boolean {\n  let f: Fraction\n  if (typeof value === 'number') {\n    f = math.fraction(value)\n  } else if (typeof value === 'string') {\n    f = math.fraction(value.replaceAll(' ', ''))\n  } else {\n    f = value.clone()\n  }\n  const den: number = Number(f.d)\n  return (\n    den !== 1 &&\n    !obtenirListeFacteursPremiers(den).some((x: number) => x !== 2 && x !== 5)\n  )\n}\n\nfunction logSteps(equationStatus: {\n  changeType: string\n  substeps?: Array<{\n    changeType: string\n    substeps?: any[]\n  }>\n}): void {\n  console.log('\\n' + equationStatus.changeType)\n  if (equationStatus?.substeps && equationStatus.substeps.length > 0) {\n    console.log('\\n substeps: [')\n    equationStatus.substeps.forEach(logSteps)\n    console.log('\\n]')\n  }\n}\n\n/**\n * @description Retourne toutes les étapes de résolution d'une équation ou d'une inéquation\n * @param {Objet} params // Les paramètres (commentaires visibles)\n * @param {string} equation // Une équation ou une inéquation\n * @example\n * resoudre('2*x+4=4*x-5') --> Donne les étapes de la résolution de l'équation\n * resoudre('2*x+4=4*x-5'), {comment: true}) --> Ajoute les commentaires\n * resoudre('2*x+4=4*x-5', {color: blue}) -> Met en bleu les changements à chaque étape\n * resoudre('2*x+4=4*x-5', {substeps: true}) --> Ajoute les sous-étapes\n * resoudre('2*x+4=4*x-5', {produitsencroix: true}) --> Utilise les produits en croix lorsque l'inconnue est au dénominateur a/f(x)=b/c\n * resoudre('2*x+4=4*x-5', {verifications: true}) --> Ajoute les vérifications de la solution\n * resoudre('a*x+c=b*x+d', {variables: {a: true, b: true, c: true, d: true, test: 'a!=b'}}) --> a, b, c et d sont choisis au hasard voir la fonction aleaVariables()\n * resoudre('2*x+4=4*x-5', {comment: true, comments: commentairesPersonnalises}) --> commentairesPersonnalises est un tableau avec des commentaires personnalisés (voir fonction commentStep())\n */\nexport function resoudre(\n  equation: string,\n  params?: {\n    comment?: boolean\n    color?: string\n    comments?: Record<string, string>\n    reduceSteps?: boolean\n    formatSolution?: number | 'decimal' | 'fraction'\n    substeps?: boolean\n    changeType?: string[]\n    produitsencroix?: boolean\n    verifications?: boolean\n    variables?: Variables\n  },\n): {\n  solution: {\n    printDecimal: string\n    decimal: number\n    exact: string\n    print: string\n  }\n  texte: string\n  texteCorr: string\n  equation: string\n  verifLeftSide?: ReturnType<typeof calculer>\n  verifRightSide?: ReturnType<typeof calculer>\n  steps: {\n    oldEquation: Equation\n    newEquation: Equation\n    changeType: string\n    stepChange?: string\n  }[]\n  printSteps: string[]\n} {\n  /*\n    formatSolution\n      2 (défaut) : décimal si la solution a 2 chiffres ou moins après la virgule, fraction sinon\n      n : décimal si la solution a n chiffres ou moins après la virgule, fraction sinon\n      'decimal' : decimal lorsque c'est possible, sinon fraction\n      'fraction' : fraction (ou entier lorsque c'est possible)\n  */\n  params = Object.assign(\n    {\n      comment: false,\n      color: 'blue',\n      comments: {},\n      reduceSteps: true,\n      formatSolution: 2,\n      substeps: false,\n      changeType: [],\n      produitsencroix: false,\n      verifications: false,\n    },\n    params,\n  )\n  if (params.variables !== undefined) {\n    equation = aleaEquation(equation, params.variables)\n  }\n  let printEquation: string = ''\n  const steps: {\n    oldEquation: Equation\n    newEquation: Equation\n    changeType: string\n    stepChange?: string\n    substeps?: any[]\n  }[] = params.substeps\n    ? traverserEtapes(solveEquation(equation), params.changeType)\n    : solveEquation(equation)\n\n  // steps.forEach(logSteps)\n\n  // Si l'équation est déjà resolue...\n  if (steps.length === 0 && equation.includes('=')) {\n    const left = math.parse(equation.split('=')[0])\n    const right = math.parse(equation.split('=')[1])\n    if (\n      left.type === 'SymbolNode' &&\n      Node.Type.isConstantOrConstantFraction(right)\n    ) {\n      // Si l'équation est déjà resolue...\n      steps.push({\n        oldEquation: new Equation(left, right, '='),\n        newEquation: new Equation(left, right, '='),\n        changeType: 'EQUALITY',\n      })\n    }\n  }\n\n  // supprime des étapes redondantes\n  const stepsNewEquation: string[] = []\n  let repetition = 0\n  steps.forEach(function (step, i) {\n    const detect = getNewChangeNodes(step)\n    step.stepChange =\n      detect?.length > 0 ? toTex(math.parse(detect[0].toString())) : ''\n    if (step.oldEquation !== null) {\n      if (\n        params.reduceSteps &&\n        (step.oldEquation.leftNode.toString() ===\n          step.newEquation.leftNode.toString() ||\n          step.oldEquation.rightNode.toString() ===\n            step.newEquation.rightNode.toString())\n      ) {\n        if (step.changeType !== 'REMOVE_ADDING_ZEROS') {\n          repetition = (repetition + 1) % 3\n        }\n      } else {\n        repetition = 0\n      }\n    }\n    const oldLeftNode =\n      step.oldEquation !== null ? toTex(step.oldEquation.leftNode, params) : ''\n    let newLeftNode = toTex(step.newEquation.leftNode, params)\n    const oldRightNode =\n      step.oldEquation !== null ? toTex(step.oldEquation.rightNode, params) : ''\n    let newRightNode = toTex(step.newEquation.rightNode, params)\n    const newEquationComparator = toTex(step.newEquation.comparator)\n    if (i === 0) {\n      printEquation = `${toTex(step.oldEquation.ascii())}`\n      stepsNewEquation.push(\n        String.raw`${oldLeftNode}&${toTex(step.oldEquation.comparator)}${oldRightNode}`,\n      )\n    }\n    if (params.color !== 'black') {\n      const color = repetition === 2 ? 'black' : params.color\n      newLeftNode = `{\\\\color{${color}}${newLeftNode.replace(oldLeftNode, `{\\\\color{black}${oldLeftNode}}`)}}`\n      newRightNode = `{\\\\color{${color}}${newRightNode.replace(oldRightNode, `{\\\\color{black}${oldRightNode}}`)}}`\n    }\n    const comment = commentStep(step, params.comments)\n    if (repetition === 2 || step.changeType === 'EQUALITY') {\n      repetition = 0\n      stepsNewEquation.pop()\n      stepsNewEquation.push(\n        `${newLeftNode}&${newEquationComparator}${newRightNode}${params.comment ? `&&${comment}` : ''}`,\n      )\n    } else {\n      stepsNewEquation.push(\n        `${newLeftNode}&${newEquationComparator}${newRightNode}${params.comment ? `&&${comment}` : ''}`,\n      )\n    }\n  })\n\n  // calculer de la solution sous différents formats\n  const lastEquation = steps[steps.length - 1].newEquation\n  let answer = lastEquation.rightNode\n  if (params.formatSolution !== 'fraction' && !answer.isConstantNode) {\n    try {\n      // On ve tenter d'obtenir le résultat sous forme de fraction, si ce n'est pas possible on quitte le try\n      math.config({ number: 'Fraction' })\n      answer = math.evaluate(answer.toString())\n      math.config({ number: 'number' })\n      // On regarde si le résultat a un nombre fini de chiffres après la virgule et n'est pas un entier\n      if (isDecimal(answer)) {\n        answer = math.round(answer.valueOf(), 15) // convertit la fraction en nombre décimal en évitant les problèmes de float\n        if (\n          params.formatSolution === 'decimal' ||\n          (typeof params.formatSolution === 'number' &&\n            answer.toString().split('.')[1].length <= params.formatSolution)\n        ) {\n          // On rajoute une étape de conversion de la fraction en nombre décimal\n          stepsNewEquation.push(\n            `${toTex(lastEquation.leftNode, params)}&${toTex(lastEquation.comparator + answer.toString())}`,\n          )\n        }\n      }\n    } catch (e) {}\n  }\n\n  const texte = `Résoudre $${printEquation}$.`\n  let texteCorr = `$\\\\begin{aligned}\\n${stepsNewEquation.join('\\\\\\\\\\n')}\\n\\\\end{aligned}$`\n  const solution = {\n    printDecimal: texNombre2(\n      math.evaluate(\n        steps[steps.length - 1].newEquation\n          .ascii()\n          .split(steps[steps.length - 1].newEquation.comparator)[1],\n      ),\n    ),\n    decimal: math.evaluate(\n      steps[steps.length - 1].newEquation\n        .ascii()\n        .split(steps[steps.length - 1].newEquation.comparator)[1],\n    ),\n    exact: steps[steps.length - 1].newEquation\n      .ascii()\n      .split(steps[steps.length - 1].newEquation.comparator)[1],\n    print: toTex(steps[steps.length - 1].newEquation.ascii()),\n  }\n  let calculateLeftSide: ReturnType<typeof calculer> | undefined\n  let calculateRightSide: ReturnType<typeof calculer> | undefined\n  if (steps[steps.length - 1].newEquation.leftNode.isSymbolNode) {\n    const sides = equation.split(steps[0].oldEquation.comparator)\n    const SymbolNode = steps[steps.length - 1].newEquation.leftNode.toString()\n    const thesolution = steps[steps.length - 1].newEquation.rightNode.toString()\n    calculateLeftSide = calculer(\n      sides[0].replaceAll(SymbolNode, `(${thesolution})`),\n    )\n    calculateRightSide = calculer(\n      sides[1].replaceAll(SymbolNode, `(${thesolution})`),\n    )\n  }\n  if (params.verifications) {\n    texteCorr = `${context.isHtml ? '<br>' : ''}\n          ${texteCorr}<br>\n          La solution est $${solution.print}$.\n          <br>\n          $\\\\textit{Vérification :}$\n          <br>\n          $\\\\bullet$ D'une part : $${calculateLeftSide?.printExpression}=${calculateLeftSide?.printResult}$\n          <br>\n          $\\\\bullet$ D'autre part : $${calculateRightSide?.printExpression}=${calculateRightSide?.printResult}$\n          `\n  }\n  return {\n    solution,\n    texte,\n    texteCorr,\n    equation: printEquation,\n    verifLeftSide: calculateLeftSide,\n    verifRightSide: calculateRightSide,\n    steps,\n    printSteps: stepsNewEquation,\n  }\n}\n\nexport function programmeCalcul(\n  stepProg = [\n    '+',\n    '-',\n    '*',\n    '/',\n    '^2',\n    '2*x',\n    '3*x',\n    '-2*x',\n    '-3*x',\n    'x^2',\n    '-x^2',\n    'x',\n    '-x',\n    '*x',\n    '/x',\n  ],\n  nombreChoisi: number,\n) {\n  const rules = math.simplify.rules\n  rules[13] = { l: 'n', r: 'n' } // Pour éviter la factorisation\n  rules[14] = { l: 'n', r: 'n' } // Pour éviter la factorisation\n  // rules.push({ l: 'n1+-n2', r: 'n1-n2' }) // Peut être utile pour des nombres négatifs\n  const variables: {\n    symbolsOp: string[]\n    namesOp: nameOps[]\n    debutsPhrase: string[]\n    debutsPhraseInv: string[]\n    op: Operator[]\n  } = {\n    symbolsOp: Object.values(stepProg),\n    namesOp: [],\n    debutsPhrase: [],\n    debutsPhraseInv: [],\n    op: [],\n  }\n  const symbolsOp = [\n    '+',\n    '-',\n    '*',\n    '/',\n    '^2',\n    '2*x',\n    '3*x',\n    '-2*x',\n    '-3*x',\n    'x^2',\n    '-x^2',\n    'x',\n    '-x',\n    '*x',\n    '/x',\n  ]\n  const op = [\n    '+',\n    '-',\n    '*',\n    '/',\n    '^',\n    '+',\n    '+',\n    '-',\n    '-',\n    '+',\n    '-',\n    '+',\n    '-',\n    '*',\n    '/',\n  ] as const\n  type Operator = (typeof op)[number]\n\n  const namesOp = [\n    'add',\n    'subtract',\n    'multiply',\n    'divide',\n    'pow',\n    'add',\n    'add',\n    'subtract',\n    'subtract',\n    'add',\n    'subtract',\n    'add',\n    'subtract',\n    'multiply',\n    'divide',\n  ] as const\n  type nameOps = (typeof namesOp)[number]\n\n  // 👇 on définit un sous-type\n  type InvertibleOps = Extract<\n    nameOps,\n    'add' | 'subtract' | 'multiply' | 'divide'\n  >\n\n  const namesOpInv: Record<InvertibleOps, InvertibleOps> = {\n    add: 'subtract',\n    subtract: 'add',\n    multiply: 'divide',\n    divide: 'multiply',\n  }\n  const symbolsOpInv: Record<InvertibleOps, Operator> = {\n    add: '-',\n    subtract: '+',\n    multiply: '/',\n    divide: '*',\n  }\n  const debutsPhrase = [\n    'Ajouter ',\n    'Soustraire ',\n    'Multiplier par ',\n    'Diviser par ',\n    'Elever au carré',\n    'Ajouter le double du nombre choisi',\n    'Ajouter le triple du nombre choisi',\n    'Soustraire le double du nombre choisi',\n    'Soustraire le triple du nombre choisi',\n    'Ajouter le carré du nombre choisi',\n    'Soustraire le carré du nombre choisi',\n    'Ajouter le nombre choisi',\n    'Soustraire le nombre choisi',\n    'Multiplier par le nombre choisi',\n    'Diviser par le nombre choisi',\n  ]\n  const debutsPhraseInv = [\n    'Soustraire ',\n    'Ajouter ',\n    'Diviser par ',\n    'Multiplier par ',\n    'Prendre la racine carré',\n    'Soustraire le double du nombre choisi',\n    'Soustraire le triple du nombre choisi',\n    'Ajouter le double du nombre choisi',\n    'Ajouter le triple du nombre choisi',\n    'Soustraire le carré du nombre choisi',\n    'Ajouter le carré du nombre choisi',\n    'Soustraire le nombre choisi',\n    'Ajouter le nombre choisi',\n    'Diviser par le nombre choisi',\n    'Multiplier par le nombre choisi',\n  ]\n  const nombresAutorises1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n  const nombresAutorises2 = [2, 3, 4, 5, 6, 7, 8, 9]\n\n  variables.symbolsOp.forEach(function (n, i) {\n    variables.namesOp[i] = namesOp[symbolsOp.indexOf(n)]\n    variables.debutsPhrase[i] = debutsPhrase[symbolsOp.indexOf(n)]\n    variables.debutsPhraseInv[i] = debutsPhraseInv[symbolsOp.indexOf(n)]\n    variables.op[i] = op[symbolsOp.indexOf(n)]\n  })\n\n  const nodes: MathNode[] = [new math.SymbolNode('x')]\n  const phrases = ['Choisir un nombre.']\n  const steps = ['x']\n  const stepsNode: MathNode[] = [new math.SymbolNode('x')]\n  const stepsSimplified = ['x']\n  const stepsInv = ['x']\n  const stepsSimplifiedInv = ['x']\n  const phrasesInv = ['On retrouve le nombre choisi à partir du résultat.']\n  const nombreChoisiNode = math.simplify(math.format(nombreChoisi))\n  const resultatIntermediaire: MathNode[] = [nombreChoisiNode]\n  const calculIntermediaire: MathNode[] = [nombreChoisiNode]\n  let step\n  const longueur = variables.symbolsOp.length + 1\n  for (let i = 1; i < longueur; i++) {\n    const choix = i - 1\n    let symbolOp = variables.symbolsOp[choix]\n    const nameOp = variables.namesOp[choix]\n    const debutPhrase = variables.debutsPhrase[choix]\n    const op = variables.op[choix]\n    let stepPrint = ''\n    switch (symbolOp) {\n      case '/':\n        step = new math.ConstantNode(choice(nombresAutorises2))\n        break\n      case '*':\n        step = new math.ConstantNode(choice(nombresAutorises2))\n        break\n      case '^2':\n        step = new math.ConstantNode(2)\n        break\n      case '-':\n        step = new math.ConstantNode(choice(nombresAutorises1))\n        break\n      case '+':\n        step = new math.ConstantNode(choice(nombresAutorises2))\n        break\n      default:\n        if (symbolOp[0] === '-') symbolOp = symbolOp.replace('-', '')\n        step = math.parse(symbolOp)\n    }\n    stepsNode.push(step)\n    if (step.type === 'ConstantNode' && symbolOp !== '^2') {\n      stepPrint = `$${step.toString()}$`\n    }\n    let nodeSimplifie = math.simplify(\n      nodes[i - 1].toString({ parenthesis: 'keep' }),\n      rules,\n    )\n    nodes.push(\n      new math.OperatorNode(op, nameOp, [\n        new math.ParenthesisNode(nodeSimplifie),\n        step,\n      ]),\n    )\n    steps.push(toTex(nodes[i], { suppr1: false }))\n    nodeSimplifie = math.simplify(\n      nodes[i].toString({ parenthesis: 'auto' }),\n      rules,\n    )\n    stepsSimplified.push(toTex(nodeSimplifie, { suppr1: false }))\n    phrases.push(debutPhrase + stepPrint)\n    if (i > 0) {\n      calculIntermediaire.push(\n        new math.OperatorNode(variables.op[choix], nameOp, [\n          resultatIntermediaire[i - 1],\n          math.simplify(step, [{ l: 'n', r: 'n' }], { x: nombreChoisi }),\n        ]),\n      )\n      resultatIntermediaire.push(\n        math.simplify(calculIntermediaire[i], { x: nombreChoisi }),\n      )\n    }\n  }\n  // Programme en sens inverse si c'est possible\n  const resultatIntermediaireInv = [resultatIntermediaire[longueur - 1]]\n  const calculIntermediaireInv = [resultatIntermediaire[longueur - 1]]\n  const nodesInv: MathNode[] = [new math.SymbolNode('x')]\n  for (let i = 1; i < longueur; i++) {\n    const choix = i - 1\n    const nameOp = variables.namesOp[longueur - 2 - choix]\n    if (nameOp === 'pow') {\n      break\n    }\n    if (symbolsOpInv[nameOp]) {\n      const node: MathNode = new math.OperatorNode(\n        symbolsOpInv[nameOp] as '+' | '-' | '*' | '/',\n        namesOpInv[nameOp],\n        [new math.ParenthesisNode(nodesInv[i - 1]), stepsNode[longueur - i]],\n      )\n      nodesInv.push(node)\n      stepsInv.push(toTex(node, { suppr1: false }))\n      const nodeSimplifieInv = math.parse(\n        nodesInv[i - 1].toString({ parenthesis: 'auto' }),\n      )\n      stepsSimplifiedInv.push(toTex(nodeSimplifieInv, { suppr1: false }))\n      const debutPhraseInv = variables.debutsPhraseInv[choix]\n      phrasesInv.push(\n        debutPhraseInv + `$${stepsNode[longueur - i].toString()}$`,\n      )\n      calculIntermediaireInv.push(\n        new math.OperatorNode(\n          symbolsOpInv[nameOp] as '+' | '-' | '*' | '/',\n          namesOpInv[nameOp],\n          [\n            resultatIntermediaireInv[i - 1],\n            math.simplify(stepsNode[longueur - i], [{ l: 'n', r: 'n' }], {\n              x: nombreChoisi,\n            }),\n          ],\n        ),\n      )\n      resultatIntermediaireInv.push(\n        math.simplify(calculIntermediaireInv[i], { x: nombreChoisi }),\n      )\n    }\n  }\n  return {\n    phrases,\n    steps,\n    stepsSimplified,\n    stepsInv,\n    stepsSimplifiedInv,\n    phrasesInv,\n    nodes,\n    stepProg,\n    calculIntermediaire,\n    resultatIntermediaire,\n    calculIntermediaireInv,\n    resultatIntermediaireInv,\n  }\n}\n\nexport function traduireProgrammeCalcul(\n  stepProg = [\n    '+',\n    '-',\n    '*',\n    '/',\n    '^2',\n    '2*x',\n    '3*x',\n    '-2*x',\n    '-3*x',\n    'x^2',\n    '-x^2',\n    'x',\n    '-x',\n    '*x',\n    '/x',\n  ],\n  nombreChoisi: number,\n  debug = false,\n) {\n  const programme = programmeCalcul(stepProg, nombreChoisi)\n  const stepsSolutionDetaillee = Object.values(programme.phrases) // Clone de phrases pour ne pas être touchée par les modifications\n  stepsSolutionDetaillee.forEach(function (step, i) {\n    stepsSolutionDetaillee[i] =\n      '&\\\\bullet~\\\\text{' + programme.phrases[i] + '}&'\n    programme.phrases[i] = '&\\\\bullet~\\\\text{' + programme.phrases[i] + '}'\n    stepsSolutionDetaillee[i] += '&' + programme.steps[i]\n    if (programme.steps[i] !== programme.stepsSimplified[i]) {\n      stepsSolutionDetaillee[i] += '&=' + programme.stepsSimplified[i]\n    }\n  })\n  let texte = String.raw` Voici un programme de calcul.\n          <br>\n          $\\begin{aligned}\n          ${programme.phrases.join('\\\\\\\\')}\n          \\end{aligned}$\n          <br>\n          Notons $x$ le nombre choisi.\n          <br>\n          Écrire le résultat du programme de calcul en fonction de $x$.\n          `\n  const texteCorr = String.raw`Solution détaillée\n          <br>\n          $\\begin{aligned}\n          ${stepsSolutionDetaillee.join('\\\\\\\\')}\n          \\end{aligned}$`\n  if (debug) texte = `${texte}<br>${texteCorr}`\n  return { texte, texteCorr }\n}\n\nexport function ecrireProgrammeCalcul(\n  stepProg = [\n    '+',\n    '-',\n    '*',\n    '/',\n    '^2',\n    '2*x',\n    '3*x',\n    '-2*x',\n    '-3*x',\n    'x^2',\n    '-x^2',\n    'x',\n    '-x',\n    '*x',\n    '/x',\n  ],\n  nombreChoisi: number,\n  debug = false,\n) {\n  const programme = programmeCalcul(stepProg, nombreChoisi)\n  const stepsSolutionDetaillee = Object.values(programme.phrases) // Clone de phrases pour ne pas être touchée par les modifications\n  stepsSolutionDetaillee.forEach(function (step, i) {\n    stepsSolutionDetaillee[i] =\n      '&\\\\bullet~\\\\text{' + programme.phrases[i] + '}&'\n    programme.phrases[i] = '&\\\\bullet~\\\\text{' + programme.phrases[i] + '}'\n    stepsSolutionDetaillee[i] += '&' + programme.steps[i]\n    if (programme.steps[i] !== programme.stepsSimplified[i]) {\n      stepsSolutionDetaillee[i] += '&=' + programme.stepsSimplified[i]\n    }\n  })\n  let texte = String.raw`Voici une expression. Écrire le programme de calcul correspondant.\n          <br>\n          $${programme.stepsSimplified[programme.stepsSimplified.length - 1]}$\n          `\n  const texteCorr = String.raw`Solution détaillée\n          <br>\n          $\\begin{aligned}\n          ${stepsSolutionDetaillee.join('\\\\\\\\')}\n          \\end{aligned}$`\n  if (debug) texte = `${texte}<br>${texteCorr}`\n  return { texte, texteCorr }\n}\n\nexport function remonterProgrammeCalcul(\n  stepProg = [\n    '+',\n    '-',\n    '*',\n    '/',\n    '^2',\n    '2*x',\n    '3*x',\n    '-2*x',\n    '-3*x',\n    'x^2',\n    '-x^2',\n    'x',\n    '-x',\n    '*x',\n    '/x',\n  ],\n  nombreChoisi: number,\n  debug = false,\n) {\n  const programme = programmeCalcul(stepProg, nombreChoisi)\n  const stepsSolutionDetaillee = Object.values(programme.phrases) // Clone de phrases pour ne pas être touchée par les modifications\n  const stepsSolutionDetailleeInv = Object.values(programme.phrases) // Clone de phrases pour ne pas être touchée par les modifications\n  const longueur = stepsSolutionDetaillee.length\n  stepsSolutionDetaillee.forEach(function (step, i) {\n    stepsSolutionDetaillee[i] =\n      '&\\\\bullet~\\\\text{' + programme.phrases[i] + '}&'\n    programme.phrases[i] = '&\\\\bullet~\\\\text{' + programme.phrases[i] + '}'\n    stepsSolutionDetaillee[i] += '&' + programme.steps[i]\n    stepsSolutionDetailleeInv[i] =\n      '&\\\\bullet~\\\\text{' + programme.phrasesInv[i] + '}&'\n    programme.phrasesInv[i] =\n      '&\\\\bullet~\\\\text{' + programme.phrasesInv[i] + '}'\n    if (i === 0) {\n      stepsSolutionDetailleeInv[i] +=\n        '&' + toTex(programme.resultatIntermediaireInv[longueur - 2])\n    } else if (i < stepsSolutionDetaillee.length - 1) {\n      stepsSolutionDetailleeInv[i] +=\n        '&' +\n        toTex(programme.calculIntermediaireInv[longueur - 1 - i]) +\n        '&&=' +\n        toTex(programme.resultatIntermediaireInv[longueur - 1 - i])\n    } else {\n      stepsSolutionDetailleeInv[i] +=\n        '&' + toTex(programme.resultatIntermediaireInv[0])\n    }\n  })\n  const nombreChoisiNode = math.simplify(math.format(nombreChoisi))\n  let texte = String.raw`On obtient le nombre $${toTex(programme.resultatIntermediaireInv[0])}$ avec le programme suivant.\n          <br>\n          $\\begin{aligned}\n          ${programme.phrases.join('\\\\\\\\')}\n          \\end{aligned}$\n          <br>\n          Quel était le nombre choisi ?\n          `\n  const texteCorr = String.raw`Solution détaillée\n          <br>\n          $\\begin{aligned}\n          ${stepsSolutionDetailleeInv.reverse().join('\\\\\\\\')}\n          \\end{aligned}$\n          <br>\n          Le nombre choisi était donc $${toTex(nombreChoisiNode)}$.\n          `\n  if (debug) texte = `${texte}<br>${texteCorr}`\n  return { texte, texteCorr }\n}\n\nexport function appliquerProgrammeCalcul(\n  stepProg = [\n    '+',\n    '-',\n    '*',\n    '/',\n    '^2',\n    '2*x',\n    '3*x',\n    '-2*x',\n    '-3*x',\n    'x^2',\n    '-x^2',\n    'x',\n    '-x',\n    '*x',\n    '/x',\n  ],\n  nombreChoisi: number,\n  debug = false,\n) {\n  const programme = programmeCalcul(stepProg, nombreChoisi)\n  const stepsSolutionDetaillee = Object.values(programme.phrases) // Clone de phrases pour ne pas être touchée par les modifications\n  stepsSolutionDetaillee.forEach(function (step, i) {\n    stepsSolutionDetaillee[i] =\n      '&\\\\bullet~\\\\text{' + programme.phrases[i] + '}&'\n    programme.phrases[i] = '&\\\\bullet~\\\\text{' + programme.phrases[i] + '}'\n    // stepsSolutionDetaillee[i] += '&' + programme.steps[i]\n    if (i === 0) {\n      stepsSolutionDetaillee[i] +=\n        '&' + toTex(programme.resultatIntermediaire[0])\n    } else if (i < stepsSolutionDetaillee.length - 1) {\n      stepsSolutionDetaillee[i] +=\n        '&' +\n        toTex(programme.calculIntermediaire[i]) +\n        '&&=' +\n        toTex(programme.resultatIntermediaire[i])\n    } else {\n      stepsSolutionDetaillee[i] +=\n        '&' + toTex(programme.resultatIntermediaire[i - 1])\n    }\n  })\n  const nombreChoisiNode = math.simplify(math.format(nombreChoisi))\n  let texte = String.raw`Choisir le nombre $${toTex(nombreChoisiNode)}$ et effectuer le programme de calcul suivant.\n          <br>\n          $\\begin{aligned}\n          ${programme.phrases.join('\\\\\\\\')}\n          \\end{aligned}$\n          <br>\n          `\n  const texteCorr = String.raw`Solution détaillée\n          <br>\n          $\\begin{aligned}\n          ${stepsSolutionDetaillee.join('\\\\\\\\')}\n          \\end{aligned}$`\n  if (debug) texte = `${texte}<br>${texteCorr}`\n  return { texte, texteCorr }\n}\n\nexport function calculExpression2(\n  expression = '4/3+5/6',\n  factoriser = false,\n  debug = false,\n) {\n  const steps: {\n    oldNode: Node\n    newNode: Node\n    changeType: string\n    substeps: any[]\n  }[] = factoriser\n    ? traverserEtapes(factor(expression))\n    : traverserEtapes(simplifyExpression(expression))\n  if (debug) {\n    console.log('* steps :')\n    console.log(steps)\n  }\n  let repetition = 0\n  const stepsExpression: string[] = []\n  let expressionPrint = ''\n  steps.forEach(function (step, i) {\n    const changement = step.changeType\n    if (step.oldNode !== null) {\n      if (step.oldNode.toString() === step.newNode.toString()) {\n        if (changement !== 'REMOVE_ADDING_ZEROS') {\n          repetition = (repetition + 1) % 2\n        }\n      } else {\n        repetition = 0\n      }\n    }\n    if (debug) {\n      console.log(changement)\n      console.log(step.newNode.toString())\n    }\n    const oldNode =\n      step.oldNode !== null ? toTex(step.oldNode, { suppr1: true }) : ''\n    const newNode = toTex(step.newNode, { suppr1: true })\n    if (debug) {\n      console.log(newNode.toString())\n    }\n    if (i === 0) {\n      expressionPrint = `${oldNode}`\n    }\n    if (debug) console.log(newNode)\n    const commentairesExclus: { [key: string]: string } = {\n      REMOVE_ADDING_ZERO: String.raw`\\text{Enlever des zéros}`,\n      EXPAND_EXPONENT: String.raw`\\text{Signification des exposants}`,\n      MULTIPLY_COEFFICIENTS: String.raw`\\text{Multiplier les coefficients}`,\n      COLLECT_LIKE_TERMS: String.raw`\\text{Regrouper les termes}`,\n      MULTIPLY_DENOMINATORS: String.raw`\\text{Calculer les dénominateurs}`,\n      ADD_EXPONENT_OF_ONE: String.raw`\\text{Ajouter l'exposant 1}`,\n      COLLECT_POLYNOMIAL_EXPONENTS: String.raw`\\text{Ajouter l'exposant 1}`,\n      DISTRIBUTE: String.raw`\\text{Distribution}`,\n      ADD_COEFFICIENT_OF_ONE: String.raw`\\text{Ajouter le coefficient }1`,\n      GROUP_COEFFICIENTS: String.raw`\\text{Regrouper les coefficients}`,\n      REMOVE_MULTIPLYING_BY_ONE: String.raw`\\text{Retirer la multiplication par } 1`,\n    }\n    let commentaires: { [key: string]: string } = {\n      COMMON_DENOMINATOR: String.raw`\\text{Obtenir le même dénominateur}`,\n      MULTIPLY_NUMERATORS: String.raw`\\text{Calculer}`,\n      COMBINE_NUMERATORS: String.raw`\\text{Combiner les numérateurs}`,\n      ADD_NUMERATORS: String.raw`\\text{Additionner les numérateurs}`,\n      FIND_GCD: String.raw`\\text{Trouver le plus grand diviseur commun.}`,\n      CANCEL_GCD: String.raw`\\text{Simplifier par le PGCD.}`,\n    }\n    if (debug) {\n      commentaires = Object.assign(commentaires, {\n        STATEMENT_IS_FALSE: String.raw`\\text{L'égalité est fausse}`,\n        STATEMENT_IS_TRUE: String.raw`\\text{L'égalité est vraie}`,\n        SIMPLIFY_RIGHT_SIDE: String.raw`\\text{Simplifier le membre de droite}`,\n        SIMPLIFY_LEFT_SIDE: String.raw`\\text{Simplifier le membre de gauche}`,\n        COLLECT_AND_COMBINE_LIKE_TERMS: String.raw`\\text{Regrouper et réduire les termes de même nature}`,\n        SIMPLIFY_ARITHMETIC: String.raw`\\text{Calcul arithmétique}`,\n        SIMPLIFY_FRACTION: String.raw`\\text{Simplifier une fraction}`,\n        REMOVE_MULTIPLYING_BY_NEGATIVE_ONE: String.raw`\\text{Calculer la multiplication par }-1`,\n        REMOVE_ADDING_ZERO: String.raw`\\text{Enlever des zéros}`,\n        SWAP_SIDES: String.raw`\\text{Echanger les deux membres}`,\n        CANCEL_MINUSES: String.raw`\\text{Annuler les signes moins}`,\n        FIND_ROOTS: String.raw`\\text{Trouver la (ou les) solution(s)}`,\n        SIMPLIFY_SIGNS: String.raw`\\text{Simplifier le signe}`,\n        MULTIPLY_BY_ZERO: String.raw`\\text{Multiplication par zéro}`,\n        ADD_FRACTIONS: String.raw`\\text{Additionner des fractions}`,\n        BREAK_UP_FRACTION: String.raw`\\text{Séparer une fraction}`,\n        CANCEL_TERMS: String.raw`\\text{Annuler les termes}`,\n      })\n    }\n    if (commentaires[changement] === undefined) commentaires[changement] = ''\n    if (commentairesExclus[changement] === undefined) {\n      stepsExpression.push(String.raw`&=${newNode}`)\n    }\n    if (debug) console.log('changement', commentaires[changement])\n  })\n  let texte = String.raw`Développer et réduire $${expressionPrint}$.`\n  const texteCorr = String.raw`Simplifier $${expressionPrint}$.\n  <br>\n  $\\begin{aligned}\n  ${expressionPrint}${stepsExpression.slice(stepsExpression.length - 4, stepsExpression.length).join('\\\\\\\\')}\n  \\end{aligned}$\n  `\n  if (debug) texte = texteCorr\n  return { texte, texteCorr }\n}\n\n/**\n * Retourne des noms de points (ou des objets) dans un ordre aléatoire.\n * @param {string|Array} names // Liste des lettres sous format string ou array\n * @param {number} n // Nombre de lettres à retourner\n * @param {string|Array} result // S'il n'y a qu'un seul nom en sortie c'est un string sinon c'est un array\n * @remarque // Les lettres Q,W,X,Y,Z ont été exclues par défaut\n * @example\n * aleaName() --> 'F'\n * aleaName(3) --> ['G', 'J', 'K']\n * aleaName('ABC') --> ['B','A','C']\n * aleaName(['chat','chien','poisson']) --> ['chien','poisson','chat']\n * aleaName(['chat','chien','poisson'],2) --> ['poisson','chat']\n * aleaName([Objet1,Objet2,Objet3]) --> [Objet2,Objet1,Objet3] où Objet peut être un Object, un Array etc.\n * @returns {Array}\n */\nexport function aleaName(\n  names: string | string[] | number,\n  n: number = 1,\n  result: string[] = [],\n) {\n  if (typeof names === 'string') {\n    names = names.split('')\n    n = names.length\n  } else if (typeof names === 'number') {\n    n = names\n    names = 'ABCDEFGHIJKLMNOPRSTUV'.split('')\n  } else if (Array.isArray(names) && names.length === 0) {\n    n = 1\n    names = 'ABCDEFGHIJKLMNOPRSTUV'.split('')\n  }\n  result.push(names.splice(Math.floor(Math.random() * names.length), 1)[0])\n  if (result.length === n) {\n    return result\n  } else {\n    return aleaName(names, n, result)\n  }\n}\n"],"names":["NodeType","node","operator","functionName","allowUnaryMinus","numerator","denominator","Change","OP_TO_STRING","COMPARATOR_TO_STRING","step","changeFormatFunctionMap","changeDescription","getChangeNodes","getOldChangeNodes","leftChangeNodeStrings","rightChangeNodeStrings","getNewChangeNodes","nodesToString","nodes","duplicates","strings","ChangeTypes","oldNodes","absNode","newNodes","before","after","opNode","termNodes","comparator","config","math","create","fractionDependencies","lcmDependencies","gcdDependencies","nthRootDependencies","NodeDependencies","formatDependencies","parseDependencies","evaluateDependencies","simplifyDependencies","randomDependencies","pickRandomDependencies","smallerDependencies","largerDependencies","smallerEqDependencies","largerEqDependencies","randomIntDependencies","assignVariables","expression","variables","nodeName","variable","toTex","params","sides","comparators","i","members","nodeCopy","printMS","basics","removeAdditionOfZero","SIMPLIFICATION_FUNCTIONS","removeMultiplicationByOne","reduceMultiplicationByZero","removeDivisionByOne","rearrangeCoefficient","reduceZeroDividedByAnything","removeExponentByOne","removeExponentBaseOne","reduceExponentByZero","removeMultiplicationByNegativeOne","functionsToTest","nodeStatus","Node","searchBasics","TreeSearch","nodeClone","iter","MAX_STEP_COUNT","result","showPlusMinus","forceMultiplySign","expressionLitterale","assignations","rules","aleaExpression","assignationsDecimales","aleaVariables","assignation","value","context","cpt","test","v","n","sign","choice","randint","values","_a","Decimal","_b","texNombre2","traverserEtapes","steps","changeType","x","substep","calculer","expressionPrint","simplifyExpression","stepsExpression","comments","oldNode","newNode","comment","commentStep","plus","texte","texteCorr","aleaEquation","equation","comparatorSearch","leftNode","rightNode","changement","stepChange","defaultComments","isDecimal","f","den","obtenirListeFacteursPremiers","resoudre","printEquation","solveEquation","left","right","Equation","stepsNewEquation","repetition","detect","oldLeftNode","newLeftNode","oldRightNode","newRightNode","newEquationComparator","color","lastEquation","answer","solution","calculateLeftSide","calculateRightSide","SymbolNode","thesolution"],"mappings":"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"}