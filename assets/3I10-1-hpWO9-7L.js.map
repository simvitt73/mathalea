{"version":3,"file":"3I10-1-hpWO9-7L.js","sources":["../../src/exercices/3e/3I10-1.js"],"sourcesContent":["import { colorToLatexOrHTML } from '../../lib/2d/colorToLatexOrHtml'\nimport { fixeBordures } from '../../lib/2d/fixeBordures'\nimport { point } from '../../lib/2d/PointAbstrait'\nimport { lampeMessage } from '../../lib/format/message'\nimport { deuxColonnes } from '../../lib/format/miseEnPage'\nimport { texteGras } from '../../lib/format/style'\nimport { propositionsQcm } from '../../lib/interactif/qcm'\nimport { choice } from '../../lib/outils/arrayOutils'\nimport { lettreMinusculeDepuisChiffre } from '../../lib/outils/outilString'\nimport {\n  ajouterAx,\n  ajouterAy,\n  allerA,\n  angleScratchTo2d,\n  attendre,\n  baisseCrayon,\n  creerLutin,\n  leveCrayon,\n  orienter,\n} from '../../modules/2dLutin'\nimport { context } from '../../modules/context'\nimport { mathalea2d } from '../../modules/mathalea2d'\nimport {\n  noteLaCouleur,\n  plateau2dNLC,\n  testInstruction,\n} from '../../modules/noteLaCouleur'\nimport { listeQuestionsToContenu, randint } from '../../modules/outils'\nimport { scratchblock } from '../../modules/scratchblock'\nimport Exercice from '../Exercice'\n\nexport const titre = 'Analyser des scripts Scratch'\nexport const interactifReady = true\nexport const interactifType = 'qcm'\nexport const amcReady = true\nexport const amcType = 'AMCHybride'\n\nexport const dateDePublication = '27/09/2022'\nexport const dateDeModifImportante = '18/06/2028'\n\n/**\n * Analyser un programme scratch utilisant NoteLaCouleur\n * On interdit le mélange des cas (c'est forcément 3 ou 4 couleurs sinon souci Capytale) par Eric Elter le 18/06/2025\n * @author Jean-Claude Lhote\n */\nexport const uuid = '2ecd9'\n\nexport const refs = {\n  'fr-fr': ['3I10-1'],\n  'fr-ch': [],\n}\nfunction nombreDeNegatifs(arr) {\n  const initialValue = 0\n  return arr.reduce(\n    (previousValue, currentValue) => previousValue + (currentValue < 0 ? 1 : 0),\n    initialValue,\n  )\n}\n\nexport default class ScratchMultiScript extends Exercice {\n  constructor() {\n    super()\n    this.besoinFormulaireTexte = [\n      'Compétence évaluée', // EE :On enlève le mélange sinon, on pourrait avoir 3 ou 4 couleurs dans des questions différentes et ensuite souci Capytale.\n      '1 : Repérage dans le plan\\n2 : Boucles répéter n fois imbriquées\\n3 : Conditionnelles',\n    ]\n\n    this.spacing = 2\n    this.nbQuestions = 1\n\n    this.typeExercice = 'Scratch'\n\n    this.sup = '2'\n    this.correctionDetailleeDisponible = true\n    this.correctionDetaille = false\n  }\n\n  nouvelleVersion() {\n    this.introduction = lampeMessage({\n      titre: 'Information',\n      texte:\n        scratchblock(\n          `\\\\begin{scratch}[${context.issortieNB ? 'print,' : ''}fill,blocks,scale=0.5]\\n\\\\blockmoreblocks{Note la couleur}\\\\end{scratch}`,\n        ) +\n        ' Cette brique donne la couleur de la case sur laquelle est positionné le lutin.',\n      couleur: 'nombres',\n    })\n    const lePlateau = plateau2dNLC({\n      type: 1,\n      melange: false,\n      scale: 0.5,\n      relatif: true,\n    })\n    const listeCouleurs = [\n      'Blanc',\n      'Vert',\n      'Bleu',\n      'Rouge',\n      'Noir',\n      'Rose',\n      'Orange',\n      'Jaune',\n      'Gris',\n    ]\n    this.consigne =\n      'Donner la série de couleurs affichées par ce' +\n      (this.nbQuestions > 1 ? 's' : '') +\n      ' programme' +\n      (this.nbQuestions > 1 ? 's.' : '.')\n    const mesQcm = []\n    let indexReponse = 0\n    const choixQuestions = parseInt(this.sup)\n    const noteLesCouleurs = []\n    const lutins = []\n    const couleurs = []\n    context.unitesLutinParCm = 20 // avancer de 10 pour le lutin lui fait parcourir 1cm (en fait 0,5cm car j'ai ajouté un scale=0.5 pour la sortie latex)\n    context.pixelsParCm = 20 // 20 pixels d'écran représentent 1cm (enfin ça dépend du zoom, donc c'est juste un réglage par défaut)\n\n    for (let i = 0, cpt = 0; i < this.nbQuestions && cpt < 50; ) {\n      const objetsCorrection = []\n      couleurs[i] = []\n      const x = []\n      const y = []\n      const touchePressee = lettreMinusculeDepuisChiffre(i + 1)\n      const choixBriqueInitiale = [\n        [\n          '\\\\blockinit{quand \\\\greenflag est cliqué}\\n',\n          'Quand le drapeau vert est cliqué',\n        ],\n        [\n          '\\\\blockinit{quand ce sprite est cliqué}\\n',\n          'Quand ce sprite est cliqué',\n        ],\n        [\n          `\\\\blockinit{quand la touche \\\\selectmenu{${touchePressee}} est pressée}\\n`,\n          `Quand la touche ${touchePressee} est pressée`,\n        ],\n        [\n          \"\\\\blockinit{quand la touche \\\\selectmenu{n'importe laquelle} est pressée}\\n\",\n          \"Quand n'importe quelle touche est pressée\",\n        ],\n      ]\n\n      let texteScratch = `\\\\begin{scratch}[${context.issortieNB ? 'print,' : ''}fill,blocks,scale=0.8]\\n`\n      const rotations = ['\\\\turnright{}', '\\\\turnleft{}']\n      const orientations = [0, 90, 180]\n      texteScratch += choixBriqueInitiale[2][0]\n      noteLesCouleurs[i] = noteLaCouleur({\n        x: 0,\n        y: 0,\n        plateau: lePlateau.plateauNLC,\n        relatif: true,\n      })\n      const pion = noteLesCouleurs[i]\n      lutins[i] = creerLutin()\n      lutins.color = colorToLatexOrHTML('green') // la couleur de la trace\n      lutins.epaisseur = 3 // son epaisseur\n      lutins.pointilles = false // le type de pointillés (on peut mettre false pour avoir un trait plein)\n      allerA(0, 0, lutins[i]) // ça c'est pour faire bouger le lutin (écrire le programme ne le fait pas exécuter !)\n      baisseCrayon(lutins[i]) // à partir de là, le lutin laissera une trace (ses positions successives sont enregistrées dans lutins[i].listeTraces)\n\n      switch (choixQuestions) {\n        case 1:\n          x[0] = 0\n          y[0] = 0\n          do {\n            for (let j = 1; j <= 3; j++) {\n              x[j] = randint(-6, 5, x)\n              y[j] = randint(-4, 3, [...y, ...x])\n            }\n            for (let j = 1; j <= 3; j++) {\n              x[j] = x[j] * 30 + 15\n              y[j] = y[j] * 30 + 15\n            }\n          } while (nombreDeNegatifs([...x, ...y]) < 3)\n          leveCrayon(lutins[i])\n          texteScratch += '\\\\blockpen{effacer tout}\\n'\n          texteScratch += `\\\\blockmove{aller à x: \\\\ovalnum{${x[0]}} y: \\\\ovalnum{${y[0]}}}\\n`\n          texteScratch += \"\\\\blockmove{s'orienter à \\\\ovalnum{90}}\\n\"\n          orienter(angleScratchTo2d(90), lutins[i])\n          texteScratch += \"\\\\blockpen{stylo en position d'écriture}\\n\"\n          baisseCrayon(lutins[i])\n          for (let j = 1; j <= 3; j++) {\n            texteScratch += `\\\\blockmove{aller à x: \\\\ovalnum{${x[j]}} y: \\\\ovalnum{${y[j]}}}\\n`\n            allerA(x[j], y[j], lutins[i])\n            pion.currentPos = { x: x[j], y: y[j] }\n            texteScratch += '\\\\blockmoreblocks{Note la couleur}\\n'\n            couleurs[i].push(pion.nlc())\n            attendre(5, lutins[i])\n          }\n          texteScratch += '\\\\blockpen{relever le stylo}\\n'\n          leveCrayon(lutins[i])\n          texteScratch += '\\\\blockstop{stop \\\\selectmenu{tout}}'\n\n          break\n\n        case 2:\n          x.push(randint(-5, 0) * 30 + 15)\n          y.push(randint(0, 1) * 30 + 15)\n          if (choice([true, false])) {\n            x.push(60, 60, 60) // ça marche avec ces valeurs sans sortir du plateau...\n            y.push(30, 30, 30) // on peut éventuellement changer à condition de vérifier si ça ne sort pas...\n          } else {\n            x.push(30, 30, 30) // ça marche avec ces valeurs sans sortir du plateau...\n            y.push(60, 60, 60) // on peut éventuellement changer à condition de vérifier si ça ne sort pas...\n          }\n          leveCrayon(lutins[i])\n          texteScratch += '\\\\blockpen{effacer tout}\\n'\n          texteScratch += `\\\\blockmove{aller à x: \\\\ovalnum{${x[0]}} y: \\\\ovalnum{${y[0]}}}\\n`\n          texteScratch += `\\\\blockmove{s'orienter à \\\\ovalnum{${i % 3 < 2 ? 90 : 180}}}\\n`\n          pion.currentPos = { x: x[0], y: y[0] }\n          allerA(x[0], y[0], lutins[i])\n          pion.currentOrientation = i % 3 < 2 ? 90 : 180\n          orienter(angleScratchTo2d(i % 3 < 2 ? 90 : 180), lutins[i])\n          texteScratch += \"\\\\blockpen{stylo en position d'écriture}\\n\"\n          baisseCrayon(lutins[i])\n          texteScratch += `\\\\blockrepeat{répéter \\\\ovalnum{2} fois}{\n\\\\blockrepeat{répéter \\\\ovalnum{2} fois}{\n\\\\blockmove{avancer de \\\\ovalnum{${x[(i % 3) + 1]}} pas}\n\\\\blockmove{tourner ${rotations[i % 2]} de \\\\ovalnum{90} degrés}\n\\\\blockmove{avancer de \\\\ovalnum{${y[(i % 3) + 1]}} pas}\n\\\\blockmove{tourner ${rotations[(i + 1) % 2]} de \\\\ovalnum{90} degrés}\n\\\\blockmoreblocks{Note la couleur}\n}\n\\\\blockmove{tourner ${rotations[i % 3 === 2 ? 1 : 0]} de \\\\ovalnum{90} degrés}\n}\\n`\n          for (let k = 0; k < 2; k++) {\n            for (let l = 0; l < 2; l++) {\n              const test = testInstruction(\n                `AV${x[(i % 3) + 1]}`,\n                lutins[i],\n                pion,\n              )\n              if (test[0]) {\n                pion.currentPos.x = test[1]\n                pion.currentPos.y = test[2]\n                pion.currentOrientation = test[3]\n                lutins[i] = test[5]\n              } else {\n                //   throw Error('Le mouvement n\\'est pas valide : sortie de plateau')\n              }\n              if (rotations[i % 2] === '\\\\turnright{}') {\n                const test = testInstruction('TD90', lutins[i], pion)\n                if (test[0]) {\n                  pion.currentPos.x = test[1]\n                  pion.currentPos.y = test[2]\n                  pion.currentOrientation = test[3]\n                  lutins[i] = test[5]\n                } else {\n                  //  throw Error('Le mouvement n\\'est pas valide : sortie de plateau')\n                }\n              } else {\n                const test = testInstruction('TG90', lutins[i], pion)\n                if (test[0]) {\n                  pion.currentPos.x = test[1]\n                  pion.currentPos.y = test[2]\n                  pion.currentOrientation = test[3]\n                  lutins[i] = test[5]\n                } else {\n                  //  throw Error('Le mouvement n\\'est pas valide : sortie de plateau')\n                }\n              }\n              const test2 = testInstruction(\n                `AV${y[(i % 3) + 1]}`,\n                lutins[i],\n                pion,\n              )\n              if (test2[0]) {\n                pion.currentPos.x = test2[1]\n                pion.currentPos.y = test2[2]\n                pion.currentOrientation = test2[3]\n                lutins[i] = test2[5]\n              } else {\n                //  throw Error('Le mouvement n\\'est pas valide : sortie de plateau')\n              }\n              if (rotations[(i + 1) % 2] === '\\\\turnright{}') {\n                const test3 = testInstruction('TD90', lutins[i], pion)\n                pion.currentPos.x = test3[1]\n                pion.currentPos.y = test3[2]\n                pion.currentOrientation = test3[3]\n                lutins[i] = test3[5]\n              } else {\n                const test3 = testInstruction('TG90', lutins[i], pion)\n                if (test3[0]) {\n                  pion.currentPos.x = test3[1]\n                  pion.currentPos.y = test3[2]\n                  pion.currentOrientation = test3[3]\n                  lutins[i] = test3[5]\n                } else {\n                  //  throw Error('Le mouvement n\\'est pas valide : sortie de plateau')\n                }\n              }\n              attendre(5, lutins[i])\n              couleurs[i].push(pion.nlc())\n            }\n            let test4\n            if (rotations[i % 3 === 2 ? 1 : 0] === '\\\\turnright{}') {\n              test4 = testInstruction('TD90', lutins[i], pion)\n            } else {\n              test4 = testInstruction('TG90', lutins[i], pion)\n            }\n            pion.currentPos.x = test4[1]\n            pion.currentPos.y = test4[2]\n            pion.currentOrientation = test4[3]\n            lutins[i] = test4[5]\n          }\n          texteScratch += '\\\\blockpen{relever le stylo}\\n'\n          leveCrayon(lutins[i])\n          texteScratch += '\\\\blockstop{stop \\\\selectmenu{tout}}\\n'\n\n          break\n\n        default:\n          x.push(randint(-4, 2) * 30 + 15)\n          y.push(randint(-4, 2) * 30 + 15)\n          x.push(-120, 30, 30, 60, 30, 30)\n          y.push(30, -120, -30, 30, 60, 60)\n          leveCrayon(lutins[i])\n          texteScratch += '\\\\blockpen{effacer tout}\\n'\n          texteScratch += `\\\\blockmove{aller à x: \\\\ovalnum{${x[0]}} y: \\\\ovalnum{${y[0]}}}\\n`\n          pion.currentPos = { x: x[0], y: y[0] }\n          allerA(x[0], y[0], lutins[i])\n          texteScratch += `\\\\blockmove{s'orienter à \\\\ovalnum{${orientations[i % 3]}}}\\n`\n          pion.currentOrientation = orientations[i % 3]\n          orienter(angleScratchTo2d(orientations[i % 3]), lutins[i])\n          texteScratch += \"\\\\blockpen{stylo en position d'écriture}\\n\"\n          baisseCrayon(lutins[i])\n          texteScratch += `\\\\blockrepeat{répéter \\\\ovalnum{4} fois}{\n\\\\blockifelse{si \\\\booloperator{\\\\ovalmove{${i % 3 < 1 ? 'abscisse x' : 'ordonnée y'}} > \\\\ovalnum{${i % 3 < 1 ? 120 : 30}}} alors}\n{\\\\blockmove{ajouter \\\\ovalnum{${x[(i % 3) + 1]}} à x}\\n\\\\blockmove{ajouter \\\\ovalnum{${y[(i % 3) + 1]}} à y}\\n}\n{\\\\blockmove{ajouter \\\\ovalnum{${x[(i % 3) + 4]}} à x}\\n\\\\blockmove{ajouter \\\\ovalnum{${y[(i % 3) + 4]}} à y}\\n}\n\\\\blockmoreblocks{Note la couleur}\\n}\\n`\n          for (let k = 0; k < 4; k++) {\n            if (i % 3 < 1) {\n              if (\n                lutins[i].x >\n                (i % 3 < 1 ? 120 : 30) / context.unitesLutinParCm\n              ) {\n                ajouterAx(x[(i % 3) + 1], lutins[i])\n                ajouterAy(y[(i % 3) + 1], lutins[i])\n                if (\n                  pion.testCoords(\n                    lutins[i].x * context.unitesLutinParCm,\n                    lutins[i].y * context.unitesLutinParCm,\n                  )\n                ) {\n                  pion.currentPos = {\n                    x: lutins[i].x * context.unitesLutinParCm,\n                    y: lutins[i].y * context.unitesLutinParCm,\n                  }\n                } else {\n                  //  throw Error('Le mouvement n\\'est pas valide : sortie de plateau')\n                }\n              } else {\n                ajouterAx(x[(i % 3) + 4], lutins[i])\n                ajouterAy(y[(i % 3) + 4], lutins[i])\n                if (\n                  pion.testCoords(\n                    lutins[i].x * context.unitesLutinParCm,\n                    lutins[i].y * context.unitesLutinParCm,\n                  )\n                ) {\n                  pion.currentPos = {\n                    x: lutins[i].x * context.unitesLutinParCm,\n                    y: lutins[i].y * context.unitesLutinParCm,\n                  }\n                } else {\n                  //     throw Error('Le mouvement n\\'est pas valide : sortie de plateau')\n                }\n              }\n            } else {\n              if (\n                lutins[i].y >\n                (i % 3 < 1 ? 120 : 30) / context.unitesLutinParCm\n              ) {\n                ajouterAx(x[(i % 3) + 1], lutins[i])\n                ajouterAy(y[(i % 3) + 1], lutins[i])\n                if (\n                  pion.testCoords(\n                    lutins[i].x * context.unitesLutinParCm,\n                    lutins[i].y * context.unitesLutinParCm,\n                  )\n                ) {\n                  pion.currentPos = {\n                    x: lutins[i].x * context.unitesLutinParCm,\n                    y: lutins[i].y * context.unitesLutinParCm,\n                  }\n                } else {\n                  //  throw Error('Le mouvement n\\'est pas valide : sortie de plateau')\n                }\n              } else {\n                ajouterAx(x[(i % 3) + 4], lutins[i])\n                ajouterAy(y[(i % 3) + 4], lutins[i])\n                if (\n                  pion.testCoords(\n                    lutins[i].x * context.unitesLutinParCm,\n                    lutins[i].y * context.unitesLutinParCm,\n                  )\n                ) {\n                  pion.currentPos = {\n                    x: lutins[i].x * context.unitesLutinParCm,\n                    y: lutins[i].y * context.unitesLutinParCm,\n                  }\n                } else {\n                  //   throw Error('Le mouvement n\\'est pas valide : sortie de plateau')\n                }\n              }\n            }\n            attendre(5, lutins[i])\n            couleurs[i].push(pion.nlc())\n          }\n          texteScratch += '\\\\blockpen{relever le stylo}\\n'\n          leveCrayon(lutins[i])\n          texteScratch += '\\\\blockstop{stop \\\\selectmenu{tout}}'\n\n          break\n      }\n      texteScratch += '\\\\end{scratch}'\n      let texte = `${this.interactif || context.isAmc ? '' : 'Noter la séquence de couleurs produite.<br>'}`\n      texte += deuxColonnes(\n        scratchblock(texteScratch),\n        mathalea2d(\n          Object.assign({}, fixeBordures(lePlateau.objets), {\n            scale: 0.4,\n            style: 'display: inline',\n          }),\n          lePlateau.objets,\n        ),\n        35,\n      )\n\n      let texteCorr = 'On obtient la série de couleurs suivante :<br> '\n      texteCorr += `${texteGras(couleurs[i][0])} `\n      for (let k = 1; k < couleurs[i].length; k++) {\n        texteCorr += `- ${texteGras(couleurs[i][k])} `\n      }\n      texteCorr += '<br>'\n      lutins[i].animation =\n        `<radialGradient id=\"Ball\" cx=\"8\" cy=\"-3\" r=\"20\" gradientUnits=\"userSpaceOnUse\">\n    <stop offset=\"0\" style=\"stop-color:#FFFF99\"/>\n    <stop offset=\"1\" style=\"stop-color:#FF9400\"/>\n  </radialGradient> <circle fill=\"url(#Ball)\"  r=\"12\" stroke-width=\"1\"\n   x=\"${lutins[i].listeTraces[0][0] * context.pixelsParCm}\"\n    y=\"${-lutins[i].listeTraces[0][1] * context.pixelsParCm}\">\\n\n    <animateMotion path=\"M ${lutins[i].listeTraces[0][0] * context.pixelsParCm} ${-lutins[i].listeTraces[0][1] * context.pixelsParCm} L`\n\n      for (let k = 0; k < lutins[i].listeTraces.length; k++) {\n        const B = point(\n          lutins[i].listeTraces[k][2],\n          lutins[i].listeTraces[k][3],\n        )\n        lutins[i].animation +=\n          ` ${B.xSVG(context.pixelsParCm)} ${B.ySVG(context.pixelsParCm)} `\n      }\n      lutins[i].animation +=\n        '\" begin=\"10s\" dur=\"10s\" repeatCount=\"indefinite\" />; </circle>'\n      lutins[i].updateBordures()\n      objetsCorrection.push(lePlateau.objets, lutins[i])\n      texteCorr += mathalea2d(\n        Object.assign({}, fixeBordures(objetsCorrection), {\n          style: 'display: inline',\n          scale: 0.4,\n        }),\n        objetsCorrection,\n      )\n      if (!context.isAmc) {\n        // on prépare les\n        for (let k = 0; k < couleurs[i].length; k++) {\n          this.autoCorrection[indexReponse + k] = {}\n          this.autoCorrection[indexReponse + k].options = {\n            ordered: true,\n            vertical: false,\n            nbCols: 9,\n          }\n\n          this.autoCorrection[indexReponse + k].propositions = []\n          for (let j = 0; j < listeCouleurs.length; j++) {\n            this.autoCorrection[indexReponse + k].propositions.push({\n              texte: listeCouleurs[j],\n              statut: couleurs[i][k] === listeCouleurs[j],\n            })\n          }\n        }\n      } else {\n        this.autoCorrection[i] = {}\n        this.autoCorrection[i].enonce = `${deuxColonnes(\n          scratchblock(texteScratch),\n          mathalea2d(\n            Object.assign({}, fixeBordures(lePlateau.objets), {\n              scale: 0.4,\n              style: 'display: inline',\n            }),\n            lePlateau.objets,\n          ),\n          35,\n        )}`\n        this.autoCorrection[i].propositions = []\n        this.autoCorrection[i].propositions.push({\n          type: 'AMCOpen',\n          propositions: [\n            {\n              enonce: 'Tracé',\n              texte: texteCorr,\n              statut: 0,\n              sanscadre: true,\n            },\n          ],\n        })\n        for (let k = 0; k < couleurs[i].length; k++) {\n          this.autoCorrection[i].propositions.push({\n            type: 'qcmMono',\n            propositions: [],\n            options: { ordered: true },\n          })\n        }\n        for (let k = 0; k < couleurs[i].length; k++) {\n          this.autoCorrection[i].propositions[k + 1].propositions = []\n          for (let j = 0; j < listeCouleurs.length; j++) {\n            this.autoCorrection[i].propositions[k + 1].propositions.push({\n              texte: listeCouleurs[j],\n              statut: listeCouleurs[j] === couleurs[i][k],\n              reponse: j === 0 ? { texte: `couleur N° ${k + 1} : ` } : {},\n            })\n          }\n        }\n      }\n      for (let k = 0; k < couleurs[i].length; k++) {\n        mesQcm[indexReponse + k] = propositionsQcm(this, indexReponse + k)\n        texte +=\n          `Couleur N° ${k + 1} ? ` +\n          (this.interactif ? mesQcm[indexReponse + k].texte : '')\n        texteCorr +=\n          `Couleur N° ${k + 1} : ` +\n          (this.interactif ? mesQcm[indexReponse + k].texteCorr : '')\n      }\n      if (!context.isHtml && i !== this.nbQuestions - 1) {\n        texte += '\\\\columnbreak'\n        texteCorr += '\\\\columnbreak'\n      }\n      if (this.questionJamaisPosee(i, ...couleurs[i])) {\n        this.listeQuestions[i] = texte\n        this.listeCorrections[i] = texteCorr\n\n        if (!context.isAmc) {\n          indexReponse += couleurs[i].length\n        } else {\n          indexReponse++\n        }\n        i++\n      }\n      cpt++\n    }\n    listeQuestionsToContenu(this)\n  }\n}\n"],"names":["titre","interactifReady","interactifType","amcReady","amcType","dateDePublication","dateDeModifImportante","uuid","refs","nombreDeNegatifs","arr","previousValue","currentValue","ScratchMultiScript","Exercice","lampeMessage","scratchblock","context","lePlateau","plateau2dNLC","listeCouleurs","mesQcm","indexReponse","choixQuestions","noteLesCouleurs","lutins","couleurs","i","cpt","objetsCorrection","x","y","touchePressee","lettreMinusculeDepuisChiffre","choixBriqueInitiale","texteScratch","rotations","orientations","noteLaCouleur","pion","creerLutin","colorToLatexOrHTML","allerA","baisseCrayon","j","randint","leveCrayon","orienter","angleScratchTo2d","attendre","choice","k","l","test","testInstruction","test2","test3","test4","ajouterAx","ajouterAy","texte","deuxColonnes","mathalea2d","fixeBordures","texteCorr","texteGras","B","point","propositionsQcm","listeQuestionsToContenu"],"mappings":"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"}