{"version":3,"file":"Cylindre3dPerspectiveCavaliere-D4DYGA_i.js","sources":["../../src/lib/3d/3dProjectionMathalea2d/Cylindre3dPerspectiveCavaliere.ts"],"sourcesContent":["import { cross, dot } from 'mathjs'\nimport { context } from '../../../modules/context'\nimport {\n  assombrirOuEclaircir,\n  colorToLatexOrHTML,\n  type ColourNames,\n} from '../../2d/colorToLatexOrHtml'\nimport { distancePointDroite, droite } from '../../2d/droites'\nimport { ObjetMathalea2D } from '../../2d/ObjetMathalea2D'\nimport type { PointAbstrait } from '../../2d/PointAbstrait'\nimport { polygone } from '../../2d/polygones'\nimport { segment } from '../../2d/segmentsVecteurs'\nimport { tracePoint } from '../../2d/TracePoint'\nimport { translation } from '../../2d/transformations'\nimport { pointIntersectionDD } from '../../2d/utilitairesPoint'\nimport { vecteur } from '../../2d/Vecteur'\nimport {\n  demicercle3d,\n  droite3d,\n  Point3d,\n  rotation3d,\n  translation3d,\n  Vecteur3d,\n  vecteur3d,\n} from './elementsEtTransformations3d'\n\n/**\n * Classe du cylindre : un cylindre de révolution défini par les centres de ses 2 bases\n * Permet en faisant varier les rayons des deux bases de créer des troncs de cônes (A VERIFIER)\n * @param {Point3d} centrebase1 Centre de la première base\n * @param {Point3d} centrebase2 Centre de la seconde base\n * @param {Vecteur3d} rayon1 Vecteur correspondant au rayon de la première base\n * @param {Vecteur3d} rayon2 Vecteur correspondant au rayon de la seconde base\n * @param {string} [color = 'black'] Couleur des \"bords\" du cylindre : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageGeneratrices = true] Permet (ou pas) l'affichage de génératrices du cylindre\n * @param {boolean} [affichageCentreBases = false] Permet (ou pas) l'affichage des centres respectifs de chaque base\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe du cylindre\n * @param {string} [colorAxe = 'black'] Couleur de l'axe et des centres respectifs de chaque base du cylindre : du type 'blue' ou du type '#f15929'\n * @param {boolean} [cylindreColore = false] Permet (ou pas) de colorier le cylindre\n * @param {string} [colorCylindre = 'lightgray'] Couleur du cylindre (avec gestion intégrée de la nuance de couleurs): du type 'blue' ou du type '#f15929'\n * @param {boolean} [avecFaceHaut = true] Permet (ou pas) d'afficher la face haut du cylindre\n * @property {Point3d} centrebase1 Centre de la première base\n * @property {Point3d} centrebase2 Centre de la seconde base\n * @property {Vecteur3d} rayon1 Vecteur correspondant au rayon de la première base\n * @property {Vecteur3d} rayon2 Vecteur correspondant au rayon de la seconde base\n * @property {string} color Couleur des \"bords\" du cylindre : du type 'blue' ou du type '#f15929'\n * @property {boolean} affichageGeneratrices Permet (ou pas) l'affichage de génératrices du cylindre\n * @property {boolean} affichageCentreBases Permet (ou pas) l'affichage des centres respectifs de chaque base\n * @property {boolean} affichageAxe Permet (ou pas) l'affichage de l'axe du cylindre\n * @property {string} colorAxe Couleur de l'axe et des centres respectifs de chaque base du cylindre : du type 'blue' ou du type '#f15929'\n * @property {boolean} cylindreColore Permet (ou pas) de colorier le cylindre\n * @property {string} colorCylindre Couleur du cylindre (avec gestion intégrée de la nuance de couleurs): du type 'blue' ou du type '#f15929'\n * @property {number} angleDepart Angle de rotation à partir duquel les demis-cercles formant la base sont tracés\n * @property {Points[]} pointsBase1 Liste des points formant la ligne de la base 1\n * @property {Points[]} pointsBase2 Liste des points formant la ligne de la base 2\n * @property {Array} c2d Contient les commandes à tracer en 2d de cette fonction\n * @author Jean-Claude Lhote (optimisé par Eric Elter)\n * @class\n */\n\nexport class Cylindre3d extends ObjetMathalea2D {\n  normal: Vecteur3d\n  centrebase1: Point3d\n  centrebase2: Point3d\n  pointsBase1: PointAbstrait[]\n  pointsBase2: PointAbstrait[]\n  rayon1: Vecteur3d\n  rayon2: Vecteur3d\n  color: [string, string]\n  affichageGeneratrices: boolean\n  affichageCentreBases: boolean\n  affichageAxe: boolean\n  colorAxe: string\n  cylindreColore: boolean\n  colorCylindre: string\n  angleDepart: number\n  c2d: ObjetMathalea2D[]\n  constructor(\n    centrebase1: Point3d,\n    centrebase2: Point3d,\n    rayon1: Vecteur3d,\n    rayon2: Vecteur3d,\n    color: string = 'black',\n    affichageGeneratrices = true,\n    affichageCentreBases = false,\n    affichageAxe = false,\n    colorAxe = 'black',\n    cylindreColore = false,\n    colorCylindre = 'lightgray',\n    avecFaceHaut = true,\n  ) {\n    super()\n    this.centrebase1 = centrebase1\n    this.centrebase2 = centrebase2\n    this.rayon1 = rayon1\n    this.rayon2 = rayon2\n    this.color = colorToLatexOrHTML(color)\n    this.affichageGeneratrices = affichageGeneratrices\n    this.affichageCentreBases = affichageCentreBases\n    this.affichageAxe = affichageAxe\n    this.colorAxe = colorAxe\n    this.cylindreColore = cylindreColore\n    this.colorCylindre = colorCylindre\n    this.c2d = []\n    let s\n    this.normal = vecteur3d(this.centrebase1, this.centrebase2)\n    const coords = cross(this.normal.matrice, this.rayon1.matrice)\n    const coordsArray = (coords as any).toArray().map(Number) as number[]\n    const prodvec = vecteur3d(coordsArray[0], coordsArray[1], coordsArray[2])\n    const prodscal = dot(prodvec.matrice, vecteur3d(0, 1, 0).matrice) as number\n\n    let cote1, cote2\n    const centre1PlusBasQueCentre2 =\n      this.centrebase1.c2d.y !== this.centrebase2.c2d.y\n        ? this.centrebase1.c2d.y < this.centrebase2.c2d.y\n        : context.anglePerspective > 0\n    if (prodscal * context.anglePerspective > 0) {\n      cote1 = centre1PlusBasQueCentre2 ? 'direct' : 'indirect'\n      cote2 = centre1PlusBasQueCentre2 ? 'indirect' : 'direct'\n    } else {\n      cote2 = centre1PlusBasQueCentre2 ? 'direct' : 'indirect'\n      cote1 = centre1PlusBasQueCentre2 ? 'indirect' : 'direct'\n    }\n    cote2 = this.rayon1.x === 0 && this.rayon1.y === 0 ? 'indirect' : cote2\n    cote1 = this.rayon1.x === 0 && this.rayon1.y === 0 ? 'direct' : cote1\n    // Cette partie permet de chercher le bon angle de départ pour le tracé des demi-bases\n    // Recherche du premier point visible sur la demi-base visible\n    let angleDepart = 0\n    let distanceMax = 0\n    const d = droite3d(this.centrebase1, this.normal)\n    let ptReference = rotation3d(\n      translation3d(this.centrebase1, this.rayon1),\n      d,\n      angleDepart,\n    )\n    const secondPt = rotation3d(\n      translation3d(this.centrebase1, this.rayon1),\n      d,\n      angleDepart + 1,\n    )\n    const sensRecherche =\n      distancePointDroite(ptReference.c2d, d.c2d) <\n      distancePointDroite(secondPt.c2d, d.c2d)\n        ? 1\n        : -1\n    while (distancePointDroite(ptReference.c2d, d.c2d) > distanceMax) {\n      distanceMax = distancePointDroite(ptReference.c2d, d.c2d)\n      angleDepart = angleDepart + sensRecherche\n      ptReference = rotation3d(\n        translation3d(this.centrebase1, this.rayon1),\n        d,\n        angleDepart,\n      )\n    }\n    angleDepart = angleDepart - sensRecherche\n    // angleDepart est donc l'angle qui permet d'avoir un tracé de demicercle3d idéal\n    this.angleDepart = angleDepart\n    // Description de chaque demi-base en position verticale\n    // c1 : cercle bas derrière\n    const c1 = demicercle3d(\n      this.centrebase1,\n      this.normal,\n      this.rayon1,\n      cote1,\n      true,\n      this.color[0],\n      angleDepart,\n    )\n    // c3 : cercle haut derrière\n    const c3 = demicercle3d(\n      this.centrebase2,\n      this.normal,\n      this.rayon2,\n      cote1,\n      false,\n      this.color[0],\n      angleDepart,\n    )\n    // c2 : cercle bas devant\n    const c2 = demicercle3d(\n      this.centrebase1,\n      this.normal,\n      this.rayon1,\n      cote2,\n      false,\n      this.color[0],\n      angleDepart,\n    )\n    // c4 : cercle haut devant\n    const c4 = demicercle3d(\n      this.centrebase2,\n      this.normal,\n      this.rayon2,\n      cote2,\n      false,\n      this.color[0],\n      angleDepart,\n    )\n    this.pointsBase1 = [...c1.listePoints, ...c2.listePoints]\n    this.pointsBase2 = [...c3.listePoints, ...c4.listePoints]\n    if (this.cylindreColore) {\n      let polygon = [...c4.listePoints]\n      for (let i = c2.listePoints.length - 1; i >= 0; i--) {\n        polygon.push(c2.listePoints[i])\n      }\n      const faceColoree = polygone(polygon, 'white')\n      faceColoree.couleurDeRemplissage = colorToLatexOrHTML(this.colorCylindre)\n      this.c2d.push(faceColoree)\n\n      polygon = [...c3.listePoints]\n      for (let i = c4.listePoints.length - 1; i >= 0; i--) {\n        polygon.push(c4.listePoints[i])\n      }\n      const baseColoree = polygone(polygon, 'white')\n      baseColoree.couleurDeRemplissage = colorToLatexOrHTML(\n        assombrirOuEclaircir(this.colorCylindre as ColourNames, 25),\n      )\n      this.c2d.push(baseColoree)\n    }\n\n    if (this.affichageGeneratrices) {\n      for (let i = 1; i < c1.listePoints.length - 1; i += 2) {\n        s = segment(c3.listePoints[i], c1.listePoints[i], this.color[0])\n        s.pointilles = 2\n        s.opacite = 0.3\n        this.c2d.push(s)\n      }\n    }\n\n    s = segment(c4.listePoints[0], c2.listePoints[0], this.color[0])\n    this.c2d.push(s)\n\n    if (this.affichageGeneratrices) {\n      for (let i = 1; i < c2.listePoints.length - 1; i++) {\n        s = segment(c4.listePoints[i], c2.listePoints[i], this.color[0])\n        this.c2d.push(s)\n      }\n    }\n\n    s = segment(\n      c4.listePoints[c2.listePoints.length - 1],\n      c2.listePoints[c2.listePoints.length - 1],\n      this.color[0],\n    )\n    this.c2d.push(s)\n\n    this.c2d.push(c1, c2)\n    if (avecFaceHaut) this.c2d.push(c3, c4)\n\n    if (this.affichageCentreBases) {\n      this.c2d.push(\n        tracePoint(this.centrebase1.c2d, this.centrebase2.c2d, this.colorAxe),\n      )\n    }\n\n    if (this.affichageAxe) {\n      let distanceMin = 9999\n      const pt = c2.listePoints\n      let i = 0\n      const axeCylindre = droite(this.centrebase2.c2d, this.centrebase1.c2d)\n      while (distancePointDroite(pt[i], axeCylindre) < distanceMin) {\n        distanceMin = distancePointDroite(pt[i], d.c2d)\n        i++\n      }\n      s = segment(this.centrebase2.c2d, this.centrebase1.c2d, this.colorAxe)\n      s.pointilles = 2\n      s.opacite = 0.7\n      this.c2d.push(s)\n\n      // Construction de l'extension de l'axe\n      s = droite(pt[i], pt[i - 1])\n      const ptAxe1 = pointIntersectionDD(s, axeCylindre)\n      if (!ptAxe1) {\n        window.notify('Axe du cylindre non défini correctement', {\n          s,\n          axeCylindre,\n        })\n        return\n      }\n      s = segment(this.centrebase1.c2d, ptAxe1, this.colorAxe)\n      s.pointilles = 2\n      s.opacite = 0.7\n      this.c2d.push(s)\n      s = segment(\n        translation(ptAxe1, vecteur(this.centrebase1.c2d, ptAxe1)),\n        ptAxe1,\n        this.colorAxe,\n      )\n      s.opacite = 0.7\n      this.c2d.push(s)\n\n      const ptAxe2 = translation(\n        this.centrebase2.c2d as PointAbstrait,\n        vecteur(\n          translation(ptAxe1, vecteur(this.centrebase1.c2d, ptAxe1)),\n          this.centrebase1.c2d,\n        ),\n      )\n      s = segment(ptAxe2, this.centrebase2.c2d)\n      s.opacite = 0.7\n      this.c2d.push(s)\n    }\n  }\n}\n/**\n * Crée un cylindre de révolution défini par les centres de ses 2 bases\n * Permet en faisant varier les rayons des deux bases de créer des troncs de cônes (A VERIFIER)\n * @param {Point3d} centrebase1 Centre de la première base\n * @param {Point3d} centrebase2 Centre de la seconde base\n * @param {Vecteur3d} rayon1 Vecteur correspondant au rayon de la première base\n * @param {Vecteur3d} rayon2 Vecteur correspondant au rayon de la seconde base\n * @param {string} [color = 'black'] Couleur des \"bords\" du cylindre : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageGeneratrices = true] Permet (ou pas) l'affichage de génératrices du cylindre\n * @param {boolean} [affichageCentreBases = false] Permet (ou pas) l'affichage des centres respectifs de chaque base\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe du cylindre\n * @param {string} [colorAxe = 'black'] Couleur de l'axe et des centres respectifs de chaque base du cylindre : du type 'blue' ou du type '#f15929'\n * @param {boolean} [cylindreColore = false] Permet (ou pas) de colorier le cylindre\n * @param {string} [colorCylindre = 'lightgray'] Couleur du cylindre (avec gestion intégrée de la nuance de couleurs): du type 'blue' ou du type '#f15929'\n * @param {boolean} [avecFaceHaut = true] Permet (ou pas) d'afficher la face haut du cylindre\n * @example cylindre3d(A, B, v, v, 'blue')\n * // Retourne un cylindre à bords bleus dont les bases ont pour centre respectif A et B et le rayon est donné par le vecteur v.\n * @example cylindre3d(A, B, v, v, 'green', false, true, true, 'red', true, 'lightblue')\n * // Retourne un cylindre à bords verts dont les bases ont pour centre respectif A et B et le rayon est donné par le vecteur v.\n * // Les génératrices sont invisibles, les centres et axe sont visibles et rouges, le cylindre est coloré en bleu.\n * @author Jean-Claude Lhote (optimisé par Eric Elter)\n * @return {Cylindre3d}\n */\nexport function cylindre3d(\n  centrebase1: Point3d,\n  centrebase2: Point3d,\n  rayon: Vecteur3d,\n  rayon2: Vecteur3d,\n  color: string = 'black',\n  affichageGeneratrices = true,\n  affichageCentreBases = false,\n  affichageAxe = false,\n  colorAxe = 'black',\n  cylindreColore = false,\n  colorCylindre = 'lightgray',\n  avecFaceHaut = true,\n) {\n  return new Cylindre3d(\n    centrebase1,\n    centrebase2,\n    rayon,\n    rayon2,\n    color,\n    affichageGeneratrices,\n    affichageCentreBases,\n    affichageAxe,\n    colorAxe,\n    cylindreColore,\n    colorCylindre,\n    avecFaceHaut,\n  )\n}\n"],"names":["Cylindre3d","ObjetMathalea2D","centrebase1","centrebase2","rayon1","rayon2","color","affichageGeneratrices","affichageCentreBases","affichageAxe","colorAxe","cylindreColore","colorCylindre","avecFaceHaut","__publicField","colorToLatexOrHTML","s","vecteur3d","coordsArray","cross","prodvec","prodscal","dot","cote1","cote2","centre1PlusBasQueCentre2","context","angleDepart","distanceMax","d","droite3d","ptReference","rotation3d","translation3d","secondPt","sensRecherche","distancePointDroite","c1","demicercle3d","c3","c2","c4","polygon","i","faceColoree","polygone","baseColoree","assombrirOuEclaircir","segment","tracePoint","distanceMin","pt","axeCylindre","droite","ptAxe1","pointIntersectionDD","translation","vecteur","ptAxe2","cylindre3d","rayon"],"mappings":"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"}