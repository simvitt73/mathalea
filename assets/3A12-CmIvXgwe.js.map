{"version":3,"file":"3A12-CmIvXgwe.js","sources":["../../src/exercices/3e/3A12.ts"],"sourcesContent":["import {\n  choice,\n  combinaisonListesSansChangerOrdre,\n} from '../../lib/outils/arrayOutils'\nimport { miseEnEvidence } from '../../lib/outils/embellissements'\nimport { numAlpha } from '../../lib/outils/outilString'\nimport {\n  decompositionFacteursPremiers,\n  pgcd,\n  ppcm,\n} from '../../lib/outils/primalite'\nimport { texNombre } from '../../lib/outils/texNombre'\nimport Exercice from '../Exercice'\nimport { context } from '../../modules/context'\nimport { listeQuestionsToContenu, randint } from '../../modules/outils'\nimport { ajouterAide } from '../../lib/outils/enrichissements'\nexport const titre = \"Résoudre un exercice d'engrenages\"\nexport const dateDeModifImportante = '01/04/2023'\n/**\n * ppcmEngrenages\n * les deux on besoin de la def partielle serie : stlX\n * @author Sébastien Lozano\n */\nexport const uuid = 'ce352'\n\nexport const refs = {\n  'fr-fr': ['3A12'],\n  'fr-ch': ['9NO4-23'],\n}\nexport default class PpcmEngrenages extends Exercice {\n  constructor() {\n    super()\n\n    context.isHtml ? (this.spacing = 2) : (this.spacing = 2)\n    context.isHtml ? (this.spacingCorr = 2) : (this.spacingCorr = 1)\n    this.nbQuestionsModifiable = false\n    this.nbQuestions = 4\n\n    this.sup = false\n  }\n\n  nouvelleVersion() {\n    let typesDeQuestions\n    const typesDeQuestionsDisponibles = [1, 2, 3]\n    const listeTypeDeQuestions = combinaisonListesSansChangerOrdre(\n      typesDeQuestionsDisponibles,\n      this.nbQuestions,\n    )\n    /*\n    const txtIntro = 'Boîte de vitesse, transmission de vélo, de moto, perceuse électrique, tout cela fonctionne avec des engrenages ! Mais au fait, comment ça fonctionne, les engrenages ?'\n    if (context.isHtml) {\n      const numEx = '3A12' // pour rendre unique les id des SVG, en cas d'utilisation dans plusieurs exercices y faisant appel\n      const idUnique = `${numEx}_${Date.now()}`\n      const idDivIntro = `divIntro${idUnique}`\n      // On ajoute un customElement au registre via la fonction svgEngrenages()\n      svgEngrenages()\n      txtIntro += warnMessage(`Attention, les roues ci-dessous ne comportent pas le nombre de dents de l'énoncé ! <br> <svg-engrenage id=\"${idDivIntro}\"></svg-engrenage>`, 'nombres', 'Coup de pouce')\n    } else {\n      txtIntro += '\\\\\\\\ \\\\textit{Attention, les roues ci-dessous ne comportent pas le nombre de dents de l\\'énoncé !} \\\\\\\\ \\\\Engrenages[Couleur=white,Unite=1mm]{1/24,1/9}'\n    }\n\n    this.introduction = lampeMessage({\n      titre: 'Arithmétique des engrenages',\n      texte: txtIntro,\n      couleur: 'nombres'\n    })\n    */\n\n    for (\n      let i = 0, texte, texteCorr, k, cpt = 0;\n      i < this.nbQuestions && cpt < 50;\n\n    ) {\n      texte = ''\n      texteCorr = ''\n      typesDeQuestions = listeTypeDeQuestions[i]\n\n      let nbDentsr1 = 0\n      let nbDentsr2 = 0\n      let txtPopup = `Soient deux nombres entiers a et b, lorsque le plus petit multiple commun à $a$ et $b$ vaut $a \\\\times b$ ${context.isHtml ? '' : '\\\\\\\\'}( $ppcm(a,b)=a\\\\times b$ ), on dit que `\n      if (context.isHtml) {\n        txtPopup += '<b>les nombres a et b sont premiers entre eux.</b>'\n      } else {\n        txtPopup += '$\\\\textbf{les nombres a et b sont premiers entre eux}$.'\n      }\n      let txtPopupBis = `Soient deux nombres entiers a et b, lorsque le plus grang diviseur commun à $a$ et $b$ vaut $1$ ${context.isHtml ? '' : '\\\\\\\\'} ( $pgcd(a,b)=1$ ), on dit que `\n      if (context.isHtml) {\n        txtPopupBis += '<b>les nombres a et b sont premiers entre eux.</b>'\n      } else {\n        txtPopupBis += '$\\\\textbf{les nombres a et b sont premiers entre eux}$.'\n      }\n      let txtPopupTer =\n        \"Soient deux nombres entiers a et b, lorsque $a$ et $b$ n'ont pas d'autre diviseur commun que $1$, on dit que \"\n      if (context.isHtml) {\n        txtPopupTer += '<b>les nombres a et b sont premiers entre eux.</b>'\n      } else {\n        txtPopupTer += '$\\\\textbf{les nombres a et b sont premiers entre eux}$.'\n      }\n\n      switch (typesDeQuestions) {\n        case 1:\n          {\n            // avec de petits nombres on calcule les mutliples\n            nbDentsr1 = randint(5, 30)\n            nbDentsr2 = randint(5, 30, nbDentsr1)\n            texte += `La roue n$^\\\\circ$1 possède $${nbDentsr1}$ dents et la roue n$^\\\\circ$2 a $${nbDentsr2}$ dents.`\n            texte +=\n              '<br>' +\n              numAlpha(0) +\n              ` Écrire la liste des multiples de $${nbDentsr1}$ et de $${nbDentsr2}$ jusqu'à trouver un multiple commun.`\n            if (ppcm(nbDentsr1, nbDentsr2) === nbDentsr1 * nbDentsr2) {\n              texte += `<br>Justifier que ${nbDentsr1} et ${nbDentsr2} sont des `\n              texte += ajouterAide(\n                `${context.isHtml ? '<br>' : '\\\\\\\\'} ${txtPopup}`,\n                {\n                  texteAvant: 'nombres premiers entre eux',\n                  titreAide:\n                    'Définition à partir du plus petit multiple commun',\n                },\n              )\n            }\n            texte += '.'\n            texte +=\n              '<br>' +\n              numAlpha(1) +\n              ' En déduire le nombre de tours de chaque roue avant le retour à leur position initiale.'\n            texteCorr =\n              numAlpha(0) +\n              ` Liste des premiers multiples de $${nbDentsr1}$ : <br>`\n            // on va faire en sorte de toujours avoir un nombre de multiples multiple de 5\n            let nbMarge = 5 - ((ppcm(nbDentsr1, nbDentsr2) / nbDentsr1) % 5)\n            let kMax = ppcm(nbDentsr1, nbDentsr2) / nbDentsr1 + nbMarge\n            for (let k = 1; k < kMax + 1; k++) {\n              texteCorr += `$${k}\\\\times${nbDentsr1} = `\n              if (k === ppcm(nbDentsr1, nbDentsr2) / nbDentsr1) {\n                texteCorr += miseEnEvidence(texNombre(k * nbDentsr1))\n                texteCorr += '$ ; '\n              } else {\n                texteCorr += `${texNombre(k * nbDentsr1)}$ ; `\n              }\n              if (k % 5 === 0) {\n                texteCorr += '<br>'\n              }\n            }\n            texteCorr += '$\\\\ldots$ '\n            texteCorr += '<br>'\n            texteCorr += ` Liste des premiers multiples de $${nbDentsr2}$ : <br>`\n            // on va faire en sorte de toujours avoir un nombre de multiples multiple de 5\n            nbMarge = 5 - ((ppcm(nbDentsr1, nbDentsr2) / nbDentsr2) % 5)\n            kMax = ppcm(nbDentsr1, nbDentsr2) / nbDentsr2 + nbMarge\n            for (let k = 1; k < kMax + 1; k++) {\n              texteCorr += `$${k}\\\\times${nbDentsr2} = `\n              if (k === ppcm(nbDentsr1, nbDentsr2) / nbDentsr2) {\n                texteCorr += miseEnEvidence(texNombre(k * nbDentsr2))\n                texteCorr += '$ ; '\n              } else {\n                texteCorr += `${texNombre(k * nbDentsr2)}$ ; `\n              }\n              if (k % 5 === 0) {\n                texteCorr += '<br>'\n              }\n            }\n            texteCorr += '$\\\\ldots$ '\n            texteCorr += '<br>'\n            if (ppcm(nbDentsr1, nbDentsr2) === nbDentsr1 * nbDentsr2) {\n              texteCorr +=\n                '$ppcm(' +\n                nbDentsr1 +\n                ';' +\n                nbDentsr2 +\n                ')=' +\n                nbDentsr1 +\n                '\\\\times' +\n                nbDentsr2 +\n                `$ donc $${nbDentsr1}$ et $${nbDentsr2}$ sont des `\n              texteCorr += ajouterAide(\n                `${context.isHtml ? '<br>' : '\\\\\\\\'} ${txtPopup}`,\n                {\n                  texteAvant: 'nombres premiers entre eux',\n                  titreAide:\n                    'Définition à partir du plus petit multiple commun',\n                },\n              )\n            }\n            texteCorr += '.'\n            texteCorr += '<br>'\n            texteCorr +=\n              numAlpha(1) +\n              ` Le plus petit multiple commun à $${nbDentsr1}$ et $${nbDentsr2}$ vaut donc $${ppcm(nbDentsr1, nbDentsr2)}$.<br>\n            Il suffit donc que chaque roue tourne de $${ppcm(nbDentsr1, nbDentsr2)}$ dents pour faire un nombre entier de tours et ainsi revenir dans sa position initiale.<br>\n            En effet, chaque roue doit tourner de façon à ce que le nombre total de dents utilisé soit un multiple de son nombre\n            de dents soit au minimum de $${texNombre(ppcm(nbDentsr1, nbDentsr2))}$ dents.`\n            texteCorr += `<br> Cela correspond à $(${ppcm(nbDentsr1, nbDentsr2)}\\\\text{ dents})\\\\div (${nbDentsr1}\\\\text{ dents/tour}) = ${ppcm(nbDentsr1, nbDentsr2) / nbDentsr1}$`\n            if (ppcm(nbDentsr1, nbDentsr2) / nbDentsr1 === 1) {\n              texteCorr += ' tour '\n            } else {\n              texteCorr += ' tours '\n            }\n            texteCorr += 'pour la roue n$^\\\\circ$1.'\n            texteCorr += `<br>Cela correspond à $(${ppcm(nbDentsr1, nbDentsr2)}\\\\text{ dents})\\\\div (${nbDentsr2}\\\\text{ dents/tour}) = ${ppcm(nbDentsr1, nbDentsr2) / nbDentsr2}$`\n            if (ppcm(nbDentsr1, nbDentsr2) / nbDentsr2 === 1) {\n              texteCorr += ' tour '\n            } else {\n              texteCorr += ' tours '\n            }\n            texteCorr += 'pour la roue n$^\\\\circ$2.'\n          }\n          break\n        case 2: // avec de plus grands nombre, c'est mieux de décomposer en facteurs premiers\n          if (this.sup) {\n            nbDentsr1 = randint(51, 100)\n            nbDentsr2 = randint(51, 100, nbDentsr1)\n            while (nbDentsr2 % nbDentsr1 === 0 || nbDentsr1 % nbDentsr2 === 0) {\n              nbDentsr2 = randint(51, 100, nbDentsr1)\n            }\n          } else {\n            nbDentsr1 = randint(31, 80)\n            nbDentsr2 = randint(31, 80, nbDentsr1)\n            while (nbDentsr2 % nbDentsr1 === 0 || nbDentsr1 % nbDentsr2 === 0) {\n              nbDentsr2 = randint(51, 100, nbDentsr1)\n            }\n          }\n\n          texte += `La roue n$^\\\\circ$1 possède $${nbDentsr1}$ dents et la roue n$^\\\\circ$2 a $${nbDentsr2}$ dents.`\n          texte +=\n            '<br>' +\n            numAlpha(0) +\n            ` Décomposer $${nbDentsr1}$ et $${nbDentsr2}$ en produit de facteurs premiers.`\n          if (ppcm(nbDentsr1, nbDentsr2) === nbDentsr1 * nbDentsr2) {\n            texte += `<br>Justifier que ${nbDentsr1} et ${nbDentsr2} sont des `\n            texte += ajouterAide(\n              `<br>- ${txtPopup} ${context.isHtml ? '<br>- ' : '\\\\\\\\- '} ${txtPopupBis} ${context.isHtml ? '<br>- ' : '\\\\\\\\- '} ${txtPopupTer}`,\n              {\n                texteAvant: 'nombres premiers entre eux',\n                titreAide: 'Trois définitions équivalentes au choix',\n              },\n            )\n          }\n          texte += '.'\n          texte +=\n            '<br>' +\n            numAlpha(1) +\n            ' En déduire le nombre de tours de chaque roue avant le retour à leur position initiale.'\n          texteCorr =\n            \"Pour un nombre de dents plus élevé, il est plus commode d'utiliser les décompositions en produit de facteurs premiers.\"\n          texteCorr +=\n            '<br>' +\n            numAlpha(0) +\n            ` Décomposition de $${nbDentsr1}$ en produit de facteurs premiers :  $${nbDentsr1} = ${decompositionFacteursPremiers(nbDentsr1)}$.`\n          texteCorr += `<br> Décomposition de $${nbDentsr2}$ en produit de facteurs premiers :  $${nbDentsr2} = ${decompositionFacteursPremiers(nbDentsr2)}$.`\n          texteCorr += '<br>'\n          if (ppcm(nbDentsr1, nbDentsr2) === nbDentsr1 * nbDentsr2) {\n            texteCorr +=\n              'Proposition de trois corrections valables pour la déduction : <br>'\n            texteCorr += 'Proposition de correction 1 : <br>'\n\n            texteCorr += `D'après les calculs précédents, $ppcm(${nbDentsr1},${nbDentsr2})= ${decompositionFacteursPremiers(ppcm(nbDentsr1, nbDentsr2))}$.<br>`\n\n            texteCorr += `Donc $${nbDentsr1}$ et $${nbDentsr2}$ sont des `\n            texteCorr += ajouterAide(\n              `${context.isHtml ? '<br>' : '\\\\\\\\'} ${txtPopup}`,\n              {\n                texteAvant: 'nombres premiers entre eux',\n                titreAide: 'Définition à partir du plus petit multiple commun',\n              },\n            )\n          }\n          texteCorr += '.'\n          if (pgcd(nbDentsr1, nbDentsr2) === 1) {\n            texteCorr += '<br>Proposition de correction 2 : <br>'\n\n            texteCorr += `D'après les calculs précédents, $pgcd(${nbDentsr1},${nbDentsr2})= ${pgcd(nbDentsr1, nbDentsr2) === 1 ? 1 : ''} ${decompositionFacteursPremiers(pgcd(nbDentsr1, nbDentsr2))}$.<br>`\n            texteCorr += `Donc $${nbDentsr1}$ et $${nbDentsr2}$ sont des `\n            texteCorr += ajouterAide(\n              `${context.isHtml ? '<br>' : '\\\\\\\\'} ${txtPopupBis}`,\n              {\n                texteAvant: 'nombres premiers entre eux',\n                titreAide: 'Définition à partir du plus grand diviseur commun',\n              },\n            )\n          }\n          texteCorr += '.'\n          if (pgcd(nbDentsr1, nbDentsr2) === 1) {\n            texteCorr += '<br>Proposition de correction 3 : <br>'\n\n            texteCorr += `D'après les calculs précédents, le seul diviseur commun à $${nbDentsr1}$ et $${nbDentsr2}$ vaut $1$.<br> `\n            texteCorr += `Donc $${nbDentsr1}$ et $${nbDentsr2}$ sont des `\n            texteCorr += ajouterAide(\n              `${context.isHtml ? '<br>' : '\\\\\\\\'} ${txtPopupTer}`,\n              {\n                texteAvant: 'nombres premiers entre eux',\n                titreAide:\n                  \"Définition à partir de l'intersection des diviseurs communs\",\n              },\n            )\n          }\n          texteCorr += '.'\n          texteCorr += '<br>'\n          texteCorr +=\n            numAlpha(1) +\n            ` Pour retrouver la position initiale,\n          chaque roue doit tourner de façon à ce que le nombre total de dents utilisé soit un multiple de son nombre\n          de dents.<br>\n          Soit, grâce aux décompositions précédentes, au minimum de $${decompositionFacteursPremiers(ppcm(nbDentsr1, nbDentsr2))} = ${ppcm(nbDentsr1, nbDentsr2)}$ dents.`\n          texteCorr += `<br> Cela correspond à $(${texNombre(ppcm(nbDentsr1, nbDentsr2))}\\\\text{ dents})\\\\div (${nbDentsr1}\\\\text{ dents/tour}) = ${ppcm(nbDentsr1, nbDentsr2) / nbDentsr1}$`\n          if (ppcm(nbDentsr1, nbDentsr2) / nbDentsr1 === 1) {\n            texteCorr += ' tour '\n          } else {\n            texteCorr += ' tours '\n          }\n          texteCorr += 'pour la roue n$^\\\\circ$1.'\n          texteCorr += `<br> Cela correspond à $(${texNombre(ppcm(nbDentsr1, nbDentsr2))}\\\\text{ dents})\\\\div (${nbDentsr2}\\\\text{ dents/tour}) = ${ppcm(nbDentsr1, nbDentsr2) / nbDentsr2}$`\n          if (ppcm(nbDentsr1, nbDentsr2) / nbDentsr2 === 1) {\n            texteCorr += ' tour '\n          } else {\n            texteCorr += ' tours '\n          }\n          texteCorr += 'pour la roue n$^\\\\circ$2.'\n          break\n        case 3: // déterminer le nombre de dents d'une roue connaissant l'autre et le nombre de tours nécessaires à la re-synchro\n          if (this.sup) k = choice([2, 3, 4, 5, 6])\n          else k = choice([2, 3])\n          nbDentsr1 = randint(5, 15)\n          nbDentsr2 = randint(5, 80, nbDentsr1)\n          nbDentsr1 *= k\n          nbDentsr2 *= k\n          texte += `La roue n$^\\\\circ$2 a maintenant $${nbDentsr2}$ dents.`\n          texte += ` Déterminer le nombre de dents de la roue n$^\\\\circ$1 qui ferait $${ppcm(nbDentsr1, nbDentsr2) / nbDentsr1}$ `\n          if (ppcm(nbDentsr1, nbDentsr2) / nbDentsr1 === 1) {\n            texte += ' tour '\n          } else {\n            texte += ' tours '\n          }\n          texte += ` pendant que la roue n$^\\\\circ$2 en fait $${ppcm(nbDentsr1, nbDentsr2) / nbDentsr2}$.`\n          texteCorr = `Puisque la roue n$^\\\\circ$2, qui a $${nbDentsr2}$ dents, fait $${ppcm(nbDentsr1, nbDentsr2) / nbDentsr2}$ `\n          if (ppcm(nbDentsr1, nbDentsr2) / nbDentsr2 === 1) {\n            texteCorr += ' tour '\n          } else {\n            texteCorr += ' tours '\n          }\n          texteCorr += `, cela représente $${texNombre(ppcm(nbDentsr1, nbDentsr2))}$ dents.`\n          texteCorr += `<br>La roue n$^\\\\circ$1 doit donc aussi tourner de $${texNombre(ppcm(nbDentsr1, nbDentsr2))}$ dents, ceci en $${ppcm(nbDentsr1, nbDentsr2) / nbDentsr1}$ `\n          if (ppcm(nbDentsr1, nbDentsr2) / nbDentsr1 === 1) {\n            texteCorr += ' tour '\n          } else {\n            texteCorr += ' tours '\n          }\n          texteCorr += '.'\n          texteCorr += `<br> On obtient donc $(${texNombre(ppcm(nbDentsr1, nbDentsr2))}\\\\text{ dents})\\\\div (${ppcm(nbDentsr1, nbDentsr2) / nbDentsr1}\\\\text{`\n          if (ppcm(nbDentsr1, nbDentsr2) / nbDentsr1 === 1) {\n            texteCorr += ' tour '\n          } else {\n            texteCorr += ' tours '\n          }\n          texteCorr += `}) = ${nbDentsr1} \\\\text{ dents/tour}.$`\n          texteCorr += `<br>La roue n$^\\\\circ$1 a donc $${nbDentsr1}$ dents.`\n          break\n      }\n\n      if (this.questionJamaisPosee(i, nbDentsr1, nbDentsr2)) {\n        // Si la question n'a jamais été posée, on en créé une autre\n        this.listeQuestions[i] = texte\n        this.listeCorrections[i] = texteCorr\n        i++\n      }\n      cpt++\n    }\n\n    listeQuestionsToContenu(this)\n  }\n}\n"],"names":["titre","dateDeModifImportante","uuid","refs","PpcmEngrenages","Exercice","context","typesDeQuestions","listeTypeDeQuestions","combinaisonListesSansChangerOrdre","i","texte","texteCorr","k","cpt","nbDentsr1","nbDentsr2","txtPopup","txtPopupBis","txtPopupTer","randint","numAlpha","ppcm","ajouterAide","nbMarge","kMax","miseEnEvidence","texNombre","decompositionFacteursPremiers","pgcd","choice","listeQuestionsToContenu"],"mappings":"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"}