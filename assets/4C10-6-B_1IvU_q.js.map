{"version":3,"file":"4C10-6-B_1IvU_q.js","sources":["../../src/exercices/4e/4C10-6.ts"],"sourcesContent":["import { propositionsQcm } from '../../lib/interactif/qcm'\nimport { combinaisonListes } from '../../lib/outils/arrayOutils'\nimport { ecritureNombreRelatif } from '../../lib/outils/ecritures'\nimport { texteEnCouleurEtGras } from '../../lib/outils/embellissements'\nimport { lettreDepuisChiffre } from '../../lib/outils/outilString'\nimport { listeQuestionsToContenu, randint } from '../../modules/outils'\nimport { Relatif } from '../../modules/Relatif'\nimport Exercice from '../Exercice'\nexport const interactifReady = true\nexport const interactifType = 'qcm'\nexport const amcReady = true\nexport const amcType = 'qcmMono'\nexport const titre =\n  'Déterminer le signe d\\'un facteur dans une multiplication ou un quotient de relatifs'\nexport const dateDeModifImportante = '18/09/2024'\n\n/**\n * Effectuer des multiplications de relatifs dans un tableau à double entrée\n *\n * @author Cédric GROLLEAU\n */\nexport const uuid = '73187'\n\nexport const refs = {\n  'fr-fr': ['4C10-6'],\n  'fr-ch': ['10NO4-8'],\n}\nexport default class ExerciceTableauMultiplicationsRelatifs extends Exercice {\n  constructor() {\n    super()\n    this.besoinFormulaireNumerique = [\n      'Niveau de difficulté',\n      5,\n      '1 : Multiplications\\n2 : Quotients \\n3 : Multiplications et quotients \\n4 : Multiplications avec plusieurs fois la lettre (dont puissances) \\n5 : Mélange ',\n    ]\n    this.sup = 3\n    this.correctionDetailleeDisponible = true\n    this.correctionDetaillee = false\n    this.spacing = 2\n    this.nbQuestions = 3\n  }\n\n  nouvelleVersion() {\n    let typesDeQuestionsDisponibles\n    switch (this.sup) {\n      case 1: // multiplications\n        typesDeQuestionsDisponibles = [1]\n        break\n      case 2: // Quotient\n        typesDeQuestionsDisponibles = [2]\n        break\n      case 3: // multiplications et quotients\n        typesDeQuestionsDisponibles = [1, 2]\n        break\n      case 4: // produit avec plusieurs fois la lettre\n        typesDeQuestionsDisponibles = [3, 4]\n        break\n      case 5: // mélange\n      default:\n        typesDeQuestionsDisponibles = [1, 2, 3, 4]\n        break\n    }\n    const listeTypeDeQuestions = combinaisonListes(\n      typesDeQuestionsDisponibles,\n      this.nbQuestions,\n    )\n    for (\n      let i = 0,\n        texte,\n        texteCorr,\n        nbLettres,\n        nbNum,\n        expLettre,\n        reponse,\n        cpt = 0;\n      i < this.nbQuestions && cpt < 50;\n\n    ) {\n      this.autoCorrection[i] = {}\n      // on ne choisit que des nombres compris entre 1 et 20\n      const nbMax = 20\n      // Le tableau des relatifs nécessaires, il m'en faut max 5 !\n      const num = new Relatif(\n        randint(-1, 1, [0]) * randint(1, nbMax),\n        randint(-1, 1, [0]) * randint(1, nbMax),\n        randint(-1, 1, [0]) * randint(1, nbMax),\n        randint(-1, 1, [0]) * randint(1, nbMax),\n        randint(-1, 1, [0]) * randint(1, nbMax),\n      )\n      const lettreTab = ['n', 'x', 'y', 'a', 'm']\n      const lettre = lettreTab[randint(0, lettreTab.length - 1)]\n      const nomExpression = lettreDepuisChiffre(i + 1)\n      const signeExpression = randint(-1, 1, [0])\n      const nbTermes =\n        listeTypeDeQuestions[i] === 1 ? randint(3, 5) : randint(4, 6)\n      let placeLettre = randint(0, nbTermes - 1)\n      const listeNombres = num.relatifs.slice(0, nbTermes - 1)\n      const listeTermes = []\n      for (let indice = 0; indice < listeNombres.length; indice++) {\n        listeTermes.push(ecritureNombreRelatif(listeNombres[indice]))\n      }\n      listeTermes.splice(placeLettre, 0, lettre)\n      let calcul = ''\n      let signeLettre, calculNombres\n      texte = `Donner le signe de $${lettre}$ pour que $${nomExpression}$ soit ${signeExpression === -1 ? 'négatif' : 'positif'}. <br>`\n      texteCorr = `${texteEnCouleurEtGras('Supposons que ' + lettre + ' soit positif : ', 'blue')}`\n\n      switch (listeTypeDeQuestions[i]) {\n        case 1: // multiplications\n          calcul += `${listeTermes[0]} `\n          for (let k = 1; k < nbTermes; k++) {\n            calcul += `\\\\times ${listeTermes[k]}`\n          }\n          texte += `$ ${nomExpression} =  ${calcul} $ <br>`\n          reponse =\n            signeExpression === num.getSigneProduitNumber(...listeNombres)\n              ? 'positif'\n              : 'négatif'\n          if (this.correctionDetaillee) {\n            texteCorr += `<br> ${num.setRegleSigneProduit(...listeNombres)}`\n            texteCorr += `<br><br> Donc si ${texteEnCouleurEtGras(lettre + ' est positif', 'black')} $ ${calcul} $ est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres), 'black')}.`\n            texteCorr += `<br><br> ${texteEnCouleurEtGras('Supposons maintenant que ' + lettre + ' soit négatif : ', 'blue')}`\n            listeNombres.push(-1)\n            texteCorr += `<br><br> ${num.setRegleSigneProduit(...listeNombres, -1)}`\n            texteCorr += `<br><br> Donc si ${texteEnCouleurEtGras(lettre + ' est négatif', 'black')} $ ${calcul} $ est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres), 'black')}.`\n            texteCorr +=\n              `<br><br> ${texteEnCouleurEtGras('Conclusion :', 'blue')} <br>` +\n                `Il faut donc que $ ${lettre} $ soit ${texteEnCouleurEtGras(signeExpression === num.getSigneProduitNumber(...listeNombres) ? 'négatif' : 'positif')} pour que $${nomExpression}$ soit ${signeExpression === -1 ? 'négatif' : 'positif'}.`\n          } else {\n            texteCorr = `Il faut que $ ${lettre} $ soit ${signeExpression === num.getSigneProduitNumber(...listeNombres) ? 'positif' : 'négatif'} pour que $${nomExpression}$ soit ${signeExpression === -1 ? 'négatif' : 'positif'}.`\n          }\n          break\n        case 2: // quotient de 2 produits\n          calcul += '\\\\dfrac {' + listeTermes[0]\n          nbNum = randint(2, nbTermes - 2)\n          for (let k = 1; k < nbNum + 1; k++) {\n            calcul += `\\\\times ${listeTermes[k]}`\n          }\n          calcul += '}{' + listeTermes[nbNum + 1]\n          for (let denom = nbNum + 2; denom < nbTermes; denom++) {\n            calcul += `\\\\times ${listeTermes[denom]}`\n          }\n          calcul += '}'\n          texte += `$ ${nomExpression} =  ${calcul} $ <br>`\n          reponse =\n            signeExpression === num.getSigneProduitNumber(...listeNombres)\n              ? 'positif'\n              : 'négatif'\n          if (this.correctionDetaillee) {\n            texteCorr += `<br> ${num.setRegleSigneQuotient(...listeNombres)}`\n            texteCorr += `<br><br> Donc si ${texteEnCouleurEtGras(lettre + ' est positif', 'black')} $ ${calcul} $ est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres), 'black')}.`\n            texteCorr += `<br><br> ${texteEnCouleurEtGras('Supposons maintenant que ' + lettre + ' soit négatif : ', 'blue')}`\n            listeNombres.push(-1)\n            texteCorr += `<br> ${num.setRegleSigneQuotient(...listeNombres)}`\n            texteCorr += `<br><br> Donc si ${texteEnCouleurEtGras(lettre + ' est négatif', 'black')} $ ${calcul} $ est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres), 'black')}.`\n            texteCorr +=\n              `<br><br> ${texteEnCouleurEtGras('Conclusion :', 'blue')} <br>` +\n                `Il faut donc que $ ${lettre} $ soit ${texteEnCouleurEtGras(signeExpression === num.getSigneProduitNumber(...listeNombres) ? 'négatif' : 'positif')} pour que $${nomExpression}$ soit ${signeExpression === -1 ? 'négatif' : 'positif'}.`\n          } else {\n            texteCorr = `Il faut que $ ${lettre} $ soit ${signeExpression === num.getSigneProduitNumber(...listeNombres) ? 'positif' : 'négatif'} pour que $${nomExpression}$ soit ${signeExpression === -1 ? 'négatif' : 'positif'}.`\n          }\n\n          break\n        case 3: // produit avec plusieurs fois la lettre\n          signeLettre = randint(-1, 1, [0])\n          texte = `Donner le signe de ${nomExpression} si $ ${lettre} $ est ${signeLettre === -1 ? 'négatif' : 'positif'}. <br>`\n          texteCorr = ''\n          nbLettres = randint(1, 3)\n          placeLettre = randint(0, nbTermes - 1)\n          for (let k = 0; k < nbLettres; k++) {\n            listeTermes.splice(placeLettre, 0, lettre)\n          }\n          calcul += `${listeTermes[0]} `\n          for (let k = 1; k < nbTermes + nbLettres; k++) {\n            calcul += `\\\\times ${listeTermes[k]}`\n          }\n          calculNombres = `${listeNombres[0]} `\n          for (let k = 1; k < nbTermes - 1; k++) {\n            calculNombres += `\\\\times ${listeNombres[k]}`\n          }\n          texte += `$ ${nomExpression} = ${calcul} $ <br>`\n          if (this.correctionDetaillee) {\n            if (nbLettres === 1 || nbLettres === 3) {\n              texteCorr += `On trouve ${nbLettres + 1} fois le facteur $ ${lettre} $.<br> Or ${nbLettres + 1} est pair donc leur produit sera positif.`\n              texteCorr += `<br>Le signe de l'expression a donc le signe de : $ ${calculNombres} $`\n              texteCorr += `<br><br> ${num.setRegleSigneProduit(...listeNombres)}`\n              texteCorr +=\n                '<br><br>' +\n                  `Donc ${nomExpression} est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres))} quel que soit le signe de $ ${lettre} $.`\n            } else {\n              texteCorr += `On trouve ${nbLettres + 1} fois le facteur $ ${lettre} $. <br> Or ${nbLettres + 1} est impair donc leur produit est du signe de $ ${lettre} $ soit ${signeLettre === -1 ? 'négatif' : 'positif'}.`\n              if (signeLettre === -1) {\n                texteCorr += `<br>Le signe de l'expression a donc le signe opposé à : $ ${calculNombres} $`\n                texteCorr += `<br><br> ${num.setRegleSigneProduit(...listeNombres)}`\n                listeNombres.push(-1)\n                texteCorr +=\n                  '<br><br>' +\n                    `Donc ${nomExpression} est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres))} quand $ ${lettre} $ est ${signeLettre === -1 ? 'négatif' : 'positif'}.`\n              } else {\n                texteCorr += `<br>Le signe de l'expression a donc le signe opposé à : $ ${calculNombres} $`\n                texteCorr += `<br><br> ${num.setRegleSigneProduit(...listeNombres)}`\n                texteCorr +=\n                  '<br><br>' +\n                    `Donc ${nomExpression} est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres))} quand $ ${lettre} $ est ${signeLettre === -1 ? 'négatif' : 'positif'}.`\n              }\n            }\n            reponse = num.getSigneProduitString(...listeNombres)\n          } else {\n            if (nbLettres === 1 || nbLettres === 3) {\n              texteCorr =\n                `Donc ${nomExpression} est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres))} quel que soit le signe de $ ${lettre} $.`\n            } else {\n              if (signeLettre === -1) {\n                listeNombres.push(-1)\n                texteCorr =\n                  `Donc ${nomExpression} est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres))} quand $ ${lettre} $ est ${signeLettre === -1 ? 'négatif' : 'positif'}.`\n              } else {\n                texteCorr =\n                  `Donc ${nomExpression} est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres))} quand $ ${lettre} $ est ${signeLettre === -1 ? 'négatif' : 'positif'}.`\n              }\n            }\n            reponse = num.getSigneProduitString(...listeNombres)\n          }\n          break\n        case 4: // puissance\n          signeLettre = randint(-1, 1, [0])\n          texte = `Donner le signe de ${nomExpression} si $ ${lettre} $ est ${signeLettre === -1 ? 'négatif' : 'positif'}. <br>`\n          texteCorr = ''\n          expLettre = randint(2, 7)\n          if (placeLettre === 0) {\n            calcul += listeTermes[0] + '^{' + expLettre + '}'\n          } else {\n            calcul += listeTermes[0]\n          }\n          for (let k = 1; k < nbTermes; k++) {\n            if (k === placeLettre) {\n              calcul += '\\\\times ' + listeTermes[k] + '^{' + expLettre + '}'\n            } else {\n              calcul += '\\\\times ' + listeTermes[k]\n            }\n          }\n          calculNombres = `${listeNombres[0]} `\n          for (let k = 1; k < nbTermes - 1; k++) {\n            calculNombres += `\\\\times ${listeNombres[k]}`\n          }\n          texte += `$ ${nomExpression} =  ${calcul} $ <br>`\n          if (this.correctionDetaillee) {\n            if (expLettre % 2 === 0) {\n              texteCorr += `On trouve ${expLettre} fois le facteur $ ${lettre} $.<br> Or ${expLettre} est pair donc leur produit sera positif.`\n              texteCorr += `<br>Le signe de l'expression a donc le signe de : $ ${calculNombres} $`\n              texteCorr += `<br><br> ${num.setRegleSigneProduit(...listeNombres)}`\n              texteCorr +=\n                '<br><br>' +\n                  `Donc ${nomExpression} est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres))} quel que soit le signe de $ ${lettre} $.`\n              reponse = num.getSigneProduitString(...listeNombres)\n            } else {\n              texteCorr += `On trouve ${expLettre} fois le facteur $ ${lettre} $. <br> Or ${expLettre} est impair donc leur produit est du signe de $ ${lettre} $ soit ${signeLettre === -1 ? 'négatif' : 'positif'}.`\n              if (signeLettre === -1) {\n                texteCorr += `<br>Le signe de l'expression a donc le signe opposé à : $ ${calculNombres} $`\n                texteCorr += `<br><br> ${num.setRegleSigneProduit(...listeNombres)}`\n                listeNombres.push(-1)\n                texteCorr +=\n                  '<br><br>' +\n                    `Donc ${nomExpression} est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres))} quand $ ${lettre} $ est ${signeLettre === -1 ? 'négatif' : 'positif'}.`\n              } else {\n                texteCorr += `<br>Le signe de l'expression a donc le signe opposé à : $ ${calculNombres} $`\n                texteCorr += `<br><br> ${num.setRegleSigneProduit(...listeNombres)}`\n                texteCorr +=\n                  '<br><br>' +\n                    `Donc ${nomExpression} est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres))} quand $ ${lettre} $ est ${signeLettre === -1 ? 'négatif' : 'positif'}.`\n              }\n              reponse = num.getSigneProduitString(...listeNombres)\n            }\n          } else {\n            if (expLettre % 2 === 0) {\n              texteCorr +=\n                `Donc ${nomExpression} est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres))} quel que soit le signe de $ ${lettre} $.`\n            } else {\n              if (signeLettre === -1) {\n                listeNombres.push(-1)\n                texteCorr = `Donc ${nomExpression} est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres))} quand $ ${lettre} $ est ${signeLettre === -1 ? 'négatif' : 'positif'}.`\n              } else {\n                texteCorr = `Donc ${nomExpression} est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres))} quand $ ${lettre} $ est ${signeLettre === -1 ? 'négatif' : 'positif'}.`\n              }\n            }\n            reponse = num.getSigneProduitString(...listeNombres)\n          }\n          break\n      }\n      this.autoCorrection[i] = {\n        enonce: texte,\n        options: { ordered: true },\n        propositions: [\n          {\n            texte: 'négatif',\n            statut: reponse === 'négatif',\n          },\n          /* {\n            texte: 'nul',\n            statut: false\n          }, */\n          {\n            texte: 'positif',\n            statut: reponse === 'positif',\n          },\n        ],\n      }\n\n      texte += propositionsQcm(this, i).texte\n      if (\n        this.questionJamaisPosee(i, listeTypeDeQuestions[i], ...listeNombres)\n      ) {\n        // Si la question n'a jamais été posée, on en créé une autre\n        this.listeQuestions[i] = texte\n        this.listeCorrections[i] = texteCorr\n        i++\n      }\n      cpt++\n    }\n    listeQuestionsToContenu(this)\n  }\n}\n"],"names":["interactifReady","interactifType","amcReady","amcType","titre","dateDeModifImportante","uuid","refs","ExerciceTableauMultiplicationsRelatifs","Exercice","typesDeQuestionsDisponibles","listeTypeDeQuestions","combinaisonListes","i","texte","texteCorr","nbLettres","nbNum","expLettre","reponse","cpt","nbMax","num","Relatif","randint","lettreTab","lettre","nomExpression","lettreDepuisChiffre","signeExpression","nbTermes","placeLettre","listeNombres","listeTermes","indice","ecritureNombreRelatif","calcul","signeLettre","calculNombres","texteEnCouleurEtGras","k","denom","propositionsQcm","listeQuestionsToContenu"],"mappings":"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"}