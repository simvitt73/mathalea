{"version":3,"file":"auto6M2A-D9PyzMr1.js","sources":["../../src/exercices/6e/auto6M2A.ts"],"sourcesContent":["import { arc } from '../../lib/2d/Arc'\nimport { codageSegment } from '../../lib/2d/CodageSegment'\nimport { colorToLatexOrHTML } from '../../lib/2d/colorToLatexOrHtml'\nimport { droite, droiteParPointEtPente } from '../../lib/2d/droites'\nimport type { ISegment } from '../../lib/2d/Interfaces'\nimport type { PointAbstrait } from '../../lib/2d/PointAbstrait'\nimport { point } from '../../lib/2d/PointAbstrait'\nimport { polygone } from '../../lib/2d/polygones'\nimport { segment } from '../../lib/2d/segmentsVecteurs'\nimport {\n  homothetie,\n  projectionOrtho,\n  rotation,\n  translation,\n} from '../../lib/2d/transformations'\nimport {\n  estDansQuadrilatere,\n  estDansTriangle,\n  longueur,\n} from '../../lib/2d/utilitairesGeometriques'\nimport {\n  milieu,\n  pointIntersectionDD,\n  pointSurSegment,\n} from '../../lib/2d/utilitairesPoint'\nimport { vecteur } from '../../lib/2d/Vecteur'\nimport { propositionsQcm } from '../../lib/interactif/qcm'\nimport { choice, combinaisonListes } from '../../lib/outils/arrayOutils'\nimport { arrondi } from '../../lib/outils/nombres'\nimport { numAlpha } from '../../lib/outils/outilString'\nimport { translationPuisRotationAnimees } from '../../modules/2dAnimation'\nimport { context } from '../../modules/context'\nimport { mathalea2d } from '../../modules/mathalea2d'\nimport {\n  gestionnaireFormulaireTexte,\n  listeQuestionsToContenu,\n  randint,\n} from '../../modules/outils'\nimport type { NestedObjetMathalea2dArray } from '../../types/2d'\nimport Exercice from '../Exercice'\n\nexport const dateDePublication = '08/06/2022'\nexport const dateDeModifImportante = '22/01/2025'\nexport const titre = 'Comparer périmètres et/ou aires de figures'\nexport const interactifReady = true\nexport const interactifType = 'qcm'\n\n/**\n * Comparer aires et/ou périmètres de figures avec ceux d'un rectangle référence\n * @author Eric Elter\n */\nexport const uuid = '95313'\n\nexport const refs = {\n  'fr-fr': ['auto6M2A'],\n  'fr-2016': ['6M21'],\n  'fr-ch': ['9GM1-10'],\n}\n\n/** Retourne un nombre décimal entre a et b, sans être trop près de a et de b\n * @param {number} a borne inférieure\n * @param {number} b borne supérieure\n * @author Eric Elter\n * @returns {number}\n */\nfunction entreDeux(a: number, b: number) {\n  if (a < b) return arrondi(a + ((b - a) * randint(10, 90)) / 100, 2)\n  else return arrondi(b + ((a - b) * randint(10, 90)) / 100, 2)\n}\n\nexport default class CompareAireEtPerimetreAvecRectangle extends Exercice {\n  constructor() {\n    super()\n    this.besoinFormulaireTexte = [\n      'Type de figures',\n      `Nombres séparés par des tirets :\n  1 : Polygone inscrit dans un rectangle\n  2 : Rectangle inscrit dans un polygone\n  3 : Rectangle avec deux demi-disques alternés qui s'emboitent\n  4 : Rectangle avec deux demi-disques alternés qui ne s'emboitent pas\n  5 : Rectangle avec deux demi-disques en plus\n  6 : Rectangle avec deux demi-disques en moins\n  7 : Quadrilatère inscrit dans un rectangle\n  8 : Rectangle inscrit dans un quadrilatère\n  9 : Rectangle avec deux triangles alternés qui s'emboîtent\n  10 : Rectangle avec deux triangles alternés qui ne s'emboîtent pas\n  11 : Rectangle avec deux triangles en plus\n  12 : Rectangle avec deux triangles en moins\n  13 : Mélange `,\n    ]\n    this.besoinFormulaire2Numerique = [\n      'Périmètres et/ou aires',\n      4,\n      \"1 : Que des périmètres\\n2 : Que des aires\\n3 : Les deux\\n4 : L'un ou l'autre au hasard des questions\",\n    ]\n\n    this.nbQuestions = 3\n    this.sup = 13\n    this.sup2 = 3\n  }\n\n  nouvelleVersion() {\n    const typesDeProblemes = gestionnaireFormulaireTexte({\n      max: 12,\n      defaut: 13,\n      melange: 13,\n      nbQuestions: this.nbQuestions,\n      saisie: this.sup,\n    })\n\n    const color = combinaisonListes(\n      ['red', 'blue', 'green', 'gray', 'pink', '#f15929'],\n      this.nbQuestions,\n    )\n\n    let aireOuPerimetre = 'Les deux'\n    if (this.sup2 === 1) aireOuPerimetre = 'Perimetre'\n    else if (this.sup2 === 2) aireOuPerimetre = 'Aire'\n\n    let compteurInteractif = 0\n    for (let q = 0, cpt = 0; q < this.nbQuestions && cpt < 50; ) {\n      compteurInteractif = this.sup2 === 3 ? 2 * q : q\n      let choixFigAire2:\n        | [PointAbstrait, PointAbstrait][]\n        | [PointAbstrait, PointAbstrait, number][] = []\n      let objets: NestedObjetMathalea2dArray = []\n      const A = point(0, 0)\n      const B = point(randint(5, 10), 0)\n      const C = point(B.x, randint(5, 10, B.x))\n      const D = point(0, C.y)\n      const rect = polygone([A, B, C, D])\n      rect.hachures = 'north east lines'\n      rect.pointilles = 2\n      let reponseAire1 = false\n      let reponseAire2 = false\n      let reponseAire3 = false\n      const comparePerimetre = choice(['grand', 'petit']) // ToDo : Appliquer la même chose pour les aires\n      if (this.sup2 === 4) aireOuPerimetre = choice(['Aire', 'Perimetre'])\n      let texte = ''\n      let texteCorr = ''\n      switch (typesDeProblemes[q]) {\n        case 1:\n          {\n            // Polygone inscrit dans rectangle\n            const E = A\n            const G = point(entreDeux((A.x + B.x) / 2, B.x), A.y)\n            const F = point(\n              entreDeux(E.x, G.x),\n              entreDeux(A.y, A.y + (D.y + A.y) / 2),\n            )\n            const H = point(\n              entreDeux(G.x, B.x),\n              entreDeux(A.y, A.y + (D.y + A.y) / 2),\n            )\n            const I = B\n            const J = point(entreDeux(H.x, B.x), entreDeux(H.y, C.y))\n            const K = point(B.x, entreDeux(J.y, C.y))\n            const L = point(\n              entreDeux(A.x + (A.x + B.x) / 2, B.x),\n              entreDeux(K.y, C.y),\n            )\n            const M = C\n            const N = point(\n              entreDeux(A.x + (A.x + B.x) / 2, L.x),\n              entreDeux(L.y, D.y),\n            )\n            const O = point(entreDeux(D.x, N.x), D.y)\n            const P = point(\n              entreDeux(D.x, O.x),\n              entreDeux(D.y, A.y + (D.y + A.y) / 2),\n            )\n            const Q = D\n            const R = point(\n              entreDeux(A.x, P.x),\n              entreDeux(P.y, A.y + (D.y + A.y) / 2),\n            )\n            const T = point(\n              entreDeux(A.x, F.x),\n              entreDeux(F.y, A.y + (D.y + A.y) / 2),\n            )\n            const S = point(A.x, entreDeux(R.y, T.y))\n\n            const poly = polygone(\n              E,\n              F,\n              G,\n              H,\n              I,\n              J,\n              K,\n              L,\n              M,\n              N,\n              O,\n              P,\n              Q,\n              R,\n              S,\n              T,\n            )\n            poly.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n            poly.opaciteDeRemplissage = 0.5\n            objets.push(poly, rect)\n            // objets.push(rect)\n\n            texte = mathalea2d(\n              {\n                xmin: -0.5,\n                ymin: -0.5,\n                xmax: B.x + 0.5,\n                ymax: C.y + 0.5,\n                pixelsParCm: 30,\n                scale: 0.7,\n                mainlevee: false,\n                optionsTikz: ['baseline=(current bounding box.north)'],\n              },\n              objets,\n            )\n            // Correction\n            texteCorr = this.sup2 === 3 ? numAlpha(0) : ''\n            texteCorr +=\n              this.sup2 === 1 || this.sup2 === 3 || aireOuPerimetre !== 'Aire'\n                ? 'Il faut parcourir plus de chemin pour effectuer le tour de la figure coloriée que le tour du rectangle hachuré. Donc, la figure coloriée a un périmètre plus grand que celui du rectangle hachuré.'\n                : ''\n            texteCorr += this.sup2 === 3 ? '<br>' + numAlpha(1) : ''\n            texteCorr +=\n              this.sup2 === 2 ||\n              this.sup2 === 3 ||\n              aireOuPerimetre !== 'Perimetre'\n                ? 'Le rectangle hachuré couvre plus de surface que la figure coloriée. Donc, le rectangle hachuré a une aire plus grande que celle de la figure coloriée.'\n                : ''\n            // QCM interactif\n            if (this.interactif) {\n              reponseAire1 = true\n            }\n          }\n          break\n        case 2:\n          {\n            // Rectangle inscrit dans polygone\n            const E = A\n            const G = point(entreDeux((A.x + B.x) / 2, B.x), A.y)\n            const F = point(\n              entreDeux(E.x, G.x),\n              entreDeux(A.y, A.y - (D.y + A.y) / 2),\n            )\n            const H = point(\n              entreDeux(G.x, B.x),\n              entreDeux(A.y, A.y - (D.y + A.y) / 2),\n            )\n            const I = B\n            const J = point(\n              entreDeux(B.x, B.x + (A.x + B.x) / 2),\n              entreDeux(I.y, (I.y + C.y) / 2),\n            )\n            const K = point(B.x, entreDeux(B.y, C.y))\n            const L = point(entreDeux(B.x, J.x), C.y)\n            const N = point(entreDeux(D.x, (C.x + D.x) / 2), C.y)\n            const M = point(\n              entreDeux(N.x, L.x),\n              entreDeux(D.y, D.y + (D.y + A.y) / 2),\n            )\n            const O = point(\n              entreDeux(D.x, N.x),\n              entreDeux(D.y, D.y + (D.y + A.y) / 2),\n            )\n            const P = point(entreDeux(A.x - (A.x + B.x) / 2, A.x), D.y)\n            const Q = point(A.x, entreDeux(A.y, D.y))\n            const R = point(\n              entreDeux(A.x - (A.x + B.x) / 2, A.x),\n              entreDeux(Q.y, A.y),\n            )\n            const poly = polygone(E, F, G, H, I, J, K, L, M, N, O, P, Q, R)\n            poly.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n            poly.opaciteDeRemplissage = 0.5\n            objets.push(poly, rect)\n            texte = mathalea2d(\n              {\n                xmin: Math.min(P.x, R.x) - 0.5,\n                ymin: Math.min(F.y, H.y) - 0.5,\n                xmax: Math.max(J.x, L.x) + 0.5,\n                ymax: Math.max(M.y, O.y) + 0.5,\n                pixelsParCm: 30,\n                scale: 0.7,\n                mainlevee: false,\n                optionsTikz: ['baseline=(current bounding box.north)'],\n              },\n              objets,\n            )\n            // Correction\n            texteCorr = this.sup2 === 3 ? numAlpha(0) : ''\n            texteCorr +=\n              this.sup2 === 1 || this.sup2 === 3 || aireOuPerimetre !== 'Aire'\n                ? 'Il faut parcourir plus de chemin pour effectuer le tour de la figure coloriée que le tour du rectangle hachuré. Donc, la figure coloriée a un périmètre plus grand que celui du rectangle hachuré.'\n                : ''\n            texteCorr += this.sup2 === 3 ? '<br>' + numAlpha(1) : ''\n            texteCorr +=\n              this.sup2 === 2 ||\n              this.sup2 === 3 ||\n              aireOuPerimetre !== 'Perimetre'\n                ? 'Le rectangle hachuré couvre moins de surface que la figure coloriée. Donc, la figure coloriée a une aire plus grande que celle du rectangle hachuré.'\n                : ''\n            // QCM interactif\n            if (this.interactif) {\n              reponseAire2 = true\n            }\n          }\n          break\n        case 3:\n          {\n            // Deux demi-disques alternés qui s'emboîtent\n            const E = point(entreDeux(A.x, A.x + (B.x - A.x) / 3), A.y)\n            const F = point(entreDeux(B.x, A.x + (2 * (B.x - A.x)) / 3), A.y)\n            const G = point(B.x, entreDeux(B.y, B.y + (C.y - B.y) / 3))\n            const H = point(B.x, entreDeux(C.y, B.y + (2 * (C.y - B.y)) / 3))\n            const I = point(entreDeux(B.x, A.x + (2 * (B.x - A.x)) / 3), D.y)\n            const J = point(entreDeux(A.x, A.x + (B.x - A.x) / 3), D.y)\n            const K = point(A.x, entreDeux(C.y, B.y + (2 * (C.y - B.y)) / 3))\n            const L = point(A.x, entreDeux(B.y, B.y + (C.y - B.y) / 3))\n            const poly = polygone(A, B, C, D)\n            poly.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n            poly.opaciteDeRemplissage = 0.5\n            poly.color = colorToLatexOrHTML('none')\n            objets.push(poly)\n            const rayonOuCote = arrondi(\n              Math.min(\n                longueur(E, F),\n                longueur(G, H),\n                longueur(I, J),\n                longueur(K, L),\n              ) / 2,\n            )\n            let M = translation(E, vecteur(rayonOuCote, 0))\n            const N = translation(G, vecteur(0, rayonOuCote))\n            let O = translation(I, vecteur(-rayonOuCote, 0))\n            const P = translation(K, vecteur(0, -rayonOuCote))\n            const paramsEnonce = {\n              xmin: -0.5,\n              ymin: -0.5,\n              xmax: B.x + 0.5,\n              ymax: C.y + 0.5,\n              pixelsParCm: 30,\n              scale: 0.7,\n              mainlevee: false,\n              optionsTikz: ['baseline=(current bounding box.north)'],\n            }\n            const choixFig = randint(0, 3)\n            let pt1: PointAbstrait\n            let pt2: PointAbstrait\n            switch (choixFig) {\n              case 0:\n                pt1 = M\n                pt2 = E\n                paramsEnonce.ymin = -0.5 - rayonOuCote\n                break\n              case 1:\n                pt1 = N\n                pt2 = G\n                paramsEnonce.xmax = rayonOuCote + B.x + 0.5\n                break\n              case 2:\n                pt1 = O\n                pt2 = I\n                paramsEnonce.ymax = rayonOuCote + C.y + 0.5\n                break\n              case 3:\n              default:\n                pt1 = P\n                pt2 = K\n                paramsEnonce.xmin = -0.5 - rayonOuCote\n                break\n            }\n\n            const figAire1 = arc(pt2, pt1, 180, false, color[q], 'black', 0.5)\n            const choixFig2 = randint(0, 3, [choixFig])\n            choixFigAire2 = [\n              [E, M],\n              [G, N],\n              [I, O],\n              [K, P],\n            ]\n            if (choixFig2 === 1) paramsEnonce.xmax = rayonOuCote + B.x + 0.5\n            if (choixFig2 === 3) paramsEnonce.xmin = -0.5 - rayonOuCote\n\n            const figAire2 = arc(\n              choixFigAire2[choixFig2][0],\n              choixFigAire2[choixFig2][1],\n              -180,\n              false,\n              'white',\n              'black',\n              1.1,\n            )\n            M = rotation(pt2, pt1, 60)\n            const NN = segment(M, pt1, 'black')\n            N.epaisseur = 2\n            O = rotation(\n              choixFigAire2[choixFig2][0],\n              choixFigAire2[choixFig2][1],\n              -60,\n            )\n            const PP = segment(O, choixFigAire2[choixFig2][1], 'black')\n            P.epaisseur = 2\n            objets.push(\n              figAire1,\n              figAire2,\n              rect,\n              NN,\n              codageSegment(M, pt1, '|||'),\n              PP,\n              codageSegment(O, choixFigAire2[choixFig2][1], '|||'),\n            )\n            texte = mathalea2d(paramsEnonce, objets)\n            // Correction\n            texteCorr = this.sup2 === 3 ? numAlpha(0) : ''\n            texteCorr +=\n              this.sup2 === 1 || this.sup2 === 3 || aireOuPerimetre !== 'Aire'\n                ? 'Il faut parcourir plus de chemin pour effectuer le tour de la figure coloriée que le tour du rectangle hachuré. Donc, la figure coloriée a un périmètre plus grand que celui du rectangle hachuré.'\n                : ''\n            texteCorr += this.sup2 === 3 ? '<br>' + numAlpha(1) : ''\n            texteCorr +=\n              this.sup2 === 2 ||\n              this.sup2 === 3 ||\n              aireOuPerimetre !== 'Perimetre'\n                ? 'Le rectangle hachuré couvre autant de surface que la figure coloriée. Donc, la figure coloriée a une aire égale à celle du rectangle hachuré.'\n                : ''\n            if (\n              this.sup2 === 2 ||\n              this.sup2 === 3 ||\n              aireOuPerimetre !== 'Perimetre'\n            ) {\n              objets = []\n              const figAire1 = arc(pt2, pt1, 180, false, 'white', 'black', 1.1)\n              const figAireCorr = arc(\n                pt2,\n                pt1,\n                180,\n                false,\n                color[q],\n                'black',\n                0.5,\n              )\n              let angleCorr =\n                choixFig2 - choixFig < 0\n                  ? choixFig2 - choixFig + 4\n                  : choixFig2 - choixFig\n              angleCorr = angleCorr === 1 ? 90 : angleCorr === 2 ? 0 : -90\n              const figAireCorr2 = arc(\n                rotation(\n                  choixFigAire2[choixFig2][0],\n                  choixFigAire2[choixFig2][1],\n                  angleCorr,\n                ),\n                choixFigAire2[choixFig2][1],\n                -180,\n                false,\n                color[q],\n                'black',\n                0.5,\n              )\n              objets.push(\n                poly,\n                figAire1,\n                figAire2,\n                rect,\n                N,\n                codageSegment(M, pt1, '|||'),\n                P,\n                codageSegment(O, choixFigAire2[choixFig2][1], '|||'),\n              )\n              if (context.isHtml)\n                objets.push(\n                  translationPuisRotationAnimees(\n                    String(q),\n                    figAireCorr,\n                    vecteur(pt1, choixFigAire2[choixFig2][1]),\n                    figAireCorr2,\n                    choixFigAire2[choixFig2][1],\n                    -angleCorr,\n                  ),\n                )\n              paramsEnonce.ymin =\n                choixFig2 === 0 ? -0.5 - rayonOuCote : paramsEnonce.ymin\n              paramsEnonce.ymax =\n                choixFig2 === 2 ? rayonOuCote + C.y + 0.5 : paramsEnonce.ymax\n              texteCorr += '<br>' + mathalea2d(paramsEnonce, objets)\n              if (context.isHtml) {\n                texteCorr += `<br><button class=\"btn ui labeled icon button\"  style=\"margin:10px\" onclick=\"document.getElementById('${figAireCorr.id}').style.visibility = 'visible',document.getElementById('${figAireCorr2.id}').style.visibility = 'hidden',\n              setTimeout(function() {document.getElementById('${figAireCorr.id}').style.visibility = 'hidden'}, 5000),\n              setTimeout(function() {document.getElementById('${figAireCorr2.id}').style.visibility = 'visible'}, 5000),document.getElementById('translat${q}').beginElement()\"><i class=\"redo circle icon\"></i>Relancer l'animation de la comparaison d'aires </button>`\n              }\n            }\n            // QCM interactif\n            if (this.interactif) {\n              reponseAire3 = true\n            }\n          }\n          break\n        case 4:\n          {\n            // Deux demi-disques alternés qui ne s'emboîtent pas\n            const E = point(entreDeux(A.x, A.x + (B.x - A.x) / 3), A.y)\n            const F = point(entreDeux(B.x, A.x + (2 * (B.x - A.x)) / 3), A.y)\n            const G = point(B.x, entreDeux(B.y, B.y + (C.y - B.y) / 3))\n            const H = point(B.x, entreDeux(C.y, B.y + (2 * (C.y - B.y)) / 3))\n            const I = point(entreDeux(B.x, A.x + (2 * (B.x - A.x)) / 3), D.y)\n            const J = point(entreDeux(A.x, A.x + (B.x - A.x) / 3), D.y)\n            const K = point(A.x, entreDeux(C.y, B.y + (2 * (C.y - B.y)) / 3))\n            const L = point(A.x, entreDeux(B.y, B.y + (C.y - B.y) / 3))\n            const poly = polygone(A, B, C, D)\n            poly.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n            poly.opaciteDeRemplissage = 0.5\n            poly.color = colorToLatexOrHTML('none')\n            objets.push(poly)\n            const aleaDemiDisque = choice([true, false])\n            const aleaRayon = randint(2, 3)\n            let rayonOuCote = arrondi(\n              Math.min(\n                longueur(E, F),\n                longueur(G, H),\n                longueur(I, J),\n                longueur(K, L),\n              ) / 2,\n            )\n            rayonOuCote = aleaDemiDisque ? rayonOuCote : rayonOuCote / aleaRayon\n            const M = translation(E, vecteur(rayonOuCote, 0))\n            const N = translation(G, vecteur(0, rayonOuCote))\n            const O = translation(I, vecteur(-rayonOuCote, 0))\n            const P = translation(K, vecteur(0, -rayonOuCote))\n            const paramsEnonce = {\n              xmin: -0.5,\n              ymin: -0.5,\n              xmax: B.x + 0.5,\n              ymax: C.y + 0.5,\n              pixelsParCm: 30,\n              scale: 0.7,\n              mainlevee: false,\n              optionsTikz: ['baseline=(current bounding box.north)'],\n            }\n            const choixFig = randint(0, 3)\n            let pt1: PointAbstrait\n            let pt2: PointAbstrait\n            switch (choixFig) {\n              case 0:\n                pt1 = M\n                pt2 = E\n                paramsEnonce.ymin = -0.5 - rayonOuCote\n                break\n              case 1:\n                pt1 = N\n                pt2 = G\n                paramsEnonce.xmax = rayonOuCote + B.x + 0.5\n                break\n              case 2:\n                pt1 = O\n                pt2 = I\n                paramsEnonce.ymax = rayonOuCote + C.y + 0.5\n                break\n              case 3:\n              default:\n                pt1 = P\n                pt2 = K\n                paramsEnonce.xmin = -0.5 - rayonOuCote\n                break\n            }\n            let figAire1 = arc(pt2, pt1, 180, false, color[q], 'black', 0.5)\n            const choixFig2 = randint(0, 3, [choixFig])\n            choixFigAire2 = [\n              [E, M],\n              [G, N],\n              [I, O],\n              [K, P],\n            ]\n            paramsEnonce.xmax =\n              choixFig2 === 1 ? rayonOuCote + B.x + 0.5 : paramsEnonce.xmax\n            paramsEnonce.xmin =\n              choixFig2 === 3 ? -0.5 - rayonOuCote : paramsEnonce.xmin\n            const figAire2 = arc(\n              aleaDemiDisque\n                ? homothetie(\n                    choixFigAire2[choixFig2][1],\n                    choixFigAire2[choixFig2][0],\n                    1 / aleaRayon,\n                  )\n                : choixFigAire2[choixFig2][0],\n              aleaDemiDisque\n                ? choixFigAire2[choixFig2][1]\n                : homothetie(\n                    choixFigAire2[choixFig2][1],\n                    choixFigAire2[choixFig2][0],\n                    aleaRayon,\n                  ),\n              -180,\n              false,\n              'white',\n              'black',\n              1.1,\n            )\n            objets.push(figAire1, figAire2, rect)\n            texte = mathalea2d(paramsEnonce, objets)\n            // Correction\n            texteCorr = this.sup2 === 3 ? numAlpha(0) : ''\n            texteCorr +=\n              this.sup2 === 1 || this.sup2 === 3 || aireOuPerimetre !== 'Aire'\n                ? 'Il faut parcourir plus de chemin pour effectuer le tour de la figure coloriée que le tour du rectangle hachuré. Donc, la figure coloriée a un périmètre plus grand que celui du rectangle hachuré.'\n                : ''\n            texteCorr += this.sup2 === 3 ? '<br>' + numAlpha(1) : ''\n            texteCorr += aleaDemiDisque\n              ? this.sup2 === 2 ||\n                this.sup2 === 3 ||\n                aireOuPerimetre !== 'Perimetre'\n                ? 'Le rectangle hachuré couvre moins de surface que la figure coloriée. Donc, la figure coloriée a une aire plus grande que celle du rectangle hachuré.'\n                : ''\n              : this.sup2 === 2 ||\n                  this.sup2 === 3 ||\n                  aireOuPerimetre !== 'Perimetre'\n                ? 'Le rectangle hachuré couvre plus de surface que la figure coloriée. Donc, le rectangle hachuré a une aire plus grande que celle de la figure coloriée.'\n                : ''\n            if (\n              this.sup2 === 2 ||\n              this.sup2 === 3 ||\n              aireOuPerimetre !== 'Perimetre'\n            ) {\n              objets = []\n              figAire1 = arc(pt2, pt1, 180, false, 'white', 'black', 1.1)\n              const figAireCorr = arc(\n                pt2,\n                pt1,\n                180,\n                false,\n                color[q],\n                'black',\n                0.5,\n              )\n              let angleCorr =\n                choixFig2 - choixFig < 0\n                  ? choixFig2 - choixFig + 4\n                  : choixFig2 - choixFig\n              angleCorr = angleCorr === 1 ? 90 : angleCorr === 2 ? 0 : -90\n              const figAireCorr2 = arc(\n                rotation(\n                  choixFigAire2[choixFig2][0],\n                  choixFigAire2[choixFig2][1],\n                  angleCorr,\n                ),\n                choixFigAire2[choixFig2][1],\n                -180,\n                false,\n                color[q],\n                'black',\n                0.5,\n              )\n              objets.push(poly, figAire1, figAire2, rect)\n              if (context.isHtml)\n                objets.push(\n                  translationPuisRotationAnimees(\n                    String(q),\n                    figAireCorr,\n                    vecteur(pt1, choixFigAire2[choixFig2][1]),\n                    figAireCorr2,\n                    choixFigAire2[choixFig2][1],\n                    -angleCorr,\n                  ),\n                )\n              paramsEnonce.ymin =\n                choixFig2 === 0 ? -0.5 - rayonOuCote : paramsEnonce.ymin\n              paramsEnonce.ymax =\n                choixFig2 === 2 ? rayonOuCote + C.y + 0.5 : paramsEnonce.ymax\n              texteCorr += '<br>' + mathalea2d(paramsEnonce, objets)\n              if (context.isHtml) {\n                texteCorr += `<br><button class=\"btn ui labeled icon button\"  style=\"margin:10px\" onclick=\"document.getElementById('${figAireCorr.id}').style.visibility = 'visible',document.getElementById('${figAireCorr2.id}').style.visibility = 'hidden',\n              setTimeout(function() {document.getElementById('${figAireCorr.id}').style.visibility = 'hidden'}, 5000),\n              setTimeout(function() {document.getElementById('${figAireCorr2.id}').style.visibility = 'visible'}, 5000),document.getElementById('translat${q}').beginElement()\"><i class=\"redo circle icon\"></i>Relancer l'animation de la comparaison d'aires </button>`\n              }\n            }\n            // QCM interactif\n            if (this.interactif) {\n              reponseAire1 = !aleaDemiDisque\n              reponseAire2 = aleaDemiDisque\n            }\n          }\n          break\n        case 5:\n          {\n            // Deux demi-disques en plus\n            const E = point(entreDeux(A.x, A.x + (B.x - A.x) / 3), A.y)\n            const F = point(entreDeux(B.x, A.x + (2 * (B.x - A.x)) / 3), A.y)\n            const G = point(B.x, entreDeux(B.y, B.y + (C.y - B.y) / 3))\n            const H = point(B.x, entreDeux(C.y, B.y + (2 * (C.y - B.y)) / 3))\n            const I = point(entreDeux(B.x, A.x + (2 * (B.x - A.x)) / 3), D.y)\n            const J = point(entreDeux(A.x, A.x + (B.x - A.x) / 3), D.y)\n            const K = point(A.x, entreDeux(C.y, B.y + (2 * (C.y - B.y)) / 3))\n            const L = point(A.x, entreDeux(B.y, B.y + (C.y - B.y) / 3))\n            const poly = polygone(A, B, C, D)\n            poly.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n            poly.opaciteDeRemplissage = 0.5\n            poly.color = colorToLatexOrHTML('none')\n            objets.push(poly)\n            const rayonOuCote = arrondi(\n              Math.min(\n                longueur(E, F),\n                longueur(G, H),\n                longueur(I, J),\n                longueur(K, L),\n              ) / 2,\n            )\n            let M = translation(E, vecteur(rayonOuCote, 0))\n            const N = translation(G, vecteur(0, rayonOuCote))\n            let O = translation(I, vecteur(-rayonOuCote, 0))\n            const P = translation(K, vecteur(0, -rayonOuCote))\n            const paramsEnonce = {\n              xmin: -0.5,\n              ymin: -0.5,\n              xmax: B.x + 0.5,\n              ymax: C.y + 0.5,\n              pixelsParCm: 30,\n              scale: 0.7,\n              mainlevee: false,\n              optionsTikz: ['baseline=(current bounding box.north)'],\n            }\n            const choixFig = randint(0, 3)\n            let pt1: PointAbstrait\n            let pt2: PointAbstrait\n            switch (choixFig) {\n              case 0:\n                pt1 = M\n                pt2 = E\n                paramsEnonce.ymin = -0.5 - rayonOuCote\n                break\n              case 1:\n                pt1 = N\n                pt2 = G\n                paramsEnonce.xmax = rayonOuCote + B.x + 0.5\n                break\n              case 2:\n                pt1 = O\n                pt2 = I\n                paramsEnonce.ymax = rayonOuCote + C.y + 0.5\n                break\n              case 3:\n              default:\n                pt1 = P\n                pt2 = K\n                paramsEnonce.xmin = -0.5 - rayonOuCote\n                break\n            }\n            const figAire1 = arc(pt2, pt1, 180, false, color[q], 'black', 0.5)\n            const choixFig2 = randint(0, 3, [choixFig])\n            choixFigAire2 = [\n              [E, M],\n              [G, N],\n              [I, O],\n              [K, P],\n            ]\n            paramsEnonce.ymin =\n              choixFig2 === 0 ? -0.5 - rayonOuCote : paramsEnonce.ymin\n            paramsEnonce.xmax =\n              choixFig2 === 1 ? rayonOuCote + B.x + 0.5 : paramsEnonce.xmax\n            paramsEnonce.ymax =\n              choixFig2 === 2 ? rayonOuCote + C.y + 0.5 : paramsEnonce.ymax\n            paramsEnonce.xmin =\n              choixFig2 === 3 ? -0.5 - rayonOuCote : paramsEnonce.xmin\n\n            const figAire2 = arc(\n              choixFigAire2[choixFig2][0],\n              choixFigAire2[choixFig2][1],\n              180,\n              false,\n              color[q],\n              'black',\n              0.5,\n            )\n            M = rotation(pt2, pt1, 60)\n            const NN = segment(M, pt1, 'black')\n            N.epaisseur = 2\n            O = rotation(\n              choixFigAire2[choixFig2][0],\n              choixFigAire2[choixFig2][1],\n              60,\n            )\n            const PP = segment(O, choixFigAire2[choixFig2][1], 'black')\n            P.epaisseur = 2\n            objets.push(\n              figAire1,\n              figAire2,\n              rect,\n              NN,\n              codageSegment(M, pt1, '|||'),\n              PP,\n              codageSegment(O, choixFigAire2[choixFig2][1], '|||'),\n            )\n            texte = mathalea2d(paramsEnonce, objets)\n            // Correction\n            texteCorr = this.sup2 === 3 ? numAlpha(0) : ''\n            texteCorr +=\n              this.sup2 === 1 || this.sup2 === 3 || aireOuPerimetre !== 'Aire'\n                ? 'Il faut parcourir plus de chemin pour effectuer le tour de la figure coloriée que le tour du rectangle hachuré. Donc, la figure coloriée a un périmètre plus grand que celui du rectangle hachuré.'\n                : ''\n            texteCorr += this.sup2 === 3 ? '<br>' + numAlpha(1) : ''\n            texteCorr +=\n              this.sup2 === 2 ||\n              this.sup2 === 3 ||\n              aireOuPerimetre !== 'Perimetre'\n                ? 'Le rectangle hachuré couvre moins de surface que la figure coloriée. Donc, la figure coloriée a une aire plus grande que celle du rectangle hachuré.'\n                : ''\n            // QCM interactif\n            if (this.interactif) {\n              reponseAire2 = true\n            }\n          }\n          break\n        case 6:\n          {\n            // Deux demi-disques en moins\n            const E = point(entreDeux(A.x, A.x + (B.x - A.x) / 3), A.y)\n            const F = point(entreDeux(B.x, A.x + (2 * (B.x - A.x)) / 3), A.y)\n            const G = point(B.x, entreDeux(B.y, B.y + (C.y - B.y) / 3))\n            const H = point(B.x, entreDeux(C.y, B.y + (2 * (C.y - B.y)) / 3))\n            const I = point(entreDeux(B.x, A.x + (2 * (B.x - A.x)) / 3), D.y)\n            const J = point(entreDeux(A.x, A.x + (B.x - A.x) / 3), D.y)\n            const K = point(A.x, entreDeux(C.y, B.y + (2 * (C.y - B.y)) / 3))\n            const L = point(A.x, entreDeux(B.y, B.y + (C.y - B.y) / 3))\n            const poly = polygone(A, B, C, D)\n            poly.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n            poly.opaciteDeRemplissage = 0.5\n            poly.color = colorToLatexOrHTML('none')\n            objets.push(poly)\n            const rayonOuCote = arrondi(\n              Math.min(\n                longueur(E, F),\n                longueur(G, H),\n                longueur(I, J),\n                longueur(K, L),\n              ) / 2,\n            )\n            let M = translation(E, vecteur(rayonOuCote, 0))\n            const N = translation(G, vecteur(0, rayonOuCote))\n            let O = translation(I, vecteur(-rayonOuCote, 0))\n            const P = translation(K, vecteur(0, -rayonOuCote))\n            const paramsEnonce = {\n              xmin: -0.5,\n              ymin: -0.5,\n              xmax: B.x + 0.5,\n              ymax: C.y + 0.5,\n              pixelsParCm: 30,\n              scale: 0.7,\n              mainlevee: false,\n              optionsTikz: ['baseline=(current bounding box.north)'],\n            }\n            const choixFig = randint(0, 3)\n            let pt1: PointAbstrait\n            let pt2: PointAbstrait\n            switch (choixFig) {\n              case 0:\n                pt1 = M\n                pt2 = E\n                paramsEnonce.ymin = -0.5 - rayonOuCote\n                break\n              case 1:\n                pt1 = N\n                pt2 = G\n                paramsEnonce.xmax = rayonOuCote + B.x + 0.5\n                break\n              case 2:\n                pt1 = O\n                pt2 = I\n                paramsEnonce.ymax = rayonOuCote + C.y + 0.5\n                break\n              case 3:\n              default:\n                pt1 = P\n                pt2 = K\n                paramsEnonce.xmin = -0.5 - rayonOuCote\n                break\n            }\n            const figAire1 = arc(pt2, pt1, -180, false, 'white', 'black', 1.1)\n            const choixFig2 = randint(0, 3, [choixFig])\n            choixFigAire2 = [\n              [E, M],\n              [G, N],\n              [I, O],\n              [K, P],\n            ]\n            paramsEnonce.ymin =\n              choixFig2 === 0 ? -0.5 - rayonOuCote : paramsEnonce.ymin\n            paramsEnonce.xmax =\n              choixFig2 === 1 ? rayonOuCote + B.x + 0.5 : paramsEnonce.xmax\n            paramsEnonce.ymax =\n              choixFig2 === 2 ? rayonOuCote + C.y + 0.5 : paramsEnonce.ymax\n            paramsEnonce.xmin =\n              choixFig2 === 3 ? -0.5 - rayonOuCote : paramsEnonce.xmin\n\n            const figAire2 = arc(\n              choixFigAire2[choixFig2][0],\n              choixFigAire2[choixFig2][1],\n              -180,\n              false,\n              'white',\n              'black',\n              1.1,\n            )\n            M = rotation(pt2, pt1, -60)\n            const NN = segment(M, pt1, 'black')\n            N.epaisseur = 2\n            O = rotation(\n              choixFigAire2[choixFig2][0],\n              choixFigAire2[choixFig2][1],\n              -60,\n            )\n            const PP = segment(O, choixFigAire2[choixFig2][1], 'black')\n            P.epaisseur = 2\n            objets.push(\n              figAire1,\n              figAire2,\n              rect,\n              NN,\n              codageSegment(M, pt1, '|||'),\n              PP,\n              codageSegment(O, choixFigAire2[choixFig2][1], '|||'),\n            )\n            texte = mathalea2d(paramsEnonce, objets)\n            // Correction\n            texteCorr = this.sup2 === 3 ? numAlpha(0) : ''\n            texteCorr +=\n              this.sup2 === 1 || this.sup2 === 3 || aireOuPerimetre !== 'Aire'\n                ? 'Il faut parcourir plus de chemin pour effectuer le tour de la figure coloriée que le tour du rectangle hachuré. Donc, la figure coloriée a un périmètre plus grand que celui du rectangle hachuré.'\n                : ''\n            texteCorr += this.sup2 === 3 ? '<br>' + numAlpha(1) : ''\n            texteCorr +=\n              this.sup2 === 2 ||\n              this.sup2 === 3 ||\n              aireOuPerimetre !== 'Perimetre'\n                ? 'Le rectangle hachuré couvre plus de surface que la figure coloriée. Donc, le rectangle hachuré a une aire plus grande que celle de la figure coloriée.'\n                : ''\n            // QCM interactif\n            if (this.interactif) {\n              reponseAire1 = true\n            }\n          }\n          break\n        case 7:\n          {\n            // Un quadrilatère inscrit dans le rectangle\n            const E = point(entreDeux(A.x, B.x), A.y)\n            const F = point(B.x, entreDeux(B.y, C.y))\n            const G = point(entreDeux(A.x, B.x), C.y)\n            const H = point(A.x, entreDeux(B.y, C.y))\n            const poly = polygone(E, F, G, H)\n            poly.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n            poly.opaciteDeRemplissage = 0.5\n            objets.push(poly, rect)\n            const paramsEnonce = {\n              xmin: -0.5,\n              ymin: -0.5,\n              xmax: B.x + 0.5,\n              ymax: C.y + 0.5,\n              pixelsParCm: 30,\n              scale: 0.7,\n              mainlevee: false,\n              optionsTikz: ['baseline=(current bounding box.north)'],\n            }\n            texte = mathalea2d(paramsEnonce, objets)\n            // Correction\n            texteCorr = this.sup2 === 3 ? numAlpha(0) : ''\n            texteCorr +=\n              this.sup2 === 1 || this.sup2 === 3 || aireOuPerimetre !== 'Aire'\n                ? 'Il faut parcourir moins de chemin pour effectuer le tour de la figure coloriée que le tour du rectangle hachuré. Donc, le rectangle hachuré a un périmètre plus grand que celui de la figure coloriée.'\n                : ''\n            texteCorr += this.sup2 === 3 ? '<br>' + numAlpha(1) : ''\n            texteCorr +=\n              this.sup2 === 2 ||\n              this.sup2 === 3 ||\n              aireOuPerimetre !== 'Perimetre'\n                ? 'Le rectangle hachuré couvre plus de surface que la figure coloriée. Donc, le rectangle hachuré a une aire plus grande que celle de la figure coloriée.'\n                : ''\n            // QCM interactif\n            if (this.interactif) {\n              reponseAire1 = true\n            }\n          }\n          break\n        case 8:\n          {\n            // Le rectangle inscrit dans un quadrilatère\n            const aleaPente = choice([0, 0.5])\n            const d1 = droiteParPointEtPente(\n              A,\n              -(aleaPente + randint(10, 50) / 100),\n            )\n            const d2 = droiteParPointEtPente(\n              B,\n              -(aleaPente - randint(50, 90) / 100),\n            )\n            const d3 = droiteParPointEtPente(\n              C,\n              -(aleaPente + randint(10, 50) / 100),\n            )\n            const d4 = droiteParPointEtPente(\n              D,\n              -(aleaPente - randint(50, 90) / 100),\n            )\n            const E = pointIntersectionDD(d1, d2)\n            const F = pointIntersectionDD(d2, d3)\n            const G = pointIntersectionDD(d3, d4)\n            const H = pointIntersectionDD(d4, d1)\n            const poly = polygone(E, F, G, H)\n            poly.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n            poly.opaciteDeRemplissage = 0.5\n            objets.push(poly, rect)\n            const paramsEnonce = {\n              xmin: H.x - 0.5,\n              ymin: E.y - 0.5,\n              xmax: F.x + 0.5,\n              ymax: G.y + 0.5,\n              pixelsParCm: 30,\n              scale: 0.7,\n              mainlevee: false,\n              optionsTikz: ['baseline=(current bounding box.north)'],\n            }\n            texte = mathalea2d(paramsEnonce, objets)\n            // Correction\n            texteCorr = this.sup2 === 3 ? numAlpha(0) : ''\n            texteCorr +=\n              this.sup2 === 1 || this.sup2 === 3 || aireOuPerimetre !== 'Aire'\n                ? 'Il faut parcourir plus de chemin pour effectuer le tour de la figure coloriée que le tour du rectangle hachuré. Donc, la figure coloriée a un périmètre plus grand que celui du rectangle hachuré.'\n                : ''\n            texteCorr += this.sup2 === 3 ? '<br>' + numAlpha(1) : ''\n            texteCorr +=\n              this.sup2 === 2 ||\n              this.sup2 === 3 ||\n              aireOuPerimetre !== 'Perimetre'\n                ? 'Le rectangle hachuré couvre moins de surface que la figure coloriée. Donc, la figure coloriée a une aire plus grande que celle du rectangle hachuré.'\n                : ''\n            // QCM interactif\n            if (this.interactif) {\n              reponseAire2 = true\n            }\n          }\n          break\n        case 9:\n          {\n            // Deux triangles alternés qui s'emboîtent\n            const E = point(entreDeux(A.x, A.x + (B.x - A.x) / 3), A.y)\n            const F = point(entreDeux(B.x, A.x + (2 * (B.x - A.x)) / 3), A.y)\n            const G = point(B.x, entreDeux(B.y, B.y + (C.y - B.y) / 3))\n            const H = point(B.x, entreDeux(C.y, B.y + (2 * (C.y - B.y)) / 3))\n            const I = point(entreDeux(B.x, A.x + (2 * (B.x - A.x)) / 3), D.y)\n            const J = point(entreDeux(A.x, A.x + (B.x - A.x) / 3), D.y)\n            const K = point(A.x, entreDeux(C.y, B.y + (2 * (C.y - B.y)) / 3))\n            const L = point(A.x, entreDeux(B.y, B.y + (C.y - B.y) / 3))\n            const poly = polygone(A, B, C, D)\n            poly.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n            poly.opaciteDeRemplissage = 0.5\n            poly.color = colorToLatexOrHTML('none')\n            objets.push(poly)\n            const rayonOuCote = Math.min(\n              longueur(E, F),\n              longueur(G, H),\n              longueur(I, J),\n              longueur(K, L),\n            )\n            const M = translation(E, vecteur(rayonOuCote, 0))\n            const N = translation(G, vecteur(0, rayonOuCote))\n            const O = translation(I, vecteur(-rayonOuCote, 0))\n            const P = translation(K, vecteur(0, -rayonOuCote))\n            const paramsEnonce = {\n              xmin: -0.5,\n              ymin: -0.5,\n              xmax: B.x + 0.5,\n              ymax: C.y + 0.5,\n              pixelsParCm: 30,\n              scale: 0.7,\n              mainlevee: false,\n              optionsTikz: ['baseline=(current bounding box.north)'],\n            }\n            const aleaLongueur = choice([-1, 1])\n            const choixFig = randint(0, 3)\n            let pt1: PointAbstrait\n            let pt2: PointAbstrait\n            switch (choixFig) {\n              case 0:\n                pt1 = M\n                pt2 = E\n                paramsEnonce.ymin = -0.5 - rayonOuCote - aleaLongueur\n                break\n              case 1:\n                pt1 = N\n                pt2 = G\n                paramsEnonce.xmax = rayonOuCote + aleaLongueur + B.x + 0.5\n                break\n              case 2:\n                pt1 = O\n                pt2 = I\n                paramsEnonce.ymax = rayonOuCote + aleaLongueur + C.y + 0.5\n                break\n              case 3:\n              default:\n                pt1 = P\n                pt2 = K\n                paramsEnonce.xmin = -0.5 - rayonOuCote - aleaLongueur\n                break\n            }\n            const aleaAngle = choice([40, 50, 70, 80])\n            const Q = pointSurSegment(pt2, pt1, rayonOuCote + aleaLongueur)\n            const R = rotation(Q, pt2, -aleaAngle)\n            let figAire1 = polygone(pt2, pt1, R)\n            figAire1.color = colorToLatexOrHTML('none')\n            figAire1.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n            figAire1.opaciteDeRemplissage = 0.5\n            const choixFig2 = randint(0, 3, [choixFig])\n            choixFigAire2 = [\n              [E, M],\n              [G, N],\n              [I, O],\n              [K, P],\n            ]\n            paramsEnonce.xmax =\n              choixFig2 === 1 ? rayonOuCote + B.x + 0.5 : paramsEnonce.xmax\n            paramsEnonce.xmin =\n              choixFig2 === 3 ? -0.5 - rayonOuCote : paramsEnonce.xmin\n            const S = pointSurSegment(\n              choixFigAire2[choixFig2][1],\n              choixFigAire2[choixFig2][0],\n              rayonOuCote + aleaLongueur,\n            )\n            const T = rotation(S, choixFigAire2[choixFig2][1], -aleaAngle)\n            const figAire2 = polygone(\n              choixFigAire2[choixFig2][0],\n              choixFigAire2[choixFig2][1],\n              T,\n            )\n            figAire2.color = colorToLatexOrHTML('none')\n            figAire2.couleurDeRemplissage = colorToLatexOrHTML('white')\n            figAire2.opaciteDeRemplissage = 1.1\n            objets.push(\n              figAire1,\n              figAire2,\n              segment(pt2, R),\n              segment(pt1, R),\n              codageSegment(pt2, R, '|||'),\n              codageSegment(pt2, pt1, 'OO'),\n              codageSegment(pt1, R, 'XX'),\n              rect,\n            )\n            objets.push(\n              segment(choixFigAire2[choixFig2][0], T),\n              segment(choixFigAire2[choixFig2][1], T),\n              codageSegment(choixFigAire2[choixFig2][1], T, '|||'),\n              codageSegment(\n                choixFigAire2[choixFig2][1],\n                choixFigAire2[choixFig2][0],\n                'OO',\n              ),\n              codageSegment(choixFigAire2[choixFig2][0], T, 'XX'),\n            )\n            texte = mathalea2d(paramsEnonce, objets)\n            // Correction\n            texteCorr = this.sup2 === 3 ? numAlpha(0) : ''\n            texteCorr +=\n              this.sup2 === 1 || this.sup2 === 3 || aireOuPerimetre !== 'Aire'\n                ? 'Il faut parcourir plus de chemin pour effectuer le tour de la figure coloriée que le tour du rectangle hachuré. Donc, la figure coloriée a un périmètre plus grand que celui du rectangle hachuré.'\n                : ''\n            texteCorr += this.sup2 === 3 ? '<br>' + numAlpha(1) : ''\n            texteCorr +=\n              this.sup2 === 2 ||\n              this.sup2 === 3 ||\n              aireOuPerimetre !== 'Perimetre'\n                ? 'Le rectangle hachuré couvre autant de surface que la figure coloriée. Donc, la figure coloriée a une aire égale à celle du rectangle hachuré.'\n                : ''\n            objets = []\n            if (\n              this.sup2 === 2 ||\n              this.sup2 === 3 ||\n              aireOuPerimetre !== 'Perimetre'\n            ) {\n              figAire1 = polygone(pt2, pt1, R)\n              figAire1.color = colorToLatexOrHTML('none')\n              figAire1.couleurDeRemplissage = colorToLatexOrHTML('white')\n              figAire1.opaciteDeRemplissage = 1.1\n              const figAireCorr = polygone(pt2, pt1, R)\n              figAireCorr.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n              figAireCorr.opaciteDeRemplissage = 0.5\n              let angleCorr =\n                choixFig2 - choixFig < 0\n                  ? choixFig2 - choixFig + 4\n                  : choixFig2 - choixFig\n              angleCorr = angleCorr === 1 ? 90 : angleCorr === 2 ? 0 : -90\n              const figAireCorr2 = rotation(\n                figAire2,\n                choixFigAire2[choixFig2][0],\n                angleCorr,\n              )\n              figAireCorr2.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n              figAireCorr2.opaciteDeRemplissage = 0.5\n              objets.push(\n                poly,\n                figAire1,\n                figAire2,\n                segment(pt2, R),\n                segment(pt1, R),\n                codageSegment(pt2, R, '|||'),\n                codageSegment(pt2, pt1, 'OO'),\n                codageSegment(pt1, R, 'XX'),\n                rect,\n              )\n              objets.push(\n                segment(choixFigAire2[choixFig2][0], T),\n                segment(choixFigAire2[choixFig2][1], T),\n                codageSegment(choixFigAire2[choixFig2][1], T, '|||'),\n                codageSegment(\n                  choixFigAire2[choixFig2][1],\n                  choixFigAire2[choixFig2][0],\n                  'OO',\n                ),\n                codageSegment(choixFigAire2[choixFig2][0], T, 'XX'),\n              )\n              if (context.isHtml)\n                objets.push(\n                  translationPuisRotationAnimees(\n                    String(q),\n                    figAireCorr,\n                    vecteur(pt1, choixFigAire2[choixFig2][0]),\n                    figAireCorr2,\n                    choixFigAire2[choixFig2][0],\n                    -angleCorr,\n                  ),\n                )\n              paramsEnonce.ymin =\n                choixFig2 === 0 ? -0.5 - rayonOuCote : paramsEnonce.ymin\n              paramsEnonce.ymax =\n                choixFig2 === 2 ? rayonOuCote + C.y + 0.5 : paramsEnonce.ymax\n              texteCorr += '<br>' + mathalea2d(paramsEnonce, objets)\n              if (context.isHtml) {\n                texteCorr += `<br><button class=\"btn ui labeled icon button\"  style=\"margin:10px\" onclick=\"document.getElementById('${figAireCorr.id}').style.visibility = 'visible',document.getElementById('${figAireCorr2.id}').style.visibility = 'hidden',\n              setTimeout(function() {document.getElementById('${figAireCorr.id}').style.visibility = 'hidden'}, 5000),\n              setTimeout(function() {document.getElementById('${figAireCorr2.id}').style.visibility = 'visible'}, 5000),document.getElementById('translat${q}').beginElement()\"><i class=\"redo circle icon\"></i>Relancer l'animation de la comparaison d'aires </button>`\n              }\n            }\n            // QCM interactif\n            if (this.interactif) {\n              reponseAire3 = true\n            }\n          }\n          break\n        case 10:\n          {\n            // Deux triangles alternés qui ne s'emboîtent pas\n            const E = point(entreDeux(A.x, A.x + (B.x - A.x) / 3), A.y)\n            const F = point(entreDeux(B.x, A.x + (2 * (B.x - A.x)) / 3), A.y)\n            const G = point(B.x, entreDeux(B.y, B.y + (C.y - B.y) / 3))\n            const H = point(B.x, entreDeux(C.y, B.y + (2 * (C.y - B.y)) / 3))\n            const I = point(entreDeux(B.x, A.x + (2 * (B.x - A.x)) / 3), D.y)\n            const J = point(entreDeux(A.x, A.x + (B.x - A.x) / 3), D.y)\n            const K = point(A.x, entreDeux(C.y, B.y + (2 * (C.y - B.y)) / 3))\n            const L = point(A.x, entreDeux(B.y, B.y + (C.y - B.y) / 3))\n            const poly = polygone(A, B, C, D)\n            poly.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n            poly.opaciteDeRemplissage = 0.5\n            poly.color = colorToLatexOrHTML('none')\n            objets.push(poly)\n            const rayonOuCote = Math.min(\n              longueur(E, F),\n              longueur(G, H),\n              longueur(I, J),\n              longueur(K, L),\n            )\n            const M = translation(E, vecteur(rayonOuCote, 0))\n            const N = translation(G, vecteur(0, rayonOuCote))\n            const O = translation(I, vecteur(-rayonOuCote, 0))\n            const P = translation(K, vecteur(0, -rayonOuCote))\n            const paramsEnonce = {\n              xmin: -0.5,\n              ymin: -0.5,\n              xmax: B.x + 0.5,\n              ymax: C.y + 0.5,\n              pixelsParCm: 30,\n              scale: 0.7,\n              mainlevee: false,\n              optionsTikz: ['baseline=(current bounding box.north)'],\n            }\n            const aleaLongueur = choice([-1, 1])\n            const choixFig = randint(0, 3)\n            let pt1: PointAbstrait\n            let pt2: PointAbstrait\n            switch (choixFig) {\n              case 0:\n                pt1 = M\n                pt2 = E\n                paramsEnonce.ymin = -0.5 - rayonOuCote - aleaLongueur\n                break\n              case 1:\n                pt1 = N\n                pt2 = G\n                paramsEnonce.xmax = rayonOuCote + aleaLongueur + B.x + 0.5\n                break\n              case 2:\n                pt1 = O\n                pt2 = I\n                paramsEnonce.ymax = rayonOuCote + aleaLongueur + C.y + 0.5\n                break\n              case 3:\n              default:\n                pt1 = P\n                pt2 = K\n                paramsEnonce.xmin = -0.5 - rayonOuCote - aleaLongueur\n                break\n            }\n            const aleaAngle = choice([40, 50, 70, 80])\n            const Q = pointSurSegment(pt2, pt1, rayonOuCote + aleaLongueur)\n            const R = rotation(Q, pt2, -aleaAngle)\n            let figAire1 = polygone(pt2, pt1, R)\n            figAire1.color = colorToLatexOrHTML('none')\n            figAire1.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n            figAire1.opaciteDeRemplissage = 0.5\n            const choixFig2 = randint(0, 3, [choixFig])\n            const hauteur = longueur(R, projectionOrtho(R, droite(pt1, pt2))) // Longueur de la hauteur issue de R dans figAire1\n            choixFigAire2 = [\n              [\n                E,\n                M,\n                arrondi(\n                  Math.min(\n                    hauteur / longueur(B, C),\n                    longueur(E, B) / longueur(E, M),\n                  ),\n                ),\n              ], // Le dernier nombre est le rapport homothétique maximal pour ne pas que le triangle sorte du triangle.\n              [\n                G,\n                N,\n                arrondi(\n                  Math.min(\n                    hauteur / longueur(A, B),\n                    longueur(G, C) / longueur(G, N),\n                  ),\n                ),\n              ],\n              [\n                I,\n                O,\n                arrondi(\n                  Math.min(\n                    hauteur / longueur(B, C),\n                    longueur(I, D) / longueur(I, O),\n                  ),\n                ),\n              ],\n              [\n                K,\n                P,\n                arrondi(\n                  Math.min(\n                    hauteur / longueur(A, B),\n                    longueur(K, A) / longueur(K, P),\n                  ),\n                ),\n              ],\n            ]\n            if (choixFig2 === 1) paramsEnonce.xmax = rayonOuCote + B.x + 0.5\n            if (choixFig2 === 3) paramsEnonce.xmin = -0.5 - rayonOuCote\n            const S = pointSurSegment(\n              choixFigAire2[choixFig2][1],\n              choixFigAire2[choixFig2][0],\n              rayonOuCote + aleaLongueur,\n            )\n            const T = rotation(S, choixFigAire2[choixFig2][1], -aleaAngle)\n            let figAire2 = polygone(\n              choixFigAire2[choixFig2][0],\n              choixFigAire2[choixFig2][1],\n              T,\n            )\n            const aleaRapportHomothetie = choice([\n              0.7,\n              0.8,\n              arrondi(Math.min(1.2, choixFigAire2[choixFig2][2] - 0.01)),\n              Math.min(1.3, arrondi(choixFigAire2[choixFig2][2] - 0.01)),\n            ])\n            figAire2 = homothetie(\n              figAire2,\n              choixFigAire2[choixFig2][0],\n              aleaRapportHomothetie,\n            )\n            figAire2.color = colorToLatexOrHTML('none')\n            figAire2.couleurDeRemplissage = colorToLatexOrHTML('white')\n            figAire2.opaciteDeRemplissage = 1.1\n            objets.push(\n              figAire1,\n              figAire2,\n              segment(pt2, R),\n              segment(pt1, R),\n              rect,\n            )\n            objets.push(\n              homothetie(\n                segment(choixFigAire2[choixFig2][0], T) as ISegment,\n                choixFigAire2[choixFig2][0],\n                aleaRapportHomothetie,\n              ),\n              homothetie(\n                segment(choixFigAire2[choixFig2][1], T) as ISegment,\n                choixFigAire2[choixFig2][0],\n                aleaRapportHomothetie,\n              ),\n            )\n            texte = mathalea2d(paramsEnonce, objets)\n            // Correction\n            texteCorr = this.sup2 === 3 ? numAlpha(0) : ''\n            texteCorr +=\n              this.sup2 === 1 || this.sup2 === 3 || aireOuPerimetre !== 'Aire'\n                ? 'Il faut parcourir plus de chemin pour effectuer le tour de la figure coloriée que le tour du rectangle hachuré. Donc, la figure coloriée a un périmètre plus grand que celui du rectangle hachuré.'\n                : ''\n            texteCorr += this.sup2 === 3 ? '<br>' + numAlpha(1) : ''\n            texteCorr +=\n              aleaRapportHomothetie < 1\n                ? this.sup2 === 2 ||\n                  this.sup2 === 3 ||\n                  aireOuPerimetre !== 'Perimetre'\n                  ? 'Le rectangle hachuré couvre moins de surface que la figure coloriée. Donc, la figure coloriée a une aire plus grande que celle du rectangle hachuré.'\n                  : ''\n                : this.sup2 === 2 ||\n                    this.sup2 === 3 ||\n                    aireOuPerimetre !== 'Perimetre'\n                  ? 'Le rectangle hachuré couvre plus de surface que la figure coloriée. Donc, le rectangle hachuré a une aire plus grande que celle de la figure coloriée.'\n                  : ''\n            if (\n              this.sup2 === 2 ||\n              this.sup2 === 3 ||\n              aireOuPerimetre !== 'Perimetre'\n            ) {\n              objets = []\n              figAire1 = polygone(pt2, pt1, R)\n              figAire1.color = colorToLatexOrHTML('none')\n              figAire1.couleurDeRemplissage = colorToLatexOrHTML('white')\n              figAire1.opaciteDeRemplissage = 1.1\n              const figAireCorr = polygone(pt2, pt1, R)\n              figAireCorr.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n              figAireCorr.opaciteDeRemplissage = 0.5\n              const figAire2Corr = homothetie(\n                figAire2,\n                choixFigAire2[choixFig2][0],\n                1 / aleaRapportHomothetie,\n              )\n              let angleCorr =\n                choixFig2 - choixFig < 0\n                  ? choixFig2 - choixFig + 4\n                  : choixFig2 - choixFig\n              angleCorr = angleCorr === 1 ? 90 : angleCorr === 2 ? 0 : -90\n              const figAireCorr2 = rotation(\n                figAire2Corr,\n                choixFigAire2[choixFig2][0],\n                angleCorr,\n              )\n              figAireCorr2.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n              figAireCorr2.opaciteDeRemplissage = 0.5\n              objets.push(\n                poly,\n                figAire1,\n                figAire2,\n                segment(pt2, R),\n                segment(pt1, R),\n                rect,\n              )\n              objets.push(\n                homothetie(\n                  segment(choixFigAire2[choixFig2][0], T) as ISegment,\n                  choixFigAire2[choixFig2][0],\n                  aleaRapportHomothetie,\n                ),\n                homothetie(\n                  segment(choixFigAire2[choixFig2][1], T) as ISegment,\n                  choixFigAire2[choixFig2][0],\n                  aleaRapportHomothetie,\n                ),\n              )\n              if (context.isHtml)\n                objets.push(\n                  translationPuisRotationAnimees(\n                    String(q),\n                    figAireCorr,\n                    vecteur(pt1, choixFigAire2[choixFig2][0]),\n                    figAireCorr2,\n                    choixFigAire2[choixFig2][0],\n                    -angleCorr,\n                  ),\n                )\n              paramsEnonce.ymin =\n                choixFig2 === 0 ? -0.5 - rayonOuCote : paramsEnonce.ymin\n              paramsEnonce.ymax =\n                choixFig2 === 2 ? rayonOuCote + C.y + 0.5 : paramsEnonce.ymax\n              texteCorr += '<br>' + mathalea2d(paramsEnonce, objets)\n              if (context.isHtml) {\n                texteCorr += `<br><button class=\"btn ui labeled icon button\"  style=\"margin:10px\" onclick=\"document.getElementById('${figAireCorr.id}').style.visibility = 'visible',document.getElementById('${figAireCorr2.id}').style.visibility = 'hidden',\n              setTimeout(function() {document.getElementById('${figAireCorr.id}').style.visibility = 'hidden'}, 5000),\n              setTimeout(function() {document.getElementById('${figAireCorr2.id}').style.visibility = 'visible'}, 5000),document.getElementById('translat${q}').beginElement()\"><i class=\"redo circle icon\"></i>Relancer l'animation de la comparaison d'aires </button>`\n              }\n            }\n            // QCM interactif\n            if (this.interactif) {\n              reponseAire1 = !(aleaRapportHomothetie < 1)\n              reponseAire2 = aleaRapportHomothetie < 1\n            }\n          }\n          break\n        case 11:\n          {\n            // Deux triangles en plus\n            const E = point(entreDeux(A.x, A.x + (B.x - A.x) / 3), A.y)\n            const F = point(entreDeux(B.x, A.x + (2 * (B.x - A.x)) / 3), A.y)\n            const G = point(B.x, entreDeux(B.y, B.y + (C.y - B.y) / 3))\n            const H = point(B.x, entreDeux(C.y, B.y + (2 * (C.y - B.y)) / 3))\n            const I = point(entreDeux(B.x, A.x + (2 * (B.x - A.x)) / 3), D.y)\n            const J = point(entreDeux(A.x, A.x + (B.x - A.x) / 3), D.y)\n            const K = point(A.x, entreDeux(C.y, B.y + (2 * (C.y - B.y)) / 3))\n            const L = point(A.x, entreDeux(B.y, B.y + (C.y - B.y) / 3))\n            const poly = polygone(A, B, C, D)\n            poly.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n            poly.opaciteDeRemplissage = 0.5\n            poly.color = colorToLatexOrHTML('none')\n            objets.push(poly)\n            const rayonOuCote = Math.min(\n              longueur(E, F),\n              longueur(G, H),\n              longueur(I, J),\n              longueur(K, L),\n            )\n            const M = translation(E, vecteur(rayonOuCote, 0))\n            const N = translation(G, vecteur(0, rayonOuCote))\n            const O = translation(I, vecteur(-rayonOuCote, 0))\n            const P = translation(K, vecteur(0, -rayonOuCote))\n            const paramsEnonce = {\n              xmin: -0.5,\n              ymin: -0.5,\n              xmax: B.x + 0.5,\n              ymax: C.y + 0.5,\n              pixelsParCm: 30,\n              scale: 0.7,\n              mainlevee: false,\n              optionsTikz: ['baseline=(current bounding box.north)'],\n            }\n            const aleaLongueur = choice([-1, 1])\n            const choixFig = randint(0, 3)\n            let pt1: PointAbstrait\n            let pt2: PointAbstrait\n            switch (choixFig) {\n              case 0:\n                pt1 = M\n                pt2 = E\n                paramsEnonce.ymin = -0.5 - rayonOuCote - aleaLongueur\n                break\n              case 1:\n                pt1 = N\n                pt2 = G\n                paramsEnonce.xmax = rayonOuCote + aleaLongueur + B.x + 0.5\n                break\n              case 2:\n                pt1 = O\n                pt2 = I\n                paramsEnonce.ymax = rayonOuCote + aleaLongueur + C.y + 0.5\n                break\n              case 3:\n              default:\n                pt1 = P\n                pt2 = K\n                paramsEnonce.xmin = -0.5 - rayonOuCote - aleaLongueur\n                break\n            }\n            const aleaAngle = choice([40, 50, 70, 80, 100, 110])\n            const Q = pointSurSegment(pt2, pt1, rayonOuCote + aleaLongueur)\n            const R = rotation(Q, pt2, -aleaAngle)\n            switch (choixFig) {\n              case 0:\n              case 2:\n                paramsEnonce.xmin = -0.5 + Math.min(A.x, R.x)\n                paramsEnonce.xmax = 0.5 + Math.max(B.x, R.x)\n                break\n              case 1:\n              case 3:\n                paramsEnonce.ymin = -0.5 + Math.min(A.y, R.y)\n                paramsEnonce.ymax = 0.5 + Math.max(D.y, R.y)\n                break\n            }\n            const figAire1 = polygone(pt2, pt1, R)\n            figAire1.color = colorToLatexOrHTML('none')\n            figAire1.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n            figAire1.opaciteDeRemplissage = 0.5\n            const choixFig2 = randint(0, 3, [choixFig])\n            choixFigAire2 = [\n              [E, M],\n              [G, N],\n              [I, O],\n              [K, P],\n            ]\n            const S = pointSurSegment(\n              choixFigAire2[choixFig2][1],\n              choixFigAire2[choixFig2][0],\n              rayonOuCote + aleaLongueur,\n            )\n            const T = rotation(S, choixFigAire2[choixFig2][1], aleaAngle)\n            switch (choixFig2) {\n              case 0:\n                paramsEnonce.xmin = -0.5 + Math.min(A.x, T.x, R.x)\n                paramsEnonce.xmax = 0.5 + Math.max(B.x, T.x, R.x)\n                paramsEnonce.ymin = -0.5 - rayonOuCote - aleaLongueur\n                break\n              case 1:\n                paramsEnonce.ymin = -0.5 + Math.min(A.y, T.y, R.y)\n                paramsEnonce.ymax = 0.5 + Math.max(D.y, T.y, R.y)\n                paramsEnonce.xmax = rayonOuCote + aleaLongueur + B.x + 0.5\n                break\n              case 2:\n                paramsEnonce.xmin = -0.5 + Math.min(A.x, T.x, R.x)\n                paramsEnonce.xmax = 0.5 + Math.max(B.x, T.x, R.x)\n                paramsEnonce.ymax = rayonOuCote + aleaLongueur + C.y + 0.5\n                break\n              case 3:\n                paramsEnonce.ymin = -0.5 + Math.min(A.y, T.y, R.y)\n                paramsEnonce.ymax = 0.5 + Math.max(D.y, T.y, R.y)\n                paramsEnonce.xmin = -0.5 - rayonOuCote - aleaLongueur\n                break\n            }\n            const figAire2 = polygone(\n              choixFigAire2[choixFig2][0],\n              choixFigAire2[choixFig2][1],\n              T,\n            )\n            figAire2.color = colorToLatexOrHTML('none')\n            figAire2.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n            figAire2.opaciteDeRemplissage = 0.5\n            objets.push(\n              figAire1,\n              figAire2,\n              segment(pt2, R),\n              segment(pt1, R),\n              codageSegment(pt2, R, '|||'),\n              codageSegment(pt2, pt1, 'OO'),\n              codageSegment(pt1, R, 'XX'),\n              rect,\n            )\n            objets.push(\n              segment(choixFigAire2[choixFig2][0], T),\n              segment(choixFigAire2[choixFig2][1], T),\n              codageSegment(choixFigAire2[choixFig2][1], T, '|||'),\n              codageSegment(\n                choixFigAire2[choixFig2][1],\n                choixFigAire2[choixFig2][0],\n                'OO',\n              ),\n              codageSegment(choixFigAire2[choixFig2][0], T, 'XX'),\n            )\n            texte = mathalea2d(paramsEnonce, objets)\n            // Correction\n            texteCorr = this.sup2 === 3 ? numAlpha(0) : ''\n            texteCorr +=\n              this.sup2 === 1 || this.sup2 === 3 || aireOuPerimetre !== 'Aire'\n                ? 'Il faut parcourir plus de chemin pour effectuer le tour de la figure coloriée que le tour du rectangle hachuré. Donc, la figure coloriée a un périmètre plus grand que celui du rectangle hachuré.'\n                : ''\n            texteCorr += this.sup2 === 3 ? '<br>' + numAlpha(1) : ''\n            texteCorr +=\n              this.sup2 === 2 ||\n              this.sup2 === 3 ||\n              aireOuPerimetre !== 'Perimetre'\n                ? 'Le rectangle hachuré couvre moins de surface que la figure coloriée. Donc, la figure coloriée a une aire plus grande que celle du rectangle hachuré.'\n                : ''\n            // QCM interactif\n            if (this.interactif) {\n              reponseAire2 = true\n            }\n          }\n          break\n        case 12:\n          {\n            // Deux triangles en moins\n            const E = point(entreDeux(A.x, A.x + (B.x - A.x) / 3), A.y)\n            const F = point(entreDeux(B.x, A.x + (2 * (B.x - A.x)) / 3), A.y)\n            const G = point(B.x, entreDeux(B.y, B.y + (C.y - B.y) / 3))\n            const H = point(B.x, entreDeux(C.y, B.y + (2 * (C.y - B.y)) / 3))\n            const I = point(entreDeux(B.x, A.x + (2 * (B.x - A.x)) / 3), D.y)\n            const J = point(entreDeux(A.x, A.x + (B.x - A.x) / 3), D.y)\n            const K = point(A.x, entreDeux(C.y, B.y + (2 * (C.y - B.y)) / 3))\n            const L = point(A.x, entreDeux(B.y, B.y + (C.y - B.y) / 3))\n            const poly = polygone(A, B, C, D)\n            poly.couleurDeRemplissage = colorToLatexOrHTML(color[q])\n            poly.opaciteDeRemplissage = 1.1\n            poly.color = colorToLatexOrHTML('none')\n            objets.push(poly)\n            const rayonOuCote = Math.min(\n              longueur(E, F),\n              longueur(G, H),\n              longueur(I, J),\n              longueur(K, L),\n            )\n            const M = translation(E, vecteur(rayonOuCote, 0))\n            const N = translation(G, vecteur(0, rayonOuCote))\n            const O = translation(I, vecteur(-rayonOuCote, 0))\n            const P = translation(K, vecteur(0, -rayonOuCote))\n            const paramsEnonce = {\n              xmin: -0.5,\n              ymin: -0.5,\n              xmax: B.x + 0.5,\n              ymax: C.y + 0.5,\n              pixelsParCm: 30,\n              scale: 0.7,\n              mainlevee: false,\n              optionsTikz: ['baseline=(current bounding box.north)'],\n            }\n            const aleaLongueur = -1\n            const choixFig = randint(0, 3)\n            let pt1: PointAbstrait\n            let pt2: PointAbstrait\n            switch (choixFig) {\n              case 0:\n                pt1 = M\n                pt2 = E\n                break\n              case 1:\n                pt1 = N\n                pt2 = G\n                break\n              case 2:\n                pt1 = O\n                pt2 = I\n                break\n              case 3:\n              default:\n                pt1 = P\n                pt2 = K\n                break\n            }\n            let aleaAngle = choice([40, 50, 70, 80, 100, 110])\n            const Q = pointSurSegment(pt2, pt1, rayonOuCote + aleaLongueur)\n            let R = rotation(Q, pt2, aleaAngle)\n            if (!estDansQuadrilatere(R, A, B, C, D)) {\n              aleaAngle = 180 - aleaAngle\n              R = rotation(Q, pt2, aleaAngle)\n            }\n            const figAire1 = polygone(pt2, pt1, R)\n            figAire1.color = colorToLatexOrHTML('none')\n            figAire1.couleurDeRemplissage = colorToLatexOrHTML('white')\n            figAire1.opaciteDeRemplissage = 1.1\n            const choixFig2 = randint(0, 3, [choixFig])\n            choixFigAire2 = [\n              [E, M],\n              [G, N],\n              [I, O],\n              [K, P],\n            ]\n            let S = pointSurSegment(\n              choixFigAire2[choixFig2][0],\n              choixFigAire2[choixFig2][1],\n              rayonOuCote + aleaLongueur,\n            )\n            let T = rotation(S, choixFigAire2[choixFig2][0], aleaAngle)\n            if (\n              !estDansQuadrilatere(T, A, B, C, D) ||\n              estDansTriangle(T, pt2, pt1, R) ||\n              estDansTriangle(\n                R,\n                choixFigAire2[choixFig2][0],\n                choixFigAire2[choixFig2][1],\n                T,\n              )\n            ) {\n              // Si les triangles se croisent, on crée le symétrique du premier par rapport au centre du rectangle.\n              S = milieu(A, C)\n              choixFigAire2[choixFig2][1] = homothetie(pt1, S, -1)\n              choixFigAire2[choixFig2][0] = homothetie(pt2, S, -1)\n              T = homothetie(R, S, -1)\n            }\n            const figAire2 = polygone(\n              choixFigAire2[choixFig2][0],\n              choixFigAire2[choixFig2][1],\n              T,\n            )\n            figAire2.color = colorToLatexOrHTML('none')\n            figAire2.couleurDeRemplissage = colorToLatexOrHTML('white')\n            figAire2.opaciteDeRemplissage = 1.1\n            objets.push(\n              figAire1,\n              figAire2,\n              segment(pt2, R),\n              segment(pt1, R),\n              codageSegment(pt2, R, '|||'),\n              codageSegment(pt2, pt1, 'OO'),\n              codageSegment(pt1, R, 'XX'),\n              rect,\n            )\n            objets.push(\n              segment(choixFigAire2[choixFig2][0], T),\n              segment(choixFigAire2[choixFig2][1], T),\n              codageSegment(choixFigAire2[choixFig2][1], T, 'XX'),\n              codageSegment(\n                choixFigAire2[choixFig2][1],\n                choixFigAire2[choixFig2][0],\n                'OO',\n              ),\n              codageSegment(choixFigAire2[choixFig2][0], T, '|||'),\n            )\n            texte = mathalea2d(paramsEnonce, objets)\n            // Correction\n            texteCorr = this.sup2 === 3 ? numAlpha(0) : ''\n            texteCorr +=\n              this.sup2 === 1 || this.sup2 === 3 || aireOuPerimetre !== 'Aire'\n                ? 'Il faut parcourir plus de chemin pour effectuer le tour de la figure coloriée que le tour du rectangle hachuré. Donc, la figure coloriée a un périmètre plus grand que celui du rectangle hachuré.'\n                : ''\n            texteCorr += this.sup2 === 3 ? '<br>' + numAlpha(1) : ''\n            texteCorr +=\n              this.sup2 === 2 ||\n              this.sup2 === 3 ||\n              aireOuPerimetre !== 'Perimetre'\n                ? 'Le rectangle hachuré couvre plus de surface que la figure coloriée. Donc, le rectangle hachuré a une aire plus grande que celle de la figure coloriée.'\n                : ''\n            // QCM interactif\n            if (this.interactif) {\n              reponseAire1 = true\n            }\n          }\n          break\n      }\n      // Gestion des QCM interactifs\n      let monQcmPerimetre: { texte: string; texteCorr: string } | undefined\n      let monQcmAire: { texte: string; texteCorr: string } | undefined\n      if (this.interactif) {\n        if (this.sup2 === 1 || this.sup2 === 3 || aireOuPerimetre !== 'Aire') {\n          this.autoCorrection[compteurInteractif] = {\n            enonce: 'Peu importe',\n            propositions: [\n              {\n                texte: 'Le rectangle hachuré',\n                statut:\n                  comparePerimetre === 'petit' ||\n                  (typesDeProblemes[q] === 7 && comparePerimetre === 'grand'), // true ou false pour indiquer si c'est une bonne réponse (true)\n                feedback: '',\n              },\n              {\n                texte: 'La figure coloriée',\n                statut:\n                  comparePerimetre === 'grand' ||\n                  (typesDeProblemes[q] === 7 && comparePerimetre === 'petit'), // true ou false pour indiquer si c'est une bonne réponse (true)\n                feedback: '',\n              },\n              {\n                texte: \"Autant l'un que l'autre\",\n                statut: false, // true ou false pour indiquer si c'est une bonne réponse (true)\n                feedback: '',\n              },\n            ],\n          }\n          monQcmPerimetre = propositionsQcm(this, compteurInteractif)\n          compteurInteractif++\n        }\n        if (\n          this.sup2 === 2 ||\n          this.sup2 === 3 ||\n          aireOuPerimetre !== 'Perimetre'\n        ) {\n          this.autoCorrection[compteurInteractif] = {\n            enonce: 'Peu importe',\n            propositions: [\n              {\n                texte: 'Le rectangle hachuré',\n                statut: reponseAire1, // true ou false pour indiquer si c'est une bonne réponse (true)\n                feedback: '',\n              },\n              {\n                texte: 'La figure coloriée',\n                statut: reponseAire2, // true ou false pour indiquer si c'est une bonne réponse (true)\n                feedback: '',\n              },\n              {\n                texte: \"Autant l'un que l'autre\",\n                statut: reponseAire3, // true ou false pour indiquer si c'est une bonne réponse (true)\n                feedback: '',\n              },\n            ],\n          }\n          monQcmAire = propositionsQcm(this, compteurInteractif)\n          compteurInteractif++\n        }\n      }\n      // Gestion des énoncés\n      if (this.sup2 === 3) texte += numAlpha(0)\n      if (this.sup2 === 1 || this.sup2 === 3 || aireOuPerimetre !== 'Aire') {\n        texte += `Entre le rectangle hachuré et la figure coloriée, lequel a le plus ${comparePerimetre} périmètre ?`\n        if (this.interactif) {\n          texte += monQcmPerimetre!.texte\n        }\n      }\n      if (this.sup2 === 3) texte += '<br>' + numAlpha(1)\n      if (\n        this.sup2 === 2 ||\n        this.sup2 === 3 ||\n        aireOuPerimetre !== 'Perimetre'\n      ) {\n        texte +=\n          'Entre le rectangle hachuré et la figure coloriée, lequel a la plus grande aire ?'\n        if (this.interactif) {\n          texte += monQcmAire!.texte\n        }\n      }\n      if (this.questionJamaisPosee(q, A.x, A.y, B.x, B.y, C.x, C.y, D.x, D.y)) {\n        this.listeQuestions[q] = texte ?? ''\n        this.listeCorrections[q] = texteCorr ?? ''\n\n        q++\n      }\n      cpt++\n    }\n    listeQuestionsToContenu(this) // On envoie l'exercice à la fonction de mise en page\n  }\n}\n"],"names":["dateDePublication","dateDeModifImportante","titre","interactifReady","interactifType","uuid","refs","entreDeux","a","b","arrondi","randint","CompareAireEtPerimetreAvecRectangle","Exercice","typesDeProblemes","gestionnaireFormulaireTexte","color","combinaisonListes","aireOuPerimetre","compteurInteractif","cpt","choixFigAire2","objets","A","point","B","C","D","rect","polygone","reponseAire1","reponseAire2","reponseAire3","comparePerimetre","choice","texte","texteCorr","E","G","F","H","I","J","K","L","M","N","O","P","Q","R","T","S","poly","colorToLatexOrHTML","mathalea2d","numAlpha","rayonOuCote","longueur","translation","vecteur","paramsEnonce","choixFig","pt1","pt2","figAire1","arc","choixFig2","figAire2","rotation","NN","segment","PP","codageSegment","figAireCorr","angleCorr","figAireCorr2","context","translationPuisRotationAnimees","aleaDemiDisque","aleaRayon","homothetie","aleaPente","d1","droiteParPointEtPente","d2","d3","d4","pointIntersectionDD","aleaLongueur","aleaAngle","pointSurSegment","hauteur","projectionOrtho","droite","aleaRapportHomothetie","figAire2Corr","estDansQuadrilatere","estDansTriangle","milieu","monQcmPerimetre","monQcmAire","propositionsQcm","listeQuestionsToContenu"],"mappings":"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"}