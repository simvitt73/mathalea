{"version":3,"file":"Etrangers2022_1Q2_alea-DynuRHTc.js","sources":["../../src/exercices/QCMBac/A2022/Etrangers2022_1Q2_alea.ts"],"sourcesContent":["import { fixeBordures } from '../../../lib/2d/fixeBordures'\nimport RepereBuilder from '../../../lib/2d/RepereBuilder'\nimport { spline } from '../../../lib/mathFonctions/Spline'\nimport { mathalea2d } from '../../../modules/mathalea2d'\nimport { randint } from '../../../modules/outils'\nimport { nombreElementsDifferents } from '../../ExerciceQcm'\nimport ExerciceQcmA from '../../ExerciceQcmA'\n\nexport const uuid = '90af7'\nexport const refs = {\n  'fr-fr': ['TSA2-QCM06'],\n  'fr-ch': [],\n}\nexport const interactifReady = true\nexport const interactifType = 'qcm'\nexport const amcReady = 'true'\nexport const amcType = 'qcmMono'\nexport const titre = 'Centres étrangers 05/22 : convexité'\nexport const dateDePublication = '08/11/2024'\n// Ceci est un exemple de QCM avec version originale et version aléatoire\n/**\n *\n * @author Stéphane Guyon\n *\n */\nexport default class MetropoleJuin24Exo4Q1 extends ExerciceQcmA {\n  // Ceci est la fonction qui s'occupe d'écrire l'énoncé, la correction et les réponses\n  // Elle factorise le code qui serait dupliqué dans versionAleatoire et versionOriginale\n  private appliquerLesValeurs(\n    xA: number,\n    xB: number,\n    yB: number,\n    xC: number,\n    yD: number,\n    xE: number,\n    yE: number,\n    xF: number,\n  ): void {\n    this.reponses = [\n      `$f'$ admet un maximum en $${xC}$ `,\n      `$f$ est convexe sur $[${xC};${xE}]$`,\n      `$f$ est concave sur $[${xB};0]$`,\n      `$f'$ est décroissante sur $[${xB};0]$`,\n    ]\n\n    this.enonce = `On a représenté ici, sur l'intervalle $[${xA};${xB}]$ la courbe représentative de $f^{\\\\prime\\\\prime}$, dérivée seconde d'une fonction $f$.<br>`\n    const nuage = [\n      { x: xA, y: 0, deriveeGauche: 0, deriveeDroit: 2, isVisible: true },\n      { x: xB, y: yB, deriveeGauche: 0, deriveeDroit: 0, isVisible: true },\n      { x: xC, y: 0, deriveeGauche: -1.5, deriveeDroit: -1.5, isVisible: true },\n      { x: 0, y: yD, deriveeGauche: -1, deriveeDroit: -1, isVisible: true },\n      { x: xE, y: yE, deriveeGauche: 0, deriveeDroit: 0, isVisible: true },\n      { x: xF, y: 0, deriveeGauche: 1, deriveeDroit: 1, isVisible: true },\n    ]\n    const f = spline(nuage)\n    const rep = new RepereBuilder({\n      xMin: xA,\n      xMax: xF,\n      yMin: yE,\n      yMax: yB,\n    }).buildStandard().objets\n    const maCourbe = f.courbe({\n      repere: rep,\n      color: 'red',\n      epaisseur: 2,\n      ajouteNoeuds: true,\n      optionsNoeuds: {},\n    })\n    this.enonce += mathalea2d(\n      Object.assign({}, fixeBordures([rep, maCourbe])),\n      rep,\n      maCourbe,\n    )\n    this.enonce += 'On peut en déduire que : '\n    this.correction = ''\n  }\n\n  // S'occupe de passser les données originales à la fonction appliquerLesValeurs\n  versionOriginale: () => void = () => {\n    this.appliquerLesValeurs(-3, -2, 3, -1, -2, 1, -3, 2) // valeurs originales\n  }\n\n  // s'occupe d'aléatoiriser les valeurs à passer à la fonction appliquerLesValeurs en vérifiant qu'on a bien 3 réponses différentes\n  // Pour un qcm à n réponses, il faudrait vérifier que nombreElementsDifferents(this.reponses) < n\n  versionAleatoire: () => void = () => {\n    const n = 4 // nombre de réponses différentes voulues (on rappelle que la première réponse est la bonne)\n    do {\n      const xA = randint(-8, -5)\n      const xB = xA + randint(1, 2)\n      const yB = randint(3, 5)\n      const xC = xB + randint(1, 2)\n      const yD = randint(-4, -3)\n      const xE = randint(2, 5)\n      const yE = yD - randint(2, 4)\n      const xF = xE + randint(3, 5)\n      this.appliquerLesValeurs(xA, xB, yB, xC, yD, xE, yE, xF)\n    } while (nombreElementsDifferents(this.reponses) < n)\n  }\n\n  // Ici il n'y a rien à faire, on appelle juste la version aleatoire (pour un qcm aleatoirisé, c'est le fonctionnement par défaut)\n  constructor() {\n    super()\n    this.options = { vertical: true, ordered: false }\n    this.versionAleatoire()\n  }\n}\n"],"names":["uuid","refs","interactifReady","interactifType","amcReady","amcType","titre","dateDePublication","MetropoleJuin24Exo4Q1","ExerciceQcmA","__publicField","xA","randint","xB","yB","xC","yD","xE","yE","xF","nombreElementsDifferents","spline","rep","RepereBuilder","maCourbe","mathalea2d","fixeBordures"],"mappings":"m0HAQO,MAAMA,GAAO,QACPC,GAAO,CAClB,QAAS,CAAC,YAAY,EACtB,QAAS,CAAA,CACX,EACaC,GAAkB,GAClBC,GAAiB,MACjBC,GAAW,OACXC,GAAU,UACVC,GAAQ,sCACRC,GAAoB,aAOjC,MAAqBC,WAA8BC,CAAa,CA2E9D,aAAc,CACZ,MAAA,EAvBFC,EAAA,wBAA+B,IAAM,CACnC,KAAK,oBAAoB,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,CAAC,CACtD,GAIAA,EAAA,wBAA+B,IAAM,CAEnC,EAAG,CACD,MAAMC,EAAKC,EAAQ,GAAI,EAAE,EACnBC,EAAKF,EAAKC,EAAQ,EAAG,CAAC,EACtBE,EAAKF,EAAQ,EAAG,CAAC,EACjBG,EAAKF,EAAKD,EAAQ,EAAG,CAAC,EACtBI,EAAKJ,EAAQ,GAAI,EAAE,EACnBK,EAAKL,EAAQ,EAAG,CAAC,EACjBM,EAAKF,EAAKJ,EAAQ,EAAG,CAAC,EACtBO,EAAKF,EAAKL,EAAQ,EAAG,CAAC,EAC5B,KAAK,oBAAoBD,EAAIE,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,CAAE,CACzD,OAASC,EAAyB,KAAK,QAAQ,EAAI,EACrD,GAKE,KAAK,QAAU,CAAE,SAAU,GAAM,QAAS,EAAA,EAC1C,KAAK,iBAAA,CACP,CA5EQ,oBACNT,EACAE,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACM,CACN,KAAK,SAAW,CACd,6BAA6BJ,CAAE,KAC/B,yBAAyBA,CAAE,IAAIE,CAAE,KACjC,yBAAyBJ,CAAE,OAC3B,+BAA+BA,CAAE,MAAA,EAGnC,KAAK,OAAS,2CAA2CF,CAAE,IAAIE,CAAE,+FASjE,MAAM,EAAIQ,EARI,CACZ,CAAE,EAAGV,EAAI,EAAG,EAAG,cAAe,EAAG,aAAc,EAAG,UAAW,EAAA,EAC7D,CAAE,EAAGE,EAAI,EAAGC,EAAI,cAAe,EAAG,aAAc,EAAG,UAAW,EAAA,EAC9D,CAAE,EAAGC,EAAI,EAAG,EAAG,cAAe,KAAM,aAAc,KAAM,UAAW,EAAA,EACnE,CAAE,EAAG,EAAG,EAAGC,EAAI,cAAe,GAAI,aAAc,GAAI,UAAW,EAAA,EAC/D,CAAE,EAAGC,EAAI,EAAGC,EAAI,cAAe,EAAG,aAAc,EAAG,UAAW,EAAA,EAC9D,CAAE,EAAGC,EAAI,EAAG,EAAG,cAAe,EAAG,aAAc,EAAG,UAAW,EAAA,CAAK,CAE9C,EAChBG,EAAM,IAAIC,EAAc,CAC5B,KAAMZ,EACN,KAAMQ,EACN,KAAMD,EACN,KAAMJ,CAAA,CACP,EAAE,cAAA,EAAgB,OACbU,EAAW,EAAE,OAAO,CACxB,OAAQF,EACR,MAAO,MACP,UAAW,EACX,aAAc,GACd,cAAe,CAAA,CAAC,CACjB,EACD,KAAK,QAAUG,EACb,OAAO,OAAO,GAAIC,EAAa,CAACJ,EAAKE,CAAQ,CAAC,CAAC,EAC/CF,EACAE,CAAA,EAEF,KAAK,QAAU,4BACf,KAAK,WAAa,EACpB,CA8BF"}