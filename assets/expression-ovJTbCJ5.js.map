{"version":3,"file":"expression-ovJTbCJ5.js","sources":["../../src/lib/types/expression.ts"],"sourcesContent":["export type Operator = '+' | '-' | '\\\\times' | '\\\\div' | '^'\n\nexport interface ExpressionNode {\n  operator: Operator\n  left: ExpressionNode | number | string\n  right: ExpressionNode | number | string\n}\n\nexport type Expression = ExpressionNode | number | string\n\n/**\n * Analyse un arbre de calculs avec priorité et fournit une string avec uniquement les parenthèses utiles\n  const example: Expression = {\n    operator: '+',\n    left: {\n        operator: '*',\n        left: 'a',\n        right: 'b'\n    },\n    right: {\n        operator: '^',\n        left: 'c',\n        right: 'd'\n    }\n  }\n  parseExpression(example, 0)\n  resultat :\n  a * b + c^d\n * @param expression\n * @param parentPrecedence\n * @param position branche du parent est à gauche ou à droite\n * @returns\n */\nexport function parseExpression(\n  expression: Expression,\n  parentPrecedence = 0,\n  position: 'g' | 'd' | '' = '',\n): string {\n  if (typeof expression === 'number' || typeof expression === 'string') {\n    // Si c'est un nombre ou une variable, retournez-le directement\n    return expression.toString()\n  }\n\n  if ('operator' in expression) {\n    const precedence = getOperatorPrecedence(expression.operator)\n    const left = parseExpression(expression.left, precedence, 'g')\n    const right = parseExpression(expression.right, precedence, 'd') // Associativité à gauche pour la plupart des opérateurs\n\n    // Ajout de parenthèses si la priorité du parent est plus élevée que celle de l'opérateur actuel\n    let shouldWrap = false\n    if (position === 'd' && precedence === parentPrecedence) shouldWrap = true\n    if (position === 'g' && precedence === parentPrecedence) shouldWrap = false\n    if (precedence < parentPrecedence) shouldWrap = true\n    const expressionString = `${left} ${expression.operator} ${right}`\n    return shouldWrap ? `(${expressionString})` : expressionString\n  }\n  throw new Error('Expression invalide')\n}\n\nfunction getOperatorPrecedence(operator: Operator | ''): number {\n  switch (operator) {\n    case '^':\n      return 3\n    case '\\\\times':\n    case '\\\\div':\n      return 2\n    case '+':\n    case '-':\n      return 1\n    default:\n      return 0 // Pas d'opérateur\n  }\n}\n"],"names":["parseExpression","expression","parentPrecedence","position","precedence","getOperatorPrecedence","left","right","shouldWrap","expressionString","operator"],"mappings":"AAiCO,SAASA,EACdC,EACAC,EAAmB,EACnBC,EAA2B,GACnB,CACR,GAAI,OAAOF,GAAe,UAAY,OAAOA,GAAe,SAE1D,OAAOA,EAAW,SAAA,EAGpB,GAAI,aAAcA,EAAY,CAC5B,MAAMG,EAAaC,EAAsBJ,EAAW,QAAQ,EACtDK,EAAON,EAAgBC,EAAW,KAAMG,EAAY,GAAG,EACvDG,EAAQP,EAAgBC,EAAW,MAAOG,EAAY,GAAG,EAG/D,IAAII,EAAa,GACbL,IAAa,KAAOC,IAAeF,IAAkBM,EAAa,IAClEL,IAAa,KAAOC,IAAeF,IAAkBM,EAAa,IAClEJ,EAAaF,IAAkBM,EAAa,IAChD,MAAMC,EAAmB,GAAGH,CAAI,IAAIL,EAAW,QAAQ,IAAIM,CAAK,GAChE,OAAOC,EAAa,IAAIC,CAAgB,IAAMA,CAChD,CACA,MAAM,IAAI,MAAM,qBAAqB,CACvC,CAEA,SAASJ,EAAsBK,EAAiC,CAC9D,OAAQA,EAAA,CACN,IAAK,IACH,MAAO,GACT,IAAK,UACL,IAAK,QACH,MAAO,GACT,IAAK,IACL,IAAK,IACH,MAAO,GACT,QACE,MAAO,EAAA,CAEb"}