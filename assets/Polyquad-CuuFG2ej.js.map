{"version":3,"file":"Polyquad-CuuFG2ej.js","sources":["../../src/lib/2d/Polyquad.ts"],"sourcesContent":["import { randint } from '../../modules/outils'\nimport type { NestedObjetMathalea2dArray } from '../../types/2d'\nimport { colorToLatexOrHTML } from './colorToLatexOrHtml'\nimport { point } from './PointAbstrait'\nimport { Polygone, polygone } from './polygones'\nimport { carre } from './polygonesParticuliers'\nimport { translation } from './transformations'\nimport { vecteur } from './Vecteur'\n\ntype BinomeXY = { x: number; y: number }\ntype BinomesXY = BinomeXY[]\n\n/**\n * fonction utilitaire pour la classe Tetris\n * Détermine si deux points sont ceux d'un couple de points (dans l'ordre ou pas)\n * @param {Point} pt1\n * @param {Point} pt2\n * @param {[Point,Point]} couple\n * @returns {boolean}\n * @author Jean-Claude Lhote\n */\nexport function trouveCouple(\n  pt1: { x: number; y: number },\n  pt2: { x: number; y: number },\n  couple: [{ x: number; y: number }, { x: number; y: number }],\n) {\n  return (\n    (pt1.x === couple[0].x &&\n      pt1.y === couple[0].y &&\n      pt2.x === couple[1].x &&\n      pt2.y === couple[1].y) ||\n    (pt1.x === couple[1].x &&\n      pt1.y === couple[1].y &&\n      pt2.x === couple[0].x &&\n      pt2.y === couple[0].y)\n  )\n}\n/**\n * fonction utilitaire pour la classe Tetris\n * @description Détermine si le point passé en paramètre est l'un des deux points d'un couple de points\n * @description Si c'est le cas, il renvoie le couple de points et la liste des couples restants après avoir supprimé le couple trouvé\n * @param {Point} pt1\n * @param {[Point,Point][]} couplesPoints\n * @returns\n */\nexport function TrouveExtremites(\n  pt1: { x: number; y: number },\n  couplesPoints: [{ x: number; y: number }, { x: number; y: number }][],\n) {\n  const index = couplesPoints.findIndex(\n    (couple: [{ x: number; y: number }, { x: number; y: number }]) =>\n      (couple[0].x === pt1.x && couple[0].y === pt1.y) ||\n      (couple[1].x === pt1.x && couple[1].y === pt1.y),\n  )\n  if (index !== -1) {\n    const couple = couplesPoints[index]\n    couplesPoints.splice(index, 1)\n    if (couple[0].x === pt1.x && couple[0].y === pt1.y) {\n      return {\n        couple: [\n          { x: couple[0].x, y: couple[0].y },\n          { x: couple[1].x, y: couple[1].y },\n        ],\n        couplesPointsRestants: couplesPoints,\n      }\n    } else {\n      return {\n        couple: [\n          { x: couple[1].x, y: couple[1].y },\n          { x: couple[0].x, y: couple[0].y },\n        ],\n        couplesPointsRestants: couplesPoints,\n      }\n    }\n  } else {\n    return { couple: null, couplesPointsRestants: couplesPoints }\n  }\n}\n\n/**\n * Classe Tetris\n * @description Cette classe permet de créer un pavage de carrés de surface aire\n * On crée une instance de la classe en lui donnant son aire et les coordonnées de l'origine (coin en bas à gauche du rectangle contenant son polygone)\n * Il faut savoir que les carresOccupes et les carresAdjacentDispo sont définis à partir du point (0;0), le polygone, lui, est translaté en (xOrigine; yOrigine).\n * sa propriété poly donne le polygone de la forme\n * sa méthode render retourne un array contenant toutes les cases carrées\n */\nexport class Polyquad {\n  xOrigine: number\n  yOrigine: number\n  poly!: Polygone\n  dots!: { x: number; y: number }[]\n  carresOccupes: { x: number; y: number }[]\n  carresAdjacentsDispo: { x: number; y: number }[]\n  complexity: number\n  rectangle: {\n    xMin: number\n    xMax: number\n    yMin: number\n    yMax: number\n  }\n\n  constructor(aire: number, xOrigine: number, yOrigine: number) {\n    this.xOrigine = xOrigine\n    this.yOrigine = yOrigine\n    const casesAdjacentes = [\n      { x: 0, y: 1 },\n      { x: 1, y: 0 },\n      { x: 0, y: -1 },\n      { x: -1, y: 0 },\n    ]\n    // on crée un polygone à base de carrés de surface aire\n    let cpt = 0\n    let aireTotale = 0\n    let aireExt = 0\n    do {\n      this.carresOccupes = [{ x: 0, y: 0 }]\n      cpt++\n      this.carresAdjacentsDispo = casesAdjacentes.map((caseAdj) => ({\n        x: caseAdj.x,\n        y: caseAdj.y,\n      }))\n      while (this.carresOccupes.length < aire) {\n        const index = randint(0, this.carresAdjacentsDispo.length - 1) // On choisit une case adjacente disponible\n        const carreChoisi = this.carresAdjacentsDispo[index] // La voilà\n        this.carresAdjacentsDispo.splice(index, 1) // On supprime la case choisie des cases adjacentes disponibles\n        this.carresOccupes.push({ x: carreChoisi.x, y: carreChoisi.y }) // Elle devient une case occupée\n        for (const caseAdj of casesAdjacentes) {\n          const caseAdjDispo = {\n            x: carreChoisi.x + caseAdj.x,\n            y: carreChoisi.y + caseAdj.y,\n          }\n          if (\n            this.carresOccupes.find(\n              (caseOccupe) =>\n                caseAdjDispo.x === caseOccupe.x &&\n                caseAdjDispo.y === caseOccupe.y,\n            ) == null\n          ) {\n            if (\n              this.carresAdjacentsDispo.find(\n                (caseAdjDispoTrouvee) =>\n                  caseAdjDispo.x === caseAdjDispoTrouvee.x &&\n                  caseAdjDispo.y === caseAdjDispoTrouvee.y,\n              ) == null\n            ) {\n              this.carresAdjacentsDispo.push(caseAdjDispo)\n            }\n          }\n        }\n      }\n\n      this.rectangle = this.findRectangle()\n      aireTotale =\n        (this.rectangle.xMax - this.rectangle.xMin) *\n        (this.rectangle.yMax - this.rectangle.yMin)\n      aireExt = this.aireExt()\n\n      this.translate(-this.rectangle.xMin, -this.rectangle.yMin)\n      // permet de renseigner this.dots (la liste des sommets.)\n      this.detoure()\n    } while (aireTotale - aireExt !== aire && cpt < 100)\n    this.complexity = aireExt / aireTotale\n\n    this.poly = translation(\n      polygone(\n        this.dots.map((el: { x: number; y: number }) => point(el.x, el.y)),\n      ),\n      vecteur(xOrigine, yOrigine),\n    )\n    this.poly.color = colorToLatexOrHTML('red')\n    this.poly.couleurDeRemplissage = colorToLatexOrHTML('orange')\n    this.poly.epaisseur = 2\n  }\n\n  ajouteCarres(n: number): Polyquad {\n    let cpt = 0\n    let aireTotale = 0\n    let aireExt = 0\n    const casesAdjacentes = [\n      { x: 0, y: 1 },\n      { x: 1, y: 0 },\n      { x: 0, y: -1 },\n      { x: -1, y: 0 },\n    ]\n    const aire = this.carresOccupes.length + n\n    let carresOccupes\n    let casesAdjacentsDispo\n    const tetris2 = new Polyquad(aire, this.xOrigine, this.yOrigine)\n    do {\n      carresOccupes = JSON.parse(JSON.stringify(this.carresOccupes))\n      casesAdjacentsDispo = JSON.parse(\n        JSON.stringify(this.carresAdjacentsDispo),\n      )\n      cpt++\n      while (carresOccupes.length < aire) {\n        const index = randint(0, casesAdjacentsDispo.length - 1) // On choisit une case adjacente disponible\n        const carreChoisi = casesAdjacentsDispo[index] // La voilà\n        casesAdjacentsDispo.splice(index, 1) // On supprime la case choisie des cases adjacentes disponibles\n        carresOccupes.push({ x: carreChoisi.x, y: carreChoisi.y }) // Elle devient une case occupée\n        for (const caseAdj of casesAdjacentes) {\n          const caseAdjDispo = {\n            x: carreChoisi.x + caseAdj.x,\n            y: carreChoisi.y + caseAdj.y,\n          }\n          if (\n            carresOccupes.find(\n              (caseOccupe: { x: number; y: number }) =>\n                caseAdjDispo.x === caseOccupe.x &&\n                caseAdjDispo.y === caseOccupe.y,\n            ) == null\n          ) {\n            if (\n              casesAdjacentsDispo.find(\n                (caseAdjDispoTrouvee: { x: number; y: number }) =>\n                  caseAdjDispo.x === caseAdjDispoTrouvee.x &&\n                  caseAdjDispo.y === caseAdjDispoTrouvee.y,\n              ) == null\n            ) {\n              casesAdjacentsDispo.push(caseAdjDispo)\n            }\n          }\n        }\n      }\n      tetris2.carresOccupes = JSON.parse(JSON.stringify(carresOccupes))\n      tetris2.carresAdjacentsDispo = JSON.parse(\n        JSON.stringify(casesAdjacentsDispo),\n      )\n      tetris2.rectangle = tetris2.findRectangle()\n      aireTotale =\n        (tetris2.rectangle.xMax - tetris2.rectangle.xMin) *\n        (tetris2.rectangle.yMax - tetris2.rectangle.yMin)\n      aireExt = tetris2.aireExt()\n\n      tetris2.translate(-tetris2.rectangle.xMin, -tetris2.rectangle.yMin)\n      // permet de renseigner this.dots (la liste des sommets)\n      tetris2.detoure()\n    } while (aireTotale - aireExt !== aire && cpt < 100)\n    tetris2.carresOccupes = JSON.parse(JSON.stringify(carresOccupes))\n    tetris2.carresAdjacentsDispo = JSON.parse(\n      JSON.stringify(casesAdjacentsDispo),\n    )\n    tetris2.complexity = aireExt / aireTotale\n\n    tetris2.poly = translation(\n      polygone(\n        tetris2.dots.map((el: { x: number; y: number }) => point(el.x, el.y)),\n      ),\n      vecteur(tetris2.xOrigine, tetris2.yOrigine),\n    )\n    tetris2.poly.color = colorToLatexOrHTML('red')\n    tetris2.poly.couleurDeRemplissage = colorToLatexOrHTML('orange')\n    tetris2.poly.epaisseur = 2\n    return tetris2\n  }\n\n  private findRectangle() {\n    let xMin = 1000\n    let xMax = -1000\n    let yMin = 1000\n    let yMax = -1000\n    for (const carre of this.carresOccupes) {\n      xMin = Math.min(xMin, carre.x)\n      xMax = Math.max(xMax, carre.x + 1)\n      yMin = Math.min(yMin, carre.y)\n      yMax = Math.max(yMax, carre.y + 1)\n    }\n    return { xMin, xMax, yMin, yMax }\n  }\n\n  translate(dx: number, dy: number) {\n    for (const carre of this.carresOccupes) {\n      carre.x += dx\n      carre.y += dy\n    }\n    for (const carre of this.carresAdjacentsDispo) {\n      carre.x += dx\n      carre.y += dy\n    }\n    this.rectangle = {\n      xMin: this.rectangle.xMin + dx,\n      xMax: this.rectangle.xMax + dx,\n      yMin: this.rectangle.yMin + dy,\n      yMax: this.rectangle.yMax + dy,\n    }\n  }\n\n  rotate(sens: boolean) {\n    const matriceTransfo = sens\n      ? [\n          [0, -1],\n          [1, 0],\n        ]\n      : [\n          [0, 1],\n          [-1, 0],\n        ]\n    if (matriceTransfo == null)\n      throw Error('La matrice ne peut pas être créée, ce qui est impossible')\n    for (const carre of this.carresOccupes) {\n      const x = matriceTransfo[0][0] * carre.x + matriceTransfo[0][1] * carre.y\n      const y = matriceTransfo[1][0] * carre.x + matriceTransfo[1][1] * carre.y\n      carre.x = x\n      carre.y = y\n    }\n    for (const carre of this.carresAdjacentsDispo) {\n      const x = matriceTransfo[0][0] * carre.x + matriceTransfo[0][1] * carre.y\n      const y = matriceTransfo[1][0] * carre.x + matriceTransfo[1][1] * carre.y\n      carre.x = x\n      carre.y = y\n    }\n    this.rectangle = this.findRectangle()\n    this.translate(-this.rectangle.xMin, -this.rectangle.yMin)\n    // permet de renseigner this.dots (la liste des sommets.)\n    this.detoure()\n\n    this.poly = translation(\n      polygone(\n        this.dots.map((el: { x: number; y: number }) => point(el.x, el.y)),\n      ),\n      vecteur(this.xOrigine, this.yOrigine),\n    )\n    this.poly.color = colorToLatexOrHTML('red')\n    this.poly.couleurDeRemplissage = colorToLatexOrHTML('orange')\n    this.poly.epaisseur = 2\n  }\n\n  isEmpty(x: number, y: number) {\n    return (\n      this.carresOccupes.find((carre) => carre.x === x && carre.y === y) == null\n    )\n  }\n\n  aireExt() {\n    let aire = 0\n    const xMin = Math.min(...this.carresOccupes.map((carre) => carre.x))\n    const xMax = Math.max(...this.carresOccupes.map((carre) => carre.x))\n    const yMin = Math.min(...this.carresOccupes.map((carre) => carre.y))\n    const yMax = Math.max(...this.carresOccupes.map((carre) => carre.y))\n    for (let y = yMin; y <= yMax; y++) {\n      let xG = xMin\n      let xD = xMax\n      let fini = false\n      do {\n        if (this.isEmpty(xG, y) && this.isEmpty(xD, y)) {\n          aire += 2\n          xG++\n          xD--\n        } else if (this.isEmpty(xG, y)) {\n          aire++\n          xG++\n        } else if (this.isEmpty(xD, y)) {\n          aire++\n          xD--\n        } else {\n          fini = true\n        }\n      } while (!fini)\n    }\n    return aire\n  }\n\n  render() {\n    const objets: NestedObjetMathalea2dArray = []\n    for (const car of this.carresOccupes) {\n      const quad = carre(\n        point(car.x + this.xOrigine, car.y + this.yOrigine),\n        point(car.x + this.xOrigine + 1, car.y + this.yOrigine),\n      )\n      quad.couleurDeRemplissage = colorToLatexOrHTML('orange')\n      quad.color = colorToLatexOrHTML('black')\n      objets.push(quad)\n    }\n    return objets\n  }\n\n  detoure() {\n    const borduresNonNettoyees: [boolean, boolean, boolean, boolean][][] = []\n    for (let x = this.rectangle.xMin; x < this.rectangle.xMax; x++) {\n      borduresNonNettoyees[x] = []\n\n      for (let y = this.rectangle.yMin; y < this.rectangle.yMax; y++) {\n        borduresNonNettoyees[x][y] =\n          this.carresOccupes.find((carre) => carre.x === x && carre.y === y) ==\n          null\n            ? [false, false, false, false]\n            : [true, true, true, true]\n      }\n    }\n    const xor = function (a: boolean, b: boolean) {\n      return (a || b) && !(a && b)\n    }\n    const borduresNettoyees: [boolean, boolean, boolean, boolean][][] = []\n    for (let x = this.rectangle.xMin; x < this.rectangle.xMax; x++) {\n      borduresNettoyees[x] = []\n      for (let y = this.rectangle.yMin; y < this.rectangle.yMax; y++) {\n        borduresNettoyees[x][y] = [false, false, false, false]\n        borduresNettoyees[x][y][0] =\n          y === 0\n            ? borduresNonNettoyees[x][y][0]\n            : xor(\n                borduresNonNettoyees[x][y][0],\n                borduresNonNettoyees[x][y - 1][2],\n              )\n        borduresNettoyees[x][y][1] =\n          x === this.rectangle.xMax - 1\n            ? borduresNonNettoyees[x][y][1]\n            : xor(\n                borduresNonNettoyees[x][y][1],\n                borduresNonNettoyees[x + 1][y][3],\n              )\n        borduresNettoyees[x][y][2] =\n          y === this.rectangle.yMax - 1\n            ? borduresNonNettoyees[x][y][2]\n            : xor(\n                borduresNonNettoyees[x][y][2],\n                borduresNonNettoyees[x][y + 1][0],\n              )\n        borduresNettoyees[x][y][3] =\n          x === 0\n            ? borduresNonNettoyees[x][y][3]\n            : xor(\n                borduresNonNettoyees[x][y][3],\n                borduresNonNettoyees[x - 1][y][1],\n              )\n      }\n    }\n    let couplesCoords: [{ x: number; y: number }, { x: number; y: number }][] =\n      []\n\n    for (let x = this.rectangle.xMin; x < this.rectangle.xMax; x++) {\n      for (let y = this.rectangle.yMin; y < this.rectangle.yMax; y++) {\n        if (borduresNettoyees[x][y][0]) {\n          const pt1 = { x, y }\n          const pt2 = { x: x + 1, y }\n          if (!couplesCoords.some((couple) => trouveCouple(pt1, pt2, couple)))\n            couplesCoords.push([pt1, pt2])\n        }\n        if (borduresNettoyees[x][y][1]) {\n          const pt1 = { x: x + 1, y }\n          const pt2 = { x: x + 1, y: y + 1 }\n          if (!couplesCoords.some((couple) => trouveCouple(pt1, pt2, couple)))\n            couplesCoords.push([pt1, pt2])\n        }\n        if (borduresNettoyees[x][y][2]) {\n          const pt1 = { x: x + 1, y: y + 1 }\n          const pt2 = { x, y: y + 1 }\n          if (!couplesCoords.some((couple) => trouveCouple(pt1, pt2, couple)))\n            couplesCoords.push([pt1, pt2])\n        }\n        if (borduresNettoyees[x][y][3]) {\n          const pt1 = { x, y: y + 1 }\n          const pt2 = { x, y }\n          if (!couplesCoords.some((couple) => trouveCouple(pt1, pt2, couple)))\n            couplesCoords.push([pt1, pt2])\n        }\n      }\n    }\n\n    this.dots = [\n      { x: couplesCoords[0][0].x, y: couplesCoords[0][0].y },\n      { x: couplesCoords[0][1].x, y: couplesCoords[0][1].y },\n    ]\n    couplesCoords.shift()\n    // afin d'éviter les boucles infinies, on limite le nombre d'itérations au nombre de couples de points.\n    let cpt = couplesCoords.length\n    while (couplesCoords.length > 0 && cpt > 0) {\n      const { couple, couplesPointsRestants } = TrouveExtremites(\n        this.dots[this.dots.length - 1],\n        couplesCoords,\n      )\n      cpt--\n      const seg = couple\n      couplesCoords = couplesPointsRestants\n      if (seg) {\n        if (seg[1].x !== this.dots[0].x || seg[1].y !== this.dots[0].y) {\n          this.dots.push({ x: seg[1].x, y: seg[1].y })\n        }\n      } else {\n        // window.notifyLocal('Le segment suivant n\\'a pas été trouvé !', { pointCourant: this.dots[this.dots.length - 1], couplesPoints })\n      }\n    }\n    // on supprime les points intermédiaires\n    this.dots = elimineBinomesXYIntermediairesAlignes(this.dots)\n  }\n}\n/**\n * Vérifie si deux vecteurs sont orientés dans la même direction\n * @param {number} dx1 Composante x du premier vecteur\n * @param {number} dy1 Composante y du premier vecteur\n * @param {number} dx2 Composante x du second vecteur\n * @param {number} dy2 Composante y du second vecteur\n * @returns {boolean} true si les vecteurs sont orientés dans la même direction, false sinon\n */\nfunction sontVecteursAlignes(\n  dx1: number,\n  dy1: number,\n  dx2: number,\n  dy2: number,\n): boolean {\n  if (dx1 === 0) {\n    if (dy1 === 0) {\n      return dx2 === 0 && dy2 === 0\n    } else {\n      return dy2 / dy1 > 0\n    }\n  }\n  if (dy1 === 0) {\n    if (dx1 === 0) {\n      return dx2 === 0 && dy2 === 0\n    } else {\n      return dx2 / dx1 > 0\n    }\n  }\n  return dx2 * dy1 === dx1 * dy2 && dx1 * dx2 > 0 && dy1 * dy2 > 0\n}\n/**\n * Supprime de la liste de binomesXY les binomes intermédiaires correspondant à des point alignés avec le précédent et le suivant afin de limiter le nombre de sommets d'un polygone\n * Elle permet aussi de supprimer les doublons consécutifs puisque forcément, ils sont alignés\n * @param {BinomesXY} binomesXY une liste de binomesXY\n * @returns {BinomesXY} une liste de binomesXY\n * @author Jean-Claude Lhote\n */\n\nexport function elimineBinomesXYIntermediairesAlignes(binomesXY: BinomesXY) {\n  // on supprime les binomesXY intermédiaires\n  for (let i = 1; i < binomesXY.length - 1; ) {\n    const pt1 = binomesXY[i - 1]\n    const pt2 = binomesXY[i]\n    const pt3 = binomesXY[i + 1]\n    const dx = pt2.x - pt1.x\n    const dy = pt2.y - pt1.y\n    const dx2 = pt3.x - pt2.x\n    const dy2 = pt3.y - pt2.y\n    if (sontVecteursAlignes(dx, dy, dx2, dy2)) {\n      binomesXY.splice(i, 1)\n    } else {\n      i++\n    }\n  }\n  const pt1 = binomesXY[binomesXY.length - 1]\n  const pt2 = binomesXY[0]\n  const pt3 = binomesXY[1]\n  const dx = pt2.x - pt1.x\n  const dy = pt2.x - pt1.y\n  const dx2 = pt3.x - pt2.x\n  const dy2 = pt3.y - pt2.y\n  if (dx2 === dx && dy2 === dy) {\n    binomesXY.splice(0, 1)\n  }\n  return binomesXY\n}\n"],"names":["trouveCouple","pt1","pt2","couple","TrouveExtremites","couplesPoints","index","Polyquad","aire","xOrigine","yOrigine","__publicField","casesAdjacentes","cpt","aireTotale","aireExt","caseAdj","randint","carreChoisi","caseAdjDispo","caseOccupe","caseAdjDispoTrouvee","translation","polygone","el","point","vecteur","colorToLatexOrHTML","n","carresOccupes","casesAdjacentsDispo","tetris2","xMin","xMax","yMin","yMax","carre","dx","dy","sens","matriceTransfo","x","y","xG","xD","fini","objets","car","quad","borduresNonNettoyees","xor","a","b","borduresNettoyees","couplesCoords","couplesPointsRestants","seg","elimineBinomesXYIntermediairesAlignes","sontVecteursAlignes","dx1","dy1","dx2","dy2","binomesXY","i","pt3"],"mappings":"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"}