{"version":3,"file":"polygones-89tGuAkc.js","sources":["../../src/lib/2d/polygones.ts"],"sourcesContent":["import earcut from 'earcut'\nimport { context } from '../../modules/context'\nimport { arrondi } from '../outils/nombres'\nimport { colorToLatexOrHTML } from './colorToLatexOrHtml'\nimport type { IPointAbstrait, IPolygone } from './Interfaces'\nimport { ObjetMathalea2D } from './ObjetMathalea2D'\nimport { pattern } from './pattern'\nimport {\n  isPointsAbstraits,\n  pointAbstrait,\n  PointAbstrait,\n} from './PointAbstrait'\nimport { segment } from './segmentsVecteurs'\nimport { texteParPoint } from './textes'\nimport { longueur } from './utilitairesGeometriques'\nimport { pointSurSegment } from './utilitairesPoint'\n\ntype BinomeXY = { x: number; y: number }\nexport type BinomesXY = BinomeXY[]\n\n// Fonction locale pour calculer l'aire d'un triangle (remplace l'import)\nfunction aireTriangle(p: {\n  listePoints: { x: number; y: number }[]\n}): number | false {\n  if (!p?.listePoints || p.listePoints.length !== 3) return false\n  const [A, B, C] = p.listePoints\n  return 0.5 * Math.abs((B.x - A.x) * (C.y - A.y) - (C.x - A.x) * (B.y - A.y))\n}\n\n/**\n * Crée le barycentre d'un polygone\n * @param {Polygone} p Polygone dont on veut créer le barycentre\n * @param {string} [nom = ''] Nom du barycentre\n * @param {string} [positionLabel = 'above'] Position du nom par rapport au point\n * @example G = barycentre(pol) // Crée G, le barycentre du polygone pol, sans lui donner de nom\n * @example G = barycentre(pol,'G','below') // Crée G, le barycentre du polygone pol, en notant G sous le point, s'il est tracé et labellisé.\n * @author Jean-Claude Lhote\n * @return {Point}\n */\n// JSDOC Validee par EE Juin 2022\nexport function barycentre(p: IPolygone, nom = '', positionLabel = 'above') {\n  let sommex = 0\n  let sommey = 0\n  let nbsommets = 0\n  for (const point of p.listePoints) {\n    sommex += point.x\n    sommey += point.y\n    nbsommets++\n  }\n  const x = sommex / nbsommets\n  const y = sommey / nbsommets\n  return pointAbstrait(x, y, nom, positionLabel)\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%% LES POLYGONES %%%%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n/**\n * polygone(A,B,C,D,E) //Trace ABCDE\n * polygone([A,B,C,D],\"blue\") // Trace ABCD en bleu\n * polygone([A,B,C,D],\"blue\",\"red\",\"green\") // Trace ABCD en bleu, rempli en rouge et hachuré en vert.\n * @property {Point[]} listePoints\n * @property {string[]} color\n * @property {string[]} couleurDeRemplissage\n * @property {string[]} couleurDesHachures\n * @property {number} epaisseurDesHachures\n * @property {number} distanceDesHachures\n * @property {number} opaciteDeRemplissage\n * @property {boolean|string} hachures\n * @property {number[]} bordures\n * @property {string} nom\n * @property {string} id\n * @property {string} style\n * @property {number} opacite\n * @property {number} epaisseur\n * @property {number} pointilles\n *\n * @author Rémi Angot*\n * @class\n */\nexport class Polygone extends ObjetMathalea2D {\n  couleurDeRemplissage: string[]\n  opaciteDeRemplissage: number\n  couleurDesHachures: string[]\n  distanceDesHachures: number\n  epaisseurDesHachures: number\n  hachures: boolean | string\n  listePoints: PointAbstrait[]\n  nom: string\n  pointilles: number\n  _triangulation: [PointAbstrait, PointAbstrait, PointAbstrait][]\n  _flat: number[]\n  _aire: number\n  stringColor: string\n  readonly perimetre: number\n  constructor(\n    ...points:\n      | (PointAbstrait | IPointAbstrait)[]\n      | [(PointAbstrait | IPointAbstrait)[], string?]\n  ) {\n    super()\n    this.epaisseurDesHachures = 1\n    this.distanceDesHachures = 10\n    this.couleurDeRemplissage = colorToLatexOrHTML('none')\n    this.opaciteDeRemplissage = 0.5\n    this.epaisseur = 1\n    this.opacite = 1\n    this.pointilles = 0\n    this._triangulation = []\n    this._flat = []\n    this._aire = 0\n    this.stringColor = 'black'\n    if (Array.isArray(points[0])) {\n      // Si le premier argument est un tableau\n      this.listePoints = points[0].map((el) =>\n        pointAbstrait(el.x, el.y, el.nom, el.positionLabel),\n      )\n      if (points[1]) {\n        this.color = colorToLatexOrHTML(String(points[1]))\n        this.stringColor = String(points[1])\n      }\n      if (points[2]) {\n        this.couleurDeRemplissage = colorToLatexOrHTML(String(points[2]))\n      } else {\n        this.couleurDeRemplissage = colorToLatexOrHTML('none')\n      }\n      if (points[3]) {\n        this.couleurDesHachures = colorToLatexOrHTML(String(points[3]))\n        this.hachures = true\n      } else {\n        this.couleurDesHachures = colorToLatexOrHTML('black')\n        this.hachures = false\n      }\n      this.nom = this.listePoints.map((el) => el.nom).join('')\n    } else {\n      if (typeof points[points.length - 1] === 'string') {\n        this.color = colorToLatexOrHTML(String(points[points.length - 1]))\n        this.stringColor = String(points[points.length - 1])\n        points.splice(points.length - 1, 1)\n      }\n      this.listePoints = points.filter((el) => el instanceof PointAbstrait)\n      this.nom = this.listePoints.map((el) => el.nom).join('')\n      this.couleurDeRemplissage = colorToLatexOrHTML('none')\n      this.couleurDesHachures = colorToLatexOrHTML('none') // Rajout EE du 22/02/2024 pour 6N22 cas 3\n      this.hachures = false\n    }\n    let xmin = 1000\n    let xmax = -1000\n    let ymin = 1000\n    let ymax = -1000\n    for (const unPoint of this.listePoints) {\n      if (unPoint.typeObjet !== 'point')\n        window.notify('Polygone : argument invalide', { ...points })\n      xmin = Math.min(xmin, unPoint.x)\n      xmax = Math.max(xmax, unPoint.x)\n      ymin = Math.min(ymin, unPoint.y)\n      ymax = Math.max(ymax, unPoint.y)\n    }\n    this.bordures = [xmin, ymin, xmax, ymax]\n    let p = 0\n    for (let i = 0; i < this.listePoints.length; i++) {\n      p += longueur(\n        this.listePoints[i],\n        this.listePoints[(i + 1) % this.listePoints.length],\n      )\n    }\n    this.perimetre = p\n  }\n\n  binomesXY(coeff: number) {\n    let liste = ''\n    for (const point of this.listePoints) {\n      liste += `${point.xSVG(coeff)},${point.ySVG(coeff)} `\n    }\n    return liste\n  }\n\n  get flat() {\n    if (this._flat.length === 0) {\n      this._flat = polygoneToFlatArray(this)\n    }\n    return this._flat\n  }\n\n  get triangulation() {\n    if (this._triangulation.length === 0) {\n      const trianglesIndices = earcut(this.flat)\n      this._triangulation = []\n      for (let i = 0; i < trianglesIndices.length; i += 3) {\n        this._triangulation.push([\n          pointAbstrait(\n            this.flat[trianglesIndices[i] * 2],\n            this.flat[trianglesIndices[i] * 2 + 1],\n          ),\n          pointAbstrait(\n            this.flat[trianglesIndices[i + 1] * 2],\n            this.flat[trianglesIndices[i + 1] * 2 + 1],\n          ),\n          pointAbstrait(\n            this.flat[trianglesIndices[i + 2] * 2],\n            this.flat[trianglesIndices[i + 2] * 2 + 1],\n          ),\n        ])\n      }\n    }\n    return this._triangulation\n  }\n\n  get aire() {\n    if (this._aire === 0) {\n      const triangles = this.triangulation\n      this._aire = 0\n      for (let i = 0; i < triangles.length; i++) {\n        this._aire += Number(aireTriangle(polygone(triangles[i])))\n      }\n    }\n    return this._aire\n  }\n\n  svg(coeff: number) {\n    if (this.epaisseur !== 1) {\n      this.style += ` stroke-width=\"${this.epaisseur}\" `\n    }\n    if (this.opacite !== 1) {\n      this.style += ` stroke-opacity=\"${this.opacite}\" `\n    }\n    switch (this.pointilles) {\n      case 1:\n        this.style += ' stroke-dasharray=\"6 10\" '\n        break\n      case 2:\n        this.style += ' stroke-dasharray=\"6 3\" '\n        break\n      case 3:\n        this.style += ' stroke-dasharray=\"3 2 6 2 \" '\n        break\n      case 4:\n        this.style += ' stroke-dasharray=\"1 2\" '\n        break\n      case 5:\n        this.style += ' stroke-dasharray=\"5 5\" '\n        break\n    }\n\n    if (this.hachures) {\n      if (this.couleurDeRemplissage.length < 1) {\n        this.couleurDeRemplissage = colorToLatexOrHTML('none')\n      }\n      return (\n        pattern({\n          motif: String(this.hachures),\n          id: String(this.id),\n          distanceDesHachures: this.distanceDesHachures,\n          epaisseurDesHachures: this.epaisseurDesHachures,\n          couleurDesHachures: this.couleurDesHachures[0] || 'black',\n          couleurDeRemplissage: this.couleurDeRemplissage[0],\n          opaciteDeRemplissage: this.opaciteDeRemplissage,\n        }) +\n        `<polygon points=\"${this.binomesXY(coeff)}\" stroke=\"${this.color[0]}\" ${this.style} id=\"${this.id}\" fill=\"url(#pattern${this.id})\" />`\n      )\n    } else {\n      if (\n        this.couleurDeRemplissage[0] === '' ||\n        this.couleurDeRemplissage[0] === undefined\n      ) {\n        this.style += ' fill=\"none\" '\n      } else {\n        this.style += ` fill=\"${this.couleurDeRemplissage[0]}\" `\n        this.style += ` fill-opacity=\"${this.opaciteDeRemplissage}\" `\n      }\n      if (this.opacite !== 1) {\n        this.style += ` stroke-opacity=\"${this.opacite}\" `\n      }\n      return `<polygon points=\"${this.binomesXY(coeff)}\" stroke=\"${this.color[0]}\" ${this.style} id=\"${this.id}\" />`\n    }\n  }\n\n  tikz() {\n    const tableauOptions = []\n    if (this.color[1].length > 1 && this.color[1] !== 'black') {\n      tableauOptions.push(`color=${this.color[1]}`)\n    }\n    if (this.epaisseur !== 1) {\n      tableauOptions.push(`line width = ${this.epaisseur}`)\n    }\n    switch (this.pointilles) {\n      case 1:\n        tableauOptions.push(' dash dot ')\n        break\n      case 2:\n        tableauOptions.push(' densely dash dot dot ')\n        break\n      case 3:\n        tableauOptions.push(' dash dot dot ')\n        break\n      case 4:\n        tableauOptions.push(' dotted ')\n        break\n      case 5:\n        tableauOptions.push(' dashed ')\n        break\n    }\n    if (this.opacite !== 1) {\n      tableauOptions.push(`opacity=${this.opacite}`)\n    }\n\n    if (\n      this.couleurDeRemplissage[1] !== '' &&\n      this.couleurDeRemplissage[1] !== 'none'\n    ) {\n      tableauOptions.push(\n        `preaction={fill,color = ${this.couleurDeRemplissage[1]}${this.opaciteDeRemplissage !== 1 ? ', opacity = ' + this.opaciteDeRemplissage : ''}}`,\n      )\n    }\n\n    if (this.hachures) this.hachures = 'dotted'\n    if (this.hachures != null && typeof this.hachures === 'string') {\n      tableauOptions.push(\n        pattern({\n          motif: this.hachures,\n          id: String(this.id),\n          distanceDesHachures: this.distanceDesHachures,\n          couleurDesHachures: this.couleurDesHachures[1],\n          couleurDeRemplissage: this.couleurDeRemplissage[1],\n          opaciteDeRemplissage: this.opaciteDeRemplissage,\n        }),\n      )\n    }\n    let optionsDraw = ''\n    if (tableauOptions.length > 0) {\n      optionsDraw = '[' + tableauOptions.join(',') + ']'\n    }\n\n    let binomeXY = ''\n\n    for (const point of this.listePoints) {\n      binomeXY += `(${arrondi(point.x)},${arrondi(point.y)})--`\n    }\n    const lines = `\\\\draw${optionsDraw} ${binomeXY}cycle;`\n\n    return lines\n  }\n\n  svgml(coeff: number, amp: number) {\n    let code = ''\n    let segmentCourant\n    let A, B\n    for (let k = 1; k <= this.listePoints.length; k++) {\n      B = this.listePoints[k % this.listePoints.length]\n      A = this.listePoints[k - 1]\n      segmentCourant = segment(A, B, this.stringColor)\n      segmentCourant.epaisseur = this.epaisseur\n      segmentCourant.opacite = this.opacite\n      code += segmentCourant.svgml(coeff, amp)\n    }\n    return code\n  }\n\n  tikzml(amp: number) {\n    let code = ''\n    let segmentCourant\n    let A, B\n    for (let k = 1; k <= this.listePoints.length; k++) {\n      B = this.listePoints[k % this.listePoints.length]\n      A = this.listePoints[k - 1]\n      segmentCourant = segment(A, B, this.stringColor)\n      segmentCourant.epaisseur = this.epaisseur\n      segmentCourant.opacite = this.opacite\n      code += '\\t' + segmentCourant.tikzml(amp) + '\\n'\n    }\n    return code\n  }\n}\n\n/**\n * Propriétés possibles : .color, .opacite, .epaisseur, .couleurDeRemplissage, .opaciteDeRemplissage, .hachures (un string correspondant à l'un des motifs de pattern), .distanceDesHachures, .epaisseurDesHachures,.couleurDesHachures\n * @return {Polygone} objet Polygone\n * @example polygone(A,B,C,D,E) //Trace ABCDE\n * @example polygone([A,B,C,D],\"blue\") // Trace ABCD en bleu\n * @example polygone([A,B,C,D],\"#f15929\") // Trace ABCD en orange (code couleur HTML : #f15929)\n * @property {PointAbstrait[]} listePoints\n * @property {string[]} color\n * @property {string[]} couleurDeRemplissage\n * @property {string[]} couleurDesHachures\n * @property {number} epaisseurDesHachures\n * @property {number} distanceDesHachures\n * @property {number} opaciteDeRemplissage\n * @property {boolean|string} hachures\n * @property {number[]} bordures\n * @property {string} nom\n * @property {string} id\n * @property {string} style\n * @property {number} opacite\n * @property {number} epaisseur\n * @property {number} pointilles\n *\n * @author Rémi Angot\n */\nexport function polygone(\n  ...args:\n    | (PointAbstrait | IPointAbstrait)[]\n    | [(PointAbstrait | IPointAbstrait)[], string?]\n) {\n  return new Polygone(...args)\n}\n\n/**\n * Crée un groupe d'objets contenant le polygone et ses sommets\n * @param  {...any} args\n * @return {array} [polygone,sommets]\n * Si le dernier argument est un nombre, celui-ci sera utilisé pour fixer la distance entre le sommet et le label (par défaut 0.5)\n * @exemple [poly, sommets] = polygoneAvecNom(A, B, C, D) // où A, B, C, D sont des objets Point\n */\nexport function polygoneAvecNom(\n  ...args: (PointAbstrait | number)[]\n): [Polygone, NommePolygone] {\n  let k = 0.5\n  if (typeof args[args.length - 1] === 'number') {\n    k = Number(args[args.length - 1])\n    args.splice(args.length - 1, 1)\n  }\n  if (!isPointsAbstraits(args)) {\n    window.notify(\n      'polygoneAvecNom : les arguments doivent être des objets PointAbstrait',\n      { args },\n    )\n    return [polygone(), nommePolygone(polygone())]\n  }\n  const p = polygone(...args)\n  let nom = ''\n  args.forEach((el: PointAbstrait) => {\n    nom += el.nom + ','\n  })\n  nom = nom.substring(0, nom.length - 1)\n  const sommets = nommePolygone(p, nom, k)\n  sommets.bordures = [0, 0, 0, 0]\n  sommets.bordures[0] = p.bordures[0] - 1 - k\n  sommets.bordures[1] = p.bordures[1] - 1 - k\n  sommets.bordures[2] = p.bordures[2] + 1 + k\n  sommets.bordures[3] = p.bordures[3] + 1 + k\n  return [p, sommets]\n}\n\n/**\n * @description en une fois tous les sommets d'un polygone avec le tableau de string fourni\n * attention si on passe un string comme 'ABCD' ça fonctionne aussi...\n * Si on veut des noms de points à plus de 1 caractère, il faut soit les passer en tableau soit les séparer par des virgules au sein du string\n * @example renommePolygone(p, \"A',B',C',D'\") ou renommePolygone(p, [\"A'\",\"B'\",\"C'\",\"D'\"])\n */\nexport function renommePolygone(p: Polygone, noms: string | string[]) {\n  noms =\n    typeof noms === 'string'\n      ? noms.includes(',')\n        ? noms.split(',')\n        : noms\n      : noms\n  for (let i = 0; i < p.listePoints.length; i++) {\n    if (noms[i] !== undefined) {\n      p.listePoints[i].nom = noms[i]\n    }\n  }\n}\n\n/**\n * @param {Polygone} p\n * @return {number[]} retourne la liste des coordonnées des sommets de p dans un seul tableau.\n * @author Jean-Claude Lhote\n */\nexport function polygoneToFlatArray(p: Polygone) {\n  const flatArray = []\n  for (let i = 0; i < p.listePoints.length; i++) {\n    flatArray.push(p.listePoints[i].x, p.listePoints[i].y)\n  }\n  return flatArray\n}\n\n/**\n *\n * @param {number[]} [data = []] tableau à une seule dimension (flat array) contenant les coordonnées des sommets (extérieurs et intérieurs) du polygone\n * @param {number[]} [holes = []] tableau à une seule dimension contenant les indices des points qui démarrent un 'trou' dans le tableau data (exemple : holes = [4, 8] indique que les points 4 à 7 définissent un trou ainsi que 8 et suivants, donc les coordonnées 8 à 15 et 16 à ...(ne pas oublier que 1 point = 2 coordonnées))\n * @param {string} [noms = ''] chaine donnant les noms des sommets\n * @param {string} [color = 'black'] couleur du polygone\n * @param {string} [couleurDeRemplissage = ' blue'] la couleur de remplissage\n * @param {string} [couleurDeFond = 'white'] la couleur des trous\n * @class\n */\nexport class PolygoneATrous extends ObjetMathalea2D {\n  _aire: number\n  _triangulation: Polygone[]\n  contour: Polygone\n  trous: Polygone[]\n  colorString: string\n  triangles: number[]\n  data: number[]\n  holes: number[]\n  stringColor: string\n  stringCouleurDeFond: string\n  stringCouleurDeRemplissage: string\n  constructor({\n    data = [],\n    holes = [],\n    noms = '',\n    color = 'black',\n    couleurDeRemplissage = 'blue',\n    couleurDeFond = 'white',\n  }) {\n    super()\n    this.colorString = color\n    this.data = data\n    this.holes = holes\n    this.triangles = earcut(data, holes) // on crée le pavage de triangles grâce à Mapbox/earcut\n\n    this._triangulation = []\n    this._aire = 0\n    this.stringColor = color\n\n    const sommetsContour = [] // on crée le polygone extérieur\n    for (let i = 0; i < 2 * holes[0]; i += 2) {\n      sommetsContour.push(pointAbstrait(data[i], data[i + 1]))\n      if (noms.length >= data.length << 1) {\n        sommetsContour[i >> 1].nom = noms[i << 1]\n      }\n    }\n    // On cherche les bordures\n    for (\n      let i = 0, xmin = 1000, xmax = -1000, ymin = 1000, ymax = -1000;\n      i < data.length;\n      i += 2\n    ) {\n      xmin = Math.min(xmin, data[i])\n      xmax = Math.max(xmax, data[i])\n      ymin = Math.min(ymin, data[i + 1])\n      ymax = Math.max(ymax, data[i + 1])\n      this.bordures = [xmin, ymin, xmax, ymax]\n    }\n    this.contour = polygone(...sommetsContour)\n    this.trous = []\n    this.stringCouleurDeRemplissage = couleurDeRemplissage\n    this.contour.couleurDeRemplissage = colorToLatexOrHTML(couleurDeRemplissage)\n    this.contour.color = colorToLatexOrHTML(this.stringColor)\n    this.stringCouleurDeFond = couleurDeFond\n    const trous: PointAbstrait[][] = []\n    let trou: PointAbstrait\n    let trouPol: Polygone\n    for (let i = 0; i < holes.length; i++) {\n      trous[i] = []\n      for (\n        let j = holes[i] * 2;\n        j < (i !== holes.length - 1 ? holes[i + 1] * 2 : data.length);\n        j += 2\n      ) {\n        trou = pointAbstrait(data[j], data[j + 1])\n        if (noms.length >= data.length >> 1) {\n          trou.nom = noms[j >> 1]\n        }\n        trous[i].push(trou)\n      }\n      trouPol = polygone(...trous[i])\n      trouPol.color = colorToLatexOrHTML(this.stringColor)\n      trouPol.couleurDeRemplissage = colorToLatexOrHTML(\n        this.stringCouleurDeFond,\n      )\n      this.trous.push(trouPol)\n    }\n  }\n\n  get triangulation(): Polygone[] {\n    if (this._triangulation === null) {\n      this._triangulation = []\n      for (let i = 0, triangle; i < this.triangles.length; i += 3) {\n        triangle = polygone([\n          pointAbstrait(\n            this.data[this.triangles[i] * 2],\n            this.data[this.triangles[i] * 2 + 1],\n          ),\n          pointAbstrait(\n            this.data[this.triangles[i + 1] * 2],\n            this.data[this.triangles[i + 1] * 2 + 1],\n          ),\n          pointAbstrait(\n            this.data[this.triangles[i + 2] * 2],\n            this.data[this.triangles[i + 2] * 2 + 1],\n          ),\n        ])\n        triangle.color = colorToLatexOrHTML(this.stringColor)\n        triangle.couleurDeRemplissage = colorToLatexOrHTML('none')\n        this._triangulation.push(triangle)\n      }\n    }\n    return this._triangulation\n  }\n\n  get aire(): number {\n    if (this._aire === null) {\n      this._aire = this.contour.aire\n      for (let i = 0; i < this.trous.length; i++) {\n        this._aire -= this.trous[i].aire\n      }\n    }\n    return this._aire\n  }\n\n  svg(coeff: number) {\n    let code = this.contour.svg(coeff)\n    for (let i = 0; i < this.trous.length; i++) {\n      code += this.trous[i].svg(coeff)\n    }\n    return code\n  }\n\n  tikz() {\n    let code = this.contour.tikz()\n    for (let i = 0; i < this.trous.length; i++) {\n      code += '\\n\\t' + this.trous[i].tikz()\n    }\n    return code\n  }\n}\n\n/**\n * Cet objet permet de créer un polygone avec une surface contenant des 'trous' eux-mêmes polygonaux\n * cerise sur le gâteau, la propriété this.triangulation fournit une liste de triangles pavant le polygone\n * @param {number[]} [data = []] contient la liste des coordonnées des sommets (contour puis trous) 2 coordonnées par point dans l'ordre abscisse, ordonnée\n * @param {number[]}  [holes = []] tableau à une seule dimension contenant les indices des points qui démarrent un 'trou' dans le tableau data (exemple : holes = [4, 8] indique que les points 4 à 7 définissent un trou ainsi que 8 et suivants, donc les coordonnées 8 à 15 et 16 à ...(ne pas oublier que 1 point = 2 coordonnées))\n * @param {string} [noms = ''] contient les noms des sommets\n * @param {string} [color = 'black'] est la couleur des bords\n * @param {string} [couleurDeRemplissage = 'blue'] est la couleur de la surface\n * @param {string} [couleurDeFond = 'white'] est la couleur de remplissage des trous\n * @return {PolygoneaTrou} un polygone à trous (ou pas : il peut ne pas y avoir de trou !)\n */\nexport function polygoneATrous({\n  data = [],\n  holes = [],\n  noms = '',\n  color = 'black',\n  couleurDeRemplissage = 'blue',\n  couleurDeFond = 'white',\n}) {\n  return new PolygoneATrous({\n    data,\n    holes,\n    noms,\n    color,\n    couleurDeRemplissage,\n    couleurDeFond,\n  })\n}\n\n/**\n * @description Place les labels passés dans le deuxième paramètre aux sommets du polygone en les plaçant alignés avec le barycentre du polygone à une distance fixée du point\n * @description Si les noms peuvent avoir plusieurs caractères, il faudra ajouter des virgules entre chaque nom dans le string passé en argument.\n * @example nommePolygone (p, \"A',B',C',D',E'\", 0.5, 'red')\n * @example nommePolygone (p,'ABCDE',0.5,'red') nomme les sommets du polygone A, B, C, D et E. Les labels sont placés à une distance de 0,5 cm des sommets\n * @author Jean-Claude Lhote\n */\nexport class NommePolygone extends ObjetMathalea2D {\n  poly: Polygone\n  dist: number\n  constructor(p: Polygone, nom = '', k = 0.5, color = 'black', size = 1) {\n    super()\n    this.poly = p\n    this.dist = k\n    this.objets = []\n    const noms = nom.includes(',') ? nom.split(',') : nom\n    for (let i = 0; i < p.listePoints.length; i++) {\n      if (noms.length > 0) p.listePoints[i].nom = noms[i]\n    }\n    p.nom = p.listePoints.map((el) => el.nom).join('')\n    const G = barycentre(p)\n    let xMin = 1000\n    let xMax = -1000\n    let yMin = 1000\n    let yMax = -1000\n    for (const pt of p.listePoints) {\n      const P = pointSurSegment(\n        G,\n        pt,\n        longueur(G, pt) +\n          (context.isHtml ? (k * 20) / context.pixelsParCm : k / context.scale),\n      )\n      P.positionLabel = 'center'\n      this.objets.push(texteParPoint(pt.nom, P, 0, color, size, 'milieu', true))\n      xMin = Math.min(xMin, P.x - 0.5)\n      xMax = Math.max(xMax, P.x + 0.5)\n      yMin = Math.min(yMin, P.y - 0.5)\n      yMax = Math.max(yMax, P.y + 0.5)\n    }\n    this.bordures = [xMin, yMin, xMax, yMax]\n  }\n\n  svg(coeff: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz() {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\n\nexport function nommePolygone(\n  p: Polygone,\n  nom = '',\n  k = 0.5,\n  color = 'black',\n  size = 1,\n) {\n  return new NommePolygone(p, nom, k, color, size)\n}\n"],"names":["aireTriangle","p","A","B","C","barycentre","nom","positionLabel","sommex","sommey","nbsommets","point","x","y","pointAbstrait","Polygone","ObjetMathalea2D","points","__publicField","colorToLatexOrHTML","el","PointAbstrait","xmin","xmax","ymin","ymax","unPoint","i","longueur","coeff","liste","polygoneToFlatArray","trianglesIndices","earcut","triangles","polygone","pattern","tableauOptions","optionsDraw","binomeXY","arrondi","amp","code","segmentCourant","k","segment","args","polygoneAvecNom","isPointsAbstraits","nommePolygone","sommets","renommePolygone","noms","flatArray","NommePolygone","color","size","G","xMin","xMax","yMin","yMax","pt","P","pointSurSegment","context","texteParPoint","objet"],"mappings":"wjBAqBA,SAASA,EAAaC,EAEH,CACjB,GAAI,EAACA,GAAA,MAAAA,EAAG,cAAeA,EAAE,YAAY,SAAW,EAAG,MAAO,GAC1D,KAAM,CAACC,EAAGC,EAAGC,CAAC,EAAIH,EAAE,YACpB,MAAO,IAAM,KAAK,KAAKE,EAAE,EAAID,EAAE,IAAME,EAAE,EAAIF,EAAE,IAAME,EAAE,EAAIF,EAAE,IAAMC,EAAE,EAAID,EAAE,EAAE,CAC7E,CAaO,SAASG,EAAWJ,EAAcK,EAAM,GAAIC,EAAgB,QAAS,CAC1E,IAAIC,EAAS,EACTC,EAAS,EACTC,EAAY,EAChB,UAAWC,KAASV,EAAE,YACpBO,GAAUG,EAAM,EAChBF,GAAUE,EAAM,EAChBD,IAEF,MAAME,EAAIJ,EAASE,EACbG,EAAIJ,EAASC,EACnB,OAAOI,EAAcF,EAAGC,EAAGP,EAAKC,CAAa,CAC/C,CA8BO,MAAMQ,UAAiBC,CAAgB,CAe5C,eACKC,EAGH,CACA,MAAA,EAnBFC,EAAA,6BACAA,EAAA,6BACAA,EAAA,2BACAA,EAAA,4BACAA,EAAA,6BACAA,EAAA,iBACAA,EAAA,oBACAA,EAAA,YACAA,EAAA,mBACAA,EAAA,uBACAA,EAAA,cACAA,EAAA,cACAA,EAAA,oBACSA,EAAA,kBAOP,KAAK,qBAAuB,EAC5B,KAAK,oBAAsB,GAC3B,KAAK,qBAAuBC,EAAmB,MAAM,EACrD,KAAK,qBAAuB,GAC5B,KAAK,UAAY,EACjB,KAAK,QAAU,EACf,KAAK,WAAa,EAClB,KAAK,eAAiB,CAAA,EACtB,KAAK,MAAQ,CAAA,EACb,KAAK,MAAQ,EACb,KAAK,YAAc,QACf,MAAM,QAAQF,EAAO,CAAC,CAAC,GAEzB,KAAK,YAAcA,EAAO,CAAC,EAAE,IAAKG,GAChCN,EAAcM,EAAG,EAAGA,EAAG,EAAGA,EAAG,IAAKA,EAAG,aAAa,CAAA,EAEhDH,EAAO,CAAC,IACV,KAAK,MAAQE,EAAmB,OAAOF,EAAO,CAAC,CAAC,CAAC,EACjD,KAAK,YAAc,OAAOA,EAAO,CAAC,CAAC,GAEjCA,EAAO,CAAC,EACV,KAAK,qBAAuBE,EAAmB,OAAOF,EAAO,CAAC,CAAC,CAAC,EAEhE,KAAK,qBAAuBE,EAAmB,MAAM,EAEnDF,EAAO,CAAC,GACV,KAAK,mBAAqBE,EAAmB,OAAOF,EAAO,CAAC,CAAC,CAAC,EAC9D,KAAK,SAAW,KAEhB,KAAK,mBAAqBE,EAAmB,OAAO,EACpD,KAAK,SAAW,IAElB,KAAK,IAAM,KAAK,YAAY,IAAKC,GAAOA,EAAG,GAAG,EAAE,KAAK,EAAE,IAEnD,OAAOH,EAAOA,EAAO,OAAS,CAAC,GAAM,WACvC,KAAK,MAAQE,EAAmB,OAAOF,EAAOA,EAAO,OAAS,CAAC,CAAC,CAAC,EACjE,KAAK,YAAc,OAAOA,EAAOA,EAAO,OAAS,CAAC,CAAC,EACnDA,EAAO,OAAOA,EAAO,OAAS,EAAG,CAAC,GAEpC,KAAK,YAAcA,EAAO,OAAQG,GAAOA,aAAcC,CAAa,EACpE,KAAK,IAAM,KAAK,YAAY,IAAKD,GAAOA,EAAG,GAAG,EAAE,KAAK,EAAE,EACvD,KAAK,qBAAuBD,EAAmB,MAAM,EACrD,KAAK,mBAAqBA,EAAmB,MAAM,EACnD,KAAK,SAAW,IAElB,IAAIG,EAAO,IACPC,EAAO,KACPC,EAAO,IACPC,EAAO,KACX,UAAWC,KAAW,KAAK,YACrBA,EAAQ,YAAc,SACxB,OAAO,OAAO,+BAAgC,CAAE,GAAGT,EAAQ,EAC7DK,EAAO,KAAK,IAAIA,EAAMI,EAAQ,CAAC,EAC/BH,EAAO,KAAK,IAAIA,EAAMG,EAAQ,CAAC,EAC/BF,EAAO,KAAK,IAAIA,EAAME,EAAQ,CAAC,EAC/BD,EAAO,KAAK,IAAIA,EAAMC,EAAQ,CAAC,EAEjC,KAAK,SAAW,CAACJ,EAAME,EAAMD,EAAME,CAAI,EACvC,IAAIxB,EAAI,EACR,QAAS0B,EAAI,EAAGA,EAAI,KAAK,YAAY,OAAQA,IAC3C1B,GAAK2B,EACH,KAAK,YAAYD,CAAC,EAClB,KAAK,aAAaA,EAAI,GAAK,KAAK,YAAY,MAAM,CAAA,EAGtD,KAAK,UAAY1B,CACnB,CAEA,UAAU4B,EAAe,CACvB,IAAIC,EAAQ,GACZ,UAAWnB,KAAS,KAAK,YACvBmB,GAAS,GAAGnB,EAAM,KAAKkB,CAAK,CAAC,IAAIlB,EAAM,KAAKkB,CAAK,CAAC,IAEpD,OAAOC,CACT,CAEA,IAAI,MAAO,CACT,OAAI,KAAK,MAAM,SAAW,IACxB,KAAK,MAAQC,EAAoB,IAAI,GAEhC,KAAK,KACd,CAEA,IAAI,eAAgB,CAClB,GAAI,KAAK,eAAe,SAAW,EAAG,CACpC,MAAMC,EAAmBC,EAAO,KAAK,IAAI,EACzC,KAAK,eAAiB,CAAA,EACtB,QAASN,EAAI,EAAGA,EAAIK,EAAiB,OAAQL,GAAK,EAChD,KAAK,eAAe,KAAK,CACvBb,EACE,KAAK,KAAKkB,EAAiBL,CAAC,EAAI,CAAC,EACjC,KAAK,KAAKK,EAAiBL,CAAC,EAAI,EAAI,CAAC,CAAA,EAEvCb,EACE,KAAK,KAAKkB,EAAiBL,EAAI,CAAC,EAAI,CAAC,EACrC,KAAK,KAAKK,EAAiBL,EAAI,CAAC,EAAI,EAAI,CAAC,CAAA,EAE3Cb,EACE,KAAK,KAAKkB,EAAiBL,EAAI,CAAC,EAAI,CAAC,EACrC,KAAK,KAAKK,EAAiBL,EAAI,CAAC,EAAI,EAAI,CAAC,CAAA,CAC3C,CACD,CAEL,CACA,OAAO,KAAK,cACd,CAEA,IAAI,MAAO,CACT,GAAI,KAAK,QAAU,EAAG,CACpB,MAAMO,EAAY,KAAK,cACvB,KAAK,MAAQ,EACb,QAASP,EAAI,EAAGA,EAAIO,EAAU,OAAQP,IACpC,KAAK,OAAS,OAAO3B,EAAamC,EAASD,EAAUP,CAAC,CAAC,CAAC,CAAC,CAE7D,CACA,OAAO,KAAK,KACd,CAEA,IAAIE,EAAe,CAOjB,OANI,KAAK,YAAc,IACrB,KAAK,OAAS,kBAAkB,KAAK,SAAS,MAE5C,KAAK,UAAY,IACnB,KAAK,OAAS,oBAAoB,KAAK,OAAO,MAExC,KAAK,WAAA,CACX,IAAK,GACH,KAAK,OAAS,4BACd,MACF,IAAK,GACH,KAAK,OAAS,2BACd,MACF,IAAK,GACH,KAAK,OAAS,gCACd,MACF,IAAK,GACH,KAAK,OAAS,2BACd,MACF,IAAK,GACH,KAAK,OAAS,2BACd,KAAA,CAGJ,OAAI,KAAK,UACH,KAAK,qBAAqB,OAAS,IACrC,KAAK,qBAAuBV,EAAmB,MAAM,GAGrDiB,EAAQ,CACN,MAAO,OAAO,KAAK,QAAQ,EAC3B,GAAI,OAAO,KAAK,EAAE,EAClB,oBAAqB,KAAK,oBAC1B,qBAAsB,KAAK,qBAC3B,mBAAoB,KAAK,mBAAmB,CAAC,GAAK,QAClD,qBAAsB,KAAK,qBAAqB,CAAC,EACjD,qBAAsB,KAAK,oBAAA,CAC5B,EACD,oBAAoB,KAAK,UAAUP,CAAK,CAAC,aAAa,KAAK,MAAM,CAAC,CAAC,KAAK,KAAK,KAAK,QAAQ,KAAK,EAAE,uBAAuB,KAAK,EAAE,UAI/H,KAAK,qBAAqB,CAAC,IAAM,IACjC,KAAK,qBAAqB,CAAC,IAAM,OAEjC,KAAK,OAAS,iBAEd,KAAK,OAAS,UAAU,KAAK,qBAAqB,CAAC,CAAC,KACpD,KAAK,OAAS,kBAAkB,KAAK,oBAAoB,MAEvD,KAAK,UAAY,IACnB,KAAK,OAAS,oBAAoB,KAAK,OAAO,MAEzC,oBAAoB,KAAK,UAAUA,CAAK,CAAC,aAAa,KAAK,MAAM,CAAC,CAAC,KAAK,KAAK,KAAK,QAAQ,KAAK,EAAE,OAE5G,CAEA,MAAO,CACL,MAAMQ,EAAiB,CAAA,EAOvB,OANI,KAAK,MAAM,CAAC,EAAE,OAAS,GAAK,KAAK,MAAM,CAAC,IAAM,SAChDA,EAAe,KAAK,SAAS,KAAK,MAAM,CAAC,CAAC,EAAE,EAE1C,KAAK,YAAc,GACrBA,EAAe,KAAK,gBAAgB,KAAK,SAAS,EAAE,EAE9C,KAAK,WAAA,CACX,IAAK,GACHA,EAAe,KAAK,YAAY,EAChC,MACF,IAAK,GACHA,EAAe,KAAK,wBAAwB,EAC5C,MACF,IAAK,GACHA,EAAe,KAAK,gBAAgB,EACpC,MACF,IAAK,GACHA,EAAe,KAAK,UAAU,EAC9B,MACF,IAAK,GACHA,EAAe,KAAK,UAAU,EAC9B,KAAA,CAEA,KAAK,UAAY,GACnBA,EAAe,KAAK,WAAW,KAAK,OAAO,EAAE,EAI7C,KAAK,qBAAqB,CAAC,IAAM,IACjC,KAAK,qBAAqB,CAAC,IAAM,QAEjCA,EAAe,KACb,2BAA2B,KAAK,qBAAqB,CAAC,CAAC,GAAG,KAAK,uBAAyB,EAAI,eAAiB,KAAK,qBAAuB,EAAE,GAAA,EAI3I,KAAK,WAAU,KAAK,SAAW,UAC/B,KAAK,UAAY,MAAQ,OAAO,KAAK,UAAa,UACpDA,EAAe,KACbD,EAAQ,CACN,MAAO,KAAK,SACZ,GAAI,OAAO,KAAK,EAAE,EAClB,oBAAqB,KAAK,oBAC1B,mBAAoB,KAAK,mBAAmB,CAAC,EAC7C,qBAAsB,KAAK,qBAAqB,CAAC,EACjD,qBAAsB,KAAK,oBAAA,CAC5B,CAAA,EAGL,IAAIE,EAAc,GACdD,EAAe,OAAS,IAC1BC,EAAc,IAAMD,EAAe,KAAK,GAAG,EAAI,KAGjD,IAAIE,EAAW,GAEf,UAAW5B,KAAS,KAAK,YACvB4B,GAAY,IAAIC,EAAQ7B,EAAM,CAAC,CAAC,IAAI6B,EAAQ7B,EAAM,CAAC,CAAC,MAItD,MAFc,SAAS2B,CAAW,IAAIC,CAAQ,QAGhD,CAEA,MAAMV,EAAeY,EAAa,CAChC,IAAIC,EAAO,GACPC,EACAzC,EAAGC,EACP,QAASyC,EAAI,EAAGA,GAAK,KAAK,YAAY,OAAQA,IAC5CzC,EAAI,KAAK,YAAYyC,EAAI,KAAK,YAAY,MAAM,EAChD1C,EAAI,KAAK,YAAY0C,EAAI,CAAC,EAC1BD,EAAiBE,EAAQ3C,EAAGC,EAAG,KAAK,WAAW,EAC/CwC,EAAe,UAAY,KAAK,UAChCA,EAAe,QAAU,KAAK,QAC9BD,GAAQC,EAAe,MAAMd,EAAOY,CAAG,EAEzC,OAAOC,CACT,CAEA,OAAOD,EAAa,CAClB,IAAIC,EAAO,GACPC,EACAzC,EAAGC,EACP,QAASyC,EAAI,EAAGA,GAAK,KAAK,YAAY,OAAQA,IAC5CzC,EAAI,KAAK,YAAYyC,EAAI,KAAK,YAAY,MAAM,EAChD1C,EAAI,KAAK,YAAY0C,EAAI,CAAC,EAC1BD,EAAiBE,EAAQ3C,EAAGC,EAAG,KAAK,WAAW,EAC/CwC,EAAe,UAAY,KAAK,UAChCA,EAAe,QAAU,KAAK,QAC9BD,GAAQ,IAAOC,EAAe,OAAOF,CAAG,EAAI;AAAA,EAE9C,OAAOC,CACT,CACF,CA0BO,SAASP,KACXW,EAGH,CACA,OAAO,IAAI/B,EAAS,GAAG+B,CAAI,CAC7B,CASO,SAASC,KACXD,EACwB,CAC3B,IAAIF,EAAI,GAKR,GAJI,OAAOE,EAAKA,EAAK,OAAS,CAAC,GAAM,WACnCF,EAAI,OAAOE,EAAKA,EAAK,OAAS,CAAC,CAAC,EAChCA,EAAK,OAAOA,EAAK,OAAS,EAAG,CAAC,GAE5B,CAACE,EAAkBF,CAAI,EACzB,cAAO,OACL,wEACA,CAAE,KAAAA,CAAA,CAAK,EAEF,CAACX,EAAA,EAAYc,EAAcd,EAAA,CAAU,CAAC,EAE/C,MAAMlC,EAAIkC,EAAS,GAAGW,CAAI,EAC1B,IAAIxC,EAAM,GACVwC,EAAK,QAAS1B,GAAsB,CAClCd,GAAOc,EAAG,IAAM,GAClB,CAAC,EACDd,EAAMA,EAAI,UAAU,EAAGA,EAAI,OAAS,CAAC,EACrC,MAAM4C,EAAUD,EAAchD,EAAGK,EAAKsC,CAAC,EACvC,OAAAM,EAAQ,SAAW,CAAC,EAAG,EAAG,EAAG,CAAC,EAC9BA,EAAQ,SAAS,CAAC,EAAIjD,EAAE,SAAS,CAAC,EAAI,EAAI2C,EAC1CM,EAAQ,SAAS,CAAC,EAAIjD,EAAE,SAAS,CAAC,EAAI,EAAI2C,EAC1CM,EAAQ,SAAS,CAAC,EAAIjD,EAAE,SAAS,CAAC,EAAI,EAAI2C,EAC1CM,EAAQ,SAAS,CAAC,EAAIjD,EAAE,SAAS,CAAC,EAAI,EAAI2C,EACnC,CAAC3C,EAAGiD,CAAO,CACpB,CAQO,SAASC,EAAgBlD,EAAamD,EAAyB,CACpEA,EACE,OAAOA,GAAS,UACZA,EAAK,SAAS,GAAG,EACfA,EAAK,MAAM,GAAG,EAEhBA,EACN,QAASzB,EAAI,EAAGA,EAAI1B,EAAE,YAAY,OAAQ0B,IACpCyB,EAAKzB,CAAC,IAAM,SACd1B,EAAE,YAAY0B,CAAC,EAAE,IAAMyB,EAAKzB,CAAC,EAGnC,CAOO,SAASI,EAAoB9B,EAAa,CAC/C,MAAMoD,EAAY,CAAA,EAClB,QAAS1B,EAAI,EAAGA,EAAI1B,EAAE,YAAY,OAAQ0B,IACxC0B,EAAU,KAAKpD,EAAE,YAAY0B,CAAC,EAAE,EAAG1B,EAAE,YAAY0B,CAAC,EAAE,CAAC,EAEvD,OAAO0B,CACT,CAqLO,MAAMC,UAAsBtC,CAAgB,CAGjD,YAAYf,EAAaK,EAAM,GAAIsC,EAAI,GAAKW,EAAQ,QAASC,EAAO,EAAG,CACrE,MAAA,EAHFtC,EAAA,aACAA,EAAA,aAGE,KAAK,KAAOjB,EACZ,KAAK,KAAO2C,EACZ,KAAK,OAAS,CAAA,EACd,MAAMQ,EAAO9C,EAAI,SAAS,GAAG,EAAIA,EAAI,MAAM,GAAG,EAAIA,EAClD,QAASqB,EAAI,EAAGA,EAAI1B,EAAE,YAAY,OAAQ0B,IACpCyB,EAAK,OAAS,IAAGnD,EAAE,YAAY0B,CAAC,EAAE,IAAMyB,EAAKzB,CAAC,GAEpD1B,EAAE,IAAMA,EAAE,YAAY,IAAKmB,GAAOA,EAAG,GAAG,EAAE,KAAK,EAAE,EACjD,MAAMqC,EAAIpD,EAAWJ,CAAC,EACtB,IAAIyD,EAAO,IACPC,EAAO,KACPC,EAAO,IACPC,EAAO,KACX,UAAWC,KAAM7D,EAAE,YAAa,CAC9B,MAAM8D,EAAIC,EACRP,EACAK,EACAlC,EAAS6B,EAAGK,CAAE,GACXG,EAAQ,OAAUrB,EAAI,GAAMqB,EAAQ,YAAcrB,EAAIqB,EAAQ,MAAA,EAEnEF,EAAE,cAAgB,SAClB,KAAK,OAAO,KAAKG,EAAcJ,EAAG,IAAKC,EAAG,EAAGR,EAAOC,EAAM,SAAU,EAAI,CAAC,EACzEE,EAAO,KAAK,IAAIA,EAAMK,EAAE,EAAI,EAAG,EAC/BJ,EAAO,KAAK,IAAIA,EAAMI,EAAE,EAAI,EAAG,EAC/BH,EAAO,KAAK,IAAIA,EAAMG,EAAE,EAAI,EAAG,EAC/BF,EAAO,KAAK,IAAIA,EAAME,EAAE,EAAI,EAAG,CACjC,CACA,KAAK,SAAW,CAACL,EAAME,EAAMD,EAAME,CAAI,CACzC,CAEA,IAAIhC,EAAe,CACjB,IAAIa,EAAO,GACX,GAAI,KAAK,QAAU,KAAM,OAAOA,EAChC,UAAWyB,KAAS,KAAK,OACvBzB,GAAQ;AAAA,GAASyB,EAAM,IAAItC,CAAK,EAElC,OAAOa,CACT,CAEA,MAAO,CACL,IAAIA,EAAO,GACX,GAAI,KAAK,QAAU,KAAM,OAAOA,EAChC,UAAWyB,KAAS,KAAK,OACvBzB,GAAQ;AAAA,GAASyB,EAAM,KAAA,EAEzB,OAAOzB,CACT,CACF,CAEO,SAASO,EACdhD,EACAK,EAAM,GACNsC,EAAI,GACJW,EAAQ,QACRC,EAAO,EACP,CACA,OAAO,IAAIF,EAAcrD,EAAGK,EAAKsC,EAAGW,EAAOC,CAAI,CACjD"}