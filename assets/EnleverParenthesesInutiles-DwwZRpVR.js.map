{"version":3,"file":"EnleverParenthesesInutiles-DwwZRpVR.js","sources":["../../src/lib/mathFonctions/EnleverParenthesesInutiles.ts"],"sourcesContent":["import { ComputeEngine, type Expression } from '@cortex-js/compute-engine'\nconst ce = new ComputeEngine()\n\n/**\n * ðŸ”¹ Supprime rÃ©cursivement les \"Delimiter\" dans le MathJSON\n */\nfunction stripDelimiter(node: Expression): Expression {\n  if (!Array.isArray(node)) return node\n\n  const arr = node as [string, ...Expression[]]\n  const op = arr[0]\n\n  if (op === 'Delimiter') {\n    const inner = arr.length === 1 ? arr[0] : arr[1]\n\n    if (Array.isArray(inner)) {\n      const innerOp = inner[0]\n      // âš™ï¸ On ne garde les parenthÃ¨ses que si le contenu est Add/Subtract\n      if (innerOp === 'Add' || innerOp === 'Subtract') {\n        return ['Delimiter', stripDelimiter(inner)] as Expression\n      }\n      // Sinon, on retire complÃ¨tement les parenthÃ¨ses\n      return stripDelimiter(inner)\n    }\n    return inner\n  }\n\n  const rest = arr.slice(1).map((x) => stripDelimiter(x as Expression))\n  return [op, ...rest] as Expression\n}\n\n/**\n * ðŸ”¹ SÃ©rialisation manuelle MathJSON â†’ LaTeX prÃ©servant lâ€™ordre et les signes\n */\nfunction mathJsonToLatex(node: Expression): string {\n  const isArray = Array.isArray\n  const getOp = (n: Expression) =>\n    isArray(n) && typeof n[0] === 'string' ? n[0] : null\n\n  function toLatex(n: Expression): string {\n    if (!isArray(n)) return String(n)\n\n    const op = n[0] as string\n    const args = n.slice(1) as Expression[]\n\n    switch (op) {\n      //\n      // ðŸ”¹ PRIMITIFS\n      //\n      case 'Number':\n      case 'Real':\n      case 'Integer':\n      case 'String':\n      case 'Symbol':\n        return String(args[0])\n\n      //\n      // ðŸ”¹ NÃ‰GATION\n      //\n      case 'Negate': {\n        const inner = args[0]\n        const innerOp = getOp(inner)\n        const latexInner = toLatex(inner)\n        // On parenthÃ¨se seulement si nÃ©cessaire\n        if (innerOp === 'Add' || innerOp === 'Subtract')\n          return `-(${latexInner})`\n        return `-${latexInner}`\n      }\n\n      //\n      // ðŸ”¹ ADDITION / SOUSTRACTION\n      //\n      case 'Add':\n        return args.map(toLatex).join('+')\n\n      case 'Subtract':\n        if (args.length === 1) return '-' + toLatex(args[0])\n        return args\n          .map((a, i) => (i === 0 ? toLatex(a) : `-${toLatex(a)}`))\n          .join('')\n\n      //\n      // ðŸ”¹ MULTIPLICATION\n      //\n      case 'Multiply': {\n        const parts = args.map((a, idx) => {\n          const opA = getOp(a)\n\n          // ðŸ”¸ 1. Nombre nÃ©gatif explicite\n          if (\n            Array.isArray(a) &&\n            a[0] === 'Number' &&\n            typeof a[1] === 'number' &&\n            a[1] < 0\n          ) {\n            const absVal = Math.abs(a[1])\n            return idx === 0 ? `-${absVal}` : `(-${absVal})`\n          }\n\n          // ðŸ”¸ 2. Negate(...)\n          if (Array.isArray(a) && a[0] === 'Negate') {\n            const inner = a[1]\n            const latexInner = toLatex(inner)\n            return idx === 0 ? `-${latexInner}` : `(-${latexInner})`\n          }\n\n          // ðŸ”¸ 3. Add/Subtract â†’ toujours parenthÃ¨ses\n          if (opA === 'Add' || opA === 'Subtract') {\n            return `(${toLatex(a)})`\n          }\n\n          // ðŸ”¸ 4. Divide â†’ parenthÃ¨ses si non premier facteur\n          if (opA === 'Divide' && idx > 0) {\n            return `(${toLatex(a)})`\n          }\n\n          // ðŸ”¸ 5. Cas normal\n          return toLatex(a)\n        })\n\n        return parts.join('\\\\times')\n      }\n\n      //\n      // ðŸ”¹ DIVISION (prÃ©serve \\div)\n      //\n      case 'Divide': {\n        const left = args[0]\n        const right = args[1]\n        const leftOp = getOp(left)\n        const rightOp = getOp(right)\n\n        const leftLatex =\n          leftOp === 'Add' || leftOp === 'Subtract'\n            ? `(${toLatex(left)})`\n            : toLatex(left)\n\n        let rightLatex = toLatex(right)\n\n        // dÃ©nominateur Add/Subtract â†’ parenthÃ¨ses\n        if (rightOp === 'Add' || rightOp === 'Subtract') {\n          rightLatex = `(${rightLatex})`\n        }\n\n        // dÃ©nominateur nÃ©gatif explicite â†’ parenthÃ¨ses aussi\n        if (\n          rightOp === 'Negate' ||\n          (isArray(right) &&\n            right[0] === 'Number' &&\n            typeof right[1] === 'number' &&\n            right[1] < 0)\n        ) {\n          rightLatex = `(${rightLatex})`\n        }\n\n        return `${leftLatex}\\\\div${rightLatex}`\n      }\n\n      //\n      // ðŸ”¹ FRACTION (vraies \\frac / \\dfrac)\n      //\n      case 'Frac': {\n        const num = args[0]\n        const den = args[1]\n        return `\\\\frac{${toLatex(num)}}{${toLatex(den)}}`\n      }\n\n      //\n      // ðŸ”¹ PUISSANCE\n      //\n      case 'Power': {\n        const base = toLatex(args[0])\n        const exp = toLatex(args[1])\n        return `${base}^{${exp}}`\n      }\n\n      //\n      // ðŸ”¹ DELIMITER\n      //\n      case 'Delimiter': {\n        // le contenu est souvent Ã  arg[1] ou arg[0]\n        const inner = args.length === 1 ? args[0] : (args[1] ?? args[0])\n        // supprime complÃ¨tement le mot-clÃ© Delimiter, garde les parenthÃ¨ses normales\n        return `(${toLatex(inner)})`\n      }\n\n      //\n      // ðŸ”¹ PAR DÃ‰FAUT\n      //\n      default: {\n        const name = op.toLowerCase()\n        const known: Record<string, string> = {\n          sin: '\\\\sin',\n          cos: '\\\\cos',\n          tan: '\\\\tan',\n        }\n        if (known[name])\n          return `${known[name]}\\\\left(${args.map(toLatex).join(',')}\\\\right)`\n        return `${op}\\\\left(${args.map(toLatex).join(',')}\\\\right)`\n      }\n    }\n  }\n\n  return toLatex(node)\n}\n\n/**\n * ðŸ”¹ Transforme certaines divisions en vraies fractions \"Frac\"\n * (quand l'entrÃ©e d'origine contenait \\frac ou \\dfrac)\n */\nfunction restoreFracNodes(\n  node: Expression,\n  count: number,\n): { node: Expression; used: number } {\n  if (!Array.isArray(node)) return { node, used: 0 }\n  const [op, ...args] = node\n  if (op === 'Divide' && count > 0) {\n    const [num, den] = args\n    return { node: ['Frac', num, den], used: 1 }\n  }\n  let used = 0\n  const newArgs = args.map((a) => {\n    const res = restoreFracNodes(a as Expression, count - used)\n    used += res.used\n    return res.node\n  })\n  return { node: [op, ...newArgs] as Expression, used }\n}\n\n/**\n * ðŸ§¹ deparenthise()\n * Nettoie une expression LaTeX sans changer les opÃ©rateurs d'origine.\n */\nexport function deparenthise(latexIn: string): string {\n  // Comptage des \\frac et \\dfrac\n  const dfracCount = (latexIn.match(/\\\\dfrac\\b/g) || []).length\n  const fracCount = (latexIn.match(/\\\\frac\\b/g) || []).length + dfracCount\n\n  // Normalisation temporaire : \\dfrac â†’ \\frac pour Compute Engine\n  const normalized = latexIn.replace(/\\\\dfrac\\b/g, '\\\\frac')\n\n  const boxed = ce.parse(normalized, { canonical: false })\n  const mathJson = boxed.json as Expression\n\n  // Nettoyage\n  const stripped = stripDelimiter(mathJson)\n\n  // Restauration des \"Frac\" Ã  partir des Divide\n  const restored = restoreFracNodes(stripped, fracCount).node\n\n  // Conversion LaTeX\n  let result = mathJsonToLatex(restored)\n\n  // Restauration des \\dfrac (si prÃ©sents en tÃªte)\n  if (dfracCount > 0) {\n    let replaced = 0\n    result = result.replace(/\\\\frac\\{/g, () => {\n      replaced++\n      return replaced <= dfracCount ? '\\\\dfrac{' : '\\\\frac{'\n    })\n  }\n\n  return result\n}\n"],"names":["ce","ComputeEngine","stripDelimiter","node","arr","op","inner","innerOp","rest","x","mathJsonToLatex","isArray","getOp","n","toLatex","args","latexInner","a","i","idx","opA","absVal","left","right","leftOp","rightOp","leftLatex","rightLatex","num","den","base","exp","name","known","restoreFracNodes","count","used","newArgs","res","deparenthise","latexIn","dfracCount","fracCount","normalized","mathJson","stripped","restored","result","replaced"],"mappings":"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"}