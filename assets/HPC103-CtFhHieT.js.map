{"version":3,"file":"HPC103-CtFhHieT.js","sources":["../../src/exercices/HP/HPC103.js"],"sourcesContent":["import { index, range } from 'mathjs'\nimport { matrice } from '../../lib/mathFonctions/Matrice'\nimport { choice } from '../../lib/outils/arrayOutils'\nimport { ecritureParentheseSiMoins } from '../../lib/outils/ecritures'\nimport { listeQuestionsToContenu, randint } from '../../modules/outils'\nimport Exercice from '../Exercice'\n\nexport const titre = 'Produit de matrices'\n\n// Les exports suivants sont optionnels mais au moins la date de publication semble essentielle\nexport const dateDePublication = '25/10/2021' // La date de publication initiale au format 'jj/mm/aaaa' pour affichage temporaire d'un tag\nexport const dateDeModifImportante = '04/03/2025' // Une date de modification importante au format 'jj/mm/aaaa' pour affichage temporaire d'un tag\n\n/**\n * Description didactique de l'exercice\n * @author Maxime Nguyen\n * Référence HPC103\n * Multiplication de matrices : on teste les produits possibles ou non et on réalise le calcul.\n */\nexport const uuid = 'a868f'\nexport const ref = 'HPC103'\nexport const refs = {\n  'fr-fr': ['HPC103'],\n  'fr-ch': [],\n}\nexport default class nomExercice extends Exercice {\n  constructor() {\n    super()\n    this.titre = titre\n    this.consigne =\n      'On définit deux matrices $A$ et $B$. Si le produit $A \\\\times B$ est possible, effectuer le calcul. Faire de même pour $B \\\\times A$.'\n    this.nbQuestions = 3 // Nombre de questions par défaut\n    this.nbCols = 2 // Uniquement pour la sortie LaTeX\n    this.nbColsCorr = 2 // Uniquement pour la sortie LaTeX\n    this.tailleDiaporama = 3 // Pour les exercices chronométrés. 50 par défaut pour les exercices avec du texte\n    this.video = '' // Id YouTube ou url\n  }\n\n  nouvelleVersion() {\n    this.autoCorrection = []\n\n    for (\n      let i = 0, texte, texteCorr, cpt = 0;\n      i < this.nbQuestions && cpt < 50;\n\n    ) {\n      // Boucle principale où i+1 correspond au numéro de la question\n      const matrices = [] // vecteur qui stocke les matrices\n      const matricesprint = [] // vecteur qui stocke les matrices écrites en LaTeX\n      const nbmatrice = 2\n      let n = randint(1, 4)\n      let m = randint(1, 4)\n      while ((n === m) & (n === 1)) {\n        m = randint(2, 4)\n      }\n      const nblignes = [] // vecteur qui stocke le nombre de lignes de chaque matrice\n      nblignes.push(n)\n      const nbcolonnes = [] // vecteur qui stocke le nombre de colonnes de chaque matrice\n      nbcolonnes.push(m)\n      n = choice([m, m, m, 1, 2, 3, 4]) // on favorise la compatibilité de la deuxieme matrices\n      nblignes.push(n)\n      m = choice([n, n, n, 1, 2, 3, 4])\n      while ((n === m) & (n === 1)) {\n        m = choice([2, 3, 4])\n      }\n      nbcolonnes.push(m)\n      const texteligne = [] // texte pour la correction\n      const textecolonne = [] // texte pour la correction\n      for (let compteur = 0; compteur < nbmatrice; compteur++) {\n        let ligne\n        const table = []\n        n = nblignes[compteur]\n        if (n === 1) {\n          texteligne.push('$1$ ligne ')\n        } else {\n          texteligne.push(`$${n}$ lignes `)\n        }\n        m = nbcolonnes[compteur]\n        if (m === 1) {\n          textecolonne.push('$1$ colonne ')\n        } else {\n          textecolonne.push(`$${m}$ colonnes `)\n        }\n        for (let i = 0; i < n; i++) {\n          ligne = []\n          for (let j = 0; j < m; j++) {\n            const coef = choice([\n              -6, -5, -4, -3, -2, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,\n              1, 1, 2, 2, 2, 3, 3, 3, 4, 5, 6,\n            ])\n            ligne.push(coef)\n          }\n          table.push(ligne)\n        }\n        const maMatrice = matrice(table)\n        matrices.push(maMatrice)\n        const texMatrice = maMatrice.toTex()\n        matricesprint.push(texMatrice)\n      }\n\n      texte = `Soient $A=${matricesprint[0]}$ et $B = ${matricesprint[1]}$.` // Le LateX entre deux symboles $, les variables dans des ${ }\n      texteCorr =\n        'La matrice $A$ a ' + texteligne[0] + 'et ' + textecolonne[0] + '. '\n      texteCorr +=\n        'La matrice $B$ a ' + texteligne[1] + 'et ' + textecolonne[1] + '. '\n      if (nbcolonnes[0] === nblignes[1]) {\n        const produit = matrices[0].multiply(matrices[1])\n        const produitprint = produit.toTex()\n        texteCorr += `<br><br> Le produit $A \\\\times B$ est possible et c'est une matrice qui a ${nblignes[0]} lignes et ${nbcolonnes[1]} colonnes. `\n        texteCorr += `<br><br> $ \\\\begin{array}{rccl} && \\\\textcolor{blue}{${matricesprint[1]}}& =\\\\textcolor{blue}{B} \\\\\\\\ \\\\textcolor{red}{A} = &\\\\textcolor{red}{${matricesprint[0]}} & ${produitprint} & = AB \\\\end{array} $`\n        // texteCorr += `Par exemple, on obtient $${math.parse(matrices[0].subset(index(nblignes[0], range(0, nbcolonnes[0]))).toString()).toTex().replaceAll('bmatrix', 'pmatrix')} $ `\n        const l1 = matrices[0].subset(nblignes[0] - 1, range(0, nbcolonnes[0]))\n        const c1 = matrices[1].subset(range(0, nblignes[1]), nbcolonnes[1] - 1)\n        let detail = `c_{${nblignes[0]}, ${nbcolonnes[1]}}  = `\n        // Vérification si l1 est un nombre ou un objet sans dimension\n        if (\n          typeof l1 === 'number' ||\n          l1.size === undefined ||\n          l1.size()[0] === undefined\n        ) {\n          // Cas où l1 est un nombre scalaire\n          for (let i = 0; i < nbcolonnes[0]; i++) {\n            const valeurL1 = typeof l1 === 'number' ? l1 : l1.subset(0, 0)\n            const valeurC1 = typeof c1 === 'number' ? c1 : c1.subset(i, 0)\n            detail +=\n              '\\\\textcolor{red}{' +\n              ecritureParentheseSiMoins(valeurL1.toString()) +\n              '} \\\\times \\\\textcolor{blue}{' +\n              ecritureParentheseSiMoins(valeurC1.toString()) +\n              '}'\n            if (i < nbcolonnes[0] - 1) {\n              detail += '+'\n            } else {\n              detail += ' = '\n            }\n          }\n        } else {\n          // Cas normal où l1 est un vecteur ou une matrice\n          for (let i = 0; i < nbcolonnes[0]; i++) {\n            detail +=\n              '\\\\textcolor{red}{' +\n              ecritureParentheseSiMoins(l1.subset(0, i).toString()) +\n              '} \\\\times \\\\textcolor{blue}{' +\n              ecritureParentheseSiMoins(c1.subset(i, 0).toString()) +\n              '}'\n            if (i < nbcolonnes[0] - 1) {\n              detail += '+'\n            } else {\n              detail += ' = '\n            }\n          }\n        }\n        detail += `${produit.subset(nblignes[0] - 1, nbcolonnes[1] - 1)}`\n        texteCorr += `<br> Le détail du calcul de $c_{${nblignes[0]}, ${nbcolonnes[1]}}$ où $c_{${nblignes[0]}, ${nbcolonnes[1]}}$ est le coefficient de la $${nblignes[0]}$-ème ligne et de la $${nbcolonnes[1]}$-ème colonne de la matrice $C = AB$ donne : <br> $${detail}$.`\n        texteCorr += `<br> On trouve $A \\\\times B =  ${produitprint}$.`\n      } else {\n        texteCorr +=\n          \"<br><br> Le produit $A \\\\times B$ n'est pas possible car le nombre de colonnes de $A$ n'est pas égal au nombre de lignes de $B$.\"\n      }\n      if (nbcolonnes[1] === nblignes[0]) {\n        const produit = matrices[1].multiply(matrices[0])\n        const produitprint = produit.toTex()\n        texteCorr += `<br><br> Le produit $B \\\\times A$ est possible et c'est une matrice qui a ${nblignes[1]} lignes et ${nbcolonnes[0]} colonnes. `\n        texteCorr += `<br><br> $ \\\\begin{array}{rccl} && \\\\textcolor{red}{${matricesprint[0]}}& =\\\\textcolor{red}{A} \\\\\\\\ \\\\textcolor{blue}{B} = &\\\\textcolor{blue}{${matricesprint[1]}} & ${produitprint} & = BA \\\\end{array} $`\n        const l1 = matrices[1].subset(nblignes[1] - 1, range(0, nbcolonnes[1]))\n        const c1 = matrices[0].subset(range(0, nblignes[0]), nbcolonnes[0] - 1)\n        let detail = `c_{${nblignes[1]}, ${nbcolonnes[0]}} = `\n        // Vérification si l1 est un nombre ou un objet sans dimension\n        if (\n          typeof l1 === 'number' ||\n          l1.size === undefined ||\n          l1.size()[0] === undefined\n        ) {\n          // Cas où l1 est un nombre scalaire\n          for (let i = 0; i < nbcolonnes[1]; i++) {\n            const valeurL1 = typeof l1 === 'number' ? l1 : l1.subset(0, 0)\n            const valeurC1 = typeof c1 === 'number' ? c1 : c1.subset(i, 0)\n            detail +=\n              '\\\\textcolor{blue}{' +\n              ecritureParentheseSiMoins(valeurL1.toString()) +\n              '} \\\\times \\\\textcolor{red}{' +\n              ecritureParentheseSiMoins(valeurC1.toString()) +\n              '}'\n            if (i < nbcolonnes[1] - 1) {\n              detail += '+'\n            } else {\n              detail += ' = '\n            }\n          }\n        } else {\n          // Cas normal où l1 est un vecteur ou une matrice\n          for (let i = 0; i < nbcolonnes[1]; i++) {\n            detail +=\n              '\\\\textcolor{blue}{' +\n              ecritureParentheseSiMoins(l1.subset(index(0, i)).toString()) +\n              '} \\\\times \\\\textcolor{red}{' +\n              ecritureParentheseSiMoins(c1.subset(index(i, 0)).toString()) +\n              '}'\n            if (i < nbcolonnes[1] - 1) {\n              detail += '+'\n            } else {\n              detail += ' = '\n            }\n          }\n        }\n        detail += `${produit.subset(nblignes[1] - 1, nbcolonnes[0] - 1)}`\n        texteCorr += `<br> Le détail du calcul de $c_{${nblignes[1]}, ${nbcolonnes[0]}}$ où $c_{${nblignes[1]}, ${nbcolonnes[0]}}$ est le coefficient de la $${nblignes[1]}$-ème ligne et de la $${nbcolonnes[0]}$-ème colonne de la matrice $C = BA$ donne : <br> $${detail}$.`\n        texteCorr += `<br> On trouve $B \\\\times A =  ${produitprint}$.`\n      } else {\n        texteCorr +=\n          \"<br><br> Le produit $B \\\\times A$ n'est pas possible car le nombre de colonnes de $B$ n'est pas égal au nombre de lignes de $A$.\"\n      }\n      // Si la question n'a jamais été posée, on l'enregistre\n      if (this.questionJamaisPosee(i, matrices)) {\n        // <- laisser le i et ajouter toutes les variables qui rendent les exercices différents (par exemple a, b, c, d...)\n        this.listeQuestions.push(texte)\n        this.listeCorrections.push(texteCorr)\n        i++\n      }\n      cpt++\n    }\n    listeQuestionsToContenu(this) // On envoie l'exercice à la fonction de mise en page\n  }\n}\n"],"names":["titre","dateDePublication","dateDeModifImportante","uuid","ref","refs","nomExercice","Exercice","i","texte","texteCorr","cpt","matrices","matricesprint","n","randint","m","nblignes","nbcolonnes","choice","texteligne","textecolonne","compteur","ligne","table","j","coef","maMatrice","matrice","texMatrice","produit","produitprint","l1","range","c1","detail","valeurL1","valeurC1","ecritureParentheseSiMoins","index","listeQuestionsToContenu"],"mappings":"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"}