{"version":3,"file":"Labyrinthe-d92hqE0O.js","sources":["../../src/modules/Labyrinthe.ts"],"sourcesContent":["import { point } from '../lib/2d/PointAbstrait'\nimport { Segment, segment } from '../lib/2d/segmentsVecteurs'\nimport {\n  Latex2d,\n  latex2d,\n  TexteParPoint,\n  texteParPoint,\n  TexteParPointEchelle,\n  texteParPointEchelle,\n  texteParPositionEchelle,\n} from '../lib/2d/textes'\nimport { combinaisonListesSansChangerOrdre } from '../lib/outils/arrayOutils'\nimport { nombreAvecEspace } from '../lib/outils/texNombre'\nimport { runAStar } from './findPath'\nimport type FractionEtendue from './FractionEtendue'\nimport { randint } from './outils'\n\nexport type LabyrintheChemin = [number, number][] // Un chemin est un tableau de points [x, y] où x et y sont des entiers\n\n/**  Crée un ensemble de chemins possibles dans un labyrinthe. Cette fonction est à associer aux méthodes conçues pour.\n * @param {Object} parametres À saisir entre accolades\n * @param {number} [parametres.nbLignes = 3]\n * @param {number} [parametres.nbColonnes = 6]\n * @param {number} [parametres.scaleFigure = 1]\n * @author Jean-Claude Lhote & Eric Elter (améliorée par EE pour choisir le nombre de lignes et de colonnes)\n * @author MGu (pour la fonction runAStar) car si le tableau est trop grand, le cout de calcul est exponentiel donc remplacer par reunAStar qui est un algorithme de recherche de chemin\n * Publié le 6/12/2020 (Modifié le 05/10/2022)\n * @class\n */\n// JSDOC Validee par EE Septembre 2022\nexport class Labyrinthe {\n  niveau: number\n  murs2d: (Segment | TexteParPoint)[]\n  chemin2d: Segment[]\n  nombres2d: (Latex2d | TexteParPointEchelle)[]\n  choisitChemin: (niveau: number) => LabyrintheChemin\n  construitMurs: (\n    chemin: LabyrintheChemin,\n    taille?: number,\n  ) => (Segment | TexteParPoint)[]\n  traceChemin: (monchemin: LabyrintheChemin, color?: string) => Segment[]\n  placeNombres: (\n    monChemin: LabyrintheChemin,\n    bonnesReponses: (number | string | FractionEtendue)[],\n    mauvaisesReponses: (number | string | FractionEtendue)[],\n    taille: number,\n  ) => (TexteParPointEchelle | Latex2d)[]\n  constructor({ nbLignes = 3, nbColonnes = 6, scaleFigure = 1 } = {}) {\n    this.niveau = 1\n    this.murs2d = []\n    this.chemin2d = []\n    this.nombres2d = []\n\n    const paths = []\n    for (let i = 0; i < nbLignes; i++) {\n      for (let j = 0; j < nbLignes; j++) {\n        const path = runAStar(nbLignes, nbColonnes, i, 0, j, nbColonnes - 1)\n        paths.push(...path)\n      }\n    }\n\n    paths.sort((a, b) => b.length - a.length) // On trie les chemins du plus court au plus long...\n\n    // // Fonction qui permet de copier des tableaux\n    // function arrayCopy (arr) {\n    //   return JSON.parse(JSON.stringify(arr))\n    // }\n\n    // // Permet de tester si un tableau est contenu dans un autre.\n    // // tableauDansTableau([0, 1, 0, 0, 1, 1, 1, 0],[1, 1]) Permet de tester si [1, 1] est contenu dans [[0, 1], [0, 0], [1, 1], [1, 0]]\n    // function tableauDansTableau (gdTableau, petitTableau) {\n    //   let test = false\n    //   let k = 0\n    //   do {\n    //     if (gdTableau[k] === petitTableau[0] && gdTableau[k + 1] === petitTableau[1]) test = true\n    //     k++\n    //     k++\n    //   } while (!test && k < gdTableau.length)\n    //   return test\n    // }\n\n    // let cheminsEE = [[1, 0]] // [[colonne,ligne]]\n    // const casesVoisinesTableau = [[-1, 0], [0, 1], [1, 0], [0, -1]] // Nord ; Est ; Sud ; Ouest\n\n    // // Fonction récursive qui recherche tous les chemins possibles à partir du point de départ caseActuelle, des points déjà parcourus et avec l'indice du chemin actuel dans le tableau actuel\n    // function rechercheCheminsPossibles (caseActuelle, indiceCheminActuel, dejaParcourus) {\n    //   const casesPossibles = []\n    //   let prochaineCasePossible = []\n\n    //   for (const element of Visitables) {\n    //     prochaineCasePossible = [caseActuelle[0] + element[0], caseActuelle[1] + element[1]] // Test de l'ouest\n    //     if (prochaineCasePossible[0] === nbColonnes) { // On est arrivé\n    //       return [nbColonnes, prochaineCasePossible[1]]\n    //     } else if (!tableauDansTableau(dejaParcourus, prochaineCasePossible)) {\n    //       if (prochaineCasePossible[0] < nbColonnes + 1 && prochaineCasePossible[0] > 0 && prochaineCasePossible[1] < nbLignes && prochaineCasePossible[1] > -1) {\n    //         const casesVoisines = []\n    //         const elementPrecedent = [-1 * element[0], -1 * element[1]] // D'où vient la case actuelle ?\n    //         for (let k = 0; k < 4; k++) {\n    //           if (!(casesVoisinesTableau[k][0] === elementPrecedent[0] && casesVoisinesTableau[k][1] === elementPrecedent[1])) casesVoisines.push(casesVoisinesTableau[k])\n    //         }\n\n    //         let nonVoisin = true // Les cases voisines sont accessibles\n    //         for (const element2 of casesVoisines) { // Recherche si les cases voisines à la prochaine case possible n'ont pas déjà été parcourues.\n    //           nonVoisin = nonVoisin && !tableauDansTableau(dejaParcourus, [prochaineCasePossible[0] + element2[0], prochaineCasePossible[1] + element2[1]])\n    //         }\n    //         if (nonVoisin) casesPossibles.push(prochaineCasePossible) // Cette prochaine case possible est validée.\n    //       }\n    //     }\n    //   }\n    //   if (casesPossibles.length === 0) {\n    //     return [0, 0] // Case impossible, retour en arriere\n    //   } else {\n    //     let cheminAVenir\n    //     const tableauIndiceFuturChemin = []\n    //     for (let ee = casesPossibles.length - 1; ee > 0; ee--) { // Préparation à la création d'un nouveau chemin\n    //       cheminsEE.push([])\n    //       tableauIndiceFuturChemin[ee] = cheminsEE.length - 1\n    //     }\n    //     for (let ee = casesPossibles.length - 1; ee > 0; ee--) {\n    //       cheminsEE[tableauIndiceFuturChemin[ee]] = cheminsEE[indiceCheminActuel].concat(casesPossibles[ee]) // Le début du nouveau chemin correspond au chemin déjà en cours\n    //       cheminAVenir = rechercheCheminsPossibles(casesPossibles[ee], tableauIndiceFuturChemin[ee], dejaParcourus.concat(casesPossibles[ee]))\n    //       if (cheminAVenir !== undefined) {\n    //         cheminsEE[tableauIndiceFuturChemin[ee]].push(cheminAVenir[0])\n    //         cheminsEE[tableauIndiceFuturChemin[ee]].push(cheminAVenir[1])\n    //       }\n    //     }\n    //     cheminsEE[indiceCheminActuel].push(casesPossibles[0][0])\n    //     cheminsEE[indiceCheminActuel].push(casesPossibles[0][1])\n    //     const prochainChemin = rechercheCheminsPossibles(casesPossibles[0], indiceCheminActuel, dejaParcourus.concat(casesPossibles[0]))\n    //     if (prochainChemin !== undefined) {\n    //       cheminsEE[indiceCheminActuel].push(prochainChemin[0])\n    //       cheminsEE[indiceCheminActuel].push(prochainChemin[1])\n    //     }\n    //   }\n    // }\n\n    // // Fin de construction récursive de chemin\n\n    // let cheminDejaParcouru = [1, 0]\n    // const Visitables = [[1, 0], [0, -1], [-1, 0], [0, 1]] // Nord ; Est ; Sud ; Ouest\n    // cheminsEE[0].push(rechercheCheminsPossibles([1, 0], 0, cheminDejaParcouru))\n    // enleveElement(cheminsEE[0], undefined) // Obligé d'enlever un undefined qui traine sans savoir pourquoi.\n    // const cheminTableauSimple = [[]]\n    // cheminTableauSimple = arrayCopy(cheminsEE)\n\n    // for (let k = 1; k < nbLignes; k++) {\n    //   cheminsEE = [[1, k]]\n    //   cheminDejaParcouru = [1, k]\n    //   cheminsEE[0].push(rechercheCheminsPossibles([1, k], 0, cheminDejaParcouru))\n    //   enleveElement(cheminsEE[0], undefined) // Obligé d'enlever un undefined qui traine sans savoir pourquoi.\n    //   cheminTableauSimple = cheminTableauSimple.concat(cheminsEE)\n    // }\n\n    // for (let k = cheminTableauSimple.length - 1; k >= 0; k--) { // On élimine les voies sans issues, celles se terminant par 0, 0\n    //   if (cheminTableauSimple[k][cheminTableauSimple[k].length - 2] === 0) cheminTableauSimple.splice(k, 1)\n    // }\n    // cheminTableauSimple.sort((a, b) => b.length - a.length) // On trie les chemins du plus court au plus long...\n\n    // const chemins = []\n    // let elementchemin = []\n\n    // // Le passage ci-dessous est obligatoire pour passer d'un tableau 2d à un tableau 3d\n    // // afin d'être en adéquation avec la fonction Labyrinthe() Version 1\n\n    // for (let i = 0; i < cheminTableauSimple.length; i++) { // on double le nombre de chemins par Symétrie.\n    //   elementchemin = []\n    //   for (let j = 0; j < cheminTableauSimple[i].length / 2; j++) {\n    //     elementchemin.push([cheminTableauSimple[i][2 * j], cheminTableauSimple[i][2 * j + 1]])\n    //   }\n    //   chemins.push(elementchemin)\n    // }\n    // // Fin de construction de chemin (qui contient tous les chemins du labyrinthe)\n\n    // MGu on change de repère\n    const cheminsPaths: LabyrintheChemin[] = []\n    paths.forEach((path) => {\n      const che: LabyrintheChemin = []\n      path.forEach((point) => {\n        che.push([point.x + 1, nbLignes - point.y - 1])\n      })\n      cheminsPaths.push(che)\n    })\n    const chemins = cheminsPaths\n    // console.log('chemins', chemins)\n    const cheminTableauSimple = paths\n\n    // Gestion des vitesses : Escargot, ..., Guépard\n    let tableauDeVitesses = [] // Plus la vitesse est grande, moins le trajet est long\n    const vitessePetite = cheminTableauSimple[0].length\n    const vitesseGrande =\n      cheminTableauSimple[cheminTableauSimple.length - 1].length\n    const ecartVitesse = (vitessePetite - vitesseGrande) / 4\n    for (let k = 0; k < 4; k++) {\n      tableauDeVitesses.push(\n        cheminTableauSimple.findIndex(\n          (element) => element.length < vitessePetite - k * ecartVitesse,\n        ),\n      )\n    }\n    tableauDeVitesses[4] = cheminTableauSimple.length\n    tableauDeVitesses = tableauDeVitesses.map((element) => element - 1)\n\n    // Fin de la fonction Labytinthe()\n\n    // Mise en place des méthodes de cette fonction\n\n    /**\n     * Retourne un chemin en fonction du niveau de rapidité\n     * @memberof Labyrinthe\n     * @param {number} niveau Niveau de résolution du labyrinthe entre 1 (le plus lent) et 6 (le plus rapide).\n     * @example monCheminChoisi = laby.traceChemin(3) // Renvoie un chemin parmi tous ceux possibles, du labyrinthe laby, dont le niveau de rapidité est 3\n     * @author Jean-Claude Lhote (et EE pour la partie \"choix du nombre de lignes et de colonnes\")\n     * @return {Array.number[]}\n     */\n    // JSDOC Validee par EE Octobre 2022\n    this.choisitChemin = function (niveau: number): LabyrintheChemin {\n      let choixchemin\n      switch (niveau) {\n        case 1:\n          choixchemin = randint(0, tableauDeVitesses[0])\n          break\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n          choixchemin = randint(\n            tableauDeVitesses[niveau - 2] + 1,\n            tableauDeVitesses[niveau - 1],\n          )\n          break\n        case 6:\n          choixchemin = randint(0, cheminTableauSimple.length - 1)\n          break\n      }\n      if (typeof choixchemin === 'undefined') {\n        window.notify(\n          'choisitChemin(niveau) doit être appelé avec un niveau entre 1 et 6.',\n          { niveau },\n        )\n        return chemins[0] // On renvoie le premier chemin par défaut\n      }\n      return chemins[choixchemin]\n    }\n\n    /**\n     * Retourne un ensemble d'objets correspondant aux murs du labyrinthe, par rapport à un chemin choisi\n     * @memberof Labyrinthe\n     * @param {Array.number[]} chemin Un chemin choisi parmi tous les chemins possibles.\n     * @param {number} [taille = 1] Taille des éléments de départ et de sortie\n     * @example lesMursDeMonLabyrinthe = laby.construitMurs(monCheminChoisi)\n     * // Renvoie les murs du labyrinthe laby correspondants au chemin monCheminChoisi.\n     * // Penser à faire mathalea2d(param, lesMursDeMonLabyrinthe) ensuite\n     * @author Jean-Claude Lhote (et EE pour la partie \"choix du nombre de lignes et de colonnes\")\n     * @return {ObjecMathalea2d[]}\n     */\n    // JSDOC Validee par EE Octobre 2022\n    this.construitMurs = function (\n      chemin: LabyrintheChemin,\n      taille?: number,\n    ): (Segment | TexteParPoint)[] {\n      const objets = []\n      let s1\n      let s2\n      const choix = chemin[0][1]\n      for (let i = 0; i < nbColonnes; i++) {\n        // Construction des T supérieurs et inférieurs\n        // T inférieurs\n        s1 = segment(point(i * 3, 1), point(i * 3, 2))\n        s1.epaisseur = 2\n        objets.push(s1)\n        // T supérieurs\n        s2 = segment(point(i * 3, 1 + 3 * nbLignes), point(i * 3, 3 * nbLignes))\n        s2.epaisseur = 2\n        objets.push(s2)\n      }\n\n      // Construction du bord gauche entre le départ et le labyrinthe\n      s1 = segment(point(0, 1 + 3 * nbLignes), point(0, 3 + choix * 3))\n      s1.epaisseur = 3\n      objets.push(s1)\n      s1 = segment(point(0, 1), point(0, 2 + choix * 3))\n      s1.epaisseur = 3\n      objets.push(s1)\n\n      // Construction case départ\n      s1 = segment(point(-3, 1 + choix * 3), point(0, 1 + choix * 3), 'green')\n      s1.epaisseur = 3\n      objets.push(s1)\n      s1 = segment(point(-3, 1 + choix * 3), point(-3, 4 + choix * 3), 'green')\n      s1.epaisseur = 3\n      objets.push(s1)\n      s1 = segment(point(-3, 4 + choix * 3), point(0, 4 + choix * 3), 'green')\n      s1.epaisseur = 3\n      objets.push(s1)\n      objets.push(\n        texteParPoint(\n          'Départ',\n          point(-1.5, 2.5 + choix * 3),\n          0,\n          'blue',\n          taille,\n          'milieu',\n          false,\n        ),\n      )\n\n      // les croix centrales communes à A et B\n      for (let i = 1; i < nbColonnes; i++) {\n        for (let k = 0; k < nbLignes - 1; k++) {\n          s1 = segment(\n            point(i * 3, 5 + 3 * k),\n            point(i * 3, 3 + 3 * k),\n            'black',\n          )\n          s1.epaisseur = 2\n          s2 = segment(\n            point(i * 3 - 0.5, 4 + 3 * k),\n            point(i * 3 + 0.5, 4 + 3 * k),\n            'black',\n          )\n          s2.epaisseur = 2\n          objets.push(s2, s1)\n        }\n      }\n      // le pourtour commun\n      s1 = segment(\n        point(0, 1 + 3 * nbLignes),\n        point(3 * nbColonnes, 1 + 3 * nbLignes),\n      )\n      s1.epaisseur = 3\n      objets.push(s1)\n      s1 = segment(\n        point(3 * nbColonnes, 1 + 3 * nbLignes - 1),\n        point(3 * nbColonnes, 1 + 3 * nbLignes),\n      )\n      s1.epaisseur = 3\n      objets.push(s1)\n      s1 = segment(point(3 * nbColonnes, 1), point(3 * nbColonnes, 2))\n      s1.epaisseur = 3\n      objets.push(s1)\n      s1 = segment(point(0, 1), point(3 * nbColonnes, 1))\n      s1.epaisseur = 3\n      objets.push(s1)\n\n      // les sorties\n      // La partie verticale\n      for (let i = 0; i < nbLignes - 1; i++) {\n        s1 = segment(\n          point(3 * nbColonnes, 3 + i * 3),\n          point(3 * nbColonnes, 5 + i * 3),\n        )\n        s1.epaisseur = 3\n        objets.push(s1)\n      }\n      // La partie horizontale\n      for (let i = 0; i < nbLignes; i++) {\n        s1 = segment(\n          point(3 * nbColonnes, 2 + i * 3),\n          point(3 * nbColonnes + 2, 2 + i * 3),\n        )\n        s1.epaisseur = 3\n        s2 = segment(\n          point(3 * nbColonnes, 3 + i * 3),\n          point(3 * nbColonnes + 2, 3 + i * 3),\n        )\n        s2.epaisseur = 3\n        objets.push(s1, s2)\n      }\n      // Le texte\n      for (let i = 1; i <= nbLignes; i++) {\n        objets.push(\n          texteParPoint(\n            `Sortie ${i}`,\n            point(3 * nbColonnes + 1.5, 2.5 + 3 * nbLignes - 3 * i),\n            0,\n            'blue',\n            taille,\n            'milieu',\n            false,\n          ),\n        )\n      }\n      return objets\n    }\n\n    /**\n     * Retourne les traits signifiant le chemin correction\n     * @memberof Labyrinthe\n     * @param {Array.number[]} monchemin Un chemin choisi parmi tous les chemins possibles.\n     * @param {string} [color = 'brown'] Couleur du tracé de la correction : du type 'blue' ou du type '#f15929'\n     * @example laCorrectionDeMonLabyrinthe = laby.traceChemin(monCheminChoisi) // Renvoie les traits signifiant le chemin correction du labyrinthe laby correspondant au chemin monCheminChoisi\n     * @author Jean-Claude Lhote (et EE pour la partie \"choix du nombre de lignes et de colonnes\")\n     * @return {ObjecMathalea2d[]}\n     */\n    // JSDOC Validee par EE Octobre 2022\n    this.traceChemin = function (monchemin: LabyrintheChemin, color = 'brown') {\n      let y = monchemin[0][1]\n      let x = 0\n      const chemin2d = []\n      let s1\n      for (let j = 0; j < monchemin.length; j++) {\n        s1 = segment(\n          point(x * 3 - 1.5, y * 3 + 2.5),\n          point(monchemin[j][0] * 3 - 1.5, monchemin[j][1] * 3 + 2.5),\n          color,\n        )\n        s1.pointilles = 5\n        s1.stylePointilles = 2\n        s1.epaisseur = 5\n        s1.opacite = 0.3\n        chemin2d.push(s1)\n        x = monchemin[j][0]\n        y = monchemin[j][1]\n      }\n      s1 = segment(\n        point(x * 3 - 1.5, y * 3 + 2.5),\n        point(x * 3 + 1.5, y * 3 + 2.5),\n        color,\n      )\n      s1.pointilles = 5\n      s1.stylePointilles = 2\n      s1.epaisseur = 5\n      s1.opacite = 0.3\n      chemin2d.push(s1)\n      return chemin2d\n    }\n\n    /**\n     * Retourne la position convenable de tous les éléments (bons ou faux) du labyrinthe (nombre, texte, fraction)\n     * @memberof Labyrinthe\n     * @param {Array.number[]} monchemin Un chemin choisi parmi tous les chemins possibles.\n     * @param {number[]|string[]|Fraction[]} bonnesReponses Tableau de bonnes réponses\n     * @param {number[]|string[]|Fraction[]} mauvaisesReponses Tableau de mauvaises réponses\n     * @param {number} taille Taille des écritures dans les cases du labyrinthe\n     * @example aVotrePlace = laby.placeNombres(monCheminChoisi,reponsesOK,reponsesPasOK,1)\n     * // Place les bonnes (reponsesOK) et les mauvaises (reponsesPasOK) réponses dans les cases adéquates du labyrinthe laby correspondant au chemin monCheminChoisi\n     * @author Jean-Claude Lhote (et EE pour la partie \"choix du nombre de lignes et de colonnes\")\n     * @return {ObjecMathalea2d[]}\n     */\n    // JSDOC Validee par EE Octobre 2022\n    this.placeNombres = function (\n      monChemin: LabyrintheChemin,\n      bonnesReponses: (number | string | FractionEtendue)[],\n      mauvaisesReponses: (number | string | FractionEtendue)[],\n      taille: number,\n    ) {\n      bonnesReponses = combinaisonListesSansChangerOrdre(\n        bonnesReponses,\n        monChemin.length,\n      )\n      mauvaisesReponses = combinaisonListesSansChangerOrdre(\n        mauvaisesReponses,\n        nbColonnes * nbLignes - monChemin.length,\n      )\n      const objets = []\n      const nombres: [\n        number | string | FractionEtendue,\n        number | string | FractionEtendue,\n      ][] = []\n      let trouve\n      let indexBonnesRep = 0\n      let indexMauvaisesRep = 0\n\n      for (let a = 0; a < nbColonnes; a++) {\n        nombres.push([0, 0])\n      }\n      for (let a = 1; a < nbColonnes + 1; a++) {\n        for (let b = 0; b < nbLignes; b++) {\n          trouve = false\n          for (let k = 0; k < monChemin.length; k++) {\n            if (monChemin[k][0] === a && monChemin[k][1] === b) trouve = true\n          }\n          if (!trouve) {\n            nombres[a - 1][b] = mauvaisesReponses[indexMauvaisesRep]\n            indexMauvaisesRep++\n          } else {\n            nombres[a - 1][b] = bonnesReponses[indexBonnesRep]\n            indexBonnesRep++\n          }\n        }\n      }\n      for (let a = 1; a < nbColonnes + 1; a++) {\n        for (let b = 0; b < nbLignes; b++) {\n          const nombre = nombres[a - 1][b]\n          if (typeof nombre === 'number') {\n            objets.push(\n              texteParPointEchelle(\n                nombreAvecEspace(nombre),\n                point(-1.5 + a * 3, 2.5 + b * 3),\n                0,\n                'black',\n                taille,\n                'milieu',\n                true,\n                scaleFigure,\n              ),\n            )\n          } else if (typeof nombre === 'string') {\n            // écriture mode Maths\n            objets.push(\n              texteParPositionEchelle(\n                nombre,\n                -1.5 + a * 3,\n                2.5 + b * 3,\n                0,\n                'black',\n                taille,\n                'milieu',\n                true,\n                scaleFigure,\n              ),\n            )\n          } else {\n            objets.push(\n              latex2d(nombre.texFraction, -1.5 + a * 3, 2.5 + b * 3, {\n                color: 'black',\n                backgroundColor: 'white',\n                letterSize: 'scriptsize',\n              }),\n            )\n          }\n        }\n      }\n      return objets\n    }\n  }\n}\n\n/**  Crée un ensemble de chemins possibles dans un labyrinthe. Cette fonction est à associer aux méthodes conçues pour.\n * @param {Object} parametres À saisir entre accolades\n * @param {number} [parametres.nbLignes = 3]\n * @param {number} [parametres.nbColonnes = 6]\n * @param {number} [parametres.scaleFigure = 1]\n * @example laby = labyrinthe ({ nbLignes: 4, nbColonnes: 5 })\n * // Crée l'ensemble de chemins possibles dans un labyrinthe à 4 lignes et 5 colonnes\n * @author Jean-Claude Lhote & Eric Elter (améliorée par EE pour choisir le nombre de lignes et de colonnes)\n * @return {Labyrinthe}\n */\n// JSDOC Validee par EE Septembre 2022\nexport function labyrinthe({\n  nbLignes = 3,\n  nbColonnes = 6,\n  scaleFigure = 1,\n} = {}) {\n  return new Labyrinthe({ nbLignes, nbColonnes, scaleFigure })\n}\n"],"names":["Labyrinthe","nbLignes","nbColonnes","scaleFigure","__publicField","paths","i","j","path","runAStar","a","b","cheminsPaths","che","point","chemins","cheminTableauSimple","tableauDeVitesses","vitessePetite","vitesseGrande","ecartVitesse","k","element","niveau","choixchemin","randint","chemin","taille","objets","s1","s2","choix","segment","texteParPoint","monchemin","color","y","x","chemin2d","monChemin","bonnesReponses","mauvaisesReponses","combinaisonListesSansChangerOrdre","nombres","trouve","indexBonnesRep","indexMauvaisesRep","nombre","texteParPointEchelle","nombreAvecEspace","texteParPositionEchelle","latex2d","labyrinthe"],"mappings":"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"}