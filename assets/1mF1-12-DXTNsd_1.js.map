{"version":3,"file":"1mF1-12-DXTNsd_1.js","sources":["../../src/exercices/ch/1mF1-12.ts"],"sourcesContent":["import MonomePlusieursVariables from '../../lib/mathFonctions/MonomePlusieursVariables'\nimport PolynomePlusieursVariables from '../../lib/mathFonctions/PolynomePlusieursVariables'\nimport { combinaisonListes } from '../../lib/outils/arrayOutils'\nimport { miseEnEvidence } from '../../lib/outils/embellissements'\nimport EquationSecondDegre from '../../modules/EquationSecondDegre'\nimport FractionEtendue from '../../modules/FractionEtendue'\nimport {\n  gestionnaireFormulaireTexte,\n  listeQuestionsToContenu,\n  randint,\n} from '../../modules/outils'\nimport Exercice from '../Exercice'\nexport const titre =\n  \"Déterminer le domaine de définition d'une fonction inverse ou racine\"\nexport const interactifReady = false\nexport const interactifType = 'mathLive'\nexport const dateDePublication = '14/03/2025'\n/**\n * @author Nathan Scheinmann\n */\n\nexport const uuid = '6ea62'\nexport const refs = {\n  'fr-fr': [],\n  'fr-ch': ['1mF1-12'],\n}\nexport default class DomaineDeDefinition extends Exercice {\n  constructor() {\n    super()\n    this.consigne = ''\n    this.nbQuestions = 1\n    this.besoinFormulaireNumerique = [\n      'Type de questions',\n      8,\n      '1 : 1/q(x)\\n2 : p(x)/q(x)\\n3 : √p(x)\\n4 : √p(x)/q(x)\\n5 : p(x)/√q(x)\\n6 : √p(x)/√q(x)\\n7 : √p(x)+√q(x)\\n8 : Mélange',\n    ]\n    this.besoinFormulaire2Numerique = [\n      'Degrés des polynômes',\n      3,\n      '1 : 1er degré\\n2 : 2e degré\\n3 : Mélange',\n    ]\n    this.sup2 = 3\n    this.sup = 1\n  }\n\n  solutionEq(p: PolynomePlusieursVariables): FractionEtendue {\n    if (p.monomes.length === 1) {\n      return new FractionEtendue(0, 1)\n    } else {\n      const termConst = p.monomes.find(\n        (monome) => monome.degre === 0,\n      ) as MonomePlusieursVariables\n      const termLin = p.monomes.find(\n        (monome) => monome.degre === 1,\n      ) as MonomePlusieursVariables\n      return termConst.coefficient\n        .oppose()\n        .diviseFraction(termLin.coefficient)\n        .simplifie()\n    }\n  }\n\n  // Notation pour les différents intervalles:\n  // sqrt ['o','-infty','f',val], ['f',val,'o','+infty'] ['f',val,'f',val] ou [R,['o',val,'o',val]]\n  // 1/x [R,val]] ou [R,val1,val2]]\n  computeDomainePolynome(\n    type: string,\n    p: PolynomePlusieursVariables,\n    racinesP: FractionEtendue[],\n  ): string[][] {\n    if (type === 'sqrt') {\n      if (racinesP.length === 1) {\n        if (\n          p.monomes.find((monome) => monome.degre === 1)?.coefficient.signe ===\n          1\n        ) {\n          return [['f', racinesP[0].texFractionSimplifiee, 'o', '+infty']]\n        } else {\n          return [['o', '-infty', 'f', racinesP[0].texFractionSimplifiee]]\n        }\n      } else if (racinesP.length === 2) {\n        if (\n          p.monomes.find((monome) => monome.degre === 2)?.coefficient.signe ===\n          1\n        ) {\n          return [\n            ['o', '-infty', 'f', racinesP[0].texFractionSimplifiee],\n            ['f', racinesP[1].texFractionSimplifiee, 'o', '+infty'],\n          ]\n        } else if (\n          p.monomes.find((monome) => monome.degre === 2)?.coefficient.signe ===\n          -1\n        ) {\n          return [\n            [\n              'f',\n              racinesP[0].texFractionSimplifiee,\n              'f',\n              racinesP[1].texFractionSimplifiee,\n            ],\n          ]\n        }\n      }\n    } else if (type === 'invSqrt') {\n      if (racinesP.length === 1) {\n        if (\n          p.monomes.find((monome) => monome.degre === 1)?.coefficient.signe ===\n          1\n        ) {\n          return [['o', racinesP[0].texFractionSimplifiee, 'o', '+infty']]\n        } else {\n          return [['o', '-infty', 'o', racinesP[0].texFractionSimplifiee]]\n        }\n      } else if (racinesP.length === 2) {\n        if (\n          p.monomes.find((monome) => monome.degre === 2)?.coefficient.signe ===\n          1\n        ) {\n          return [\n            ['o', '-infty', 'o', racinesP[0].texFractionSimplifiee],\n            ['o', racinesP[1].texFractionSimplifiee, 'o', '+infty'],\n          ]\n        } else if (\n          p.monomes.find((monome) => monome.degre === 2)?.coefficient.signe ===\n          -1\n        ) {\n          return [\n            [\n              'o',\n              racinesP[0].texFractionSimplifiee,\n              'o',\n              racinesP[1].texFractionSimplifiee,\n            ],\n          ]\n        }\n      }\n    } else if (type === 'inverse') {\n      if (racinesP.length === 1) {\n        return [['R', racinesP[0].texFractionSimplifiee]]\n      } else if (racinesP.length === 2) {\n        return [\n          [\n            'R',\n            racinesP[0].texFractionSimplifiee,\n            racinesP[1].texFractionSimplifiee,\n          ],\n        ]\n      }\n    }\n    return [['']]\n  }\n\n  // --- Helper: parse an endpoint (assumes LaTeX fractions like \"\\dfrac{num}{den}\" or ±infty)\n  parseEndpoint(s: string): number {\n    if (s === '+infty') return Infinity\n    if (s === '-infty') return -Infinity\n    const regex = /\\\\dfrac\\{([^}]+)\\}\\{([^}]+)\\}/\n    const match = s.match(regex)\n    if (match) {\n      // Replace commas with dots if needed\n      const num = parseFloat(match[1].replace(',', '.'))\n      const den = parseFloat(match[2].replace(',', '.'))\n      if (s.match(/-/)) {\n        return -num / den\n      } else {\n        return num / den\n      }\n    }\n    return parseFloat(s)\n  }\n\n  // --- Existing helper: intersect two intervals (works for both sqrt– and R–types)\n  intersectTwoIntervals(i1: string[], i2: string[]): string[][] {\n    // Both are R–type:\n    if (i1[0] === 'R' && i2[0] === 'R') {\n      const exclusions = Array.from(new Set([...i1.slice(1), ...i2.slice(1)]))\n      exclusions.sort((a, b) => this.parseEndpoint(a) - this.parseEndpoint(b))\n      return [['R', ...exclusions]]\n    }\n    // One is R–type and one is sqrt–type:\n    if (i1[0] === 'R' && i2[0] !== 'R') {\n      return this.intersectSqrtAndR(i2, i1)\n    }\n    if (i2[0] === 'R' && i1[0] !== 'R') {\n      return this.intersectSqrtAndR(i1, i2)\n    }\n    // Both are sqrt–type: expected format [lMarker, lVal, rMarker, rVal]\n    const l1 = this.parseEndpoint(i1[1])\n    const u1 = this.parseEndpoint(i1[3])\n    const l2 = this.parseEndpoint(i2[1])\n    const u2 = this.parseEndpoint(i2[3])\n\n    // Lower bound: maximum of the two lower endpoints.\n    let newLower: string, newLowerMarker: string\n    if (l1 > l2) {\n      newLower = i1[1]\n      newLowerMarker = i1[0]\n    } else if (l2 > l1) {\n      newLower = i2[1]\n      newLowerMarker = i2[0]\n    } else {\n      newLower = i1[1]\n      newLowerMarker = i1[0] === 'o' || i2[0] === 'o' ? 'o' : 'f'\n    }\n    // Upper bound: minimum of the two upper endpoints.\n    let newUpper: string, newUpperMarker: string\n    if (u1 < u2) {\n      newUpper = i1[3]\n      newUpperMarker = i1[2]\n    } else if (u2 < u1) {\n      newUpper = i2[3]\n      newUpperMarker = i2[2]\n    } else {\n      newUpper = i1[3]\n      newUpperMarker = i1[2] === 'o' || i2[2] === 'o' ? 'o' : 'f'\n    }\n    const lowerVal = this.parseEndpoint(newLower)\n    const upperVal = this.parseEndpoint(newUpper)\n    if (\n      lowerVal > upperVal ||\n      (lowerVal === upperVal &&\n        (newLowerMarker === 'o' || newUpperMarker === 'o'))\n    ) {\n      return [] // no intersection\n    }\n    return [[newLowerMarker, newLower, newUpperMarker, newUpper]]\n  }\n\n  // --- Helper: intersect a sqrt–type interval with an R–type interval\n  intersectSqrtAndR(sqrtInterval: string[], rInterval: string[]): string[][] {\n    const exclusions = rInterval.slice(1)\n    let intervals: string[][] = [sqrtInterval]\n    exclusions.forEach((ex) => {\n      const exVal = this.parseEndpoint(ex)\n      const newIntervals: string[][] = []\n      intervals.forEach((inter) => {\n        const lVal = this.parseEndpoint(inter[1])\n        const uVal = this.parseEndpoint(inter[3])\n        if (exVal <= lVal || exVal >= uVal) {\n          newIntervals.push(inter)\n        } else {\n          const left = [inter[0], inter[1], 'o', ex]\n          const right = ['o', ex, inter[2], inter[3]]\n          if (this.parseEndpoint(left[1]) < this.parseEndpoint(left[3]))\n            newIntervals.push(left)\n          if (this.parseEndpoint(right[1]) < this.parseEndpoint(right[3]))\n            newIntervals.push(right)\n        }\n      })\n      intervals = newIntervals\n    })\n    return intervals\n  }\n\n  // --- NEW: reduce (merge) overlapping or adjacent sqrt–intervals\n  reduceUnionSqrt(intervals: string[][]): string[][] {\n    // Expect intervals in sqrt–format: [marker, left, marker, right]\n    type IntervalObj = {\n      left: number\n      right: number\n      leftMarker: string // 'o' for open, 'f' for closed\n      rightMarker: string\n      leftStr: string\n      rightStr: string\n    }\n\n    const objs: IntervalObj[] = intervals.map((interval) => ({\n      left: this.parseEndpoint(interval[1]),\n      right: this.parseEndpoint(interval[3]),\n      leftMarker: interval[0],\n      rightMarker: interval[2],\n      leftStr: interval[1],\n      rightStr: interval[3],\n    }))\n\n    // Sort by left endpoint; if equal, closed endpoints (f) come before open (o).\n    objs.sort((a, b) => {\n      if (a.left !== b.left) return a.left - b.left\n      return a.leftMarker === b.leftMarker ? 0 : a.leftMarker === 'f' ? -1 : 1\n    })\n\n    const merged: IntervalObj[] = []\n    for (const cur of objs) {\n      if (merged.length === 0) {\n        merged.push({ ...cur })\n      } else {\n        const last = merged[merged.length - 1]\n        // Check if cur overlaps or touches last.\n        if (\n          cur.left < last.right ||\n          (cur.left === last.right &&\n            (last.rightMarker === 'f' || cur.leftMarker === 'f'))\n        ) {\n          // Extend the merged interval if needed.\n          if (cur.right > last.right) {\n            last.right = cur.right\n            last.rightMarker = cur.rightMarker\n            last.rightStr = cur.rightStr\n          } else if (cur.right === last.right) {\n            if (last.rightMarker === 'o' && cur.rightMarker === 'f') {\n              last.rightMarker = 'f'\n            }\n          }\n        } else {\n          merged.push({ ...cur })\n        }\n      }\n    }\n\n    // If the merged union covers the whole real line, return an R–type interval.\n    if (\n      merged.length === 1 &&\n      merged[0].left === -Infinity &&\n      merged[0].right === Infinity\n    ) {\n      return [['R']]\n    }\n    if (merged.length === 0) return [[]] // no intervals left\n    // Convert merged objects back to our string[][] format.\n    return merged.map((obj) => [\n      obj.leftMarker,\n      obj.leftStr,\n      obj.rightMarker,\n      obj.rightStr,\n    ])\n  }\n\n  // --- Updated intersectDomains that calls reduceUnionSqrt on sqrt–type intervals\n  intersectDomains(domain1: string[][], domain2: string[][]): string[][] {\n    let result: string[][] = []\n    domain1.forEach((interval1) => {\n      domain2.forEach((interval2) => {\n        const inter = this.intersectTwoIntervals(interval1, interval2)\n        result.push(...inter)\n      })\n    })\n\n    // If all results are sqrt–type intervals, try to reduce the union.\n    const allSqrt = result.every(\n      (interval) => interval.length === 4 && interval[0] !== 'R',\n    )\n    if (allSqrt) {\n      result = this.reduceUnionSqrt(result)\n    }\n    return result\n  }\n\n  convertDomainToLatex(domain: string[][]): string {\n    // Helper to convert an endpoint to its LaTeX representation.\n    function convertEndpoint(ep: string): string {\n      if (ep === '+infty') return '+\\\\infty'\n      if (ep === '-infty') return '-\\\\infty'\n      return ep // Assume already in LaTeX form (e.g. \"\\dfrac{num}{den}\")\n    }\n\n    const intervalsLatex: string[] = []\n    for (const interval of domain) {\n      // Handle R-type intervals: ℝ minus some excluded points.\n      if (interval.length === 0) {\n        intervalsLatex.push('\\\\emptyset')\n      } else if (interval[0] === 'R') {\n        const exclusions = interval\n          .slice(1)\n          .map(convertEndpoint)\n          .join('\\\\,;\\\\,')\n        intervalsLatex.push(\n          `\\\\mathbb{R}\\\\setminus\\\\left\\\\{${exclusions}\\\\right\\\\}`,\n        )\n      } else if (interval.length === 4) {\n        const [lMarker, lValue, rMarker, rValue] = interval\n        // 'f' stands for closed (use [ or ]) and 'o' stands for open (use ( or ))\n        const leftBracket = lMarker === 'f' ? '\\\\left[' : '\\\\left]'\n        const rightBracket = rMarker === 'f' ? '\\\\right]' : '\\\\right['\n        const leftValLatex = convertEndpoint(lValue)\n        const rightValLatex = convertEndpoint(rValue)\n        // Use a semicolon as the separator with a thin space before and after.\n        intervalsLatex.push(\n          `${leftBracket}${leftValLatex}\\\\,;\\\\,${rightValLatex}${rightBracket}`,\n        )\n      } else {\n        intervalsLatex.push(interval.join('\\\\,;\\\\,'))\n      }\n    }\n\n    // Join multiple intervals using the union symbol.\n    return intervalsLatex.join(' \\\\cup ')\n  }\n\n  nouvelleVersion() {\n    this.listeQuestions = []\n    this.listeCorrections = []\n    this.autoCorrection = []\n    const typesDeQuestionsDisponibles = gestionnaireFormulaireTexte({\n      saisie: this.sup,\n      min: 1,\n      max: 7,\n      melange: 8,\n      defaut: 1,\n      listeOfCase: [\n        '1/q',\n        'p/q',\n        'racineP',\n        'racineP/q',\n        'p/racineQ',\n        'racineP/racineQ',\n        'racineP+racineQ',\n      ],\n      nbQuestions: this.nbQuestions,\n      shuffle: true,\n    })\n    const listeTypeDeQuestions = combinaisonListes(\n      typesDeQuestionsDisponibles,\n      this.nbQuestions,\n    )\n    for (let i = 0, cpt = 0; i < this.nbQuestions && cpt < 50; ) {\n      let texte = ''\n      let texteCorr = ''\n      texte =\n        'Déterminer le domaine de définition de la fonction $f$ définie par $f(x) = '\n      let p: PolynomePlusieursVariables\n      let q: PolynomePlusieursVariables\n      let pEq: EquationSecondDegre\n      let qEq: EquationSecondDegre\n      let stringQ = ''\n      let stringP = ''\n      let racinesP: FractionEtendue[]\n      let racinesQ: FractionEtendue[]\n      let degP: number\n      let degQ: number\n      if (this.sup2 === 3) {\n        degP = randint(1, 2)\n        degQ = randint(1, 2)\n      } else if (this.sup2 === 2) {\n        degP = 2\n        degQ = 2\n      } else {\n        degP = 1\n        degQ = 1\n      }\n      if (degP === 2 && degQ === 2) {\n        do {\n          const a = new FractionEtendue(\n            randint(-10, 10, [0]),\n            randint(-10, 10, [0]),\n          ).simplifie()\n          const b = new FractionEtendue(\n            randint(-10, 10, [0]),\n            randint(-10, 10, [0]),\n          ).simplifie()\n          const c = new FractionEtendue(\n            randint(-10, 10, [0]),\n            randint(-10, 10, [0]),\n          ).simplifie()\n          const d = new FractionEtendue(\n            randint(-10, 10, [0]),\n            randint(-10, 10, [0]),\n          ).simplifie()\n          pEq = EquationSecondDegre.aPartirDesSolutions(\n            a,\n            b,\n            new FractionEtendue(a.den * b.den, 1),\n            { variable: 'x', format: 'reduit' },\n          )\n          qEq = EquationSecondDegre.aPartirDesSolutions(\n            c,\n            d,\n            new FractionEtendue(c.den * d.den, 1),\n            { variable: 'x', format: 'reduit' },\n          )\n        } while (\n          pEq.equationTex === qEq.equationTex &&\n          pEq.delta.signe !== 1 &&\n          qEq.delta.signe !== 1\n        )\n        p = pEq.polynomeFormeReduite()\n        q = qEq.polynomeFormeReduite()\n        racinesP = pEq.solutionFrac() as FractionEtendue[]\n        racinesQ = qEq.solutionFrac() as FractionEtendue[]\n      } else if (degP === 1 && degQ === 2) {\n        do {\n          const a = new FractionEtendue(\n            randint(-10, 10, [0]),\n            randint(-10, 10, [0]),\n          ).simplifie()\n          const b = new FractionEtendue(\n            randint(-10, 10, [0]),\n            randint(-10, 10, [0]),\n          ).simplifie()\n          pEq = EquationSecondDegre.aPartirDesSolutions(\n            a,\n            b,\n            new FractionEtendue(a.den * b.den, 1),\n            { variable: 'x', format: 'reduit' },\n          )\n        } while (pEq.delta.signe !== 1)\n        p = pEq.polynomeFormeReduite()\n        racinesP = pEq.solutionFrac() as FractionEtendue[]\n        q = PolynomePlusieursVariables.createRandomPolynome(1, 1, 2, 'entier', [\n          'x',\n        ])\n        racinesQ = [this.solutionEq(q)]\n      } else if (degP === 2 && degQ === 1) {\n        do {\n          const a = new FractionEtendue(\n            randint(-10, 10, [0]),\n            randint(-10, 10, [0]),\n          ).simplifie()\n          const b = new FractionEtendue(\n            randint(-10, 10, [0]),\n            randint(-10, 10, [0]),\n          ).simplifie()\n          qEq = EquationSecondDegre.aPartirDesSolutions(\n            a,\n            b,\n            new FractionEtendue(a.den * b.den, 1),\n            { variable: 'x', format: 'reduit' },\n          )\n        } while (qEq.delta.signe !== 1)\n        q = qEq.polynomeFormeReduite()\n        racinesQ = qEq.solutionFrac() as FractionEtendue[]\n        p = PolynomePlusieursVariables.createRandomPolynome(1, 1, 2, 'entier', [\n          'x',\n        ])\n        racinesP = [this.solutionEq(p)]\n      } else {\n        p = PolynomePlusieursVariables.createRandomPolynome(1, 1, 2, 'entier', [\n          'x',\n        ])\n        q = PolynomePlusieursVariables.createRandomPolynome(1, 1, 2, 'entier', [\n          'x',\n        ])\n        racinesP = [this.solutionEq(p)]\n        racinesQ = [this.solutionEq(q)]\n      }\n      stringP = p.toString()\n      stringQ = q.toString()\n      const coeffDomP = p.ordonner().monomes[0].coefficient\n      const coeffDomQ = q.ordonner().monomes[0].coefficient\n      switch (listeTypeDeQuestions[i]) {\n        case '1/q':\n          {\n            const domLatexQ = this.convertDomainToLatex(\n              this.computeDomainePolynome('inverse', q, racinesQ),\n            )\n\n            texte += `\\\\dfrac{1}{${stringQ}}$`\n            texteCorr += `La condition sur le domaine de définition est la suivante \\\\[${stringQ}\\\\neq 0,\\\\] car le dénominateur d'une fraction ne peut pas valoir $0$. `\n            if (degQ === 2) {\n              texteCorr += `On détermine les valeurs qui annulent $${stringQ}$. On obtient que ces valeurs sont $\\\\left\\\\{${racinesQ.map((item) => item.texFractionSimplifiee).join(',')}\\\\right\\\\}.$ `\n            } else {\n              texteCorr += `La valeur qui annule $${stringQ}$ est $${racinesQ.map((item) => item.texFractionSimplifiee).join(',')}.$ `\n            }\n            texteCorr += `Ainsi, le domaine de définition est donné par\n          \\\\[D_f=${miseEnEvidence(domLatexQ)}\\\\]`\n          }\n          break\n        case 'p/q':\n          {\n            const domLatexQ = this.convertDomainToLatex(\n              this.computeDomainePolynome('inverse', q, racinesQ),\n            )\n\n            texte += `\\\\dfrac{${stringP}}{${stringQ}}$`\n            texteCorr += `La condition sur le domaine de définition est la suivante \\\\[${stringQ}\\\\neq 0,\\\\] car le dénominateur d'une fraction ne peut pas valoir $0$. <br> Le numérateur n'influence pas le domaine de définition dans ce cas.`\n            if (degQ === 2) {\n              texteCorr += `On détermine les valeurs qui annulent $${stringQ}$. On obtient que ces valeurs sont $\\\\left\\\\{${racinesQ.map((item) => item.texFractionSimplifiee).join(',')}\\\\right\\\\}.$ `\n            } else {\n              texteCorr += `La valeur qui annule $${stringQ}$ est $${racinesQ.map((item) => item.texFractionSimplifiee).join(',')}.$ `\n            }\n            texteCorr += `Ainsi, le domaine de définition est donné par\n          \\\\[D_f=${miseEnEvidence(domLatexQ)}\\\\]`\n          }\n          break\n        case 'racineP':\n          {\n            texte += `\\\\sqrt{${stringP}}$`\n            const domLatexP = this.convertDomainToLatex(\n              this.computeDomainePolynome('sqrt', p, racinesP),\n            )\n            texteCorr += `La condition sur le domaine de définition est la suivante : \\\\[${stringP}\\\\geq 0,\\\\] car la racine est définie sur les nombres positifs.\n          <br>`\n            if (degP === 2) {\n              texteCorr += `On détermine les valeurs qui annulent $${stringP}$. On obtient que ces valeurs sont $\\\\left\\\\{${racinesP.map((item) => item.texFractionSimplifiee).join(',')}\\\\right\\\\}.$ Le coefficient dominant de $${stringP}$ est $${coeffDomP.texFractionSimplifiee}${coeffDomP.signe === 1 ? '>0' : '<0'}$, donc la parabole associée est ${coeffDomP.signe === 1 ? 'convexe' : 'concave'}. `\n            } else {\n              texteCorr += `Le zéro de $${stringP}$ est $${racinesP.map((item) => item.texFractionSimplifiee).join(',')}.$ La pente de $${stringP}$ est $${coeffDomP.texFractionSimplifiee}${coeffDomP.signe === 1 ? '>0' : '<0'}$, donc la droite associée est ${coeffDomP.signe === 1 ? 'croissante' : 'décroissante'}. `\n            }\n            texteCorr += `Ainsi, $${stringP}$ est positif sur l'intervalle sur l'intervalle $${domLatexP}$, c'est également l'intervalle qui vérifie la première condition.<br> Le domaine de définition de $f$ correspond à l'intervalle déterminé '\n          \\\\[D_f=${miseEnEvidence(domLatexP)}\\\\]`\n          }\n          break\n        case 'racineP/q':\n          {\n            texte += `\\\\dfrac{\\\\sqrt{${stringP}}}{${stringQ}}$`\n            const domLatexP = this.convertDomainToLatex(\n              this.computeDomainePolynome('sqrt', p, racinesP),\n            )\n            const domLatexQ = this.convertDomainToLatex(\n              this.computeDomainePolynome('inverse', q, racinesQ),\n            )\n            texteCorr += `Les conditions sur le domaine de définition sont les suivantes : \\\\[\\\\text{Première condition : }${stringP}\\\\geq 0,\\\\] car la racine est définie sur les nombres positifs. \\\\[\\\\text{Deuxième condition : }${stringQ}\\\\neq 0,\\\\] car le dénominateur ne peut pas valoir $0$.\n          <br>`\n            if (degP === 2) {\n              texteCorr += `On détermine les valeurs qui annulent $${stringP}$. On obtient que ces valeurs sont $\\\\left\\\\{${racinesP.map((item) => item.texFractionSimplifiee).join(',')}\\\\right\\\\}.$ Le coefficient dominant de $${stringP}$ est $${coeffDomP.texFractionSimplifiee}${coeffDomP.signe === 1 ? '>0' : '<0'}$, donc la parabole associée est ${coeffDomP.signe === 1 ? 'convexe' : 'concave'}. `\n            } else {\n              texteCorr += `Le zéro de $${stringP}$ est $${racinesP.map((item) => item.texFractionSimplifiee).join(',')}.$ La pente de $${stringP}$ est $${coeffDomP.texFractionSimplifiee}${coeffDomP.signe === 1 ? '>0' : '<0'}$, donc la droite associée est ${coeffDomP.signe === 1 ? 'croissante' : 'décroissante'}. `\n            }\n            texteCorr += `Ainsi, $${stringP}$ est positif sur l'intervalle sur l'intervalle $${domLatexP}$, c'est également l'intervalle qui vérifie la première condition.<br> On s'occupe à présent de la deuxième condition.   `\n            if (degQ === 2) {\n              texteCorr += `On détermine les valeurs qui annulent $${stringQ}$. On obtient que ces valeurs sont $\\\\left\\\\{${racinesQ.map((item) => item.texFractionSimplifiee).join(',')}\\\\right\\\\}.$ `\n            } else {\n              texteCorr += `Le zéro de $${stringQ}$ est $${racinesQ.map((item) => item.texFractionSimplifiee).join(',')}.$ `\n            }\n            texteCorr += `Ainsi, $${stringQ}$ est différent de zéro sur l'intervalle $${domLatexQ}$, c'est également l'intervalle qui vérifie la deuxième condition.<br> Le domaine de définition de $f$ correspond à l'intersection des deux intervalles \n          \\\\[D_f=${domLatexP.match('cup') ? '\\\\left (\\\\,' : ''}${domLatexP}${domLatexP.match('cup') ? '\\\\,\\\\right )' : ''}\\\\cap ${domLatexQ.match('cup') ? '\\\\left (\\\\,' : ''}${domLatexQ}${domLatexQ.match('cup') ? '\\\\,\\\\right )' : ''}=${miseEnEvidence(this.convertDomainToLatex(this.intersectDomains(this.computeDomainePolynome('inverse', q, racinesQ), this.computeDomainePolynome('sqrt', p, racinesP))))}\\\\]`\n          }\n          break\n        case 'p/racineQ':\n          {\n            texte += `\\\\dfrac{${stringP}}{\\\\sqrt{${stringQ}}}$`\n            const domLatexQ = this.convertDomainToLatex(\n              this.computeDomainePolynome('invSqrt', q, racinesQ),\n            )\n            texteCorr += `La condition sur le domaine de définition est la suivante\\\\[${stringQ}> 0,\\\\] car la racine est définie sur les nombres positifs et le dénominateur ne peut pas valoir $0$. Le numérateur n'influence pas le domaine de définition dans ce cas.\n          <br>`\n            if (degQ === 2) {\n              texteCorr += `On détermine les valeurs qui annulent $${stringQ}$. On obtient que ces valeurs sont $\\\\left\\\\{${racinesQ.map((item) => item.texFractionSimplifiee).join(',')}\\\\right\\\\}.$ Le coefficient dominant de $${stringQ}$ est $${coeffDomQ.texFractionSimplifiee}${coeffDomP.signe === 1 ? '>0' : '<0'}$, donc la parabole associée est ${coeffDomQ.signe === 1 ? 'convexe' : 'concave'}. `\n            } else {\n              texteCorr += `Le zéro de $${stringQ}$ est $${racinesQ.map((item) => item.texFractionSimplifiee).join(',')}.$ La pente de $${stringQ}$ est $${coeffDomQ.texFractionSimplifiee}${coeffDomP.signe === 1 ? '>0' : '<0'}$, donc la droite associée est ${coeffDomQ.signe === 1 ? 'croissante' : 'décroissante'}. `\n            }\n            texteCorr += `Ainsi, $${stringQ}$ est strictement positif sur l'intervalle $${domLatexQ}$, c'est également l'intervalle qui vérifie la deuxième condition.<br> Le domaine de définition de $f$ est donc\n          \\\\[D_f=${miseEnEvidence(domLatexQ)}\\\\]`\n          }\n          break\n        case 'racineP/racineQ':\n          {\n            const domLatexP = this.convertDomainToLatex(\n              this.computeDomainePolynome('sqrt', p, racinesP),\n            )\n            const domLatexQ = this.convertDomainToLatex(\n              this.computeDomainePolynome('invSqrt', q, racinesQ),\n            )\n            texte += `\\\\dfrac{\\\\sqrt{${stringP}}}{\\\\sqrt{${stringQ}}}$`\n            texteCorr += `Les conditions sur le domaine de définition sont les suivantes : \\\\[\\\\text{Première condition : }${stringP}\\\\geq 0,\\\\] car la racine est définie sur les nombres positifs. \\\\[\\\\text{Deuxième condition : }${stringQ}> 0,\\\\] car la racine est définie sur les nombres positifs et le dénominateur ne peut pas valoir $0$.\n          <br>`\n            if (degP === 2) {\n              texteCorr += `On détermine les valeurs qui annulent $${stringP}$. On obtient que ces valeurs sont $\\\\left\\\\{${racinesP.map((item) => item.texFractionSimplifiee).join(',')}\\\\right\\\\}.$ Le coefficient dominant de $${stringP}$ est $${coeffDomP.texFractionSimplifiee}${coeffDomP.signe === 1 ? '>0' : '<0'}$, donc la parabole associée est ${coeffDomP.signe === 1 ? 'convexe' : 'concave'}. `\n            } else {\n              texteCorr += `Le zéro de $${stringP}$ est $${racinesP.map((item) => item.texFractionSimplifiee).join(',')}.$ La pente de $${stringP}$ est $${coeffDomP.texFractionSimplifiee}${coeffDomP.signe === 1 ? '>0' : '<0'}$, donc la droite associée est ${coeffDomP.signe === 1 ? 'croissante' : 'décroissante'}. `\n            }\n            texteCorr += `Ainsi, $${stringP}$ est positif sur l'intervalle sur l'intervalle $${domLatexP}$, c'est également l'intervalle qui vérifie la première condition.<br> On fait de même avec $${stringQ}$.   `\n            if (degQ === 2) {\n              texteCorr += `On détermine les valeurs qui annulent $${stringQ}$. On obtient que ces valeurs sont $\\\\left\\\\{${racinesQ.map((item) => item.texFractionSimplifiee).join(',')}\\\\right\\\\}.$ Le coefficient dominant de $${stringQ}$ est $${coeffDomQ.texFractionSimplifiee}${coeffDomP.signe === 1 ? '>0' : '<0'}$, donc la parabole associée est ${coeffDomQ.signe === 1 ? 'convexe' : 'concave'}. `\n            } else {\n              texteCorr += `Le zéro de $${stringQ}$ est $${racinesQ.map((item) => item.texFractionSimplifiee).join(',')}.$ La pente de $${stringQ}$ est $${coeffDomQ.texFractionSimplifiee}${coeffDomP.signe === 1 ? '>0' : '<0'}$, donc la droite associée est ${coeffDomQ.signe === 1 ? 'croissante' : 'décroissante'}. `\n            }\n            texteCorr += `Ainsi, $${stringQ}$ est strictement positif sur l'intervalle $${domLatexQ}$, c'est également l'intervalle qui vérifie la deuxième condition.<br> Le domaine de définition de $f$ correspond à l'intersection des deux intervalles \n          \\\\[D_f=${domLatexP.match('cup') ? '\\\\left (\\\\,' : ''}${domLatexP}${domLatexP.match('cup') ? '\\\\,\\\\right )' : ''}\\\\cap ${domLatexQ.match('cup') ? '\\\\left (\\\\,' : ''}${domLatexQ}${domLatexQ.match('cup') ? '\\\\,\\\\right )' : ''}=${miseEnEvidence(this.convertDomainToLatex(this.intersectDomains(this.computeDomainePolynome('invSqrt', q, racinesQ), this.computeDomainePolynome('sqrt', p, racinesP))))}\\\\]`\n          }\n          break\n        case 'racineP+racineQ':\n          {\n            texte += `\\\\sqrt{${stringP}}+\\\\sqrt{${stringQ}}$`\n            const domLatexP = this.convertDomainToLatex(\n              this.computeDomainePolynome('sqrt', p, racinesP),\n            )\n            const domLatexQ = this.convertDomainToLatex(\n              this.computeDomainePolynome('sqrt', q, racinesQ),\n            )\n            texteCorr += `Les conditions sur le domaine de définition sont les suivantes : \\\\[\\\\text{Première condition : }${stringP}\\\\geq 0\\\\] \\\\[\\\\text{Deuxième condition : }${stringQ}\\\\geq 0,\\\\] car la racine est définie sur les nombres positifs.\n          <br>`\n            if (degP === 2) {\n              texteCorr += `On détermine les valeurs qui annulent $${stringP}$. On obtient que ces valeurs sont $\\\\left\\\\{${racinesP.map((item) => item.texFractionSimplifiee).join(',')}\\\\right\\\\}.$ Le coefficient dominant de $${stringP}$ est $${coeffDomP.texFractionSimplifiee}${coeffDomP.signe === 1 ? '>0' : '<0'}$, donc la parabole associée est ${coeffDomP.signe === 1 ? 'convexe' : 'concave'}. `\n            } else {\n              texteCorr += `Le zéro de $${stringP}$ est $${racinesP.map((item) => item.texFractionSimplifiee).join(',')}.$ La pente de $${stringP}$ est $${coeffDomP.texFractionSimplifiee}${coeffDomP.signe === 1 ? '>0' : '<0'}$, donc la droite associée est ${coeffDomP.signe === 1 ? 'croissante' : 'décroissante'}. `\n            }\n            texteCorr += `Ainsi, $${stringP}$ est positif sur l'intervalle sur l'intervalle $${domLatexP}$, c'est également l'intervalle qui vérifie la première condition.<br> On fait de même avec $${stringQ}$.   `\n            if (degQ === 2) {\n              texteCorr += `On détermine les valeurs qui annulent $${stringQ}$. On obtient que ces valeurs sont $\\\\left\\\\{${racinesQ.map((item) => item.texFractionSimplifiee).join(',')}\\\\right\\\\}.$ Le coefficient dominant de $${stringQ}$ est $${coeffDomQ.texFractionSimplifiee}${coeffDomP.signe === 1 ? '>0' : '<0'}$, donc la parabole associée est ${coeffDomQ.signe === 1 ? 'convexe' : 'concave'}. `\n            } else {\n              texteCorr += `Le zéro de $${stringQ}$ est $${racinesQ.map((item) => item.texFractionSimplifiee).join(',')}.$ La pente de $${stringQ}$ est $${coeffDomQ.texFractionSimplifiee}${coeffDomP.signe === 1 ? '>0' : '<0'}$, donc la droite associée est ${coeffDomQ.signe === 1 ? 'croissante' : 'décroissante'}. `\n            }\n            texteCorr += `Ainsi, $${stringQ}$ est positif sur l'intervalle $${domLatexQ}$, c'est également l'intervalle qui vérifie la deuxième condition.<br> Le domaine de définition de $f$ correspond à l'intersection des deux intervalles \n          \\\\[D_f=${domLatexP.match('cup') ? '\\\\left (\\\\,' : ''}${domLatexP}${domLatexP.match('cup') ? '\\\\,\\\\right )' : ''}\\\\cap ${domLatexQ.match('cup') ? '\\\\left (\\\\,' : ''}${domLatexQ}${domLatexQ.match('cup') ? '\\\\,\\\\right )' : ''}=${miseEnEvidence(this.convertDomainToLatex(this.intersectDomains(this.computeDomainePolynome('sqrt', q, racinesQ), this.computeDomainePolynome('sqrt', p, racinesP))))}\\\\]`\n          }\n          break\n      }\n      if (this.listeQuestions.indexOf(texte) === -1) {\n        this.listeQuestions.push(texte)\n        this.listeCorrections.push(texteCorr)\n        i++\n      }\n      cpt++\n\n      listeQuestionsToContenu(this)\n    }\n  }\n}\n"],"names":["titre","interactifReady","interactifType","dateDePublication","uuid","refs","DomaineDeDefinition","Exercice","p","FractionEtendue","termConst","monome","termLin","type","racinesP","_a","_b","_c","_d","_e","_f","regex","match","num","den","i1","i2","exclusions","a","b","l1","u1","l2","u2","newLower","newLowerMarker","newUpper","newUpperMarker","lowerVal","upperVal","sqrtInterval","rInterval","intervals","ex","exVal","newIntervals","inter","lVal","uVal","left","right","objs","interval","merged","cur","last","obj","domain1","domain2","result","interval1","interval2","domain","convertEndpoint","ep","intervalsLatex","lMarker","lValue","rMarker","rValue","leftBracket","rightBracket","leftValLatex","rightValLatex","typesDeQuestionsDisponibles","gestionnaireFormulaireTexte","listeTypeDeQuestions","combinaisonListes","cpt","texte","texteCorr","q","pEq","qEq","stringQ","stringP","racinesQ","degP","degQ","randint","c","d","EquationSecondDegre","PolynomePlusieursVariables","coeffDomP","coeffDomQ","domLatexQ","item","miseEnEvidence","domLatexP","listeQuestionsToContenu"],"mappings":"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"}