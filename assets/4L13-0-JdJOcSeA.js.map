{"version":3,"file":"4L13-0-JdJOcSeA.js","sources":["../../src/lib/2d/CodageCarre.ts","../../src/exercices/4e/4L13-0.ts"],"sourcesContent":["import { codageAngleDroit } from './CodageAngleDroit'\nimport { codageSegments } from './CodageSegment'\nimport type { IPolygone } from './Interfaces'\nimport { ObjetMathalea2D } from './ObjetMathalea2D'\n\n/**\n * Code un carré\n * @param {Polygone} c Carré à coder\n * @param {string} [color = 'black'] Couleur des codages : du type 'blue' ou du type '#f15929'\n * @param {string} [mark='x'] Symbole posé sur les côtés\n * @property {string} svg Sortie au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} tikz Sortie au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @class\n */\n// JSDOC Validee par EE Juin 2022\n\nexport class CodageCarre extends ObjetMathalea2D {\n  constructor(c: IPolygone, color = 'black', mark = '×') {\n    super()\n    this.objets = []\n    this.objets.push(codageSegments(mark, color, ...c.listePoints))\n    this.objets.push(\n      codageAngleDroit(\n        c.listePoints[0],\n        c.listePoints[1],\n        c.listePoints[2],\n        color,\n      ),\n    )\n    this.objets.push(\n      codageAngleDroit(\n        c.listePoints[1],\n        c.listePoints[2],\n        c.listePoints[3],\n        color,\n      ),\n    )\n    this.objets.push(\n      codageAngleDroit(\n        c.listePoints[2],\n        c.listePoints[3],\n        c.listePoints[0],\n        color,\n      ),\n    )\n    this.objets.push(\n      codageAngleDroit(\n        c.listePoints[3],\n        c.listePoints[0],\n        c.listePoints[1],\n        color,\n      ),\n    )\n  }\n\n  svg(coeff: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz() {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\n/**\n * Met un codage complet sur un carré\n * @param {Polygone} c Carré à coder\n * @param {string} [color = 'black'] Couleur des codages : du type 'blue' ou du type '#f15929'\n * @param {string} [mark='x'] Symbole posé sur les côtés\n * @property {string} svg Sortie au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} tikz Sortie au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @example codageCarre(carre) // Code, en noir, le carré carre.\n * @example codageCarre(carre,'red','||') // Code, en rouge, le carré carre avec la marque || sur les côtés\n * @return {CodageCarre}\n */\n// JSDOC Validee par EE Juin 2022\n\nexport function codageCarre(c: IPolygone, color = 'black', mark = '×') {\n  return new CodageCarre(c, color, mark)\n}\n","import { afficheCoteSegment } from '../../lib/2d/AfficheCoteSegment'\nimport { codageCarre } from '../../lib/2d/CodageCarre'\nimport { codageSegments } from '../../lib/2d/CodageSegment'\nimport { point } from '../../lib/2d/PointAbstrait'\nimport { nommePolygone } from '../../lib/2d/polygones'\nimport { polygoneRegulierParCentreEtRayon } from '../../lib/2d/polygonesParticuliers'\nimport { segment } from '../../lib/2d/segmentsVecteurs'\nimport { vide2d } from '../../lib/2d/Vide2d'\nimport { egaliteCompare } from '../../lib/interactif/comparisonFunctions'\nimport { ajouteQuestionMathlive } from '../../lib/interactif/questionMathLive'\nimport { miseEnEvidence } from '../../lib/outils/embellissements'\nimport { creerNomDePolygone } from '../../lib/outils/outilString'\nimport { prenom } from '../../lib/outils/Personne'\nimport { context } from '../../modules/context'\nimport { mathalea2d } from '../../modules/mathalea2d'\nimport {\n  gestionnaireFormulaireTexte,\n  listeQuestionsToContenu,\n  randint,\n} from '../../modules/outils'\nimport Exercice from '../Exercice'\nexport const titre =\n  'Mettre en équation un problème sans objectif de résolution'\nexport const dateDeModifImportante = '28/03/2025'\nexport const interactifReady = true\nexport const interactifType = 'mathLive'\n\n/**\n * Produire une forme littérale en introduisant une lettre pour désigner une valeur inconnue afin de mettre en équation un problème\n * à partir de figure géométriques élémentaires\n * @author Sébastien Lozano (EE : Rajout de paramètres, aléatoirisation des sommets, meilleure colorisation de la correction...)\n */\nexport const uuid = '5a6f2'\n\nexport const refs = {\n  'fr-fr': ['4L13-0', 'BP2RES1'],\n  'fr-ch': ['10FA3-9'],\n}\n\nconst myPolyName = function (n: number) {\n  const sortie = {\n    article: '',\n    name: '',\n    nameParSommets: '',\n  }\n  switch (n) {\n    case 3:\n      sortie.article = 'du '\n      sortie.name = 'triangle équilatéral'\n      break\n    case 4:\n      sortie.article = 'du '\n      sortie.name = 'carré'\n      break\n    case 5:\n      sortie.article = 'du '\n      sortie.name = 'pentagone régulier'\n      break\n    case 6:\n      sortie.article = \"de l'\"\n      sortie.name = 'hexagone régulier'\n      break\n    case 7:\n      sortie.article = \"de l'\"\n      sortie.name = 'heptagone régulier'\n      break\n    case 8:\n    default:\n      sortie.article = \"de l'\"\n      sortie.name = 'octogone régulier'\n      break\n  }\n  sortie.nameParSommets = creerNomDePolygone(n, ['O', 'Q', 'X'])\n  return sortie\n}\n\nexport default class MettreEnEquationSansResoudre extends Exercice {\n  constructor() {\n    super()\n    this.besoinFormulaireTexte = [\n      'Type de polygones',\n      [\n        'Nombres séparés par des tirets  :',\n        '1 : Triangle',\n        '2 : Quadrilatère',\n        '3 : Pentagone',\n        '4 : Hexagone',\n        '5 : Heptagone',\n        '6 : Octogone',\n        '7 : Mélange',\n      ].join('\\n'),\n    ]\n\n    this.sup = 7\n    this.nbQuestions = 2\n\n    this.consigne =\n      \"Donner une équation qui permet de résoudre le problème.<br>On ne demande pas de résoudre l'équation.\"\n  }\n\n  nouvelleVersion() {\n    const typesDeQuestionsDisponibles = gestionnaireFormulaireTexte({\n      saisie: this.sup,\n      min: 1,\n      max: 6,\n      melange: 7,\n      defaut: 7,\n      nbQuestions: this.nbQuestions,\n    })\n\n    const variables = ['a', 'b', 'c', 'x', 'y', 'z']\n    const unites = [\n      '$\\\\text{mm}$',\n      '$\\\\text{cm}$',\n      '$\\\\text{dm}$',\n      '$\\\\text{m}$',\n      '$\\\\text{dam}$',\n      '$\\\\text{hm}$',\n      '$\\\\text{km}$',\n    ]\n\n    for (let i = 0, cpt = 0; i < this.nbQuestions && cpt < 50; ) {\n      // une fonction pour dire le nom du polygone\n\n      // on choisit le nombre de côtés su polygone\n      const n = Number(typesDeQuestionsDisponibles[i]) + 2\n      // on choisit un nom pour la variable\n      const inc = variables[randint(0, variables.length - 1)]\n      // on choisit une unité\n      const unite = unites[randint(0, unites.length - 1)]\n      // on prépare le polygone\n      const po = polygoneRegulierParCentreEtRayon(point(0, 0), 4, n)\n      po.opacite = 0.5\n      po.epaisseur = 2\n      // on pépare la côte\n      const s = segment(po.listePoints[0], po.listePoints[1])\n      s.styleExtremites = '<->'\n      // on fait un test pour coder les angles droits du carré\n      let anglesDroitsIfIsCarre\n      if (n === 4) {\n        anglesDroitsIfIsCarre = codageCarre(po)\n      } else {\n        anglesDroitsIfIsCarre = vide2d()\n      }\n      // on finit les appels\n      const mesAppels = [\n        po,\n        codageSegments('X', 'blue', po.listePoints),\n        afficheCoteSegment(s, `${inc}`, 1, 'red', 2, 0.5, 'black'),\n        nommePolygone(po, myPolyName(n).nameParSommets),\n        anglesDroitsIfIsCarre,\n      ]\n      // on prépare l'objet polygone\n      const polygone = {\n        nb_cotes: n,\n        unite,\n        article: myPolyName(n).article,\n        nom: myPolyName(n).name,\n        let_cote: inc,\n        perimetre: randint(200, 500),\n        fig: mathalea2d(\n          {\n            xmin: -7,\n            ymin: -5,\n            xmax: 7,\n            ymax: 5,\n            pixelsParCm: 20,\n            scale: 0.5, // 0.7\n          },\n          mesAppels,\n        ),\n      }\n\n      const enonces = []\n      const equation = `${polygone.nb_cotes}\\\\times ${polygone.let_cote} = ${polygone.perimetre}`\n\n      enonces.push({\n        enonce: `On considère la figure suivante où l'unité est le ${polygone.unite}.<br>${prenom()} se demande pour quelle valeur de $${polygone.let_cote}$, exprimée en ${polygone.unite}, le périmètre ${polygone.article}${polygone.nom} est égal à $${polygone.perimetre}$ ${polygone.unite} .<br> ${polygone.fig}`,\n        question: '',\n        correction: `La figure est un ${polygone.nom}, il a donc $${polygone.nb_cotes}$ côtés de même longueur.<br>\n        Cette longueur est notée $${polygone.let_cote}$, le périmètre de la figure, exprimé en fonction de $${polygone.let_cote}$, vaut donc $${polygone.nb_cotes}\\\\times ${polygone.let_cote}$.<br>\n        D'après l'énoncé, ce périmètre vaut $${polygone.perimetre}$ ${polygone.unite}.<br>\n        L'équation suivante permet donc de résoudre le problème : \n        $${miseEnEvidence(equation)}$.`,\n      })\n\n      if (this.questionJamaisPosee(i, n, inc)) {\n        // Si la question n'a jamais été posée, on en créé une autre\n        this.listeQuestions[i] = `${enonces[0].enonce}`\n        if (context.isHtml && this.interactif) {\n          this.listeQuestions[i] += ajouteQuestionMathlive({\n            exercice: this,\n            question: i,\n            typeInteractivite: 'mathlive',\n            objetReponse: {\n              reponse: {\n                value: equation,\n                compare: egaliteCompare,\n              },\n            },\n          })\n        }\n        this.listeCorrections[i] = `${enonces[0].correction}`\n        i++\n      }\n      cpt++\n    }\n    listeQuestionsToContenu(this)\n  }\n}\n"],"names":["CodageCarre","ObjetMathalea2D","c","color","mark","codageSegments","codageAngleDroit","coeff","code","objet","codageCarre","titre","dateDeModifImportante","interactifReady","interactifType","uuid","refs","myPolyName","sortie","creerNomDePolygone","MettreEnEquationSansResoudre","Exercice","typesDeQuestionsDisponibles","gestionnaireFormulaireTexte","variables","unites","cpt","n","inc","randint","unite","po","polygoneRegulierParCentreEtRayon","point","s","segment","anglesDroitsIfIsCarre","vide2d","mesAppels","afficheCoteSegment","nommePolygone","polygone","mathalea2d","enonces","equation","prenom","miseEnEvidence","context","ajouteQuestionMathlive","egaliteCompare","listeQuestionsToContenu"],"mappings":"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"}