{"version":3,"file":"6G2C-BtOlmhJc.js","sources":["../../src/lib/2d/Cordelette.ts","../../src/exercices/6e/6G2C.ts"],"sourcesContent":["import { colorToLatexOrHTML } from './colorToLatexOrHtml'\nimport MainLevee from './MainLevee'\nimport { ObjetMathalea2D } from './ObjetMathalea2D'\nimport { pointAbstrait, type PointAbstrait } from './PointAbstrait'\n\nexport class Cordelette extends ObjetMathalea2D {\n  amplitude: number\n  constructor(\n    A: PointAbstrait,\n    B: PointAbstrait,\n    amplitude = 1,\n    mollesse = 0.5,\n    color = 'black',\n  ) {\n    super()\n    this.typeObjet = 'cordelette'\n    this.A = A\n    this.B = B\n    this.tailleExtremites = 0\n    this.color = colorToLatexOrHTML(color)\n    this.amplitude = amplitude\n    this.bordures = [\n      Math.min(A.x, B.x),\n      Math.min(A.y, B.y),\n      Math.max(A.x, B.x),\n      Math.max(A.y, B.y),\n    ]\n  }\n\n  svg(coeff: number) {\n    const mainLevee = MainLevee.create()\n    if (mainLevee != null) {\n      const A = this.A\n      const B = this.B\n\n      // Calcul de la distance entre A et B\n      const distance = Math.sqrt((B.x - A.x) ** 2 + (B.y - A.y) ** 2)\n\n      // Nombre de points intermédiaires basé sur la distance\n      // Plus la distance est grande, plus on a de points (environ 1 point tous les 0.5 unités)\n      const nbPointsIntermediaires = Math.max(2, Math.floor(distance / 0.2))\n\n      // Génération des points de la cordelette\n      const points = this.genererPointsCordelette(A, B, nbPointsIntermediaires)\n\n      // Conversion en coordonnées SVG\n      const pointsSVG = points.map((point) => [\n        point.x * coeff,\n        -point.y * coeff,\n      ]) as [number, number][]\n\n      const code = mainLevee.curve(pointsSVG, {\n        color: this.color[0],\n        epaisseur: this.epaisseur,\n        roughness: this.amplitude * 0.5, // Réduire la roughness car on a déjà le décalage\n        bowing: 1, // Réduire le bowing aussi\n      })\n\n      mainLevee.destroy()\n      return code\n    } else return ''\n  }\n\n  /**\n   * Génère des points intermédiaires décalés pour simuler une cordelette\n   */\n  private genererPointsCordelette(\n    A: PointAbstrait,\n    B: PointAbstrait,\n    nbPoints: number,\n  ) {\n    const points = [A] // Commence par le point A\n\n    // Vecteur directeur AB\n    const vecteurAB = { x: B.x - A.x, y: B.y - A.y }\n    // Vecteur perpendiculaire (pour les décalages)\n    const vecteurPerp = { x: -vecteurAB.y, y: vecteurAB.x }\n    // Normalisation du vecteur perpendiculaire\n    const normePerp = Math.sqrt(vecteurPerp.x ** 2 + vecteurPerp.y ** 2)\n    if (normePerp > 0) {\n      vecteurPerp.x /= normePerp\n      vecteurPerp.y /= normePerp\n    }\n\n    // Distance entre A et B\n    const longueurAB = Math.sqrt(vecteurAB.x ** 2 + vecteurAB.y ** 2)\n\n    // Génération d'une fonction de décalage continue basée sur plusieurs sinusoïdes\n    // pour créer un aspect naturel mais lisse\n    const frequence1 = 1 // Oscillation principale\n    const frequence2 = 2.3 // Oscillation secondaire (nombre premier pour éviter la périodicité)\n    const frequence3 = 3.7 // Oscillation tertiaire\n\n    // Amplitudes relatives\n    const amp1 = 1\n    const amp2 = 0.6\n    const amp3 = 0.3\n\n    // Seed pour la reproductibilité (basé sur les coordonnées des points)\n    const seed = (A.x + A.y + B.x + B.y) * 1000\n\n    // Fonction de décalage continue\n    const calculerDecalage = (t: number): number => {\n      // Facteur d'atténuation aux extrémités (forme en cloche)\n      const facteurExtremites = Math.sin(t * Math.PI)\n\n      // Combinaison de plusieurs sinusoïdes avec phases différentes\n      const phase1 = seed * 0.001\n      const phase2 = seed * 0.0013\n      const phase3 = seed * 0.0017\n\n      const decalage =\n        amp1 * Math.sin(t * Math.PI * frequence1 + phase1) +\n        amp2 * Math.sin(t * Math.PI * frequence2 + phase2) +\n        amp3 * Math.sin(t * Math.PI * frequence3 + phase3)\n\n      return decalage * facteurExtremites\n    }\n\n    // Génération des points intermédiaires\n    for (let i = 1; i < nbPoints; i++) {\n      const t = i / nbPoints // Paramètre entre 0 et 1\n\n      // Point sur le segment AB\n      const pointSurSegment = {\n        x: A.x + t * vecteurAB.x,\n        y: A.y + t * vecteurAB.y,\n      }\n\n      // Amplitude du décalage basée sur la longueur et l'amplitude fournie\n      const amplitudeDecalage = this.amplitude * 0.05 * longueurAB\n\n      // Décalage continu et lisse\n      const decalage = calculerDecalage(t) * amplitudeDecalage\n\n      // Effet de gravité (la cordelette \"tombe\" naturellement)\n      const decalageGravite =\n        Math.sin(t * Math.PI) * this.amplitude * 0.02 * longueurAB\n\n      // Point final décalé\n      const pointDecale = pointAbstrait(\n        pointSurSegment.x + decalage * vecteurPerp.x,\n        pointSurSegment.y + decalage * vecteurPerp.y - decalageGravite,\n      )\n\n      points.push(pointDecale)\n    }\n\n    points.push(B) // Termine par le point B\n    return points\n  }\n\n  tikz() {\n    const A = this.A\n    const B = this.B\n\n    // Calcul de la distance entre A et B\n    const distance = Math.sqrt((B.x - A.x) ** 2 + (B.y - A.y) ** 2)\n\n    // Nombre de points intermédiaires basé sur la distance\n    const nbPointsIntermediaires = Math.max(2, Math.floor(distance / 0.2))\n\n    // Génération des points de la cordelette\n    const points = this.genererPointsCordelette(A, B, nbPointsIntermediaires)\n\n    // Construction des options TikZ\n    const tableauOptions = []\n\n    // Gestion de la couleur (utilise this.color[1] qui est le nom de couleur LaTeX)\n    if (this.color[1] !== 'black') {\n      tableauOptions.push(this.color[1])\n    }\n\n    if (this.epaisseur !== 1) {\n      tableauOptions.push(`line width=${this.epaisseur}`)\n    }\n\n    if (this.opacite !== 1) {\n      tableauOptions.push(`opacity=${this.opacite}`)\n    }\n\n    const optionsDraw =\n      tableauOptions.length > 0 ? `[${tableauOptions.join(', ')}]` : ''\n\n    // Construction du path avec courbes lisses (sans décorateur conflictuel)\n    const coordonnees = points\n      .map((point) => `(${point.x.toFixed(3)},${point.y.toFixed(3)})`)\n      .join(' ')\n\n    return `\\\\draw${optionsDraw} plot[smooth] coordinates {${coordonnees}};`\n  }\n}\n\nexport function cordelette(\n  A: PointAbstrait,\n  B: PointAbstrait,\n  amplitude = 1,\n  mollesse = 0.5,\n  color = 'black',\n) {\n  return new Cordelette(A, B, amplitude, mollesse, color)\n}\n","import { afficheCoteSegment } from '../../lib/2d/AfficheCoteSegment'\nimport { Arc, arc } from '../../lib/2d/Arc'\nimport { BoiteBuilder } from '../../lib/2d/BoiteBuilder'\nimport { cercle } from '../../lib/2d/cercle'\nimport { colorToLatexOrHTML } from '../../lib/2d/colorToLatexOrHtml'\nimport { cordelette } from '../../lib/2d/Cordelette'\nimport { droite } from '../../lib/2d/droites'\nimport { fixeBordures } from '../../lib/2d/fixeBordures'\nimport { placeLatexSurSegment } from '../../lib/2d/placeLatexSurSegment'\nimport { PointAbstrait, pointAbstrait } from '../../lib/2d/PointAbstrait'\nimport { polygone } from '../../lib/2d/polygones'\nimport { segment } from '../../lib/2d/segmentsVecteurs'\nimport { labelPoint, texteParPosition } from '../../lib/2d/textes'\nimport { tracePoint } from '../../lib/2d/TracePoint'\nimport { homothetie, rotation } from '../../lib/2d/transformations'\nimport { angleOriente, longueur } from '../../lib/2d/utilitairesGeometriques'\nimport {\n  pointIntersectionCC,\n  pointIntersectionDD,\n  pointIntersectionLC,\n  pointSurSegment,\n} from '../../lib/2d/utilitairesPoint'\nimport { vide2d } from '../../lib/2d/Vide2d'\nimport { numAlpha } from '../../lib/outils/outilString'\nimport { context } from '../../modules/context'\nimport { mathalea2d } from '../../modules/mathalea2d'\nimport { gestionnaireFormulaireTexte, randint } from '../../modules/outils'\nimport Exercice from '../Exercice'\n\nexport const titre =\n  'Résoudre des problèmes mettant en jeu des distances à un point'\nexport const interactifReady = false\n\nexport const dateDePublication = '03/08/2025'\n\n/**\n * Exercice tiré des documents officiels : un classique de la géométrie plane\n * @author Jean-Claude Lhote\n\n*/\nexport const uuid = '29c3c'\n\nexport const refs = {\n  'fr-fr': ['6G2C'],\n  'fr-2016': ['6G54'],\n  'fr-ch': ['9ES4-15'],\n}\nexport default class ProblemeDeLaChevreDansSonEnclos extends Exercice {\n  constructor() {\n    super()\n    this.comment =\n      \"Cet exercice n'est pas interactif, il s'agit d'un problème de géométrie plane classique à faire sur papier.\"\n    this.nbQuestions = 1\n    this.besoinFormulaireTexte = [\n      'Types de question',\n      \"Nombres séparés par des tirets :\\n1 : Cabane au coin de l'enclos\\n2 : Cabane sur un côté de l'enclos\\n3 : Cabane sans contact avec l'enclos\\n4 : Mélange\",\n    ]\n    this.sup = '1'\n  }\n\n  nouvelleVersion() {\n    const listeTypesDeQuestions = gestionnaireFormulaireTexte({\n      saisie: this.sup,\n      nbQuestions: this.nbQuestions,\n      min: 1,\n      max: 3,\n      defaut: 1,\n      melange: 4,\n    }).map(Number)\n    for (let i = 0, cpt = 0; i < this.nbQuestions && cpt < 50; ) {\n      const longueurEnclos = randint(12, 16)\n      const largeurEnclos = randint(10, longueurEnclos - 1)\n      const longueurCabane = randint(4, Math.ceil(longueurEnclos / 3))\n      const largeurCabane = randint(\n        3,\n        Math.min(Math.ceil(largeurEnclos / 3), longueurCabane - 1),\n      )\n      const offsetPointP = randint(1, longueurCabane - 1)\n      // La corde n'intercepte jamais le bord gauche quand la cabane est collée au bord droit... Mais attention à la cabane au centre !\n      const longueurCordelette = randint(\n        Math.max(offsetPointP, longueurCabane - offsetPointP + 1),\n        largeurEnclos - largeurCabane,\n      )\n\n      const objetsEnonce = []\n      const objetsCorrection = []\n      let texte = ''\n      let texteCorr = ''\n      const A = pointAbstrait(0, 0)\n      const B = pointAbstrait(longueurEnclos, 0)\n      const C = pointAbstrait(longueurEnclos, largeurEnclos)\n      const D = pointAbstrait(0, largeurEnclos)\n      // Les bords de l'enclos pour les intersections\n      const AB = droite(A, B)\n      const BC = droite(B, C)\n      const CD = droite(C, D)\n      const DA = droite(D, A)\n      let cabA: PointAbstrait\n      let cabB: PointAbstrait\n      let cabC: PointAbstrait\n      let cabD: PointAbstrait\n      let P: PointAbstrait\n      const enclos = polygone(A, B, C, D)\n\n      switch (listeTypesDeQuestions[i]) {\n        /*********************************/\n        // cabane sur le côté droit\n        /*********************************/\n        case 2:\n          {\n            cabA = pointAbstrait(\n              longueurEnclos,\n              randint(3, largeurEnclos - largeurCabane - 1),\n            )\n            cabB = pointAbstrait(longueurEnclos, cabA.y + largeurCabane)\n            cabD = pointAbstrait(cabA.x - longueurCabane, cabA.y)\n            cabC = pointAbstrait(cabD.x, cabB.y)\n            P = pointAbstrait(cabA.x - offsetPointP, cabA.y, 'P', 'above')\n            // longueur additionnelle énoncé\n            const hSousCabane = afficheCoteSegment(\n              segment(cabA, B),\n              `${cabA.y}\\\\,\\\\text{m}`,\n              0.2,\n              'black',\n              1,\n              1,\n              context.isHtml ? 'gray' : 'darkgray',\n              true,\n            )\n            objetsEnonce.push(hSousCabane)\n            // On s'occupe d'abord de ce qu'il y a sous la cabane\n            let I: PointAbstrait\n            const J = homothetie(\n              P,\n              cabA,\n              (offsetPointP + longueurCordelette) / offsetPointP,\n            )\n            const c1 = cercle(P, longueurCordelette)\n            if (cabA.y >= longueurCordelette) {\n              if (longueurCordelette < offsetPointP) {\n                // On a un demi-cercle de centre P\n                I = pointIntersectionLC(droite(cabA, cabD), c1, '', 2)\n                const a1 = arc(\n                  I,\n                  P,\n                  -Math.abs(angleOriente(I, P, J)),\n                  true,\n                  'pink',\n                  'black',\n                  0.4,\n                )\n                a1.couleurDesHachures = colorToLatexOrHTML('black')\n                a1.hachures = 'north east lines'\n                a1.opacite = 0.2\n                objetsCorrection.push(a1)\n              } else {\n                // la corde intercepte le coté droit et comme longueurCordelette<=cabA.y, ça se trouve dans l'enclos et l'arc n'est pas intercepté par le bord de l'enclos\n                I = pointIntersectionLC(droite(cabA, B), c1, '', 2)\n                const a1 = arc(\n                  I,\n                  P,\n                  -Math.abs(angleOriente(I, P, J)),\n                  true,\n                  'pink',\n                  'black',\n                  0.4,\n                )\n                a1.couleurDesHachures = colorToLatexOrHTML('black')\n                a1.hachures = 'north east lines'\n                a1.opacite = 0.2\n\n                const t1 = polygone(I, cabA, P)\n                t1.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                t1.opaciteDeRemplissage = 0.4\n                t1.couleurDesHachures = colorToLatexOrHTML('black')\n                t1.hachures = 'north east lines'\n                t1.opacite = 0.2\n                objetsCorrection.push(a1, t1)\n              }\n            } else {\n              /* --------------------------------- */\n              // la corde intercepte le bord bas\n              /* --------------------------------- */\n              if (longueurCordelette < offsetPointP) {\n                // La corde d'intercepte pas le bord droit\n                // On a un demi-cercle de centre P itercepté par le bord bas de l'enclos\n                // On va faire : 1 triangle PMN et deux arcs IM et NJ de centre P\n                I = pointIntersectionLC(droite(cabA, cabD), c1, '', 2)\n                const M = pointIntersectionLC(AB, c1, '', 2)\n                const N = pointIntersectionLC(AB, c1, '', 1)\n                const a1 = arc(\n                  I,\n                  P,\n                  -Math.abs(angleOriente(I, P, M)),\n                  true,\n                  'pink',\n                  'black',\n                  0.4,\n                )\n                a1.couleurDesHachures = colorToLatexOrHTML('black')\n                a1.hachures = 'north east lines'\n                a1.opacite = 0.2\n\n                const t1 = polygone(P, M, N)\n                t1.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                t1.opaciteDeRemplissage = 0.4\n                t1.couleurDesHachures = colorToLatexOrHTML('black')\n                t1.hachures = 'north east lines'\n                t1.opacite = 0.2\n                const a2 = arc(\n                  N,\n                  P,\n                  -Math.abs(angleOriente(N, P, J)),\n                  true,\n                  'pink',\n                  'black',\n                  0.4,\n                )\n                a2.couleurDesHachures = colorToLatexOrHTML('black')\n                a2.hachures = 'north east lines'\n                a2.opacite = 0.2\n                objetsCorrection.push(a1, t1, a2)\n              } else {\n                // la corde intercepte le coté droit et intercepte aussi le bord bas.\n                // on va faire : t1, a1, t2, a2 ou, si le coin est à portée de cordelette, un trapèze et un arc.\n                if (\n                  longueurCordelette ** 2 >=\n                  offsetPointP ** 2 + cabA.y ** 2\n                ) {\n                  // On couvre tout le coin en bas à droite par un trapèze jusqu'au point de départ de l'arc\n                  // on s'occupe déja du trapèze\n                  const N = pointIntersectionLC(AB, c1, '', 1)\n                  I = N\n                  const t1 = polygone(P, cabA, B, N)\n                  t1.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                  t1.opaciteDeRemplissage = 0.4\n                  t1.couleurDesHachures = colorToLatexOrHTML('black')\n                  t1.hachures = 'north east lines'\n                  t1.opacite = 0.2\n                  const a2 = arc(\n                    N,\n                    P,\n                    -Math.abs(angleOriente(N, P, J)),\n                    true,\n                    'pink',\n                    'black',\n                    0.4,\n                  )\n                  a2.couleurDesHachures = colorToLatexOrHTML('black')\n                  a2.hachures = 'north east lines'\n                  a2.opacite = 0.2\n                  objetsCorrection.push(t1, a2)\n                } else {\n                  I = pointIntersectionLC(droite(cabA, B), c1, '', 2)\n                  const M = pointIntersectionLC(AB, c1, '', 2)\n                  const N = pointIntersectionLC(AB, c1, '', 1)\n                  if (I.y !== cabA.y) {\n                    // On peut avoir un arc tangent au bord droit, dans ce cas, pas besoin de triangle.\n                    const t1 = polygone(P, cabA, I)\n                    t1.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                    t1.opaciteDeRemplissage = 0.4\n                    t1.couleurDesHachures = colorToLatexOrHTML('black')\n                    t1.hachures = 'north east lines'\n                    t1.opacite = 0.2\n                    objetsCorrection.push(t1)\n                  }\n                  const a1 = arc(\n                    I,\n                    P,\n                    -Math.abs(angleOriente(I, P, M)),\n                    true,\n                    'pink',\n                    'black',\n                    0.4,\n                  )\n                  a1.couleurDesHachures = colorToLatexOrHTML('black')\n                  a1.hachures = 'north east lines'\n                  a1.opacite = 0.2\n                  const t2 = polygone(P, M, N)\n                  t2.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                  t2.opaciteDeRemplissage = 0.4\n                  t2.couleurDesHachures = colorToLatexOrHTML('black')\n                  t2.hachures = 'north east lines'\n                  t2.opacite = 0.2\n                  const a2 = arc(\n                    N,\n                    P,\n                    -Math.abs(angleOriente(N, P, J)),\n                    true,\n                    'pink',\n                    'black',\n                    0.4,\n                  )\n                  a2.couleurDesHachures = colorToLatexOrHTML('black')\n                  a2.hachures = 'north east lines'\n                  a2.opacite = 0.2\n                  objetsCorrection.push(a1, t2, a2)\n                }\n              }\n            }\n            const r1Mes = afficheCoteSegment(\n              segment(P, I),\n              `${longueurCordelette}\\\\,\\\\text{m}`,\n              0,\n              'black',\n              0.5,\n              0.5,\n              context.isHtml ? 'gray' : 'darkgray',\n              true,\n            )\n            // const r1Mes = placeLatexSurSegment(`${longueurCordelette}\\\\text{ m}`, P, I, { distance: 0.3 })\n            objetsCorrection.push(r1Mes)\n            /* --------------------------------------------------- */\n            // fin de la partie 'sous-cabane' on attaque la partie commençant à J qui ne peut pas intercepter le bord gauche (ouf !)\n            /* --------------------------------------------------- */\n            const longueurRestante1 =\n              longueurCordelette - (longueurCabane - offsetPointP)\n            const diff = afficheCoteSegment(\n              segment(P, cabD),\n              `${longueurCabane - offsetPointP}\\\\,\\\\text{m}`,\n              0.5,\n              'black',\n              1,\n              0.5,\n              'black',\n            )\n            if (longueurRestante1 + cabA.y > largeurEnclos) {\n              /* ------------------------------------ */\n              // Le quart de cercle intercepte le bord haut de l'enclos : on a arc puis triangle puis arc\n              /* ------------------------------------ */\n              const c2 = cercle(cabD, longueurRestante1)\n              const M = pointIntersectionLC(CD, c2, '', 1)\n              const l1 = afficheCoteSegment(\n                segment(cabD, M),\n                `${longueurRestante1}\\\\,\\\\text{m}`,\n                0,\n                'black',\n                0.5,\n                0.5,\n                context.isHtml ? 'gray' : 'darkgray',\n                true,\n              )\n              const a1 = arc(\n                J,\n                cabD,\n                angleOriente(J, cabD, M),\n                true,\n                'pink',\n                'black',\n                0.3,\n              )\n              a1.couleurDesHachures = colorToLatexOrHTML('black')\n              a1.hachures = 'north east lines'\n              a1.opacite = 0.2\n\n              const K = pointIntersectionDD(droite(cabC, cabD), CD)\n              const t1 = polygone(M, cabD, K)\n              t1.couleurDeRemplissage = colorToLatexOrHTML('pink')\n              t1.opaciteDeRemplissage = 0.3\n              t1.couleurDesHachures = colorToLatexOrHTML('black')\n              t1.hachures = 'north east lines'\n              t1.opacite = 0.2\n              const longueurRestante2 = longueurRestante1 - largeurCabane\n              if (\n                longueurRestante2 ** 2 >=\n                longueurCabane ** 2 + (largeurEnclos - cabB.y) ** 2\n              ) {\n                // La corde permet d'aller jusqu'au coin haut droit de l'enclos\n                // on dessine un rectangle\n                const r1 = polygone(K, C, cabB, cabC)\n                r1.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                r1.opaciteDeRemplissage = 0.2\n                r1.couleurDesHachures = colorToLatexOrHTML('black')\n                r1.hachures = 'north east lines'\n                r1.opacite = 0.2\n                objetsCorrection.push(r1)\n              } else {\n                // on n'atteint pas le coin, mais peut-être le bord droit !\n                // tout d'abord le triangle\n                const c2 = cercle(cabC, longueurRestante2)\n                const N = pointIntersectionLC(CD, c2, '', 2)\n                const t3 = polygone(K, N, cabC)\n                const X = homothetie(\n                  rotation(K, cabC, -45),\n                  cabC,\n                  longueurRestante2 / longueur(cabC, K),\n                )\n                const l2 = afficheCoteSegment(\n                  segment(cabC, X),\n                  `${longueurRestante2}\\\\,\\\\text{m}`,\n                  0,\n                  'black',\n                  1,\n                  0.5,\n                  context.isHtml ? 'gray' : 'darkgray',\n                  true,\n                )\n                t3.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                t3.opaciteDeRemplissage = 0.2\n                t3.couleurDesHachures = colorToLatexOrHTML('black')\n                t3.hachures = 'north east lines'\n                t3.opacite = 0.2\n                objetsCorrection.push(t3, l2)\n                if (longueurRestante2 > longueurCabane) {\n                  // Le bord droit bloque : triangle + arc + triangle\n                  const X = pointIntersectionLC(BC, c2, '', 1)\n                  const a3 = arc(\n                    N,\n                    cabC,\n                    angleOriente(N, cabC, X),\n                    true,\n                    'pink',\n                    'black',\n                    0.2,\n                  )\n                  a3.couleurDesHachures = colorToLatexOrHTML('black')\n                  a3.hachures = 'north east lines'\n                  a3.opacite = 0.2\n                  const t4 = polygone(X, cabC, cabB)\n                  t4.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                  t4.opaciteDeRemplissage = 0.2\n                  t4.couleurDesHachures = colorToLatexOrHTML('black')\n                  t4.hachures = 'north east lines'\n                  t4.opacite = 0.2\n                  objetsCorrection.push(a3, t4)\n                } else {\n                  // On n'atteint pas le bord droit : triangle + arc\n                  const a3 = arc(\n                    N,\n                    cabC,\n                    angleOriente(N, cabC, cabB),\n                    true,\n                    'pink',\n                    'black',\n                    0.2,\n                  )\n                  a3.couleurDesHachures = colorToLatexOrHTML('black')\n                  a3.hachures = 'north east lines'\n                  a3.opacite = 0.2\n                  objetsCorrection.push(a3)\n                }\n              }\n              objetsCorrection.push(a1, t1, l1)\n            } else {\n              // Pas de contact avec bord haut, le quart de cercle est complet et ensuite on a un autre quart de cercle\n              const quartDeC2 = arc(J, cabD, -90, true, 'pink', 'black', 0.3)\n              quartDeC2.hachures = 'north east lines'\n              quartDeC2.couleurDesHachures = colorToLatexOrHTML('black')\n              quartDeC2.opacite = 0.2\n              const Z = rotation(J, cabD, -45)\n              const r2 = afficheCoteSegment(\n                segment(cabD, Z),\n                `${longueurRestante1}\\\\,\\\\text{m}`,\n                0,\n                'black',\n                0.5,\n                0.5,\n                context.isHtml ? 'gray' : 'darkgray',\n                true,\n              )\n              objetsCorrection.push(quartDeC2, r2, diff)\n              if (longueurRestante1 > largeurCabane) {\n                const longueurRestante2 = longueurRestante1 - largeurCabane\n                const K = rotation(J, cabD, -90)\n                const quartDeC3 = arc(K, cabC, -90, true, 'pink', 'black', 0.2)\n                quartDeC3.hachures = 'north east lines'\n                quartDeC3.couleurDesHachures = colorToLatexOrHTML('black')\n                quartDeC3.opacite = 0.2\n                const W = rotation(K, cabC, -45)\n                const r3 = afficheCoteSegment(\n                  segment(cabC, W),\n                  `${longueurRestante2}\\\\,\\\\text{m}`,\n                  0,\n                  'black',\n                  0.5,\n                  0.5,\n                  context.isHtml ? 'gray' : 'darkgray',\n                  true,\n                )\n                objetsCorrection.push(quartDeC3, r3)\n              }\n            }\n          }\n          break\n        case 3:\n          /*********************************/\n          // cabane au centre\n          /*********************************/\n          {\n            cabA = pointAbstrait(\n              randint(\n                Math.ceil(longueurEnclos / 3) + longueurCabane,\n                longueurEnclos - 2,\n              ),\n              randint(\n                Math.max(2, Math.floor(largeurEnclos / 2 - largeurCabane / 2)),\n                Math.min(\n                  largeurEnclos - largeurCabane - 2,\n                  Math.floor(largeurEnclos / 2 + largeurCabane / 2),\n                ),\n              ),\n            )\n            cabB = pointAbstrait(cabA.x, cabA.y + largeurCabane)\n            cabD = pointAbstrait(cabA.x - longueurCabane, cabA.y)\n            cabC = pointAbstrait(cabD.x, cabB.y)\n            P = pointAbstrait(cabA.x - offsetPointP, cabA.y, 'P', 'above')\n            const hSousCabane = afficheCoteSegment(\n              segment(cabA, pointAbstrait(cabA.x, 0)),\n              `${cabA.y}\\\\,\\\\text{m}`,\n              0.2,\n              'darkgray',\n              1,\n              1,\n              context.isHtml ? 'gray' : 'darkgray',\n              true,\n            )\n            const offsetCabane = afficheCoteSegment(\n              segment(pointAbstrait(0, cabC.y), cabC),\n              `${cabC.x}\\\\,\\\\text{m}`,\n              0.2,\n              'darkgray',\n              1,\n              1,\n              context.isHtml ? 'gray' : 'darkgray',\n              true,\n            )\n            objetsEnonce.push(hSousCabane, offsetCabane)\n            // On détermine s'il y a des intersections\n            const longueurRestanteDroite = longueurCordelette - offsetPointP\n            const longueurRestanteGauche =\n              longueurCordelette - (longueurCabane - offsetPointP)\n            const longueurRestanteHautDroite =\n              longueurRestanteDroite - largeurCabane\n            const longueurRestanteHautGauche =\n              longueurRestanteGauche - largeurCabane\n\n            const isTouchAB = longueurCordelette > cabA.y\n            const isTouchCDByLeft =\n              cabD.y + longueurRestanteGauche > largeurEnclos\n            const isTouchCDByRight =\n              cabA.y + longueurRestanteDroite > largeurEnclos\n            // On commence par le dessous de la cabane\n            let M: PointAbstrait\n            let N: PointAbstrait\n            let I: PointAbstrait\n            let J: PointAbstrait\n            const c1 = cercle(P, longueurCordelette)\n            if (isTouchAB) {\n              // On commence par ajouter le triangle bas\n              M = pointIntersectionLC(AB, c1, '', 1)\n              if (M.x < 0) M = A\n              N = pointIntersectionLC(AB, c1, '', 2)\n              if (N.x > longueurEnclos) N = B\n              const t1 = polygone(P, M, N)\n              t1.couleurDeRemplissage = colorToLatexOrHTML('pink')\n              t1.opaciteDeRemplissage = 0.4\n              t1.couleurDesHachures = colorToLatexOrHTML('black')\n              t1.hachures = 'north east lines'\n              const r1 = afficheCoteSegment(\n                segment(P, M),\n                `${longueurCordelette}\\\\,\\\\text{m}`,\n                0,\n                'black',\n                0.5,\n                0.5,\n                context.isHtml ? 'gray' : 'darkgray',\n                true,\n              )\n              const r2 = afficheCoteSegment(\n                segment(P, N),\n                `${longueurCordelette}\\\\,\\\\text{m}`,\n                0,\n                'black',\n                0.5,\n                0.5,\n                context.isHtml ? 'gray' : 'darkgray',\n                true,\n              )\n              objetsCorrection.push(t1, r1, r2)\n              // arc gauche\n              const X = pointAbstrait(0, cabA.y)\n              if (P.x - longueurCordelette < 0 && M.x > 0) {\n                // contact à gauche\n                J = pointIntersectionLC(DA, c1, '', 2)\n              } else {\n                J = X\n              }\n              const a1 =\n                Math.abs(M.x) < 0.01\n                  ? polygone(M, P, J)\n                  : arc(M, P, angleOriente(M, P, J), true)\n              a1.opaciteDeRemplissage = 0.4\n              a1.couleurDeRemplissage = colorToLatexOrHTML('pink')\n              a1.couleurDesHachures = colorToLatexOrHTML('black')\n              a1.hachures = 'north east lines'\n              a1.opacite = 0.2\n              if (J.y < cabA.y) {\n                // On a dessiné un arc, mais il reste un triangle à faire\n                const t2 = polygone(P, J, X)\n                t2.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                t2.opaciteDeRemplissage = 0.4\n                t2.couleurDesHachures = colorToLatexOrHTML('black')\n                t2.hachures = 'north east lines'\n                t2.opacite = 0.2\n                const r2 = afficheCoteSegment(\n                  segment(cabD, X),\n                  `${cabD.x}\\\\,\\\\text{m}`,\n                  0,\n                  'black',\n                  0.5,\n                  0.5,\n                  context.isHtml ? 'gray' : 'darkgray',\n                  true,\n                )\n                objetsCorrection.push(t2, r2)\n              }\n              // arc droit\n              if (\n                P.x + longueurCordelette > longueurEnclos &&\n                N.x < longueurEnclos\n              ) {\n                // il y a contact avec la droite\n                I = pointIntersectionLC(BC, c1, '', 2)\n              } else {\n                I = pointAbstrait(\n                  Math.min(longueurEnclos, P.x + longueurCordelette),\n                  cabA.y,\n                )\n              }\n              const a2 =\n                N.x === longueurEnclos\n                  ? polygone(N, P, I)\n                  : arc(N, P, angleOriente(N, P, I), true)\n              a2.opaciteDeRemplissage = 0.4\n              a2.couleurDeRemplissage = colorToLatexOrHTML('pink')\n              a2.couleurDesHachures = colorToLatexOrHTML('black')\n              a2.hachures = 'north east lines'\n              a2.opacite = 0.2\n              objetsCorrection.push(a1, a2)\n            } else {\n              // On ne touche pas le fond, on dessine un arc\n              const X = pointAbstrait(P.x, P.y - longueurCordelette)\n              if (P.x + longueurCordelette >= longueurEnclos) {\n                // il y a contact avec la droite\n                I = pointIntersectionLC(BC, c1, '', 2)\n              } else {\n                I = pointAbstrait(P.x + longueurCordelette, cabA.y)\n              }\n              if (P.x - longueurCordelette < 0) {\n                // il y a contact avec la gauche\n                J = pointIntersectionLC(DA, c1, '', 2)\n              } else {\n                J = pointAbstrait(P.x - longueurCordelette, cabA.y)\n              }\n              const r1 = afficheCoteSegment(\n                segment(P, X),\n                `${longueurCordelette}\\\\,\\\\text{m}`,\n                0,\n                'black',\n                0.5,\n                0.5,\n                context.isHtml ? 'gray' : 'darkgray',\n                true,\n              )\n              const r2 = afficheCoteSegment(\n                segment(cabA, I),\n                `${longueurRestanteDroite}\\\\,\\\\text{m}`,\n                0,\n                'black',\n                0.5,\n                -0.5,\n                context.isHtml ? 'gray' : 'darkgray',\n                true,\n              )\n\n              const r3 = afficheCoteSegment(\n                segment(cabD, J),\n                `${longueurRestanteGauche}\\\\,\\\\text{m}`,\n                0,\n                'black',\n                0.5,\n                0.5,\n                context.isHtml ? 'gray' : 'darkgray',\n                true,\n              )\n              const a1 = arc(\n                I,\n                P,\n                -Math.abs(angleOriente(I, P, J)),\n                true,\n                'pink',\n                'black',\n                0.4,\n              )\n              a1.couleurDesHachures = colorToLatexOrHTML('black')\n              a1.hachures = 'north east lines'\n              a1.opacite = 0.2\n              objetsCorrection.push(a1, r1, r2, r3)\n            }\n            if (I.y < cabA.y) {\n              // on a dessiné un arc jusqu'au bord droit mais il reste un triangle à faire\n              const t2 = polygone(I, P, pointAbstrait(longueurEnclos, cabA.y))\n              t2.couleurDeRemplissage = colorToLatexOrHTML('pink')\n              t2.opaciteDeRemplissage = 0.4\n              t2.couleurDesHachures = colorToLatexOrHTML('black')\n              t2.hachures = 'north east lines'\n              t2.opacite = 0.2\n              objetsCorrection.push(t2)\n            }\n            // **********************************************\n            // On s'occupe de la partie à droite de la cabane\n            const c2 = cercle(cabA, longueurRestanteDroite)\n            const SDroit = pointIntersectionLC(droite(cabA, cabB), c2, '', 1)\n            let TDroit: PointAbstrait\n            let a2: Arc\n\n            if (!isTouchCDByRight) {\n              // On ne touche pas le haut, on peut tracer un arc jusqu'à la veticale du bord droit de la cabane\n              TDroit = cabB // C'est juste pour éviter de faire des tests de nullité, il ne sera pas utilisé si on ne touche pas le haut\n              if (P.x + longueurCordelette <= longueurEnclos) {\n                const extremiteDroite = pointAbstrait(\n                  P.x + longueurCordelette,\n                  cabA.y,\n                )\n                a2 = arc(\n                  extremiteDroite,\n                  cabA,\n                  angleOriente(extremiteDroite, cabA, SDroit),\n                  true,\n                  'pink',\n                  'black',\n                  0.3,\n                )\n              } else {\n                let T = pointIntersectionLC(BC, c2, '', 1)\n                if (T.y > largeurEnclos) T = C // ça ne devrait pas arriver vu qu'on n'est pas censé toucher le bord haut\n                const t2 = polygone(\n                  pointAbstrait(longueurEnclos, cabA.y),\n                  cabA,\n                  T,\n                )\n                t2.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                t2.opaciteDeRemplissage = 0.3\n                t2.couleurDesHachures = colorToLatexOrHTML('black')\n                t2.hachures = 'north east lines'\n                t2.opacite = 0.2\n                objetsCorrection.push(t2)\n                const r1 = afficheCoteSegment(\n                  segment(cabA, pointAbstrait(longueurEnclos, cabA.y)),\n                  `${longueurEnclos - cabA.x}\\\\,\\\\text{m}`,\n                  0,\n                  'black',\n                  0.5,\n                  -0.5,\n                  context.isHtml ? 'gray' : 'darkgray',\n                  true,\n                )\n                const r2 = afficheCoteSegment(\n                  segment(cabA, T),\n                  `${longueurRestanteDroite}\\\\,\\\\text{m}`,\n                  0,\n                  'black',\n                  0.5,\n                  -0.5,\n                  context.isHtml ? 'gray' : 'darkgray',\n                  true,\n                )\n                a2 = arc(\n                  T,\n                  cabA,\n                  angleOriente(T, cabA, SDroit),\n                  true,\n                  'pink',\n                  'black',\n                  0.3,\n                )\n                if (longueurRestanteHautDroite > 0) {\n                  const r3 = afficheCoteSegment(\n                    segment(\n                      cabB,\n                      pointAbstrait(\n                        cabB.x,\n                        cabC.y + longueurRestanteHautDroite,\n                      ),\n                    ),\n                    `${longueurRestanteHautDroite}\\\\,\\\\text{m}`,\n                    0,\n                    'black',\n                    0.5,\n                    -0.7,\n                    context.isHtml ? 'gray' : 'darkgray',\n                    true,\n                  )\n                  objetsCorrection.push(r3)\n                }\n                objetsCorrection.push(r1, r2)\n              }\n              a2.couleurDesHachures = colorToLatexOrHTML('black')\n              a2.hachures = 'north east lines'\n              a2.opacite = 0.2\n\n              objetsCorrection.push(a2)\n            } else {\n              // Là on va toucher en haut on doit donc s'arrêter avant de depasser le bord haut de l'enclos\n              const U = pointIntersectionLC(CD, c2, '', 2)\n              TDroit = pointAbstrait(cabA.x, largeurEnclos)\n              const r1 = afficheCoteSegment(\n                segment(cabA, pointAbstrait(longueurEnclos, cabA.y)),\n                `${longueurEnclos - cabA.x}\\\\,\\\\text{m}`,\n                0,\n                'black',\n                0.5,\n                -0.5,\n                context.isHtml ? 'gray' : 'darkgray',\n                true,\n              )\n              if (U.x - longueurEnclos >= 0) {\n                // le contact a lieu à droite de l'enclos on doit donc tracer un trapèze\n                const t3 = polygone(\n                  cabA,\n                  pointAbstrait(longueurEnclos, cabA.y),\n                  C,\n                  TDroit,\n                )\n                t3.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                t3.opaciteDeRemplissage = 0.3\n                t3.couleurDesHachures = colorToLatexOrHTML('black')\n                t3.hachures = 'north east lines'\n                t3.opacite = 0.2\n                objetsCorrection.push(t3)\n              } else {\n                // contact haut et droite, le coin C est inaccessible on trace un arc entre 2 triangles\n                if (P.x + longueurCordelette > longueurEnclos) {\n                  let T = pointIntersectionLC(BC, c2, '', 1)\n                  if (T.y > largeurEnclos) T = C // ça ne devrait pas arriver\n                  const t3 = polygone(\n                    cabA,\n                    pointAbstrait(longueurEnclos, cabA.y),\n                    T,\n                  )\n                  const t4 = polygone(cabA, U, TDroit)\n                  a2 = arc(\n                    T,\n                    cabA,\n                    angleOriente(T, cabA, U),\n                    true,\n                    'pink',\n                    'black',\n                    0.3,\n                  )\n                  ;[t3, a2, t4].forEach((obj) => {\n                    obj.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                    obj.opaciteDeRemplissage = 0.3\n                    obj.couleurDesHachures = colorToLatexOrHTML('black')\n                    obj.hachures = 'north east lines'\n                    obj.opacite = 0.2\n                  })\n                  objetsCorrection.push(t3, a2, t4)\n                }\n              }\n              objetsCorrection.push(r1)\n            }\n            // **********************************************\n            // On s'occupe de la partie à gauche de la cabane\n            const c3 = cercle(cabD, longueurRestanteGauche)\n            const SGauche = pointIntersectionLC(droite(cabC, cabD), c3, '', 1)\n            let TGauche: PointAbstrait\n            let a3: Arc\n            if (!isTouchCDByLeft) {\n              // On ne touche pas le haut, on peut tracer un arc jusqu'à la veticale du bord gauche de la cabane\n              TGauche = cabD // C'est juste pour éviter de faire des tests de nullité, il ne sera pas utilisé si on ne touche pas le haut\n              if (P.x - longueurCordelette >= 0) {\n                const extremiteGauche = pointAbstrait(\n                  P.x - longueurCordelette,\n                  cabA.y,\n                )\n                a3 = arc(\n                  extremiteGauche,\n                  cabD,\n                  angleOriente(extremiteGauche, cabD, SGauche),\n                  true,\n                  'pink',\n                  'black',\n                  0.3,\n                )\n                const r1 = afficheCoteSegment(\n                  segment(cabD, extremiteGauche),\n                  `${longueurRestanteGauche}\\\\,\\\\text{m}`,\n                  0,\n                  'black',\n                  0.5,\n                  0.5,\n                  context.isHtml ? 'gray' : 'darkgray',\n                  true,\n                )\n                objetsCorrection.push(r1)\n              } else {\n                let T = pointIntersectionLC(DA, c3, '', 1)\n                const r1 = afficheCoteSegment(\n                  segment(cabD, T),\n                  `${longueurRestanteGauche}\\\\,\\\\text{m}`,\n                  0,\n                  'black',\n                  0.5,\n                  -0.5,\n                  context.isHtml ? 'gray' : 'darkgray',\n                  true,\n                )\n                const r2 = afficheCoteSegment(\n                  segment(\n                    cabC,\n                    pointAbstrait(cabC.x, cabD.y + longueurRestanteGauche),\n                  ),\n                  `${longueurRestanteHautGauche}\\\\,\\\\text{m}`,\n                  0,\n                  'black',\n                  0.5,\n                  0.5,\n                  context.isHtml ? 'gray' : 'darkgray',\n                  true,\n                )\n                if (T.y > largeurEnclos) T = D // ça ne devrait pas arriver vu qu'on n'est pas censé toucher le bord haut\n                const t2 = polygone(pointAbstrait(0, cabA.y), cabD, T)\n                t2.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                t2.opaciteDeRemplissage = 0.3\n                t2.couleurDesHachures = colorToLatexOrHTML('black')\n                t2.hachures = 'north east lines'\n                t2.opacite = 0.2\n                objetsCorrection.push(t2, r1, r2)\n                a3 = arc(\n                  T,\n                  cabD,\n                  angleOriente(T, cabD, SGauche),\n                  true,\n                  'pink',\n                  'black',\n                  0.3,\n                )\n              }\n              a3.couleurDesHachures = colorToLatexOrHTML('black')\n              a3.hachures = 'north east lines'\n              a3.opacite = 0.2\n\n              objetsCorrection.push(a3)\n            } else {\n              // Là on va toucher en haut on doit donc s'arrêter avant de depasser le bord haut de l'enclos\n              const U = pointIntersectionLC(CD, c3, '', 1)\n              TGauche = pointAbstrait(cabD.x, largeurEnclos)\n              const r2 = afficheCoteSegment(\n                segment(TGauche, cabC),\n                `${largeurEnclos - cabC.y}\\\\,\\\\text{m}`,\n                -0.2,\n                'black',\n                0.5,\n                -0.7,\n                context.isHtml ? 'gray' : 'darkgray',\n                true,\n              )\n              objetsCorrection.push(r2)\n              if (U.x <= 0) {\n                // le contact a lieu à gauche de l'enclos on doit donc tracer un trapèze\n                const t3 = polygone(\n                  cabD,\n                  pointAbstrait(0, cabA.y),\n                  D,\n                  pointAbstrait(cabD.x, largeurEnclos),\n                )\n                t3.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                t3.opaciteDeRemplissage = 0.3\n                t3.couleurDesHachures = colorToLatexOrHTML('black')\n                t3.hachures = 'north east lines'\n                t3.opacite = 0.2\n                objetsCorrection.push(t3)\n              } else {\n                // contact haut avec le coin inaccessible : on cherche on trace un arc entre 2 triangles\n                let T: PointAbstrait\n                if (P.x - longueurCordelette <= 0) {\n                  // On touche à gauche\n                  T = pointIntersectionLC(DA, c3, '', 1)\n                  if (T.y > largeurEnclos) T = D // ça ne devrait pas arriver vu qu'on n'est pas censé toucher le bord haut\n                  if (T.y > cabD.y) {\n                    const t3 = polygone(cabD, pointAbstrait(0, cabA.y), T)\n                    t3.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                    t3.opaciteDeRemplissage = 0.3\n                    t3.couleurDesHachures = colorToLatexOrHTML('black')\n                    t3.hachures = 'north east lines'\n                    t3.opacite = 0.2\n                    objetsCorrection.push(t3)\n                  }\n                } else {\n                  // On ne touche pas à gauche}\n                  T = pointAbstrait(cabD.x - longueurRestanteGauche, cabD.y)\n                }\n                const t4 = polygone(cabD, U, TGauche)\n                const r2 = afficheCoteSegment(\n                  segment(cabD, U),\n                  `${longueurRestanteGauche}\\\\,\\\\text{m}`,\n                  0,\n                  'black',\n                  0.5,\n                  0.5,\n                  context.isHtml ? 'gray' : 'darkgray',\n                  true,\n                )\n                a3 = arc(\n                  T,\n                  cabD,\n                  angleOriente(T, cabD, U),\n                  true,\n                  'pink',\n                  'black',\n                  0.3,\n                )\n                ;[a3, t4].forEach((obj) => {\n                  obj.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                  obj.opaciteDeRemplissage = 0.3\n                  obj.couleurDesHachures = colorToLatexOrHTML('black')\n                  obj.hachures = 'north east lines'\n                  obj.opacite = 0.2\n                })\n                objetsCorrection.push(a3, t4, r2)\n              }\n            }\n            // **********************************************\n            // On s'occupe de la partie au-dessus de la cabane\n            if (\n              longueurRestanteHautDroite <= 0 &&\n              longueurRestanteHautGauche <= 0\n            ) {\n              break // Il n'y a pas de cordelette au dessus de la cabane\n            }\n            let VGauche: PointAbstrait | undefined\n            let VDroite: PointAbstrait | undefined\n\n            const c5 = cercle(cabB, Math.max(longueurRestanteHautDroite, 0))\n            const c6 = cercle(cabC, Math.max(longueurRestanteHautGauche, 0))\n            if (\n              longueurRestanteHautDroite + longueurRestanteHautGauche >=\n              cabB.x - cabC.x\n            ) {\n              // Il y a contact entre les deux arcs\n\n              const contact = pointIntersectionCC(c5, c6, '', 1)\n              if (isTouchCDByRight) {\n                VDroite = pointIntersectionLC(CD, c5, '', 1)\n              } else {\n                VDroite = SDroit\n              }\n              if (isTouchCDByLeft) {\n                VGauche = pointIntersectionLC(CD, c6, '', 2)\n              } else {\n                VGauche = SGauche\n              }\n\n              if (contact && contact.y < largeurEnclos) {\n                // PointAbstrait de contact en dessous du bord haut de l'enclos et au dessus de la cabane\n                if (TDroit.y === largeurEnclos && TDroit.x !== VDroite.x) {\n                  const t6 = polygone(cabB, TDroit, VDroite)\n                  t6.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                  t6.opaciteDeRemplissage = 0.3\n                  t6.couleurDesHachures = colorToLatexOrHTML('black')\n                  t6.hachures = 'north east lines'\n                  t6.opacite = 0.3\n                  objetsCorrection.push(t6)\n                }\n                if (TGauche.y === largeurEnclos && TGauche.x !== VGauche.x) {\n                  const t7 = polygone(cabC, TGauche, VGauche)\n                  t7.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                  t7.opaciteDeRemplissage = 0.3\n                  t7.couleurDesHachures = colorToLatexOrHTML('black')\n                  t7.hachures = 'north east lines'\n                  t7.opacite = 0.3\n                  objetsCorrection.push(t7)\n                }\n                if (contact.y > cabB.y) {\n                  const t7 = polygone(cabB, cabC, contact)\n                  t7.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                  t7.opaciteDeRemplissage = 0.3\n                  t7.couleurDesHachures = colorToLatexOrHTML('black')\n                  t7.hachures = 'north east lines'\n                  t7.opacite = 0.2\n                  objetsCorrection.push(t7)\n                }\n                const a4 = arc(\n                  contact,\n                  cabB,\n                  angleOriente(contact, cabB, VDroite),\n                  true,\n                  'pink',\n                  'black',\n                  0.3,\n                )\n                a4.couleurDesHachures = colorToLatexOrHTML('black')\n                a4.hachures = 'north east lines'\n                a4.opacite = 0.3\n                const a5 = arc(\n                  contact,\n                  cabC,\n                  angleOriente(contact, cabC, VGauche),\n                  true,\n                  'pink',\n                  'black',\n                  0.3,\n                )\n                a5.couleurDesHachures = colorToLatexOrHTML('black')\n                a5.hachures = 'north east lines'\n                a5.opacite = 0.3\n                objetsCorrection.push(a5, a4)\n              } else if (contact && contact.y >= largeurEnclos) {\n                // On trace un rectangle car les deux arcs se croisent au dessus de l'enclos\n                const t8 = polygone(\n                  cabB,\n                  pointAbstrait(cabB.x, largeurEnclos),\n                  pointAbstrait(cabC.x, largeurEnclos),\n                  cabC,\n                )\n                t8.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                t8.opaciteDeRemplissage = 0.2\n                t8.couleurDesHachures = colorToLatexOrHTML('black')\n                t8.hachures = 'north east lines'\n                t8.opacite = 0.2\n                objetsCorrection.push(t8)\n              }\n            } else {\n              // la cordelette ne permet pas de faire se toucher les deux arcs\n              // on trace séparément les deux arcs, parce qu'ils peuvent potentiellement ne pas exister\n              if (longueurRestanteHautDroite > 0) {\n                if (isTouchCDByRight) {\n                  VDroite = pointIntersectionLC(CD, c5, '', 1)\n                } else {\n                  VDroite = SDroit\n                }\n                const finDroite = pointIntersectionLC(\n                  droite(cabB, cabC),\n                  c5,\n                  '',\n                  1,\n                )\n                const a4 = arc(\n                  VDroite,\n                  cabB,\n                  angleOriente(VDroite, cabB, finDroite),\n                  true,\n                  'pink',\n                  'black',\n                  0.3,\n                )\n                a4.couleurDesHachures = colorToLatexOrHTML('black')\n                a4.hachures = 'north east lines'\n                a4.opacite = 0.2\n                const a6 = polygone(\n                  cabB,\n                  VDroite,\n                  pointAbstrait(cabB.x, largeurEnclos),\n                )\n                a6.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                a6.opaciteDeRemplissage = 0.3\n                a6.couleurDesHachures = colorToLatexOrHTML('black')\n                a6.hachures = 'north east lines'\n                a6.opacite = 0.3\n                objetsCorrection.push(a4, a6)\n              }\n              if (longueurRestanteHautGauche > 0) {\n                if (isTouchCDByLeft) {\n                  VGauche = pointIntersectionLC(CD, c6, '', 2)\n                } else {\n                  VGauche = SGauche\n                }\n                const finGauche = pointIntersectionLC(\n                  droite(cabB, cabC),\n                  c6,\n                  '',\n                  2,\n                )\n                const a5 = arc(\n                  VGauche,\n                  cabC,\n                  angleOriente(VGauche, cabC, finGauche),\n                  true,\n                  'pink',\n                  'black',\n                  0.3,\n                )\n                a5.couleurDesHachures = colorToLatexOrHTML('black')\n                a5.hachures = 'north east lines'\n                a5.opacite = 0.2\n                const a7 = polygone(\n                  cabC,\n                  VGauche,\n                  pointAbstrait(cabC.x, largeurEnclos),\n                )\n                a7.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                a7.opaciteDeRemplissage = 0.3\n                a7.couleurDesHachures = colorToLatexOrHTML('black')\n                a7.hachures = 'north east lines'\n                a7.opacite = 0.3\n                objetsCorrection.push(a5, a7)\n              }\n            }\n          }\n          break\n        case 1:\n        default:\n          /*********************************/\n          // cabane en haut à droite\n          /*********************************/\n          {\n            // éléments communs énoncé et correction\n            cabA = pointAbstrait(longueurEnclos, largeurEnclos - largeurCabane)\n            cabB = C\n            cabC = pointAbstrait(longueurEnclos - longueurCabane, largeurEnclos)\n            cabD = pointAbstrait(\n              longueurEnclos - longueurCabane,\n              largeurEnclos - largeurCabane,\n            )\n            P = pointAbstrait(\n              longueurEnclos - offsetPointP,\n              largeurEnclos - largeurCabane,\n              'P',\n              'above',\n            )\n\n            // éléments correction\n            const c1 = cercle(P, longueurCordelette)\n            const I = pointIntersectionLC(droite(B, C), c1, '', 2)\n            const r1Mes =\n              I.y === P.y\n                ? vide2d()\n                : placeLatexSurSegment(\n                    `${longueurCordelette}\\\\text{ m}`,\n                    P,\n                    I,\n                    {\n                      distance: -0.7,\n                      horizontal: true,\n                      letterSize: 'normalsize',\n                    },\n                  )\n            const J = homothetie(\n              P,\n              cabA,\n              (offsetPointP + longueurCordelette) / offsetPointP,\n            )\n            const t1 = polygone(I, cabA, P)\n            t1.couleurDeRemplissage = colorToLatexOrHTML('pink')\n            t1.opaciteDeRemplissage = 0.4\n            t1.couleurDesHachures = colorToLatexOrHTML('black')\n            t1.hachures = 'north east lines'\n            const a1 = arc(\n              I,\n              P,\n              -Math.abs(angleOriente(I, P, J)),\n              true,\n              'pink',\n              'black',\n              0.4,\n            )\n            a1.couleurDesHachures = colorToLatexOrHTML('black')\n            a1.hachures = 'north east lines'\n\n            const diff = afficheCoteSegment(\n              segment(P, cabD),\n              `${longueurCabane - offsetPointP}\\\\,\\\\text{m}`,\n              0.5,\n              'black',\n              1,\n              0.5,\n              'black',\n            )\n            const longRestante =\n              longueurCordelette - (longueurCabane - offsetPointP)\n            a1.opacite = 0.2\n            t1.opacite = 0.2\n            objetsCorrection.push(a1, r1Mes, t1)\n            if (longRestante < largeurCabane) {\n              const quartDeC2 = arc(J, cabD, -90, true, 'pink', 'black', 0.2)\n              quartDeC2.hachures = 'north east lines'\n              quartDeC2.couleurDesHachures = colorToLatexOrHTML('black')\n              quartDeC2.opacite = 0.2\n              const r2 = placeLatexSurSegment(\n                `${longRestante}\\\\,\\\\text{m}`,\n                cabD,\n                rotation(J, cabD, -90),\n                { distance: 0.7, horizontal: true, letterSize: 'normalsize' },\n              )\n\n              objetsCorrection.push(quartDeC2, r2, diff)\n            } else {\n              const c2 = cercle(cabD, longRestante)\n              const K = pointIntersectionLC(droite(C, D), c2, '', 1)\n              const a2 = arc(\n                J,\n                cabD,\n                -Math.abs(angleOriente(J, cabD, K)),\n                true,\n                'pink',\n                'black',\n                0.2,\n              )\n              a2.couleurDesHachures = colorToLatexOrHTML('black')\n              a2.hachures = 'north east lines'\n              const t2 = polygone(cabD, cabC, K)\n              t2.couleurDeRemplissage = colorToLatexOrHTML('pink')\n              t2.opaciteDeRemplissage = 0.2\n              t2.couleurDesHachures = colorToLatexOrHTML('black')\n              t2.hachures = 'north east lines'\n              const r2 = placeLatexSurSegment(\n                `${longRestante}\\\\,\\\\text{m}`,\n                cabD,\n                K,\n                { distance: 0.7, horizontal: true, letterSize: 'normalsize' },\n              )\n              t2.opacite = 0.2\n              a2.opacite = 0.2\n              objetsCorrection.push(a2, t2, r2, diff)\n            }\n          }\n          break\n      }\n      // objets communs à tous les types de questions\n      const indicEnclos = new BoiteBuilder({\n        xMin: 1,\n        xMax: 4,\n        yMin: largeurEnclos,\n        yMax: largeurEnclos + 1.2,\n      })\n      indicEnclos.addColor({\n        colorBackground: 'darkgray',\n        color: 'black',\n        opacity: 1,\n        backgroudOpacity: 0.2,\n      })\n      indicEnclos.addTextIn({\n        textIn: 'Enclos',\n        color: 'black',\n        opacity: 0.8,\n        size: 1,\n      })\n      const cabane = polygone(cabA, cabB, cabC, cabD)\n      const indicCabane = new BoiteBuilder({\n        xMin: (cabA.x + cabD.x) / 2 - 1.5,\n        xMax: (cabA.x + cabD.x) / 2 + 1.5,\n        yMin: (cabA.y + cabB.y) / 2 - 0.6,\n        yMax: (cabA.y + cabB.y) / 2 + 0.6,\n      })\n      indicCabane.addTextIn({\n        textIn: 'Cabane',\n        color: 'black',\n        opacity: 0.8,\n        size: 1,\n      })\n      indicCabane.addColor({\n        colorBackground: 'darkgray',\n        color: 'none',\n        opacity: 0,\n        backgroudOpacity: 0.2,\n      })\n      const longCab = afficheCoteSegment(\n        segment(cabC, cabB),\n        `${longueurCabane}\\\\text{ m}`,\n        0.2,\n        'black',\n        0.5,\n        0.7,\n        context.isHtml ? 'gray' : 'darkgray',\n        true,\n      )\n      const largCab = afficheCoteSegment(\n        segment(cabB, cabA),\n        `${largeurCabane}\\\\text{ m}`,\n        0.2,\n        'black',\n        0.5,\n        0.7,\n        context.isHtml ? 'gray' : 'darkgray',\n        true,\n      )\n      const distP = afficheCoteSegment(\n        segment(cabA, P),\n        `${offsetPointP}\\\\text{ m}`,\n        0.2,\n        'black',\n        0.5,\n        0.7,\n        'black',\n        true,\n      )\n      const longEnclos = afficheCoteSegment(\n        segment(B, A),\n        `${longueurEnclos}\\\\text{ m}`,\n        0.2,\n        'black',\n        1,\n        0.7,\n        context.isHtml ? 'gray' : 'darkgray',\n        true,\n      )\n      const largEnclos = afficheCoteSegment(\n        segment(A, D),\n        `${largeurEnclos}\\\\text{ m}`,\n        0.2,\n        'black',\n        1,\n        1,\n        context.isHtml ? 'gray' : 'darkgray',\n        true,\n      )\n      const ch = pointSurSegment(\n        P,\n        A,\n        longueurCordelette * 0.85,\n        '$\\\\text{chèvre}$',\n        'below left',\n      )\n      const chLablel = texteParPosition(\n        'chèvre',\n        ch.x - 0.6,\n        ch.y - 0.5,\n        0,\n        context.isHtml ? 'gray' : 'darkgray',\n        1,\n        'milieu',\n        false,\n        1,\n      )\n      const longe = cordelette(P, ch)\n      const longCord = texteParPosition(\n        'Corde',\n        (P.x + ch.x) / 2 + 0.5,\n        (P.y + ch.y) / 2 - 0.5,\n        0,\n        context.isHtml ? 'gray' : 'darkgray',\n        1,\n        'milieu',\n      )\n      const PetCh = tracePoint(P, ch)\n      PetCh.style = 'o'\n\n      objetsEnonce.push(\n        tracePoint(A),\n        enclos,\n        cabane,\n        indicCabane.render(),\n        indicEnclos.render(),\n        longCab,\n        largCab,\n        distP,\n        longEnclos,\n        largEnclos,\n        PetCh,\n        labelPoint(P),\n        chLablel,\n        longe,\n        longCord,\n      )\n      objetsCorrection.push(\n        enclos,\n        cabane,\n        indicCabane.render(),\n        indicEnclos.render(),\n        tracePoint(P),\n        labelPoint(P),\n        distP,\n        longCab,\n        largCab,\n      )\n\n      texte +=\n        \"Dans l'enclos rectangulaire représenté ci-dessous, on a attaché une chèvre à un piquet $(P)$ situé sur le mur d'une cabane rectangulaire, elle aussi.<br>\"\n      texte += `La corde qui limite les déplacements de la chèvre mesure $${longueurCordelette}\\\\,\\\\text{m}$.<br>`\n      texte += `${numAlpha(0)} Représenter le schéma de l'enclos en utilisant comme échelle : $1\\\\,\\\\text{cm}$ pour $1\\\\,\\\\text{m}$.<br>`\n      texte += `${numAlpha(1)} Délimiter et hachurer la zone de l'enclos dans laquelle peut brouter la chèvre.<br><br>`\n\n      texte += mathalea2d(\n        Object.assign({ scale: 0.5 }, fixeBordures(objetsEnonce)),\n        objetsEnonce,\n      )\n      texteCorr += mathalea2d(\n        Object.assign({}, fixeBordures(objetsCorrection)),\n        objetsCorrection,\n      )\n      if (\n        this.questionJamaisPosee(\n          i,\n          longueurEnclos,\n          largeurEnclos,\n          longueurCabane,\n          largeurCabane,\n          longueurCordelette,\n          offsetPointP,\n        )\n      ) {\n        this.listeQuestions.push(texte)\n        this.listeCorrections.push(texteCorr)\n        i++\n      }\n      cpt++\n    }\n  }\n}\n"],"names":["Cordelette","ObjetMathalea2D","A","amplitude","mollesse","color","__publicField","colorToLatexOrHTML","coeff","mainLevee","MainLevee","B","distance","nbPointsIntermediaires","pointsSVG","point","code","nbPoints","points","vecteurAB","vecteurPerp","normePerp","longueurAB","frequence1","frequence2","frequence3","amp1","amp2","amp3","seed","calculerDecalage","t","facteurExtremites","phase1","phase2","phase3","i","pointSurSegment","amplitudeDecalage","decalage","decalageGravite","pointDecale","pointAbstrait","tableauOptions","optionsDraw","coordonnees","cordelette","titre","interactifReady","dateDePublication","uuid","refs","ProblemeDeLaChevreDansSonEnclos","Exercice","listeTypesDeQuestions","gestionnaireFormulaireTexte","cpt","longueurEnclos","randint","largeurEnclos","longueurCabane","largeurCabane","offsetPointP","longueurCordelette","objetsEnonce","objetsCorrection","texte","texteCorr","C","D","AB","droite","BC","CD","DA","cabA","cabB","cabC","cabD","P","enclos","polygone","hSousCabane","afficheCoteSegment","segment","context","I","J","homothetie","c1","cercle","pointIntersectionLC","a1","arc","angleOriente","t1","M","N","a2","t2","r1Mes","longueurRestante1","diff","c2","l1","K","pointIntersectionDD","longueurRestante2","r1","t3","X","rotation","longueur","l2","a3","t4","quartDeC2","Z","r2","quartDeC3","W","r3","offsetCabane","longueurRestanteDroite","longueurRestanteGauche","longueurRestanteHautDroite","longueurRestanteHautGauche","isTouchAB","isTouchCDByLeft","isTouchCDByRight","SDroit","TDroit","U","T","obj","extremiteDroite","c3","SGauche","TGauche","extremiteGauche","VGauche","VDroite","c5","c6","contact","pointIntersectionCC","t6","t7","a4","a5","t8","finDroite","a6","finGauche","a7","vide2d","placeLatexSurSegment","longRestante","indicEnclos","BoiteBuilder","cabane","indicCabane","longCab","largCab","distP","longEnclos","largEnclos","ch","chLablel","texteParPosition","longe","longCord","PetCh","tracePoint","labelPoint","numAlpha","mathalea2d","fixeBordures"],"mappings":"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"}