{"version":3,"file":"polygonesParticuliers-BQc_Ltiy.js","sources":["../../src/lib/2d/polygonesParticuliers.ts"],"sourcesContent":["import { randint } from '../../modules/outils'\nimport { rangeMinMax } from '../outils/nombres'\nimport { lettreDepuisChiffre } from '../outils/outilString'\nimport { codageAngleDroit } from './CodageAngleDroit'\nimport { codageSegments } from './CodageSegment'\nimport type { ObjetMathalea2D } from './ObjetMathalea2D'\nimport { pointAbstrait, type PointAbstrait } from './PointAbstrait'\nimport { polygone, polygoneAvecNom } from './polygones'\nimport { homothetie, rotation, translation } from './transformations'\nimport { pointAdistance, pointSurSegment } from './utilitairesPoint'\nimport { vecteur } from './Vecteur'\n\n/*********************************************/\n/**\n * fonction qui retourne le parallélogramme ABCD dont on donne les 3 premiers points A, B et C\n *\n * @param {string} nom\n * @param {PointAbstrait} A\n * @param {PointAbstrait} B\n * @param {PointAbstrait} C\n * @return {PolygoneAvecNom}\n */\n\nexport function parallelogramme3points(\n  nom: string,\n  A: PointAbstrait,\n  B: PointAbstrait,\n  C: PointAbstrait,\n) {\n  const D = translation(A, vecteur(B, C), nom[3])\n  A.nom = nom[0]\n  B.nom = nom[1]\n  C.nom = nom[2]\n  return polygoneAvecNom(A, B, C, D)\n}\n/**\n * parallelogramme2points1hauteur(A,B,5) renvoie un parallélogramme ABCD de base [AB] et de hauteur h\n * parallelogramme2points1hauteur(A,7,5) renvoie un parallélogramme ABCD de base 7cm (le point B est choisi sur le cercle de centre A et de rayon 7cm) et de hauteur h\n *\n * @param {String} nom\n * @param {objet} A\n * @param {objet} B\n * @param {number} h\n * @return {PolygoneAvecNom}\n */\nexport function parallelogramme2points1hauteur(\n  nom: string,\n  A: PointAbstrait,\n  B: PointAbstrait,\n  h: number,\n) {\n  if (typeof B === 'number') {\n    B = pointAdistance(A, B, randint(-180, 180))\n  }\n  A.nom = nom[0]\n  B.nom = nom[1]\n  let H = rotation(B, A, 90)\n  H = pointSurSegment(A, H, h)\n  const pointHomothetie = homothetie(\n    B,\n    A,\n    randint(-5, 5, rangeMinMax(-2, 2)) / 10,\n  )\n  const D = translation(H, vecteur(A, pointHomothetie as PointAbstrait), nom[3])\n  const C = translation(D, vecteur(A, B), nom[2])\n  return polygoneAvecNom(A, B, C, D)\n}\n/**\n * Construit un rectangle à partir d'un point A et de deux longueurs\n * @param {PointAbstrait} A\n * @param {number} longueur\n * @param {number} largeur\n * @param {object} options\n * @param {string} [options.nom] noms des sommets\n * @param {number} [options.angleRotation] angle de rotation du rectangle\n * @return {PolygoneAvecNom}\n * @example rectangle1Point2Longueurs(A, 5, 3)\n * @example rectangle1Point2Longueurs(A, 5, 3, { nom: 'ABCD' })\n * @example rectangle1Point2Longueurs(A, 5, 3, { angleRotation: 45 })\n * @example rectangle1Point2Longueurs(A, 5, 3, { nom: 'ABCD', angleRotation: 45 })\n * @author Guillaume Valmont d'après 6M11 d'Eric Elter\n */\nexport function rectangle1Point2Longueurs(\n  A: PointAbstrait,\n  longueur: number,\n  largeur: number,\n  options: {\n    nom?: string\n    angleRotation?: number\n    avecCodageSegments?: boolean\n    avecCodagesAnglesDroits?: boolean\n  } = { avecCodageSegments: true, avecCodagesAnglesDroits: true },\n) {\n  const objets: ObjetMathalea2D[] = []\n  const angleRotation = options.angleRotation ?? 0\n  const B = pointAdistance(A, longueur, angleRotation)\n  const C = rotation(pointAdistance(B, largeur, 180 + angleRotation), B, -90)\n  const D = rotation(pointAdistance(A, largeur, angleRotation), A, 90)\n  if (options.nom) {\n    A.nom = options.nom[0]\n    B.nom = options.nom[1]\n    C.nom = options.nom[2]\n    D.nom = options.nom[3]\n  } else {\n    const numA = randint(1, 26)\n    const numB = randint(1, 26, [numA])\n    const numC = randint(1, 26, [numA, numB])\n    const numD = randint(1, 26, [numA, numB, numC])\n    A.nom = lettreDepuisChiffre(numA)\n    B.nom = lettreDepuisChiffre(numB)\n    C.nom = lettreDepuisChiffre(numC)\n    D.nom = lettreDepuisChiffre(numD)\n  }\n  objets.push(...polygoneAvecNom(A, B, C, D))\n  if (options.avecCodageSegments || options.avecCodageSegments === undefined) {\n    // Lorsqu'un objet d'options est passé, le avecCodageSegments: true par défaut est écrasé donc s'il n'est pas redéfini en false, on le considère comme true\n    objets.push(\n      codageSegments('/', 'red', B, C, D, A),\n      codageSegments('||', 'blue', A, B, C, D),\n    )\n  }\n  if (\n    options.avecCodagesAnglesDroits ||\n    options.avecCodagesAnglesDroits === undefined\n  ) {\n    // Lorsqu'un objet d'options est passé, le avecCodagesAnglesDroits: true par défaut est écrasé donc s'il n'est pas redéfini en false, on le considère comme true\n    objets.push(\n      codageAngleDroit(A, B, C),\n      codageAngleDroit(D, C, B),\n      codageAngleDroit(A, D, C),\n      codageAngleDroit(B, A, D),\n    )\n  }\n  return objets\n}\n\n/**\n * Trace le polygone régulier direct à n côtés qui a pour côté [AB]\n * Pour tracer le polygone régulier indirect de côté [AB], on iversera A et B\n * @param {PointAbstrait} A\n * @param {PointAbstrait} B\n * @param {number} n Nombre de côtés\n * @param {string} [color = 'black'] Couleur de l'arc ou 'none' : du type 'blue' ou du type '#f15929'\n * @return {Polygone}\n * @author Rémi Angot\n **/\nexport function polygoneRegulier(\n  A: PointAbstrait,\n  B: PointAbstrait,\n  n: number,\n  color = 'black',\n) {\n  const listePoints = [A, B]\n  for (let i = 1; i < n - 1; i++) {\n    listePoints[i + 1] = rotation(\n      listePoints[i - 1],\n      listePoints[i],\n      -180 + 360 / n,\n    )\n  }\n  return polygone(listePoints, color)\n}\n\n/**\n * polygoneRegulierParCentreEtRayon(O,r,n) //Trace le polygone régulier à n côtés et de rayon r\n * @returns {Polygone} Objet Mathalea2d\n * @author Rémi Angot\n */\nexport function polygoneRegulierParCentreEtRayon(\n  O: PointAbstrait,\n  r: number,\n  n: number,\n  color = 'black',\n) {\n  const p = []\n  p[0] = pointAbstrait(O.x + r, O.y)\n  for (let i = 1; i < n; i++) {\n    p[i] = rotation(p[i - 1], O, -360 / n)\n  }\n  return polygone(p, color)\n}\n\n/**\n * Trace un carré\n * @param {PointAbstrait} A Un sommet du carré\n * @param {PointAbstrait} B Un sommet du carré, consécutif au précédent\n * @param {string} [color = 'black'] Couleur de l'arc ou 'none' : du type 'blue' ou du type '#f15929'\n * @example carre(M,N)\n *  // Trace le carré noir de sommets consécutifs M et N dans le sens direct\n * @example carre(N,M)\n *  // Trace le carré noir de sommets consécutifs M et N dans le sens indirect\n * @example carre(M,N,'blue')\n *  // Trace le carré bleu de sommets consécutifs M et N dans le sens direct\n * @return {Polygone}\n * @author Rémi Angot\n * JSDOC Validee par EE Juin 2022\n *\n */\nexport function carre(A: PointAbstrait, B: PointAbstrait, color = 'black') {\n  return polygoneRegulier(A, B, 4, color)\n}\n"],"names":["parallelogramme2points1hauteur","nom","A","B","h","pointAdistance","randint","H","rotation","pointSurSegment","pointHomothetie","homothetie","rangeMinMax","D","translation","vecteur","C","polygoneAvecNom","rectangle1Point2Longueurs","longueur","largeur","options","objets","angleRotation","numA","numB","numC","numD","lettreDepuisChiffre","codageSegments","codageAngleDroit","polygoneRegulier","n","color","listePoints","i","polygone","polygoneRegulierParCentreEtRayon","O","r","p","pointAbstrait","carre"],"mappings":"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"}