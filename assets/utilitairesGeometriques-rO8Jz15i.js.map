{"version":3,"file":"utilitairesGeometriques-rO8Jz15i.js","sources":["../../src/lib/2d/colorToLatexOrHtml.ts","../../src/lib/2d/utilitairesGeometriques.ts"],"sourcesContent":["/**\n * convertHexToRGB convertit une couleur en hexadécimal (sans le #) en un tableau RVB avec des valeurs entre 0 et 255.\n * @param {string} [couleur='000000'] Code couleur HTML sans le #\n * @example convertHexToRGB('f15929')=[241,89,41]\n * @author Eric Elter\n * @return {number[]}\n */\n\nexport const colours = {\n  aliceblue: '#f0f8ff',\n  antiquewhite: '#faebd7',\n  aqua: '#00ffff',\n  aquamarine: '#7fffd4',\n  azure: '#f0ffff',\n  beige: '#f5f5dc',\n  bisque: '#ffe4c4',\n  black: '#000000',\n  blanchedalmond: '#ffebcd',\n  blue: '#0000ff',\n  blueviolet: '#8a2be2',\n  brown: '#a52a2a',\n  burlywood: '#deb887',\n  cadetblue: '#5f9ea0',\n  chartreuse: '#7fff00',\n  chocolate: '#d2691e',\n  coral: '#ff7f50',\n  cornflowerblue: '#6495ed',\n  cornsilk: '#fff8dc',\n  crimson: '#dc143c',\n  cyan: '#00ffff',\n  darkblue: '#00008b',\n  darkcyan: '#008b8b',\n  darkgoldenrod: '#b8860b',\n  darkgray: '#a9a9a9',\n  darkgreen: '#006400',\n  darkkhaki: '#bdb76b',\n  darkmagenta: '#8b008b',\n  darkolivegreen: '#556b2f',\n  darkorange: '#ff8c00',\n  darkorchid: '#9932cc',\n  darkred: '#8b0000',\n  darksalmon: '#e9967a',\n  darkseagreen: '#8fbc8f',\n  darkslateblue: '#483d8b',\n  darkslategray: '#2f4f4f',\n  darkturquoise: '#00ced1',\n  darkviolet: '#9400d3',\n  deeppink: '#ff1493',\n  deepskyblue: '#00bfff',\n  dimgray: '#696969',\n  dodgerblue: '#1e90ff',\n  firebrick: '#b22222',\n  floralwhite: '#fffaf0',\n  forestgreen: '#228b22',\n  fuchsia: '#ff00ff',\n  gainsboro: '#dcdcdc',\n  ghostwhite: '#f8f8ff',\n  gold: '#ffd700',\n  goldenrod: '#daa520',\n  gray: '#808080',\n  green: '#008000',\n  greenyellow: '#adff2f',\n  honeydew: '#f0fff0',\n  hotpink: '#ff69b4',\n  'indianred ': '#cd5c5c',\n  indigo: '#4b0082',\n  ivory: '#fffff0',\n  khaki: '#f0e68c',\n  lavender: '#e6e6fa',\n  lavenderblush: '#fff0f5',\n  lawngreen: '#7cfc00',\n  lemonchiffon: '#fffacd',\n  lightblue: '#add8e6',\n  lightcoral: '#f08080',\n  lightcyan: '#e0ffff',\n  lightgoldenrodyellow: '#fafad2',\n  lightgray: '#d3d3d3',\n  lightgrey: '#d3d3d3',\n  lightgreen: '#90ee90',\n  lightpink: '#ffb6c1',\n  lightsalmon: '#ffa07a',\n  lightseagreen: '#20b2aa',\n  lightskyblue: '#87cefa',\n  lightslategray: '#778899',\n  lightsteelblue: '#b0c4de',\n  lightyellow: '#ffffe0',\n  lime: '#00ff00',\n  limegreen: '#32cd32',\n  linen: '#faf0e6',\n  magenta: '#ff00ff',\n  maroon: '#800000',\n  mediumaquamarine: '#66cdaa',\n  mediumblue: '#0000cd',\n  mediumorchid: '#ba55d3',\n  mediumpurple: '#9370d8',\n  mediumseagreen: '#3cb371',\n  mediumslateblue: '#7b68ee',\n  mediumspringgreen: '#00fa9a',\n  mediumturquoise: '#48d1cc',\n  mediumvioletred: '#c71585',\n  midnightblue: '#191970',\n  mintcream: '#f5fffa',\n  mistyrose: '#ffe4e1',\n  moccasin: '#ffe4b5',\n  navajowhite: '#ffdead',\n  navy: '#000080',\n  oldlace: '#fdf5e6',\n  olive: '#808000',\n  olivedrab: '#6b8e23',\n  orange: '#ffa500',\n  orangered: '#ff4500',\n  orchid: '#da70d6',\n  palegoldenrod: '#eee8aa',\n  palegreen: '#98fb98',\n  paleturquoise: '#afeeee',\n  palevioletred: '#d87093',\n  papayawhip: '#ffefd5',\n  peachpuff: '#ffdab9',\n  peru: '#cd853f',\n  pink: '#ffc0cb',\n  plum: '#dda0dd',\n  powderblue: '#b0e0e6',\n  purple: '#800080',\n  rebeccapurple: '#663399',\n  red: '#ff0000',\n  rosybrown: '#bc8f8f',\n  royalblue: '#4169e1',\n  saddlebrown: '#8b4513',\n  salmon: '#fa8072',\n  sandybrown: '#f4a460',\n  seagreen: '#2e8b57',\n  seashell: '#fff5ee',\n  sienna: '#a0522d',\n  silver: '#c0c0c0',\n  skyblue: '#87ceeb',\n  slateblue: '#6a5acd',\n  slategray: '#708090',\n  snow: '#fffafa',\n  springgreen: '#00ff7f',\n  steelblue: '#4682b4',\n  tan: '#d2b48c',\n  teal: '#008080',\n  thistle: '#d8bfd8',\n  tomato: '#ff6347',\n  turquoise: '#40e0d0',\n  violet: '#ee82ee',\n  wheat: '#f5deb3',\n  white: '#ffffff',\n  whitesmoke: '#f5f5f5',\n  yellow: '#ffff00',\n  yellowgreen: '#9acd32',\n}\nexport type ColourNames = keyof typeof colours\n\n// JSDOC Validee par EE Juin 2022\nfunction convertHexToRGB(couleur = '000000') {\n  const hexDecoupe = couleur.match(/.{1,2}/g)\n  if (hexDecoupe !== null && hexDecoupe.length === 3) {\n    return [\n      Number.parseInt(hexDecoupe[0], 16),\n      Number.parseInt(hexDecoupe[1], 16),\n      Number.parseInt(hexDecoupe[2], 16),\n    ]\n  } else {\n    window.notify(\n      'Une couleur est mal formée. Veuillez le signaler aux développeurs de MathALEA.',\n      { couleur },\n    )\n    return [0, 0, 0]\n  }\n}\n\nexport function convertColorWithDieseToLatex(color: string) {\n  if (!color.startsWith('#')) return color\n  const rgb = convertHexToRGB(color.replace('#', ''))\n  return '{rgb,255:red,' + rgb[0] + ';green,' + rgb[1] + ';blue,' + rgb[2] + '}'\n}\n/**\n * colorToLatexOrHTML prend en paramètre une couleur sous forme prédéfinie ('red','yellow',...) ou sous forme HTML en hexadécimal (avec #, genre '#f15929')\n * La sortie de cette fonction est un tableau où :\n * - le premier élément est cette couleur exploitable en SVG, donc en HTML.\n * - le second élément est cette couleur exploitable en TikZ, donc en Latex.\n * @param {string} couleur Une couleur du type 'blue' ou du type '#f15929'\n * @example colorToLatexOrHTML('red')=['red','{red}']\n * @example colorToLatexOrHTML('#f15929')=['#f15929','{rgb,255:red,241;green,89;blue,41}']\n * @example colorToLatexOrHTML('')=''\n * @example colorToLatexOrHTML('none')=['none','none']\n * @author Eric Elter\n * @return {[string,string]}\n */\n// JSDOC Validee par EE Juin 2022\nexport function colorToLatexOrHTML(couleur: string): [string, string] {\n  // let rgb = []\n  if (Array.isArray(couleur) && couleur.length === 2) {\n    if (couleur[1] === 'none') couleur[1] = '' // pas de 'none' comme couleur en latex !\n    if (couleur.length === 2) {\n      return [String(couleur[0]), String(couleur[1])]\n    } else {\n      window.notify(\n        'Une couleur est mal formée. Veuillez le signaler aux développeurs de MathALEA.',\n        { couleur },\n      )\n      return ['', '']\n    }\n    // Si jamais une fonction rappelle une couleur qui aurait déjà été transformée par cette même fonction\n    // else if (couleur === undefined || couleur === '') return '' // EE : 01/10/2023 : Code commenté au profit de celui de dessus pour vérifier si une couleur nulle se ballade dans le projet.\n  } else if (couleur === undefined || couleur === '') {\n    window.notify(\n      'Une couleur est undefined ou bien une chaine vide. Veuillez le signaler aux développeurs de MathALEA.',\n      { couleur },\n    )\n    return ['', '']\n  } else if (couleur === 'none') {\n    return ['none', ''] // 'none' n'est pas une couleur valide en latex ! Modifié par Jean-Claude Lhote le 19:&é:éàé\"\n  } else {\n    const tabCouleur: string[] = []\n    tabCouleur[0] = couleur\n    if (couleur[0] === '#') {\n      tabCouleur[1] = convertColorWithDieseToLatex(couleur)\n    } else {\n      tabCouleur[1] = `{${couleur}}`.replace('{{', '{').replace('}}', '}')\n    }\n    return tabCouleur.slice(0, 2) as [string, string]\n  }\n}\n\n/**\n * Convertit un code couleur en sa valeur hexadecimale\n * @param {string} color Une couleur du type 'blue' et uniquement de ce type\n * @example convertCodeCouleurToHex('beige')='#f5f5dc'\n * @author Eric Elter\n * @return {boolean||string} Retourne false si le code couleur ne peut pas être converti car non trouvé dans la liste\n */\n// JSDOC Validee par EE Novembre 2022\nexport function convertCodeCouleurToHex(color: ColourNames) {\n  if (typeof colours[color] !== 'undefined') {\n    return colours[color]\n  }\n  window.notify(\n    'La couleur ' +\n      color +\n      \" n'a pas été trouvée dans la liste des couleurs prédéfinies.\",\n    { color },\n  )\n  return '#ffffff'\n}\n\n/**\n * Assombrit ou éclaircit une couleur\n * @param {string} couleur Une couleur du type 'blue' ou du type '#f15929'\n * @param {number} coefficient Plus grand est un coefficient positif et plus on éclaircit. Plus petit est un coefficient négatif et plus on assombrit.\n * @example assombrirOuEclaircir('beige',20) renvoie une couleur beige plus claire.\n * @example assombrirOuEclaircir('f15929',-30) renvoie une couleur orange plus foncée.\n * @author Eric Elter\n * @return {string} Retourne le code hexadecimal de la nouvelle couleur\n */\n// JSDOC Validee par EE Novembre 2022\nexport function assombrirOuEclaircir(\n  couleur: ColourNames,\n  coefficient: number,\n) {\n  let convertCodeCouleur = convertCodeCouleurToHex(couleur) ?? couleur\n  convertCodeCouleur = convertCodeCouleur.replace('#', '')\n  if (convertCodeCouleur.length === 6) {\n    const decimalColor = Number.parseInt(convertCodeCouleur, 16)\n    let r = (decimalColor >> 16) + coefficient\n    r > 255 && (r = 255)\n    r < 0 && (r = 0)\n    let g = (decimalColor & 0x0000ff) + coefficient\n    g > 255 && (g = 255)\n    g < 0 && (g = 0)\n    let b = ((decimalColor >> 8) & 0x00ff) + coefficient\n    b > 255 && (b = 255)\n    b < 0 && (b = 0)\n    return `#${(g | (b << 8) | (r << 16)).toString(16)}`\n  } else {\n    return convertCodeCouleur\n  }\n}\n","import type {\n  ICercle,\n  IDroite,\n  IPointAbstrait,\n  IPolygone,\n  ISegment,\n} from './Interfaces'\n\n/**\n * Teste l'appartenance d'un point dans un triangle\n * @param {IPointAbstrait} M Point à tester\n * @param {IPointAbstrait} A Premier sommet du triangle\n * @param {IPointAbstrait} B Deuxième sommet du triangle\n * @param {IPointAbstrait} C Troisième sommet du triangle\n * @example estDansTriangle(M, V, S, T) // Renvoie true si M appartient au triangle VST, false sinon\n * @author Eric Elter\n * @return {boolean}\n */\nexport function estDansTriangle(\n  M: IPointAbstrait,\n  A: IPointAbstrait,\n  B: IPointAbstrait,\n  C: IPointAbstrait,\n): boolean {\n  const vMA = { x: A.x - M.x, y: A.y - M.y }\n  const vMB = { x: B.x - M.x, y: B.y - M.y }\n  const vMC = { x: C.x - M.x, y: C.y - M.y }\n  const x1 = vMB.x * vMC.y - vMB.y * vMC.x\n  const x2 = vMC.x * vMA.y - vMC.y * vMA.x\n  const x3 = vMA.x * vMB.y - vMA.y * vMB.x\n  return (x1 >= 0 && x2 >= 0 && x3 >= 0) || (x1 <= 0 && x2 <= 0 && x3 <= 0)\n}\n\n/**\n * Teste l'appartenance d'un point dans un quadrilatère\n * @param {IPointAbstrait} M Point à tester\n * @param {IPointAbstrait} A Premier sommet du quadrilatère\n * @param {IPointAbstrait} B Deuxième sommet du quadrilatère\n * @param {IPointAbstrait} C Troisième sommet du quadrilatère\n * @param {IPointAbstrait} D Quatrième sommet du quadrilatère\n * @example estDansQuadrilatere(M, F, G, H, I) // Renvoie true si M appartient au quadrilatère FGHI, false sinon\n * @author Eric Elter\n * @return {boolean}\n */\nexport function estDansQuadrilatere(\n  M: IPointAbstrait,\n  A: IPointAbstrait,\n  B: IPointAbstrait,\n  C: IPointAbstrait,\n  D: IPointAbstrait,\n): boolean {\n  return estDansTriangle(M, A, B, C) || estDansTriangle(M, A, C, D)\n}\n\n/**\n * Teste l'appartenance d'un point à un polygone convexe\n * @param {IPointAbstrait} M Point à tester\n * @param {Polygone} p Polygone dont on veut tester l'appartenance avec le point\n * @example estDansPolygoneConvexe(M, p1) // Renvoie true si M appartient au polygone convexe p1, false sinon\n * @author Jean-Claude Lhote\n * @return {boolean}\n */\nexport function estDansPolygoneConvexe(\n  M: IPointAbstrait,\n  p: IPolygone,\n): boolean {\n  const l = p.listePoints.length\n  if (l === 3) {\n    return estDansTriangle(\n      M,\n      p.listePoints[0],\n      p.listePoints[1],\n      p.listePoints[2],\n    )\n  } else {\n    const A = p.listePoints[0]\n    const B = p.listePoints[1]\n    const C = p.listePoints[l - 1]\n    // Import dynamique pour éviter la circularité\n    const { polygone } = require('./polygones')\n    const p2 = polygone(...p.listePoints.slice(1))\n    if (estDansTriangle(M, A, B, C)) return true\n    else return estDansPolygoneConvexe(M, p2)\n  }\n}\n\n/**\n * Teste l'appartenance d'un point à tout type de polygone (non convexe ou convexe)\n * Pour info, la fonction utilise une triangulation du polygone réalisée par la librairie earcut\n * @param {IPointAbstrait} M Point à tester\n * @param {Polygone} p Polygone dont on veut tester l'appartenance avec le point\n * @example estDansPolygone(M, p1) // Renvoie true si M appartient au polygone p1, false sinon\n * @author Jean-Claude Lhote\n * @return {boolean}\n */\nexport function estDansPolygone(M: IPointAbstrait, p: IPolygone): boolean {\n  for (const triangle of p.triangulation) {\n    if (estDansTriangle(M, triangle[0], triangle[1], triangle[2])) return true\n  }\n  return false\n}\n\n/**\n * Teste si un point M est sur un objet géométrique (droite, segment, demi-droite, cercle)\n */\nexport function pointEstSur(\n  M: IPointAbstrait,\n  objet:\n    | IDroite\n    | ISegment\n    | { extremite1: IPointAbstrait; extremite2: IPointAbstrait }\n    | ICercle,\n): boolean {\n  // Droite (ax + by + c = 0)\n  if ('pente' in objet) {\n    return Math.abs(objet.a * M.x + objet.b * M.y + objet.c) <= 0.01\n  }\n\n  // Segment (borné) — détection via propriété longueur (ISegment)\n  if ('extremite1' in objet && 'extremite2' in objet && 'longueur' in objet) {\n    const prodvect =\n      (objet.extremite2.x - objet.extremite1.x) * (M.y - objet.extremite1.y) -\n      (M.x - objet.extremite1.x) * (objet.extremite2.y - objet.extremite1.y)\n    const prodscal =\n      (M.x - objet.extremite1.x) * (objet.extremite2.x - objet.extremite1.x) +\n      (M.y - objet.extremite1.y) * (objet.extremite2.y - objet.extremite1.y)\n    const prodscalABAB =\n      (objet.extremite2.x - objet.extremite1.x) ** 2 +\n      (objet.extremite2.y - objet.extremite1.y) ** 2\n    return (\n      Math.abs(prodvect) <= 0.01 && prodscal >= 0 && prodscal <= prodscalABAB\n    )\n  }\n\n  // Demi-droite (non bornée dans un sens) — détection générique par extremite1/extremite2\n  if ('extremite1' in objet && 'extremite2' in objet) {\n    const OM = { x: M.x - objet.extremite1.x, y: M.y - objet.extremite1.y }\n    const vd = {\n      x: objet.extremite2.x - objet.extremite1.x,\n      y: objet.extremite2.y - objet.extremite1.y,\n    }\n    const prodscal = OM.x * vd.x + OM.y * vd.y\n    const prodvect = OM.x * vd.y - OM.y * vd.x\n    return Math.abs(prodvect) <= 0.01 && Math.abs(prodscal) >= 0.01\n  }\n\n  // Cercle (distance au centre = rayon)\n  if ('rayon' in objet && 'centre' in objet) {\n    return Math.abs(longueur(M, objet.centre) - Number(objet.rayon)) <= 0.01\n  }\n\n  return false\n}\n\nexport const longueur = (\n  A: IPointAbstrait,\n  B: IPointAbstrait,\n  precision = 2,\n): number => {\n  const dx = B.x - A.x\n  const dy = B.y - A.y\n  return Number(Math.sqrt(dx * dx + dy * dy).toFixed(precision))\n}\n/**\n * Convertit un nombre de degrés quelconque en une mesure comprise entre -180 et 180\n * @param {number} a Valeur en degrés dont on cherche la valeur entre -180 et 180\n * @example x = angleModulo(170)\n * // x contient 170\n * @example x = angleModulo(190)\n * // x contient -170\n * @example x = angleModulo(3690)\n * // x contient 90\n * @example x = angleModulo(180)\n * // x contient 180\n * @example x = angleModulo(-180)\n * // x contient 180\n * @return {number}\n */\n// JSDOC Validee par EE Juin 2022\n\nexport function angleModulo(a: number) {\n  while (a <= -180) a = a + 360\n  while (a > 180) a = a - 360\n  return a\n} /**\n * Retourne la valeur signée de la mesure d'un angle en degré\n * @param {PointAbstrait} A Point sur un côté de l'angle\n * @param {PointAbstrait} O Sommet de l'angle\n * @param {PointAbstrait} B Point sur l'autre côté de l'angle\n * @param {number} [precision = 2] Nombre maximal de décimales de la valeur arrondie de la mesure de l'angle orienté\n * @example x = angleOriente(H,E,T)\n * // x contient la valeur de la mesure de l'angle orienté HET, arrondie au centième\n * @example x = angleOriente(H,E,T,0)\n * // x contient la valeur de la mesure de l'angle orienté HET, arrondie à l'unité\n * @return {number}\n * @author Jean-Claude Lhote\n */\nexport function angleOriente(\n  A: IPointAbstrait,\n  O: IPointAbstrait,\n  B: IPointAbstrait,\n  precision = 2,\n) {\n  const OA = longueur(O, A, precision)\n  const OB = longueur(O, B, precision)\n  if (OA < 1e-12 || OB < 1e-12) {\n    // On considère qu'un côté de l'angle a une longueur nulle, et ce n'est pas normal !\n    return 0\n  }\n\n  // Vecteurs OA et OB\n  const vOA = { x: A.x - O.x, y: A.y - O.y }\n  const vOB = { x: B.x - O.x, y: B.y - O.y }\n\n  // Produit vectoriel (déterminant 2D) : OA × OB\n  const produitVectoriel = vOA.x * vOB.y - vOA.y * vOB.x\n\n  // Signe de l'angle orienté\n  const signe = produitVectoriel >= 0 ? 1 : -1\n\n  return Number((signe * angle(A, O, B, 10)).toFixed(precision))\n} /**\n * Retourne la valeur la mesure d'un angle en radian\n * @param {PointAbstrait} A Point sur un côté de l'angle\n * @param {PointAbstrait} O Sommet de l'angle\n * @param {PointAbstrait} B Point sur l'autre côté de l'angle\n * @param {number} [precision = 2] Nombre maximal de décimales de la valeur arrondie de la mesure de l'angle orienté\n * @example x = angleradian(H,E,T)\n * // x contient la valeur de la mesure de l'angle HET en radians, arrondie au centième\n * @example x = angleradian(H,E,T,0)\n * // x contient la valeur de la mesure de l'angle HET en radians, arrondie à l'unité\n * @return {number}\n * @author Rémi Angot\n */\n// JSDOC Validee par EE Juin 2022\n\nexport function angleradian(\n  A: IPointAbstrait,\n  O: IPointAbstrait,\n  B: IPointAbstrait,\n  precision = 2,\n) {\n  const OA = longueur(O, A, precision)\n  const OB = longueur(O, B, precision)\n  const AB = longueur(A, B, precision)\n  return Number(\n    Math.acos((AB ** 2 - OA ** 2 - OB ** 2) / (-2 * OA * OB)).toFixed(\n      precision,\n    ),\n  )\n} /**\n * Renvoie la mesure d'angle en degré\n * @param {PointAbstrait} A Point sur un côté de l'angle\n * @param {PointAbstrait} O Sommet de l'angle\n * @param {PointAbstrait} B Point sur l'autre côté de l'angle\n * @param {number} [precision = 2] Nombre maximal de décimales de la valeur arrondie de la mesure de l'angle\n * @example x = angle(H,E,T)\n * // x contient la mesure en degré de l'angle HET, arrondi au centième\n * @example x = angle(H,E,T,0)\n * // x contient la mesure en degré de l'angle HET, arrondi à l'unité\n * @return {number}\n * @author Rémi Angot\n */\n// JSDOC Validee par EE Juin 2022\n\nexport function angle(\n  A: IPointAbstrait,\n  O: IPointAbstrait,\n  B: IPointAbstrait,\n  precision = 2,\n) {\n  const OA = longueur(O, A, precision)\n  const OB = longueur(O, B, precision)\n  const AB = longueur(A, B, precision)\n  if (OA > 0 && OB > 0) {\n    const v = { x: A.x - O.x, y: A.y - O.y }\n    const w = { x: B.x - O.x, y: B.y - O.y }\n    if (Math.abs(v.x * w.y - v.y * w.x) <= 0.000000000001) {\n      // vecteurs colinéaires à epsilon près pour éviter les effets de bords dus aux flottants.\n      if (v.x * w.x > 0) return 0\n      else if (v.x * w.x < 0) return 180\n      else if (v.y * w.y > 0) return 0\n      else return 180\n    } else {\n      let cos = (AB ** 2 - OA ** 2 - OB ** 2) / (-2 * OA * OB)\n      if (cos < -1) cos = -1\n      if (cos > 1) cos = 1\n      const alpha = Math.acos(cos)\n      return Number(((alpha * 180) / Math.PI).toFixed(precision))\n    }\n  } else {\n    // Ce n'est pas normal de demander la mesure d'un angle dont un côté a une longueur nulle.\n    return 0\n  }\n}\n/**\n * norme(V) renvoie la norme du vecteur\n *\n * @author Rémi Angot\n */\n\nexport function norme(v: { x: number; y: number }): number {\n  return Math.sqrt(v.x ** 2 + v.y ** 2)\n}\n\n/**\n * Teste si un segment coupe un cercle, une droite, une demi-droite ou un autre segment\n * Déleste la classe Segment pour éviter les dépendances circulaires.\n */\nexport function estSecant(\n  s:\n    | ISegment\n    | {\n        extremite1: IPointAbstrait\n        extremite2: IPointAbstrait\n      },\n  objet:\n    | IDroite\n    | ISegment\n    | {\n        extremite1: IPointAbstrait\n        extremite2: IPointAbstrait\n      }\n    | ICercle,\n): boolean {\n  const A = s.extremite1\n  const B = s.extremite2\n  const eps = 0.01\n\n  // Segment dégénéré: on teste si l’unique point est sur l’objet\n  if (Math.abs(A.x - B.x) < eps && Math.abs(A.y - B.y) < eps) {\n    return pointEstSur(A, objet as any)\n  }\n\n  // Aides internes\n  const lineFrom2Pts = (P: IPointAbstrait, Q: IPointAbstrait) => {\n    // ax + by + c = 0\n    const a = P.y - Q.y\n    const b = Q.x - P.x\n    const c = P.x * Q.y - Q.x * P.y\n    return { a, b, c }\n  }\n  const intersectLines = (\n    L1: { a: number; b: number; c: number },\n    L2: { a: number; b: number; c: number },\n  ): IPointAbstrait | null => {\n    const det = L1.a * L2.b - L2.a * L1.b\n    if (Math.abs(det) < 1e-12) return null\n    const x = (L1.b * L2.c - L2.b * L1.c) / det\n    const y = (L1.c * L2.a - L2.c * L1.a) / det\n    return { x, y, nom: '' } as IPointAbstrait\n  }\n  const onSegment = (M: IPointAbstrait, P: IPointAbstrait, Q: IPointAbstrait) =>\n    Math.min(P.x, Q.x) - eps <= M.x &&\n    M.x <= Math.max(P.x, Q.x) + eps &&\n    Math.min(P.y, Q.y) - eps <= M.y &&\n    M.y <= Math.max(P.y, Q.y) + eps &&\n    Math.abs((Q.x - P.x) * (M.y - P.y) - (Q.y - P.y) * (M.x - P.x)) <= eps\n\n  const dist2PointSegment = (\n    M: IPointAbstrait,\n    P: IPointAbstrait,\n    Q: IPointAbstrait,\n  ) => {\n    const vx = Q.x - P.x\n    const vy = Q.y - P.y\n    const wx = M.x - P.x\n    const wy = M.y - P.y\n    const vv = vx * vx + vy * vy\n    if (vv === 0) return (M.x - P.x) ** 2 + (M.y - P.y) ** 2\n    let t = (wx * vx + wy * vy) / vv\n    t = Math.max(0, Math.min(1, t))\n    const px = P.x + t * vx\n    const py = P.y + t * vy\n    return (M.x - px) ** 2 + (M.y - py) ** 2\n  }\n\n  // Cercle\n  if ('rayon' in (objet as any) && 'centre' in (objet as any)) {\n    const R = Number((objet as ICercle).rayon)\n    const C = (objet as ICercle).centre\n    const d2 = dist2PointSegment(C, A, B)\n    if (d2 <= (R + eps) ** 2) return true\n    // sinon, pas d’intersection\n    return false\n  }\n\n  // Droite (via équation ax+by+c=0 si dispo)\n  if ('a' in (objet as any) && 'b' in (objet as any) && 'c' in (objet as any)) {\n    const Ls = lineFrom2Pts(A, B)\n    const Ld = {\n      a: (objet as any).a as number,\n      b: (objet as any).b as number,\n      c: (objet as any).c as number,\n    }\n    const I = intersectLines(Ls, Ld)\n    return I != null && onSegment(I, A, B)\n  }\n\n  // Segment ou demi-droite générique (extrémités)\n  if ('extremite1' in (objet as any) && 'extremite2' in (objet as any)) {\n    const C = (objet as any).extremite1 as IPointAbstrait\n    const D = (objet as any).extremite2 as IPointAbstrait\n    const L1 = lineFrom2Pts(A, B)\n    const L2 = lineFrom2Pts(C, D)\n    const I = intersectLines(L1, L2)\n\n    if (I == null) {\n      // Parallèles ou confondues -> tester recouvrement (points sur l’autre)\n      return (\n        onSegment(A, C, D) ||\n        onSegment(B, C, D) ||\n        onSegment(C, A, B) ||\n        onSegment(D, A, B)\n      )\n    }\n\n    // Si l’objet dispose d’une longueur => segment borné, sinon demi-droite\n    const isOtherSegment = 'longueur' in (objet as any)\n\n    const IOnS = onSegment(I, A, B)\n    if (!IOnS) return false\n    if (isOtherSegment) return onSegment(I, C, D)\n\n    // Demi-droite: vérifier la direction (produit scalaire >= 0 par rapport à C->D)\n    const dirx = D.x - C.x\n    const diry = D.y - C.y\n    const vix = I.x - C.x\n    const viy = I.y - C.y\n    return vix * dirx + viy * diry >= -eps\n  }\n\n  // Par défaut\n  return false\n}\n/**\n * Normalise un angle pour l'orientation d'un div\n * Les divs HTML ne supportent bien la rotation que dans l'intervalle [-180, 180]\n * Cette fonction convertit n'importe quel angle en son équivalent dans cet intervalle\n * @param orientation Angle en degrés (peut être négatif ou > 360)\n * @returns Angle normalisé entre -180 et 180 degrés\n * @example normaliseOrientation(326) // retourne -34\n * @example normaliseOrientation(190) // retourne -170\n * @example normaliseOrientation(-200) // retourne 160\n */\nexport function normaliseOrientation(orientation: number): number {\n  // Ramène d'abord l'angle dans [0, 360[\n  let angle = orientation % 360\n\n  // Gère les angles négatifs\n  if (angle < 0) {\n    angle += 360\n  }\n\n  // Convertit en [-180, 180]\n  if (angle > 180) {\n    angle -= 360\n  }\n\n  return angle\n}\n"],"names":["colours","convertHexToRGB","couleur","hexDecoupe","convertColorWithDieseToLatex","color","rgb","colorToLatexOrHTML","tabCouleur","convertCodeCouleurToHex","assombrirOuEclaircir","coefficient","convertCodeCouleur","decimalColor","r","g","b","estDansTriangle","M","A","B","C","vMA","vMB","vMC","x1","x2","x3","estDansQuadrilatere","D","estDansPolygone","p","triangle","pointEstSur","objet","prodvect","prodscal","prodscalABAB","OM","vd","longueur","precision","dx","dy","angleModulo","a","angleOriente","O","OA","OB","vOA","vOB","signe","angle","AB","v","w","cos","alpha","norme","estSecant","s","eps","lineFrom2Pts","P","Q","c","intersectLines","L1","L2","det","x","y","onSegment","dist2PointSegment","vx","vy","wx","wy","vv","t","px","py","R","Ls","Ld","I","isOtherSegment","dirx","diry","vix","viy","normaliseOrientation","orientation"],"mappings":"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"}