{"version":3,"file":"lists-OzKsERu-.js","sources":["../../src/lib/format/lists.ts"],"sourcesContent":["import { context } from '../../modules/context'\n\n// const unorderedListTypes: string[] = ['puces', 'carres', 'qcm', 'fleches']\nconst orderedListTypes: string[] = [\n  'nombres',\n  'alpha',\n  'Alpha',\n  'roman',\n  'Roman',\n]\n\nconst labelsByStyle = new Map([\n  ['puces', '$\\\\bullet$'],\n  ['carres', '\\\\tiny$\\\\blacksquare$'],\n  ['qcm', '$\\\\square$'],\n  ['fleches', '\\\\tiny$\\\\blacktriangleright$'],\n  ['nombres', '\\\\arabic*.'],\n  ['alpha', '\\\\alph*.'],\n  ['Alpha', '\\\\Alph*.'],\n  ['roman', '\\\\roman*.'],\n  ['Roman', '\\\\Roman*.'],\n])\n\ntype ListStyle =\n  | 'none'\n  | 'puces'\n  | 'carres'\n  | 'qcm'\n  | 'fleches'\n  | 'nombres'\n  | 'alpha'\n  | 'Alpha'\n  | 'roman'\n  | 'Roman'\nexport type DescriptionItem = {\n  /**\n   * Entête de la description\n   */\n  description: string\n  /**\n   * Texte de la description\n   */\n  text: string\n}\n\nexport type List<T> = {\n  /**\n   * Entrée de la liste ou déclaration d'une autre liste\n   */\n  items: (string | DescriptionItem | T)[]\n  /**\n   * Style pour les puces ou les numérotations. Sera ajouté à `class` et traité par `app.css`\n   */\n  style: ListStyle\n  /**\n   * Options (optionnelles) de mise en forme pour la liste à ajouter `class`\n   */\n  classOptions?: string\n  /**\n   * Texte (optionnel) précédent la liste\n   */\n  introduction?: string\n}\n\ninterface NestedList extends List<NestedList> {}\n\n/**\n * Vérifier si le type d'un objet est bien `DescriptionItem`\n * (`typeof` ne fonctionnant pas pour les types maison)\n * @see https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates\n * @param item Objet à controller\n * @returns `true` si l'objet est de type `DescriptionItem`\n */\nexport function isDescriptionItem(\n  item: DescriptionItem | NestedList,\n): item is DescriptionItem {\n  return (item as DescriptionItem).description !== undefined\n}\n\n/**\n * Contruit une liste formattée suivant un style à partir d'un tableau de chaînes de caractères comme entrées.\n * @param {NestedList} list Objet décrivant la liste\n * @param {number} startWith Numéro de départ pour les listes numérotées\n * @returns {string} chaîne représentant le code HTML ou LaTeX à afficher suivant la variable `context.isHtml`\n * @author sylvain, Jean-Léon Henry\n * @link https://forge.apps.education.fr/coopmaths/mathalea/-/wikis/Numérotation-et-listes\n */\nexport function createList(\n  list: NestedList,\n  shift: string = '',\n  startWith: number = 1,\n  nestedLevel: number = 0,\n): string {\n  const isOrdered: boolean = orderedListTypes.includes(list.style)\n  let lineStart = list.style === 'none' ? '' : '\\t\\\\item '\n  let lineEnd = list.style === 'none' ? '\\\\par' : ''\n  const lineBreak: string = '\\n'\n  const label: string = labelsByStyle.get(list.style) ?? '' // only used in latex output\n  const HTMLCorrection: string = startWith > 1 ? ` start='${startWith}'` : ''\n  const LaTeXCorrection: string =\n    startWith > 1\n      ? ` \\\\setcounter{enum${'i'.repeat(nestedLevel + 1)}}{${startWith - 1}}`\n      : ''\n  let openingTagOrdered = '\\\\begin{enumerate}'\n  let openingTagUnordered = '\\\\begin{itemize}'\n  let closingTagOrdered = '\\\\end{enumerate}'\n  let closingTagUnordered = '\\\\end{itemize}'\n  let openingTagLine: string\n  let output = ''\n\n  if (context.isHtml) {\n    lineStart = list.style === 'none' ? '<li>' : '\\t<li>'\n    lineEnd = '</li>'\n\n    let classOptionsFormatted = list.classOptions ?? ''\n    if (classOptionsFormatted !== '') {\n      classOptionsFormatted = ' ' + classOptionsFormatted\n    }\n    openingTagOrdered = `<ol class='${list.style}${classOptionsFormatted}'${HTMLCorrection}>`\n    openingTagUnordered = `<ul class='${list.style}${classOptionsFormatted}'>`\n    closingTagOrdered = '</ol>'\n    closingTagUnordered = '</ul>'\n  }\n\n  const openingTag = isOrdered ? openingTagOrdered : openingTagUnordered\n  const closingTag = isOrdered ? closingTagOrdered : closingTagUnordered\n  openingTagLine = lineBreak + shift + openingTag\n  const closingTagLine = shift + closingTag + lineBreak\n\n  if (!context.isHtml && label.length !== 0) {\n    openingTagLine += `[label=${label}]` + LaTeXCorrection\n  } else {\n    openingTagLine += !context.isHtml ? LaTeXCorrection : ''\n  }\n\n  openingTagLine += lineBreak\n  output += openingTagLine\n\n  function lineFactory(\n    inside: string,\n    before: string = shift + lineStart,\n    after: string = lineEnd + lineBreak,\n  ) {\n    return before + inside + after\n  }\n\n  for (const item of list.items) {\n    let liContent = ''\n    if (typeof item === 'string') {\n      liContent = item\n    } else if (isDescriptionItem(item)) {\n      if (!context.isHtml) {\n        output += lineFactory(\n          item.text,\n          shift + `\\t\\\\item[\\\\textbf{${item.description}}] `,\n        )\n        continue\n      }\n      const span = `<span>${item.description}</span>`\n      liContent = span + item.text\n    } else {\n      // item is neither a string or a DescriptionItem, it's probably a sublist\n      liContent =\n        (item.introduction ?? '') +\n        createList(item, shift + '\\t', 1, nestedLevel++)\n    }\n    output += lineFactory(liContent)\n  }\n\n  output += closingTagLine\n  return output\n}\n"],"names":["orderedListTypes","labelsByStyle","isDescriptionItem","item","createList","list","shift","startWith","nestedLevel","isOrdered","lineStart","lineEnd","lineBreak","label","HTMLCorrection","LaTeXCorrection","openingTagOrdered","openingTagUnordered","closingTagOrdered","closingTagUnordered","openingTagLine","output","context","classOptionsFormatted","openingTag","closingTag","closingTagLine","lineFactory","inside","before","after","liContent"],"mappings":"wCAGA,MAAMA,EAA6B,CACjC,UACA,QACA,QACA,QACA,OACF,EAEMC,MAAoB,IAAI,CAC5B,CAAC,QAAS,YAAY,EACtB,CAAC,SAAU,uBAAuB,EAClC,CAAC,MAAO,YAAY,EACpB,CAAC,UAAW,8BAA8B,EAC1C,CAAC,UAAW,YAAY,EACxB,CAAC,QAAS,UAAU,EACpB,CAAC,QAAS,UAAU,EACpB,CAAC,QAAS,WAAW,EACrB,CAAC,QAAS,WAAW,CACvB,CAAC,EAoDM,SAASC,EACdC,EACyB,CACzB,OAAQA,EAAyB,cAAgB,MACnD,CAUO,SAASC,EACdC,EACAC,EAAgB,GAChBC,EAAoB,EACpBC,EAAsB,EACd,CACR,MAAMC,EAAqBT,EAAiB,SAASK,EAAK,KAAK,EAC/D,IAAIK,EAAYL,EAAK,QAAU,OAAS,GAAK,WACzCM,EAAUN,EAAK,QAAU,OAAS,QAAU,GAChD,MAAMO,EAAoB;AAAA,EACpBC,EAAgBZ,EAAc,IAAII,EAAK,KAAK,GAAK,GACjDS,EAAyBP,EAAY,EAAI,WAAWA,CAAS,IAAM,GACnEQ,EACJR,EAAY,EACR,qBAAqB,IAAI,OAAOC,EAAc,CAAC,CAAC,KAAKD,EAAY,CAAC,IAClE,GACN,IAAIS,EAAoB,qBACpBC,EAAsB,mBACtBC,EAAoB,mBACpBC,EAAsB,iBACtBC,EACAC,EAAS,GAEb,GAAIC,EAAQ,OAAQ,CAClBZ,EAAYL,EAAK,QAAU,OAAS,OAAS,QAC7CM,EAAU,QAEV,IAAIY,EAAwBlB,EAAK,cAAgB,GAC7CkB,IAA0B,KAC5BA,EAAwB,IAAMA,GAEhCP,EAAoB,cAAcX,EAAK,KAAK,GAAGkB,CAAqB,IAAIT,CAAc,IACtFG,EAAsB,cAAcZ,EAAK,KAAK,GAAGkB,CAAqB,KACtEL,EAAoB,QACpBC,EAAsB,OACxB,CAEA,MAAMK,EAAaf,EAAYO,EAAoBC,EAC7CQ,EAAahB,EAAYS,EAAoBC,EACnDC,EAAiBR,EAAYN,EAAQkB,EACrC,MAAME,EAAiBpB,EAAQmB,EAAab,EAExC,CAACU,EAAQ,QAAUT,EAAM,SAAW,EACtCO,GAAkB,UAAUP,CAAK,IAAME,EAEvCK,GAAmBE,EAAQ,OAA2B,GAAlBP,EAGtCK,GAAkBR,EAClBS,GAAUD,EAEV,SAASO,EACPC,EACAC,EAAiBvB,EAAQI,EACzBoB,EAAgBnB,EAAUC,EAC1B,CACA,OAAOiB,EAASD,EAASE,CAC3B,CAEA,UAAW3B,KAAQE,EAAK,MAAO,CAC7B,IAAI0B,EAAY,GAChB,GAAI,OAAO5B,GAAS,SAClB4B,EAAY5B,UACHD,EAAkBC,CAAI,EAAG,CAClC,GAAI,CAACmB,EAAQ,OAAQ,CACnBD,GAAUM,EACRxB,EAAK,KACLG,EAAQ,oBAAqBH,EAAK,WAAW,KAAA,EAE/C,QACF,CAEA4B,EADa,SAAS5B,EAAK,WAAW,UACnBA,EAAK,IAC1B,MAEE4B,GACG5B,EAAK,cAAgB,IACtBC,EAAWD,EAAMG,EAAQ,IAAM,EAAGE,GAAa,EAEnDa,GAAUM,EAAYI,CAAS,CACjC,CAEA,OAAAV,GAAUK,EACHL,CACT"}