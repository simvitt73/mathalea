{"version":3,"file":"2F20-4--RB-IDaB.js","sources":["../../src/exercices/2e/2F20-4.ts"],"sourcesContent":["import { handleAnswers } from '../../lib/interactif/gestionInteractif'\nimport { ajouteChampTexteMathLive } from '../../lib/interactif/questionMathLive'\nimport { Polynome } from '../../lib/mathFonctions/Polynome'\nimport { interpolationDeLagrange } from '../../lib/mathFonctions/outilsMaths'\nimport { choice } from '../../lib/outils/arrayOutils'\nimport { reduirePolynomeDegre3 } from '../../lib/outils/ecritures'\nimport { miseEnEvidence } from '../../lib/outils/embellissements'\nimport { lettreMinusculeDepuisChiffre } from '../../lib/outils/outilString'\nimport { texNombre } from '../../lib/outils/texNombre'\nimport { randint } from '../../modules/outils'\nimport Exercice from '../Exercice'\n\nimport Figure from 'apigeom'\nimport { courbe } from '../../lib/2d/Courbe'\nimport { point } from '../../lib/2d/PointAbstrait'\nimport RepereBuilder from '../../lib/2d/RepereBuilder'\nimport { colorToLatexOrHTML } from '../../lib/2d/colorToLatexOrHtml'\nimport { fixeBordures } from '../../lib/2d/fixeBordures'\nimport { segment } from '../../lib/2d/segmentsVecteurs'\nimport { latex2d } from '../../lib/2d/textes'\nimport { mathalea2d } from '../../modules/mathalea2d'\n\nexport const titre = 'Résoudre graphiquement une équation ou une inéquation'\nexport const dateDePublication = '29/10/2023'\nexport const dateDeModifImportante = '24/04/2024'\nexport const interactifReady = true\nexport const interactifType = 'mathLive'\n\n/**\n * Résoudre graphiquement une équation ou une inéquation\n *\n * @author Jean-Claude Lhote\n */\n\nexport const uuid = '28997'\n\nexport const refs = {\n  'fr-fr': ['2F20-4'],\n  'fr-ch': ['2mIneq-1'],\n}\ntype TypesDeFonction = 'constante' | 'affine' | 'poly2' | 'poly3'\n\n/**\n * retourne le yMin pour cadrer la figure\n * @param poly1\n * @param poly2\n */\nfunction trouveMaxMin(\n  poly1: Polynome,\n  poly2: Polynome,\n  np1: {\n    x: number\n    y: number\n  }[],\n  np2: {\n    x: number\n    y: number\n  }[],\n): number {\n  // on s'embête pas avec les constantes, elles sont toujours dans la fenêtre\n  // on ne s'embête pas avec les affines, la encore, on sait comment elles se comportent quand elles sortent de la fenêtre\n  // on va chercher donc le min et le max de fct1 et fct2 si ce sont au moins des polynomes de degré 2\n  const fPrime1 = poly1.derivee()\n  const fPrime2 = poly2.derivee()\n  let yMin1: number\n  let yMin2: number\n  if (fPrime1.deg === 2) {\n    const [c, b, a] = fPrime1.monomes as [number, number, number]\n    const delta1 = b ** 2 - 4 * a * c\n    if (delta1 > 0) {\n      // deux racines dérivée négative entre les racines donc fonction croissante puis décroissante puis croissante ou l'inverse selon le signe de a\n      const ptitDelta1 = Math.sqrt(delta1)\n      const x1 = (-b - ptitDelta1) / (2 * a)\n      const x2 = (-b + ptitDelta1) / (2 * a)\n      yMin1 =\n        a > 0 ? poly1.image(Math.max(x1, x2)) : poly1.image(Math.min(x1, x2))\n    } else {\n      // une seule racine la dérivée est du signe de a sur tout l'intervalle donc monotone, on ne cherche pas de min\n      yMin1 = 0\n    }\n  } else if (fPrime1.deg === 1) {\n    // poly de degré 2\n    const [b, a] = fPrime1.monomes as [number, number]\n    if (a < 0) {\n      // la courbe est concave, on ne cherche pas de min\n      yMin1 = 0\n    } else {\n      yMin1 = poly1.image(-b / a)\n    }\n  } else {\n    // c'est une fonction affine, on ne cherche pas de min\n    yMin1 = 0\n  }\n  if (fPrime2.deg === 2) {\n    const [c, b, a] = fPrime2.monomes as [number, number, number]\n    const delta2 = b ** 2 - 4 * a * c\n    if (delta2 > 0) {\n      // deux racines dérivée négative entre les racines donc fonction croissante puis décroissante puis croissante ou l'inverse selon le signe de a\n      const ptitDelta2 = Math.sqrt(delta2)\n      const x1 = (-b - ptitDelta2) / (2 * a)\n      const x2 = (-b + ptitDelta2) / (2 * a)\n      yMin2 =\n        a > 0 ? poly2.image(Math.max(x1, x2)) : poly2.image(Math.min(x1, x2))\n    } else {\n      // une seule racine ou aucune la dérivée est du signe de a sur tout l'intervalle donc monotone, on ne cherche pas de min\n      yMin2 = 0\n    }\n  } else if (fPrime2.deg === 1) {\n    // poly de degré 2\n    const [b, a] = fPrime2.monomes as [number, number]\n    if (a < 0) {\n      // la courbe est concave, on ne cherche pas de min\n      yMin2 = 0\n    } else {\n      yMin2 = poly2.image(-b / a)\n    }\n  } else {\n    // c'est une fonction affine, on ne cherche pas de min\n    yMin2 = 0\n  }\n\n  return Math.min(\n    yMin1,\n    yMin2,\n    ...np1.map((el) => el.y),\n    ...np2.map((el) => el.y),\n  )\n}\n\nfunction renseigneFonction(poly: Polynome) {\n  const func = poly.fonction\n  const monomesNormalized = poly.monomes.slice()\n  while (monomesNormalized.length < 4) {\n    monomesNormalized.push(0)\n  }\n  const [a, b, c, d]: [number, number, number, number] = monomesNormalized\n    .map(Number)\n    .reverse()\n    .map((el: number) => (Math.abs(el) < 1e-10 ? 0 : el)) as [\n    number,\n    number,\n    number,\n    number,\n  ]\n  const expr: string = reduirePolynomeDegre3(a, b, c, d)\n    .replaceAll('\\\\,', '')\n    .replaceAll('{,}', '.')\n  return { func, expr, poly }\n}\n\n/**\n * La fonction pour récupérer les intervalles de solutions\n * @param fonc\n * @param inferieur\n */\nexport function chercheIntervalles(\n  fonc: Polynome,\n  soluces: number[],\n  inferieur: boolean,\n  xMin: number,\n  xMax: number,\n): string {\n  const liste = [xMin, ...soluces, xMax]\n  const values = liste.filter((el, i) => el !== liste[i + 1])\n  const solutions: string[] = []\n  for (let i = 0; i < values.length - 1; i++) {\n    const middle = (values[i] + values[i + 1]) / 2\n    const imageMiddle = fonc.image(middle)\n    if ((imageMiddle < 0 && inferieur) || (!inferieur && imageMiddle > 0)) {\n      solutions.push(\n        `[${texNombre(values[i], 1)};${texNombre(values[i + 1], 1)}]`,\n      )\n    } else if (\n      i === values.length - 2 &&\n      soluces[soluces.length - 1] === xMax\n    ) {\n      solutions.push(`\\\\{${texNombre(values[i + 1], 1)}\\\\}`)\n    }\n  }\n  return solutions.join('\\\\cup')\n}\n\nclass resolutionEquationInequationGraphique extends Exercice {\n  // On déclare des propriétés supplémentaires pour cet exercice afin de pouvoir les réutiliser dans la correction\n  figureApiGeom!: Figure\n\n  constructor() {\n    super()\n    this.nbQuestions = 1\n    this.listePackages = ['tkz-base']\n    this.nbQuestionsModifiable = false\n    this.formatChampTexte = 'none' // Pour un exercice de type simple qui n'utilise pas le champ de réponse\n    this.exoCustomResultat = true\n    this.answers = {}\n    this.sup2 = 10\n    this.sup = 1\n    this.besoinFormulaireNumerique = [\n      'Choix des questions',\n      3,\n      '1 : Résoudre une équation\\n2 : Résoudre une inéquation\\n3: Résoudre une équation et une inéquation',\n    ]\n    this.besoinFormulaire2Numerique = [\n      'Choix des deux fonctions',\n      10,\n      'Constante-affine\\nConstante-degré2\\nConstante-degré3\\nAffine-affine\\nAffine-degré2\\nAffine-degré3\\nDegré2-degré2\\nDegré2-degré3\\nDegré3-degré3\\nMélange',\n    ]\n  }\n\n  nouvelleVersion(): void {\n    // on va chercher une spline aléatoire\n\n    this.listeCorrections = ['']\n\n    const aleaF1 = randint(1, 20, [5, 9, 10, 15]) // EE : J'enlève e, i, j et o.\n    const f1 = lettreMinusculeDepuisChiffre(aleaF1)\n    const f2 = lettreMinusculeDepuisChiffre(\n      randint(1, 20, [5, 9, 10, 15, aleaF1]),\n    )\n    const choixFonctions = this.sup2 < 10 ? this.sup2 : randint(1, 9)\n    let integraleDiff: number\n    let f1Type: TypesDeFonction\n    let f2Type: TypesDeFonction\n    let fonction1: {\n      func: (x: number) => number\n      expr: string\n      poly: Polynome\n    }\n    let fonction2: {\n      func: (x: number) => number\n      expr: string\n      poly: Polynome\n    }\n    let texteCorr = ''\n    const xbase = randint(-2, 2)\n    const x0 = -4 + xbase\n    const x1 = randint(-2, -1) + xbase\n    const x2 = randint(1, 2) + xbase\n    const x3 = 4 + xbase\n    const decalAxe = randint(0, 2)\n    const xMin = x0 - decalAxe - 1\n    const xMax = xMin + 10\n    let yMin\n    let cpt = 0\n    do {\n      // Une boucle pour tester des valeurs et on sort si les courbes sont suffisamment distantes      }\n      // On choisit les noeuds passants (il en faut 4 pour déterminer un poly3, qui peut le plus peut le moins !\n      cpt++\n      let y0: number\n      let y1: number\n      let y2: number\n      let y3: number\n      let vec1: {\n        u: number\n        v: number\n      }\n      let vec2: {\n        u: number\n        v: number\n      }\n      let vec3: {\n        u: number\n        v: number\n      }\n      // Calcul des coordonnées d'un vecteur\n      const vector = (x0: number, y0: number, x1: number, y1: number) =>\n        Object.assign(\n          {},\n          {\n            u: x1 - x0,\n            v: y1 - y0,\n          },\n        )\n      // est-ce que deux vecteurs sont colinéaires ou à peu près colinéaires\n      const areColineaires = (\n        v1: {\n          u: number\n          v: number\n        },\n        v2: {\n          u: number\n          v: number\n        },\n      ) => Boolean(Math.abs(v1.u * v2.v - v1.v * v2.u) < 0.1)\n      if (this.sup2 < 7) {\n        // il faut des points alignés et une pente pas trop importante\n        do {\n          y0 = randint(-2, 2)\n          y1 = randint(-3, 3, y0)\n        } while (Math.abs((y1 - y0) / (x1 - x0)) > 1)\n        const a = (y1 - y0) / (x1 - x0)\n        const b = y1 - a * x1\n        y2 = a * x2 + b\n        y3 = a * x3 + b\n      } else {\n        do {\n          y0 = randint(-2, 2)\n          y1 = randint(-3, 3, y0)\n          y2 = randint(-4, 4, y1)\n          y3 = randint(-2, 3, [y0, y2, y1])\n          vec1 = vector(x0, y0, x1, y1)\n          vec2 = vector(x0, y0, x2, y2)\n          vec3 = vector(x0, y0, x3, y3)\n        } while (areColineaires(vec1, vec2) || areColineaires(vec1, vec3)) // On cherche des points non alignés\n      }\n\n      // les noeuds passants qu'on trie dans l'ordre des x croissants\n      // on initialise noeudsPassants1 et noeudsPassants2. Les 4 noeuds sont identiques, mais on va les changer selon le type de fonction\n\n      const noeudsPassants1 = [\n        { x: x0, y: y0 },\n        { x: x1, y: y1 },\n        { x: x2, y: y2 },\n        { x: x3, y: y3 },\n      ].sort((el1, el2) => el1.x - el2.x)\n      const noeudsPassants2 = [\n        { x: x0, y: y0 },\n        { x: x1, y: y1 },\n        { x: x2, y: y2 },\n        { x: x3, y: y3 },\n      ].sort((el1, el2) => el1.x - el2.x)\n\n      switch (\n        choixFonctions // On choisit les fonctions demandées\n      ) {\n        case 1: // constante et affine\n          {\n            f1Type = 'constante'\n            f2Type = 'affine'\n            // C'est l'index du point d'intersection\n            const indexPI = randint(0, 1)\n            // c'est l'index du point non commun\n            const indexPNC = randint(0, 3, indexPI)\n            // la fonction constante\n            fonction1 = {\n              // On prend un noeud au milieu de la liste pour éviter d'avoir une tangente en début de graphe.\n              func: () => noeudsPassants1[indexPI].y,\n              expr: `${noeudsPassants1[indexPI].y}`,\n              poly: new Polynome({\n                rand: false,\n                deg: 3,\n                coeffs: [noeudsPassants1[indexPI].y, 0, 0, 0],\n              }),\n            }\n            // la fonction affine\n            const noeudsFonction = noeudsPassants1.filter(\n              (el, i) => i === indexPI || i === indexPNC,\n            )\n            const poly = interpolationDeLagrange(noeudsFonction)\n            fonction2 = renseigneFonction(poly)\n          }\n          break\n        case 2:\n          {\n            // constante et degré2\n            f1Type = 'constante'\n            f2Type = 'poly2'\n            const indexPI1 = 0\n            const indexPI2 = randint(1, 3)\n            fonction1 = {\n              func: () => noeudsPassants1[indexPI1].y,\n              expr: `${noeudsPassants1[indexPI1].y}`,\n              poly: new Polynome({\n                rand: false,\n                deg: 3,\n                coeffs: [noeudsPassants1[indexPI1].y, 0, 0, 0],\n              }),\n            } // la fonction constante\n            noeudsPassants2[indexPI2].y = noeudsPassants1[0].y\n            // c'est l'index du point non commun\n            const indexNC1 = randint(0, 3, [indexPI1, indexPI2])\n            noeudsPassants2[indexNC1].y = randint(-5, 5, [\n              noeudsPassants1[indexPI1].y,\n              noeudsPassants1[indexPI1].y - 1,\n              noeudsPassants1[indexPI1].y + 1,\n            ])\n            const noeudsFonction = noeudsPassants2.filter(\n              (el, i) => i === indexPI1 || i === indexPI2 || i === indexNC1,\n            )\n            const poly = interpolationDeLagrange(noeudsFonction)\n            fonction2 = renseigneFonction(poly) // une fonction de degré 2\n          }\n          break\n        case 3:\n          {\n            // constante et degré3\n            f1Type = 'constante'\n            f2Type = 'poly3'\n            const indexPI1 = randint(0, 1)\n            const indexPI2 = randint(1, 3, indexPI1)\n            const indexPI3 = randint(1, 3, [indexPI1, indexPI2])\n            const indexNC = randint(0, 3, [indexPI1, indexPI2, indexPI3])\n            fonction1 = {\n              // On prend un noeud au milieu de la liste pour éviter d'avoir une tangente en début de graphe.\n              func: () => noeudsPassants1[indexPI1].y,\n              expr: `${noeudsPassants1[indexPI1].y}`,\n              poly: new Polynome({\n                rand: false,\n                deg: 3,\n                coeffs: [noeudsPassants1[indexPI1].y, 0, 0, 0],\n              }),\n            } // la fonction constante\n            for (const index of [indexPI1, indexPI2, indexPI3]) {\n              noeudsPassants2[index].y = noeudsPassants1[indexPI1].y\n            }\n            noeudsPassants2[indexNC].y = randint(-5, 5, [\n              noeudsPassants1[indexPI1].y,\n              noeudsPassants1[indexPI1].y - 1,\n              noeudsPassants1[indexPI1].y + 1,\n            ])\n            const poly = interpolationDeLagrange(noeudsPassants2)\n            fonction2 = renseigneFonction(poly) // une fonction de degré 3\n          }\n          break\n        case 4: // 2 affines\n          f1Type = 'affine'\n          f2Type = 'affine'\n          {\n            const indexPI1 = randint(0, 3)\n            const indexNC1 = randint(0, 2, indexPI1)\n            const indexNC2 = randint(0, 2, [indexPI1, indexNC1])\n            const noeudsFonction1 = noeudsPassants1.filter(\n              (el, i) => i === indexPI1 || i === indexNC1,\n            )\n            noeudsPassants2[indexNC2].y = randint(-4, 4, [\n              noeudsPassants1[indexPI1].y,\n              noeudsPassants1[indexNC1].y,\n            ])\n            const noeudsFonction2 = noeudsPassants2.filter(\n              (el, i) => i === indexPI1 || i === indexNC2,\n            )\n            const poly1 = interpolationDeLagrange(noeudsFonction1)\n            fonction1 = renseigneFonction(poly1) // une fonction affine\n            const poly2 = interpolationDeLagrange(noeudsFonction2)\n            fonction2 = renseigneFonction(poly2) // la deuxième fonction affine\n          }\n          break\n        case 5: // affine et degré2\n          f1Type = 'affine'\n          f2Type = 'poly2'\n          {\n            const indexPI = randint(0, 3)\n            const indexPNC1 = randint(0, 3, indexPI)\n            const indexPI2 = randint(0, 3, [indexPI, indexPNC1])\n            const noeudsFonction1 = noeudsPassants1.filter(\n              (el, i) => i === indexPI || i === indexPNC1,\n            )\n            const poly1 = interpolationDeLagrange(noeudsFonction1)\n            fonction1 = renseigneFonction(poly1) // la fonction affine\n            for (const index of [indexPI, indexPI2]) {\n              noeudsPassants2[index].y = fonction1.func(\n                noeudsPassants2[index].x,\n              )\n            }\n            noeudsPassants2[indexPNC1].y = randint(-5, 5, [\n              noeudsPassants1[indexPNC1].y,\n              noeudsPassants2[0].y,\n              noeudsPassants2[1].y,\n              noeudsPassants2[2].y,\n              noeudsPassants2[3].y,\n            ])\n            const noeudsFonction2 = noeudsPassants2.filter(\n              (el, i) => i === indexPI || i === indexPNC1 || i === indexPI2,\n            )\n            const poly2 = interpolationDeLagrange(noeudsFonction2)\n            fonction2 = renseigneFonction(poly2) // la fonction degré 2\n          }\n          break\n        case 6:\n          {\n            // affine et degré3\n            f1Type = 'affine'\n            f2Type = 'poly3'\n            const indexPI = randint(0, 3)\n            const indexPI1 = randint(0, 3, indexPI)\n            const indexPI2 = randint(0, 3, [indexPI, indexPI1])\n            const indexPNC1 = randint(0, 3, [indexPI, indexPI1, indexPI2])\n            const noeudsFonction1 = noeudsPassants1.filter(\n              (el, i) => i === indexPI || i === indexPI1,\n            )\n            const poly1 = interpolationDeLagrange(noeudsFonction1)\n            fonction1 = renseigneFonction(poly1) // la fonction affine\n            for (const index of [indexPI, indexPI1, indexPI2]) {\n              noeudsPassants2[index].y = fonction1.func(\n                noeudsPassants2[index].x,\n              )\n            }\n            noeudsPassants2[indexPNC1].y = randint(-5, 5, [\n              noeudsPassants1[indexPNC1].y,\n              noeudsPassants2[0].y,\n              noeudsPassants2[1].y,\n              noeudsPassants2[2].y,\n              noeudsPassants2[3].y,\n            ])\n            const poly2 = interpolationDeLagrange(noeudsPassants2)\n            fonction2 = renseigneFonction(poly2) // la fonction degré 3\n          }\n          break\n        case 7: // degré2 et degré2\n          f1Type = 'poly2'\n          f2Type = 'poly2'\n          {\n            const indexPI = randint(0, 3)\n            const indexPI1 = randint(0, 3, indexPI)\n            const indexPNC1 = randint(0, 3, [indexPI, indexPI1])\n            const indexPNC2 = randint(0, 3, [indexPI, indexPNC1, indexPNC1])\n            const noeudsFonction1 = noeudsPassants1.filter(\n              (el, i) => i === indexPI || i === indexPI1 || i === indexPNC1,\n            )\n            const noeudsFonction2 = noeudsPassants2.filter(\n              (el, i) => i === indexPI || i === indexPNC1 || i === indexPNC2,\n            )\n            const poly1 = interpolationDeLagrange(noeudsFonction1)\n            fonction1 = renseigneFonction(poly1) // la première parabole\n            const poly2 = interpolationDeLagrange(noeudsFonction2)\n            fonction2 = renseigneFonction(poly2) // la deuxième parabole\n          }\n          break\n        case 8: // degré2 et degré3\n          f1Type = 'poly2'\n          f2Type = 'poly3'\n          {\n            const indexPI1 = randint(0, 3)\n            const indexPI2 = randint(0, 3, indexPI1)\n            const indexPNC1 = randint(0, 3, [indexPI1, indexPI2])\n            const noeudsFonction1 = noeudsPassants1.filter(\n              (el, i) => i === indexPI1 || i === indexPNC1 || i === indexPI2,\n            )\n            const poly1 = interpolationDeLagrange(noeudsFonction1)\n            fonction1 = renseigneFonction(poly1) // la parabole\n            const poly2 = interpolationDeLagrange(noeudsPassants2)\n            fonction2 = renseigneFonction(poly2) // la fonction degré 3\n          }\n          break\n        case 9: // degré3 et degré3\n          f1Type = 'poly3'\n          f2Type = 'poly3'\n          {\n            const poly1 = interpolationDeLagrange(noeudsPassants1) // une fonction de degré 3\n            fonction1 = renseigneFonction(poly1)\n            // on modifie la valeur y de l'un des points passants qui devient non passant pour la fonction1\n            const indexPNC1 = randint(0, 3)\n            const ordonnees = noeudsPassants1.map((el) => el.y)\n            let newY: number\n            do {\n              newY =\n                (noeudsPassants1[indexPNC1].y > 0 ? -1 : 1) *\n                randint(-4, 4, ordonnees)\n            } while (Math.abs(newY - noeudsPassants1[indexPNC1].y) > 5)\n            noeudsPassants2[indexPNC1].y = newY\n            const poly2 = interpolationDeLagrange(noeudsPassants2)\n            fonction2 = renseigneFonction(poly2) // une fonction de degré 3\n          }\n          break\n        default: // affine et affine (c'est le this.sup par défaut) Le code du case 4 est dupliqué ici pour avoir une valeur par défaut au cas où\n          f1Type = 'affine'\n          f2Type = 'affine'\n          {\n            const indexPI = randint(0, 3)\n            const indexPNC1 = randint(0, 3, indexPI)\n            const indexPNC2 = randint(0, 3, [indexPI, indexPNC1])\n            const noeudsFonction1 = noeudsPassants1.filter(\n              (el, i) => i === indexPI || i === indexPNC1,\n            )\n            const noeudsFonction2 = noeudsPassants2.filter(\n              (el, i) => i === indexPI || i === indexPNC2,\n            )\n            const poly1 = interpolationDeLagrange(noeudsFonction1)\n            fonction1 = renseigneFonction(poly1) // une fonction affine\n            const poly2 = interpolationDeLagrange(noeudsFonction2)\n            fonction2 = renseigneFonction(poly2) // la deuxième fonction affine\n          }\n\n          break\n      }\n      const integrales = []\n      // on calcule la différence des polys, on intègre entre -5 et 0 et entre 0 et 5\n      const poly = fonction1.poly\n      if (poly == null) {\n        // noremalement, ça ne doit pas arriver car la seule à ne pas avoir la propriété poly est la spline qui est éliminée\n        // d'ailleurs typescript le sait puisque dans le test, si on met f1Type !== 'spline' il nous fait remarquer que c'est pas la peine !\n        // donc ce test est là juste pour que typescript ne me dise pas que fonctions[0].poly peut être undefined\n        throw Error(\"la fonction 1 n'a pas de polynôme alors qu'elle devrait\")\n      }\n      const diff = poly.multiply(-1).add(fonction2.poly)\n      for (let k = 0; k < 10; k++) {\n        integrales.push(Math.abs(diff.image(x0 + k) - diff.image(x0 - 1 + k)))\n      }\n      integraleDiff = Math.min(...integrales)\n      yMin =\n        Math.min(\n          trouveMaxMin(\n            fonction1.poly,\n            fonction2.poly,\n            noeudsPassants1,\n            noeudsPassants2,\n          ),\n          -1,\n        ) - 0.3\n    } while (integraleDiff < 0.2 && cpt < 50)\n    const yMax = yMin + 12\n    const polyDiff = fonction1.poly.add(fonction2.poly.multiply(-1))\n    this.figureApiGeom = new Figure({\n      xMin: xMin - 0.5,\n      yMin,\n      width: 378,\n      height: 378,\n      isDynamic: true,\n    })\n    this.figureApiGeom.options.automaticUserMessage = false\n    this.figureApiGeom.userMessage =\n      'Cliquer sur le point $M$ pour le déplacer.'\n    this.figureApiGeom.create('Grid')\n\n    // on s'occupe de la fonction 1 et du point mobile dessus on trace tout ça.\n    // Maintenant, la fonction1 n'est jamais une spline !\n    let courbeF\n    let M\n    if (f1Type === 'constante' || f1Type === 'affine') {\n      const a = fonction1.poly.monomes[1] as number\n      const b = fonction1.poly.monomes[0] as number\n      const B = this.figureApiGeom.create('Point', {\n        x: xMin - 0.5,\n        y: (xMin - 0.5) * a + b,\n        isVisible: false,\n      })\n      const A = this.figureApiGeom.create('Point', {\n        x: xMax + 2.5,\n        y: (xMax + 2.5) * a + b,\n        isVisible: false,\n      })\n      const d = this.figureApiGeom.create('Segment', { point1: B, point2: A })\n      d.color = 'blue'\n      d.thickness = 2\n      d.isDashed = false\n      if (this.interactif) {\n        M = this.figureApiGeom.create('PointOnLine', { line: d })\n        M.shape = 'o'\n        M.color = 'blue'\n      }\n    } else {\n      courbeF = this.figureApiGeom.create('Graph', {\n        expression: fonction1.expr as string,\n        color: 'blue',\n        thickness: 2,\n        fillOpacity: 0.5,\n        xMin,\n        xMax,\n        isDashed: false,\n      })\n      if (this.interactif) {\n        M = this.figureApiGeom.create('PointOnGraph', { graph: courbeF })\n        M.shape = 'o'\n        M.color = 'blue'\n        M!.label = 'M'\n      }\n    }\n    if (this.interactif) {\n      M!.createSegmentToAxeX()\n      M!.createSegmentToAxeY()\n      // const textX = this.figureApiGeom.create('DynamicX', { point: M! })\n      //  const textY = this.figureApiGeom.create('DynamicY', { point: M! })\n      //  textX.dynamicText.maximumFractionDigits = 1\n      // textY.dynamicText.maximumFractionDigits = 1\n    }\n    /* if (f2Type === 'affine') {\n      const a = fonction2.poly.monomes[1] as number\n      const b = fonction2.poly.monomes[0] as number\n      const B = this.figureApiGeom.create('Point', { x: xMin - 0.5, y: a * (xMin - 0.5) + b, isVisible: false })\n      const A = this.figureApiGeom.create('Point', { x: xMax + 2.5, y: a * (xMax + 2.5) + b, isVisible: false })\n      const d = this.figureApiGeom.create('Segment', { point1: B, point2: A })\n      d.color = 'red'\n      d.thickness = 2\n      d.isDashed = false\n    } else {\n      this.figureApiGeom.create('Graph', {\n        expression: fonction2.expr as string,\n        color: 'red',\n        thickness: 2,\n        fillOpacity: 0.5,\n        xMin: xMin - 0.5,\n        xMax: xMax + 2.5\n      })\n    }\n    this.figureApiGeom.create('TextByPosition', { x: xMin + 0.5, y: yMax - 1, text: `$\\\\mathscr{C_${f1}}$`, color: 'blue' })\n    this.figureApiGeom.create('TextByPosition', { x: xMin + 0.5, y: yMax - 2, text: `$\\\\mathscr{C_${f2}}$`, color: 'red' })\n    const p1A = this.figureApiGeom.create('Point', { x: xMin + 1, y: yMax - 1, isVisible: false })\n    const p1B = this.figureApiGeom.create('Point', { x: xMin + 2, y: yMax - 1, isVisible: false })\n    const p2A = this.figureApiGeom.create('Point', { x: xMin + 1, y: yMax - 2, isVisible: false })\n    const p2B = this.figureApiGeom.create('Point', { x: xMin + 2, y: yMax - 2, isVisible: false })\n    this.figureApiGeom.create('Segment', { point1: p1A, point2: p1B, color: 'blue', thickness: 2 })\n    this.figureApiGeom.create('Segment', { point1: p2A, point2: p2B, color: 'red', thickness: 2 })\n*/\n    // De -6.3 à 6.3 donc width = 12.6 * 30 = 378\n    let enonce = `On considère les fonctions $${f1}$ et $${f2}$ définies sur $\\\\R$ et dont on a représenté ci-dessous une partie de leurs courbes respectives.<br><br>`\n    // let diff\n    let soluces: number[]\n    const inferieur = Boolean(choice([true, false]))\n\n    soluces = []\n    if (fonction1.poly == null && fonction2.poly == null)\n      throw Error(\"Un problème avec l'un des polynômes.\")\n\n    const racines = polyDiff.racines()\n    if (racines == null)\n      throw Error(\n        `Il n'y aurait pas de points d'intersection !!! polyDiff = ${polyDiff.toLatex()}`,\n      )\n    const racinesArrondies = racines.map((el) => Number(el.toFixed(1)))\n    for (let n = 0; n < racinesArrondies.length; n++) {\n      const image = fonction1.func(racinesArrondies[n])\n      const isInside =\n        racinesArrondies[n] <= xMax + 0.5 && racinesArrondies[n] >= xMin\n      const isInside2 = image >= yMin && image <= yMin + 12.6\n      if (isInside && isInside2) {\n        soluces.push(racinesArrondies[n])\n      }\n    }\n    soluces = Array.from(new Set(soluces)) as number[]\n    soluces = soluces.sort((a: number, b: number) => a - b)\n    if (this.sup === 1 || this.sup === 3) {\n      enonce += `Résoudre graphiquement l'équation $${f1}(x)${miseEnEvidence('~=~', 'black')}${f2}(x)$ sur  [$${xMin};$${xMax}].<br>`\n      if (this.interactif)\n        enonce +=\n          'Si besoin, les solutions doivent être séparées par un point-virgule.<br>'\n      texteCorr += `L'ensemble de solutions de l'équation $${f1}(x)${miseEnEvidence('~=~', 'black')}${f2}(x)$ sur [$${xMin};$${xMax}] correspond aux abscisses des points d'intersection des deux courbes, soit : `\n      texteCorr +=\n        this.sup === 1\n          ? `$\\\\{${soluces.map((el) => texNombre(el, 1)).join(';')}\\\\}$`\n          : `$${miseEnEvidence(`\\\\{${soluces.map((el) => texNombre(el, 1)).join(';')}\\\\}`)}$.<br>`\n    }\n    let indexQuestion = 0\n    if (soluces != null) {\n      if (this.sup === 1 || this.sup === 3) {\n        if (this.interactif)\n          enonce +=\n            `L'ensemble de solutions de l'équation $${f1}(x)${miseEnEvidence('~=~', 'black')}${f2}(x)$ sur [$${xMin};$${xMax}] est : ` +\n            ajouteChampTexteMathLive(this, indexQuestion, '  lycee ml-2') +\n            '<br><br>' // '$\\\\{' + Array.from(soluces).join(' ; ') + '\\\\}$'//\n        handleAnswers(this, indexQuestion, {\n          reponse: {\n            value: `\\\\{${Array.from(soluces).join(';')}\\\\}`,\n            options: { ensembleDeNombres: true },\n          },\n        }) // on s'en fiche du formatInteractif, c'est la fonction compare qui fait ce qu'il faut\n        indexQuestion++\n      }\n    }\n    if (this.sup !== 1) {\n      enonce += `Résoudre graphiquement l'inéquation $${f1}(x)${inferieur ? miseEnEvidence('\\\\leqslant', 'black') : miseEnEvidence('~\\\\geqslant~', 'black')}${f2}(x)$ sur $\\\\left[${texNombre(xMin, 1)};${texNombre(xMax, 1)}\\\\right]$.<br>`\n      if (this.interactif) {\n        enonce +=\n          \"On peut taper 'union' au clavier ou utiliser le clavier virtuel pour le signe $\\\\cup$.<br>\"\n        enonce +=\n          `L'ensemble des solutions de l'inéquation $${f1}(x)${inferieur ? miseEnEvidence('\\\\leqslant', 'black') : miseEnEvidence('~\\\\geqslant~', 'black')}${f2}(x)$ sur [$${xMin};$${xMax}] est : ` +\n          ajouteChampTexteMathLive(this, indexQuestion, '  lycee ml-2') +\n          '<br><br>'\n      }\n      const soluces2: string = chercheIntervalles(\n        polyDiff,\n        soluces,\n        Boolean(inferieur),\n        xMin,\n        xMax,\n      )\n\n      handleAnswers(this, indexQuestion, {\n        reponse: {\n          value: soluces2,\n          options: { intervalle: true },\n        },\n      })\n\n      texteCorr += `Pour trouver l'ensemble des solutions de l'inéquation $${f1}(x)${inferieur ? miseEnEvidence('\\\\leqslant', 'black') : miseEnEvidence('~\\\\geqslant~', 'black')}${f2}(x)$ sur $[${xMin};${xMax}]$ , on regarde les portions où la courbe $${miseEnEvidence('\\\\mathscr{C}_' + f1, 'blue')}$ est située ${inferieur ? 'en dessous' : 'au-dessus'} de la  courbe $${miseEnEvidence('\\\\mathscr{C}_' + f2, 'red')}$.<br>`\n      texteCorr += `On lit les intervalles correspondants sur l'axe des abscisses : $${soluces2}$`\n    }\n    /*  this.figureApiGeom.setToolbar({ tools: ['DRAG'], position: 'top' })\n    this.figureApiGeom.isDynamic = true\n    // Il est impératif de choisir les boutons avant d'utiliser figureApigeom\n\n    this.figureApiGeom.divButtons.style.display = 'flex'\n    this.figureApiGeom.ui.send({ type: 'DRAG'})\n    if (context.isHtml) {\n      if (this.interactif) {\n        this.listeQuestions = [enonce + figureApigeom({ exercice: this, i: 0, figure: this.figureApiGeom, isDynamic: true })]\n      } else {\n        this.listeQuestions = [enonce + wrapperApigeomToMathalea(this.figureApiGeom)]\n      }\n    } else {\n      this.listeQuestions = [enonce + this.figureApiGeom.tikz()]\n    }\n*/\n    const repere = new RepereBuilder({\n      xMin: xMin - 0.2,\n      yMin: yMin - 0.2,\n      xMax: xMax + 2.5,\n      yMax: yMax + 0.2,\n    })\n      .setGrille({\n        grilleX: {\n          dx: 1,\n          xMin,\n          xMax: xMax + 2.5,\n        },\n        grilleY: {\n          dy: 1,\n          yMin,\n          yMax,\n        },\n      })\n      .setGrilleSecondaire({\n        grilleX: {\n          dx: 0.2,\n          xMin,\n          xMax: xMax + 2.5,\n        },\n        grilleY: { dy: 0.2, yMin, yMax: yMin + 12 },\n      })\n      .setThickX({ xMin, xMax: xMax + 2.5, dx: 1 })\n      .setThickY({ yMin, yMax, dy: 1 })\n      .buildCustom()\n\n    let courbe1, courbe2\n    if (f1Type === 'constante' || f1Type === 'affine') {\n      courbe1 = segment(\n        xMin,\n        fonction1.func(xMin),\n        xMax,\n        fonction1.func(xMax),\n        'blue',\n      )\n    } else {\n      courbe1 = courbe(fonction1.func, { repere, xMin, xMax, color: 'blue' })\n    }\n    const nomCourbe1 = latex2d(`\\\\mathscr{C}_${f1}`, xMin + 0.5, yMax - 1, {\n      color: 'blue',\n      letterSize: 'normalsize',\n      backgroundColor: '',\n    })\n    const nomCourbe2 = latex2d(`\\\\mathscr{C}_${f2}`, xMin + 0.5, yMax - 2, {\n      color: 'red',\n      letterSize: 'normalsize',\n      backgroundColor: '',\n    })\n\n    courbe1.color = colorToLatexOrHTML('blue')\n\n    courbe1.epaisseur = 2\n    if (f2Type === 'affine') {\n      courbe2 = segment(\n        xMin,\n        fonction2.func(xMin),\n        xMax,\n        fonction2.func(xMax),\n        'red',\n      )\n    } else {\n      courbe2 = courbe(fonction2.func, { repere, xMin, xMax, color: 'red' })\n    }\n    const p1A = point(xMin + 1, yMax - 1)\n    const p1B = point(xMin + 2, yMax - 1)\n    const p2A = point(xMin + 1, yMax - 2)\n    const p2B = point(xMin + 2, yMax - 2)\n    const trait1 = segment(p1A, p1B, 'blue')\n    const trait2 = segment(p2A, p2B, 'red')\n    trait1.epaisseur = 2\n    trait2.epaisseur = 2\n    const courbes = [courbe1, courbe2, trait1, trait2, nomCourbe1, nomCourbe2]\n    this.listeQuestions = [\n      enonce +\n        mathalea2d(\n          Object.assign({}, fixeBordures([...(repere.objets ?? [])])),\n          repere.objets ?? [],\n          ...courbes,\n        ),\n    ]\n    // Uniformisation : Mise en place de la réponse attendue en interactif en orange et gras\n    const textCorrSplit = texteCorr.split(':')\n    let aRemplacer = textCorrSplit[textCorrSplit.length - 1]\n    aRemplacer = aRemplacer.replaceAll('$', '')\n\n    texteCorr = ''\n    for (let ee = 0; ee < textCorrSplit.length - 1; ee++) {\n      texteCorr += textCorrSplit[ee] + ':'\n    }\n    texteCorr += ` $${miseEnEvidence(aRemplacer)}$`\n    // Fin de cette uniformisation\n    texteCorr += '.'\n    this.listeCorrections = [texteCorr]\n  }\n}\n\nexport default resolutionEquationInequationGraphique\n"],"names":["titre","dateDePublication","dateDeModifImportante","interactifReady","interactifType","uuid","refs","trouveMaxMin","poly1","poly2","np1","np2","fPrime1","fPrime2","yMin1","yMin2","c","b","a","delta1","ptitDelta1","x1","x2","delta2","ptitDelta2","el","renseigneFonction","poly","func","monomesNormalized","d","expr","reduirePolynomeDegre3","chercheIntervalles","fonc","soluces","inferieur","xMin","xMax","liste","values","i","solutions","middle","imageMiddle","texNombre","resolutionEquationInequationGraphique","Exercice","__publicField","aleaF1","randint","f1","lettreMinusculeDepuisChiffre","f2","choixFonctions","integraleDiff","f1Type","f2Type","fonction1","fonction2","texteCorr","xbase","x0","x3","decalAxe","yMin","cpt","y0","y1","y2","y3","vec1","vec2","vec3","vector","areColineaires","v1","v2","noeudsPassants1","el1","el2","noeudsPassants2","indexPI","indexPNC","Polynome","noeudsFonction","interpolationDeLagrange","indexPI1","indexPI2","indexNC1","indexPI3","indexNC","index","indexNC2","noeudsFonction1","noeudsFonction2","indexPNC1","indexPNC2","ordonnees","newY","integrales","diff","k","yMax","polyDiff","Figure","courbeF","M","B","A","enonce","choice","racines","racinesArrondies","n","image","isInside","isInside2","miseEnEvidence","indexQuestion","ajouteChampTexteMathLive","handleAnswers","soluces2","repere","RepereBuilder","courbe1","courbe2","segment","courbe","nomCourbe1","latex2d","nomCourbe2","colorToLatexOrHTML","p1A","point","p1B","p2A","p2B","trait1","trait2","courbes","mathalea2d","fixeBordures","textCorrSplit","aRemplacer","ee"],"mappings":"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"}