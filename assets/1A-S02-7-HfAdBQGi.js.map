{"version":3,"file":"1A-S02-7-HfAdBQGi.js","sources":["../../src/exercices/1e/1A-S02-7.ts"],"sourcesContent":["import { shuffle } from '../../lib/outils/arrayOutils'\nimport { texteGras } from '../../lib/outils/embellissements'\nimport { texNombre } from '../../lib/outils/texNombre'\nimport { nombreElementsDifferents } from '../ExerciceQcm'\nimport ExerciceQcmA from '../ExerciceQcmA'\n\nexport const uuid = '0c97a'\nexport const refs = {\n  'fr-fr': ['1A-S02-7'],\n  'fr-ch': ['4mQCM-1'],\n}\nexport const interactifReady = true\nexport const interactifType = 'qcm'\nexport const amcReady = 'true'\nexport const amcType = 'qcmMono'\nexport const titre =\n  \"Comparer la moyenne et l'écart-type d'une série rangée en classes\"\nexport const dateDePublication = '05/08/2025'\n// Ceci est un exemple de QCM avec version originale et version aléatoire\n/**\n * @author Stéphane Guyon\n */\n\nexport default class MoyenneEcartTypeClasseQCM extends ExerciceQcmA {\n  private appliquerLesValeurs(\n    serieAForcee?: number[],\n    serieBForcee?: number[],\n  ): void {\n    const moyenne = (arr: number[]) =>\n      arr.reduce((sum, x) => sum + x, 0) / arr.length\n\n    const ecartType = (arr: number[]) => {\n      const m = moyenne(arr)\n      const variance =\n        arr.reduce((sum, x) => sum + Math.pow(x - m, 2), 0) / arr.length\n      return Math.sqrt(variance)\n    }\n\n    const genereSerie = (\n      moyenneCible: number,\n      dispersion: number,\n    ): number[] => {\n      const base = moyenneCible\n      const deltas = {\n        faible: [0, 0, 1, -1],\n        moyenne: [0, 2, -2, 0],\n        forte: [3, -3, 0, 0],\n      }\n\n      const ecarts =\n        deltas[\n          dispersion === 1 ? 'faible' : dispersion === 2 ? 'moyenne' : 'forte'\n        ]\n      const melange = shuffle(ecarts)\n      return melange.map((d) => base + d)\n    }\n\n    let serieA: number[] = []\n    let serieB: number[] = []\n\n    // Si des séries sont forcées (version originale), on les utilise\n    if (serieAForcee && serieBForcee) {\n      serieA = serieAForcee\n      serieB = serieBForcee\n    } else {\n      // Sinon, génération aléatoire (version aléatoire)\n      const scenario = Math.floor(Math.random() * 4)\n\n      switch (scenario) {\n        case 0:\n          // Même moyenne, mais série B plus dispersée\n          serieA = genereSerie(10, 1)\n          serieB = genereSerie(10, 3)\n          break\n        case 1:\n          // Moyenne A > B, écart-type similaire\n          serieA = genereSerie(12, 2)\n          serieB = genereSerie(9, 2)\n          break\n        case 2:\n          // Moyenne égale, A plus dispersée\n          serieA = genereSerie(10, 3)\n          serieB = genereSerie(10, 1)\n          break\n        case 3:\n          // Moyenne B > A, écart-type égal\n          serieA = genereSerie(9, 3)\n          serieB = genereSerie(12, 3)\n          break\n      }\n    }\n\n    const moyA = moyenne(serieA)\n    const moyB = moyenne(serieB)\n    const etA = ecartType(serieA)\n    const etB = ecartType(serieB)\n\n    // Liste standardisée des 4 réponses possibles\n    const toutesLesReponses = [\n      'La moyenne de la série B est strictement supérieure à la moyenne de la série A.',\n      'La moyenne de la série A est strictement supérieure à la moyenne de la série B.',\n      \"L'écart-type de la série A est strictement supérieur à l'écart-type de la série B.\",\n      \"L'écart-type de la série B est strictement supérieur à l'écart-type de la série A.\",\n    ]\n\n    // Détection automatique de la bonne réponse\n    let bonnePhrase = ''\n    let explication = ''\n\n    if (moyB > moyA) {\n      bonnePhrase = toutesLesReponses[0]\n      explication = `La moyenne de la série B est ${texNombre(moyB, 2)}, celle de la série A est ${texNombre(moyA, 2)}.<br>\n      On peut conclure que la seule réponse acceptable est que la moyenne de la série B est strictement supérieure à celle de la série A.<br>\n      Il n'est pas nécessaire de calculer l'écart-type pour répondre à cette question.`\n    } else if (moyA > moyB) {\n      bonnePhrase = toutesLesReponses[1]\n      explication = `La moyenne de la série A est ${texNombre(moyA, 2)}, celle de la série B est ${texNombre(moyB, 2)}.\n      <br>On peut conclure que la seule réponse acceptable est que la moyenne de la série A est strictement supérieure à celle de la série B.<br>\n      Il n'est pas nécessaire de calculer l'écart-type pour répondre à cette question.`\n    } else if (etA > etB) {\n      bonnePhrase = toutesLesReponses[2]\n\n      // Calcul des termes pour l'écart-type A\n      const termesA = serieA\n        .map((x) => `(${x} - ${texNombre(moyA, 0)})^2`)\n        .join(' + ')\n      const sommeCarresA = serieA.reduce(\n        (sum, x) => sum + Math.pow(x - moyA, 2),\n        0,\n      )\n      const varianceA = sommeCarresA / serieA.length\n\n      // Calcul des termes pour l'écart-type B\n      const termesB = serieB\n        .map((x) => `(${x} - ${texNombre(moyB, 0)})^2`)\n        .join(' + ')\n      const sommeCarresB = serieB.reduce(\n        (sum, x) => sum + Math.pow(x - moyB, 2),\n        0,\n      )\n      const varianceB = sommeCarresB / serieB.length\n\n      explication = `On calcule les moyennes des deux séries qui sont toutes les deux égales à ${texNombre(moyA, 2)}.<br>\n      Les moyennes sont égales, on calcule les écarts-types :<br>\n      $\\\\sigma_A = \\\\sqrt{\\\\dfrac{${termesA}}{${serieA.length}}} = \\\\sqrt{\\\\dfrac{${sommeCarresA}}{${serieA.length}}} = \\\\sqrt{${texNombre(varianceA, 2)}}$<br>\n      $\\\\sigma_B = \\\\sqrt{\\\\dfrac{${termesB}}{${serieB.length}}} = \\\\sqrt{\\\\dfrac{${sommeCarresB}}{${serieB.length}}} = \\\\sqrt{${texNombre(varianceB, 2)}}$<br>\n      On a donc $\\\\sigma_A > \\\\sigma_B$.<br>\n      L'écart-type de la série A est strictement supérieur à celui de la série B.`\n    } else {\n      bonnePhrase = toutesLesReponses[3]\n\n      // Calcul des termes pour l'écart-type A\n      const termesA = serieA\n        .map((x) => `(${x} - ${texNombre(moyA, 0)})^2`)\n        .join(' + ')\n      const sommeCarresA = serieA.reduce(\n        (sum, x) => sum + Math.pow(x - moyA, 2),\n        0,\n      )\n      const varianceA = sommeCarresA / serieA.length\n\n      // Calcul des termes pour l'écart-type B\n      const termesB = serieB\n        .map((x) => `(${x} - ${texNombre(moyB, 0)})^2`)\n        .join(' + ')\n      const sommeCarresB = serieB.reduce(\n        (sum, x) => sum + Math.pow(x - moyB, 2),\n        0,\n      )\n      const varianceB = sommeCarresB / serieB.length\n\n      explication = `On calcule les moyennes des deux séries qui sont toutes les deux égales à ${texNombre(moyA, 2)}.<br>\n      Les moyennes sont égales, on calcule les écarts-types :<br>\n      $\\\\sigma_A = \\\\sqrt{\\\\dfrac{${termesA}}{${serieA.length}}} = \\\\sqrt{\\\\dfrac{${sommeCarresA}}{${serieA.length}}} = \\\\sqrt{${texNombre(varianceA, 2)}}$<br>\n      $\\\\sigma_B = \\\\sqrt{\\\\dfrac{${termesB}}{${serieB.length}}} = \\\\sqrt{\\\\dfrac{${sommeCarresB}}{${serieB.length}}} = \\\\sqrt{${texNombre(varianceB, 2)}}$<br>\n      On a donc $\\\\sigma_B > \\\\sigma_A$.<br>\n      L'écart-type de la série B est strictement supérieur à celui de la série A.`\n    }\n\n    // Réorganiser les réponses pour mettre la bonne en premier\n    const autres = toutesLesReponses.filter((r) => r !== bonnePhrase)\n    this.reponses = [bonnePhrase, ...autres]\n\n    // Construire l'énoncé\n    this.enonce = `On considère les deux séries suivantes :  <br>\n${texteGras('Série A :')} $${serieA.join(' ; ')} $ <br>\n${texteGras('Série B :')} $${serieB.join(' ; ')} $ <br>\n\nLaquelle des quatre propositions suivantes est vraie ?`\n\n    // Définir la bonne réponse\n    this.reponse = bonnePhrase\n\n    // Correction : explication simple, claire\n    this.correction = explication\n  }\n\n  versionOriginale: () => void = () => {\n    // Données fixes de la version originale\n    const serieA = [10, 11, 10, 9]\n    const serieB = [7, 13, 10, 10]\n    this.appliquerLesValeurs(serieA, serieB)\n  }\n\n  versionAleatoire: () => void = () => {\n    const n = 4 // nombre de réponses différentes voulues (on rappelle que la première réponse est la bonne)\n    do {\n      this.appliquerLesValeurs()\n    } while (nombreElementsDifferents(this.reponses) < n)\n  }\n\n  // Ici il n'y a rien à faire, on appelle juste la version aleatoire (pour un qcm aleatoirisé, c'est le fonctionnement par défaut)\n  constructor() {\n    super()\n    this.options = { vertical: true, ordered: false }\n    this.spacing = 1.5\n    this.versionAleatoire()\n  }\n}\n"],"names":["uuid","refs","interactifReady","interactifType","amcReady","amcType","titre","dateDePublication","MoyenneEcartTypeClasseQCM","ExerciceQcmA","__publicField","serieA","serieB","nombreElementsDifferents","serieAForcee","serieBForcee","moyenne","arr","sum","x","ecartType","m","variance","genereSerie","moyenneCible","dispersion","base","ecarts","shuffle","d","moyA","moyB","etA","etB","toutesLesReponses","bonnePhrase","explication","texNombre","termesA","sommeCarresA","varianceA","termesB","sommeCarresB","varianceB","autres","r","texteGras"],"mappings":"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"}