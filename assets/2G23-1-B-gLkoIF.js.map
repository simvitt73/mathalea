{"version":3,"file":"2G23-1-B-gLkoIF.js","sources":["../../src/exercices/2e/2G23-1.ts"],"sourcesContent":["import { grille } from '../../lib/2d/Grille'\nimport { point } from '../../lib/2d/PointAbstrait'\nimport {\n  representant,\n  representantNomme,\n} from '../../lib/2d/representantVecteur'\nimport { Segment, segment } from '../../lib/2d/segmentsVecteurs'\nimport { labelPoint } from '../../lib/2d/textes'\nimport { tracePoint } from '../../lib/2d/TracePoint'\nimport { translation } from '../../lib/2d/transformations'\nimport { vecteur } from '../../lib/2d/Vecteur'\nimport { KeyboardType } from '../../lib/interactif/claviers/keyboard'\nimport { setReponse } from '../../lib/interactif/gestionInteractif'\nimport { ajouteChampTexteMathLive } from '../../lib/interactif/questionMathLive'\nimport { choice } from '../../lib/outils/arrayOutils'\nimport { miseEnEvidence } from '../../lib/outils/embellissements'\nimport { mathalea2d } from '../../modules/mathalea2d'\nimport {\n  gestionnaireFormulaireTexte,\n  listeQuestionsToContenu,\n} from '../../modules/outils'\nimport Exercice from '../Exercice'\n\nexport const interactifReady = true\nexport const interactifType = 'mathLive'\nexport const titre = 'Déterminer graphiquement des images par des translations'\nexport const dateDePublication = '13/07/2023'\nexport const dateDeModifImportante = '15/10/2023'\n\n/**\n * Images de points par des translations\n * @author Stéphan Grignon (modifié par EE pour une meilleure visibilité de la correction)\n */\nexport const uuid = 'd2b57'\n\nexport const refs = {\n  'fr-fr': ['2G23-1'],\n  'fr-ch': [],\n}\n\n// Une fonction pour créer la liste des noms possibles pour un triangle\nfunction allTrianglesNames(nomA: string, nomB: string, nomC: string): string[] {\n  const nomsSommets = [nomA, nomB, nomC]\n  const noms = []\n  do {\n    const premierSommet = nomsSommets[0]\n    const deuxiemmeSommet = nomsSommets[1]\n    const troisiemeSommet = nomsSommets[2]\n    noms.push(\n      premierSommet + deuxiemmeSommet + troisiemeSommet,\n      premierSommet + troisiemeSommet + deuxiemmeSommet,\n    )\n    nomsSommets.shift()\n    nomsSommets.push(premierSommet)\n  } while (noms.length < 6)\n  return noms\n}\n\nfunction coefDirVecteurEgaleA1(seg1: Segment, seg2: Segment, seg3: Segment) {\n  // recherche si un des segments a pour coef directeur 1 ou -1 et possède un point sur la ligne d'en bas\n  return (\n    (seg1.extremite2.y - seg1.extremite1.y ===\n      seg1.extremite2.x - seg1.extremite1.x ||\n      seg2.extremite2.y - seg2.extremite1.y ===\n        seg2.extremite2.x - seg2.extremite1.x ||\n      seg3.extremite2.y - seg3.extremite1.y ===\n        seg3.extremite2.x - seg3.extremite1.x) &&\n    (seg1.extremite1.y === 0 ||\n      seg2.extremite1.y === 0 ||\n      seg3.extremite1.y === 0 ||\n      seg1.extremite2.y === 0 ||\n      seg2.extremite2.y === 0 ||\n      seg3.extremite2.y === 0)\n  )\n}\n\nfunction coefDirVecteurSegEgaleA1(seg1: Segment) {\n  // recherche si un des segments a pour coef directeur 1 ou -1 et possède un point sur la ligne d'en bas\n  return (\n    seg1.extremite2.y - seg1.extremite1.y ===\n    seg1.extremite2.x - seg1.extremite1.x\n  )\n}\n\nfunction estEgalAUnAutreSegment(\n  s: Segment,\n  s1: Segment,\n  s2: Segment,\n  s3: Segment,\n) {\n  // recherche si le segment s est égal au segment s1, s2, ou s3\n  return (\n    (((s.extremite1.x === s1.extremite1.x &&\n      s.extremite1.y === s1.extremite1.y) ||\n      (s.extremite1.x === s1.extremite2.x &&\n        s.extremite1.y === s1.extremite2.y)) &&\n      ((s.extremite2.x === s1.extremite1.x &&\n        s.extremite2.y === s1.extremite1.y) ||\n        (s.extremite2.x === s1.extremite2.x &&\n          s.extremite2.y === s1.extremite2.y))) ||\n    (((s.extremite1.x === s2.extremite1.x &&\n      s.extremite1.y === s2.extremite1.y) ||\n      (s.extremite1.x === s2.extremite2.x &&\n        s.extremite1.y === s2.extremite2.y)) &&\n      ((s.extremite2.x === s2.extremite1.x &&\n        s.extremite2.y === s2.extremite1.y) ||\n        (s.extremite2.x === s2.extremite2.x &&\n          s.extremite2.y === s2.extremite2.y))) ||\n    (((s.extremite1.x === s3.extremite1.x &&\n      s.extremite1.y === s3.extremite1.y) ||\n      (s.extremite1.x === s3.extremite2.x &&\n        s.extremite1.y === s3.extremite2.y)) &&\n      ((s.extremite2.x === s3.extremite1.x &&\n        s.extremite2.y === s3.extremite1.y) ||\n        (s.extremite2.x === s3.extremite2.x &&\n          s.extremite2.y === s3.extremite2.y)))\n  )\n}\n\nexport default class ImagePtParTranslation extends Exercice {\n  classe: number\n  constructor() {\n    super()\n    this.besoinFormulaireTexte = [\n      'Situations différentes ',\n      \"Nombres séparés par des tirets \\n1 : À partir d'une point\\n2 : À partir d'une segment\\n3 : À partir d'un triangle\\n4 : Mélange\",\n    ]\n\n    this.nbQuestions = 2\n\n    this.sup = '1'\n    this.classe = 2\n  }\n\n  nouvelleVersion() {\n    const listeTypeDeQuestions = gestionnaireFormulaireTexte({\n      saisie: this.sup,\n      min: 1,\n      max: 3,\n      defaut: 1,\n      melange: 4,\n      nbQuestions: this.nbQuestions,\n      listeOfCase: ['point', 'segment', 'triangle'],\n    })\n    for (\n      let i = 0, texte, texteCorr, cpt = 0;\n      i < this.nbQuestions && cpt < 50;\n\n    ) {\n      const objets = []\n      const objetsCorr = []\n      const A = point(0, 4, 'A', 'above')\n      const B = point(2, 4, 'B', 'above')\n      const C = point(4, 4, 'C', 'above')\n      const D = point(6, 4, 'D', 'above')\n      const E = point(8, 4, 'E', 'above')\n      const F = point(10, 4, 'F', 'above')\n      const G = point(0, 2, 'G', 'left')\n      const H = point(2, 2, 'H', 'below left')\n      const I = point(4, 2, 'I', 'below left')\n      const J = point(6, 2, 'J', 'below left')\n      const K = point(8, 2, 'K', 'below left')\n      const L = point(10, 2, 'L', 'right')\n      const M = point(0, 0, 'M', 'below')\n      const N = point(2, 0, 'N', 'below')\n      const O = point(4, 0, 'O', 'below')\n      const P = point(6, 0, 'P', 'below')\n      const Q = point(8, 0, 'Q', 'below')\n      const R = point(10, 0, 'R', 'below')\n      const CoorPt = [\n        [0, 4],\n        [2, 4],\n        [4, 4],\n        [6, 4],\n        [8, 4],\n        [10, 4],\n        [0, 2],\n        [2, 2],\n        [4, 2],\n        [6, 2],\n        [8, 2],\n        [10, 2],\n        [0, 0],\n        [2, 0],\n        [4, 0],\n        [6, 0],\n        [8, 0],\n        [10, 0],\n      ]\n      const NomPt = [\n        'A',\n        'B',\n        'C',\n        'D',\n        'E',\n        'F',\n        'G',\n        'H',\n        'I',\n        'J',\n        'K',\n        'L',\n        'M',\n        'N',\n        'O',\n        'P',\n        'Q',\n        'R',\n      ]\n      const Pt = [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R]\n      const PositionPt = tracePoint(\n        A,\n        B,\n        C,\n        D,\n        E,\n        F,\n        G,\n        H,\n        I,\n        J,\n        K,\n        L,\n        M,\n        N,\n        O,\n        P,\n        Q,\n        R,\n      )\n      let LabelsPt = labelPoint(\n        A,\n        B,\n        C,\n        D,\n        E,\n        F,\n        G,\n        H,\n        I,\n        J,\n        K,\n        L,\n        M,\n        N,\n        O,\n        P,\n        Q,\n        R,\n      )\n      const Grille = grille(0, 0, 10, 4)\n      let xSOL = 100\n      let xPtArrivSeg = 100\n      let xPt2Triangle = 100\n      let PtDepart\n      switch (listeTypeDeQuestions[i]) {\n        case 'point':\n          {\n            // À partir d'un point\n            PtDepart = choice([\n              A,\n              B,\n              C,\n              D,\n              E,\n              F,\n              G,\n              H,\n              I,\n              J,\n              K,\n              L,\n              M,\n              N,\n              O,\n              P,\n              Q,\n              R,\n            ])\n            let OrigVec = choice(\n              [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R],\n              [PtDepart],\n            )\n            let ExtrVec = choice(\n              [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R],\n              [PtDepart, OrigVec],\n            )\n            xSOL = PtDepart.x + ExtrVec.x - OrigVec.x\n            let ySOL = PtDepart.y + ExtrVec.y - OrigVec.y\n            while (xSOL < 0 || xSOL > 10 || ySOL < 0 || ySOL > 4) {\n              OrigVec = choice(\n                [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R],\n                [PtDepart],\n              )\n              ExtrVec = choice(\n                [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R],\n                [PtDepart, OrigVec],\n              )\n              xSOL = PtDepart.x + ExtrVec.x - OrigVec.x\n              ySOL = PtDepart.y + ExtrVec.y - OrigVec.y\n            }\n            const nomPD = PtDepart.nom\n            const nomOR = OrigVec.nom\n            const nomEXT = ExtrVec.nom\n            const NomSOL =\n              NomPt[\n                CoorPt.findIndex(\n                  (couple) => couple[0] === xSOL && couple[1] === ySOL,\n                )\n              ]\n            const trPtDepart = tracePoint(PtDepart, 'blue')\n            trPtDepart.epaisseur = 2\n            objets.push(PositionPt, LabelsPt, Grille)\n            objets.push(trPtDepart)\n\n            texte =\n              this.classe === 2\n                ? `Sans justifier, donner l'image du point $${nomPD}$ par la translation de vecteur $\\\\overrightarrow{${nomOR}${nomEXT}}$.`\n                : `Sans justifier, donner l'image du point $${nomPD}$ par la translation qui transforme $${nomOR}$ en $${nomEXT}$.`\n            texte += mathalea2d(\n              {\n                xmin: -1,\n                ymin: -1,\n                xmax: 12,\n                ymax: 5,\n                pixelsParCm: 20,\n                scale: 0.5,\n                zoom: 1.75,\n              },\n              objets,\n            ) // On trace le graphique de la solution\n\n            if (this.interactif) {\n              texte += ajouteChampTexteMathLive(\n                this,\n                i,\n                KeyboardType.alphanumeric,\n                {\n                  texteAvant: `<br><br>L'image du point $${nomPD}$ est :`,\n                  texteApres: '.',\n                },\n              )\n            }\n\n            const VecDepl = vecteur(\n              ExtrVec.x - OrigVec.x,\n              ExtrVec.y - OrigVec.y,\n            ) // Crée le vecteur déplacement\n            const VecDeplRep = representant(\n              VecDepl,\n              PtDepart,\n              'green',\n            ) as Segment // Trace le vecteur déplacement\n            VecDeplRep.epaisseur = 2 // Variable qui grossit le tracé du vecteur\n            VecDeplRep.styleExtremites = '->' // Donne l'extrémité du vecteur\n            const nomVecDepl = representantNomme(\n              VecDepl,\n              PtDepart,\n              nomOR + nomEXT,\n              1,\n              'green',\n            ) // Affiche le nom du vecteur déplacement\n            const PositionPtCorr = tracePoint(\n              A,\n              B,\n              C,\n              D,\n              E,\n              F,\n              G,\n              H,\n              I,\n              J,\n              K,\n              L,\n              M,\n              N,\n              O,\n              P,\n              Q,\n              R,\n              'lightgray',\n            )\n            const LabelsPtCorr = labelPoint(\n              A,\n              B,\n              C,\n              D,\n              E,\n              F,\n              G,\n              H,\n              I,\n              J,\n              K,\n              L,\n              M,\n              N,\n              O,\n              P,\n              Q,\n              R,\n              'lightgray',\n            )\n            objetsCorr.push(PositionPtCorr, LabelsPtCorr, Grille, VecDeplRep)\n            if (this.classe === 2) objetsCorr.push(nomVecDepl)\n            objetsCorr.push(labelPoint(OrigVec, ExtrVec, 'green'))\n            objetsCorr.push(representant(VecDepl, OrigVec, 'green'))\n            objetsCorr.push(labelPoint(PtDepart, 'blue'), trPtDepart)\n            const ptSol = translation(PtDepart, VecDepl, NomSOL)\n            ptSol.positionLabel =\n              ptSol.y === 0 ? 'below' : ptSol.y === 4 ? 'above' : 'below left'\n            const trPtSol = tracePoint(ptSol, '#f15929')\n            trPtSol.epaisseur = 2\n            objetsCorr.push(labelPoint(ptSol, '#f15929'), trPtSol)\n            texteCorr =\n              this.classe === 2\n                ? `Le point $${miseEnEvidence(NomSOL)}$ est l'image du point $${nomPD}$ par la translation de vecteur $\\\\overrightarrow{${nomOR}${nomEXT}}$.`\n                : `Le point $${miseEnEvidence(NomSOL)}$ est l'image du point $${nomPD}$ par la translation qui transforme $${nomOR}$ en $${nomEXT}$.`\n            texteCorr += mathalea2d(\n              {\n                xmin: -1,\n                ymin: -1,\n                xmax: 12,\n                ymax: 5,\n                pixelsParCm: 20,\n                scale: 0.5,\n                zoom: 1.75,\n              },\n              objetsCorr,\n            ) // On trace le graphique de la solution\n            setReponse(this, i, NomSOL, { formatInteractif: 'texte' })\n          }\n          break\n\n        case 'segment':\n          {\n            // À partir d'un segment\n            const PtDepartSeg = choice([\n              A,\n              B,\n              C,\n              D,\n              E,\n              F,\n              G,\n              H,\n              I,\n              J,\n              K,\n              L,\n              M,\n              N,\n              O,\n              P,\n              Q,\n              R,\n            ])\n            PtDepart = PtDepartSeg\n            xPtArrivSeg = PtDepartSeg.x + choice([-2, 0, 2])\n            let yPtArrivSeg = PtDepartSeg.y + choice([-2, 0, 2])\n            while (\n              xPtArrivSeg < 0 ||\n              xPtArrivSeg > 10 ||\n              yPtArrivSeg < 0 ||\n              yPtArrivSeg > 4 ||\n              (xPtArrivSeg === PtDepartSeg.x && yPtArrivSeg === PtDepartSeg.y)\n            ) {\n              xPtArrivSeg = PtDepartSeg.x + choice([-2, 0, 2])\n              yPtArrivSeg = PtDepartSeg.y + choice([-2, 0, 2])\n            }\n            const Seg = segment(\n              PtDepartSeg.x,\n              PtDepartSeg.y,\n              xPtArrivSeg,\n              yPtArrivSeg,\n              'blue',\n            )\n            Seg.epaisseur = 2 // Variable qui grossit le tracé du segment\n            const nomPDSeg = PtDepartSeg.nom\n            const nomPASeg =\n              NomPt[\n                CoorPt.findIndex(\n                  (couple) =>\n                    couple[0] === xPtArrivSeg && couple[1] === yPtArrivSeg,\n                )\n              ]\n            const PtArrivSeg =\n              Pt[\n                CoorPt.findIndex(\n                  (couple) =>\n                    couple[0] === xPtArrivSeg && couple[1] === yPtArrivSeg,\n                )\n              ]\n            let OrigVec = choice(\n              [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R],\n              [PtDepartSeg, PtArrivSeg],\n            )\n            let ExtrVec = choice(\n              [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R],\n              [PtDepartSeg, PtArrivSeg, OrigVec],\n            )\n            let xSOLPDSeg = PtDepartSeg.x + ExtrVec.x - OrigVec.x\n            let ySOLPDSeg = PtDepartSeg.y + ExtrVec.y - OrigVec.y\n            let xSOLPASeg = PtArrivSeg.x + ExtrVec.x - OrigVec.x\n            let ySOLPASeg = PtArrivSeg.y + ExtrVec.y - OrigVec.y\n            while (\n              xSOLPDSeg < 0 ||\n              xSOLPASeg < 0 ||\n              ySOLPDSeg < 0 ||\n              ySOLPASeg < 0 ||\n              xSOLPDSeg > 10 ||\n              xSOLPASeg > 10 ||\n              ySOLPDSeg > 4 ||\n              ySOLPASeg > 4\n            ) {\n              OrigVec = choice(\n                [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R],\n                [PtDepartSeg, PtArrivSeg],\n              )\n              ExtrVec = choice(\n                [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R],\n                [PtDepartSeg, PtArrivSeg, OrigVec],\n              )\n              xSOLPDSeg = PtDepartSeg.x + ExtrVec.x - OrigVec.x\n              ySOLPDSeg = PtDepartSeg.y + ExtrVec.y - OrigVec.y\n              xSOLPASeg = PtArrivSeg.x + ExtrVec.x - OrigVec.x\n              ySOLPASeg = PtArrivSeg.y + ExtrVec.y - OrigVec.y\n            }\n            const nomOR = OrigVec.nom\n            const nomEXT = ExtrVec.nom\n            const nomSOLPDSeg =\n              NomPt[\n                CoorPt.findIndex(\n                  (couple) =>\n                    couple[0] === xSOLPDSeg && couple[1] === ySOLPDSeg,\n                )\n              ]\n            const nomSOLPASeg =\n              NomPt[\n                CoorPt.findIndex(\n                  (couple) =>\n                    couple[0] === xSOLPASeg && couple[1] === ySOLPASeg,\n                )\n              ]\n            const SegSOL = segment(\n              xSOLPDSeg,\n              ySOLPDSeg,\n              xSOLPASeg,\n              ySOLPASeg,\n              '#f15929',\n            )\n            SegSOL.epaisseur = 2 // Variable qui grossit le tracé du vecteur\n\n            const VecDepl = vecteur(\n              ExtrVec.x - OrigVec.x,\n              ExtrVec.y - OrigVec.y,\n            ) // Crée le vecteur déplacement\n            const VecDeplRep = representant(VecDepl, PtDepartSeg, 'green') // Trace le vecteur déplacement\n            VecDeplRep.epaisseur = 2 // Variable qui grossit le tracé du vecteur\n            VecDeplRep.styleExtremites = '->' // Donne l'extrémité du vecteur\n\n            // Recherche du meilleur placement des points H à K pour éviter chevauchement\n            let placementPoints\n            if (coefDirVecteurSegEgaleA1(VecDeplRep)) {\n              // placementPoints = VecDeplRep.extremite1.x - VecDeplRep.extremite2.x > 0 ? 'below right' : 'above left'\n              placementPoints =\n                VecDeplRep.extremite1.x - VecDeplRep.extremite2.x > 0\n                  ? 'below'\n                  : 'above'\n            } else {\n              // placementPoints = VecDeplRep.extremite1.x - VecDeplRep.extremite2.x > 0 ? 'above left' : 'below left'\n              placementPoints =\n                VecDeplRep.extremite1.x - VecDeplRep.extremite2.x > 0\n                  ? 'above'\n                  : 'below'\n            }\n            H.positionLabel = placementPoints\n            I.positionLabel = placementPoints\n            J.positionLabel = placementPoints\n            K.positionLabel = placementPoints\n            LabelsPt = labelPoint(\n              A,\n              B,\n              C,\n              D,\n              E,\n              F,\n              G,\n              H,\n              I,\n              J,\n              K,\n              L,\n              M,\n              N,\n              O,\n              P,\n              Q,\n              R,\n            )\n\n            objets.push(PositionPt, LabelsPt, Grille, Seg)\n            texte =\n              this.classe === 3\n                ? `Sans justifier, donner l'image du segment $[${nomPDSeg}${nomPASeg}]$ par la translation de vecteur $\\\\overrightarrow{${nomOR}${nomEXT}}$.`\n                : `Sans justifier, donner l'image du segment $[${nomPDSeg}${nomPASeg}]$ par la translation qui transforme $${nomOR}$ en $${nomEXT}$.`\n            texte += mathalea2d(\n              {\n                xmin: -1,\n                ymin: -1,\n                xmax: 12,\n                ymax: 5,\n                pixelsParCm: 20,\n                scale: 0.5,\n                zoom: 1.75,\n              },\n              objets,\n            ) // On trace le graphique de la solution\n\n            if (this.interactif) {\n              texte += ajouteChampTexteMathLive(\n                this,\n                i,\n                KeyboardType.alphanumeric,\n                {\n                  texteAvant: `<br><br>L'image du segment $[${nomPDSeg}${nomPASeg}]$ est :`,\n                  texteApres: '.',\n                },\n              )\n            }\n\n            const nomVecDepl = representantNomme(\n              VecDepl,\n              PtDepartSeg,\n              nomOR + nomEXT,\n              1,\n              'green',\n            ) // Affiche le nom du vecteur déplacement\n            const PositionPtCorr = tracePoint(\n              A,\n              B,\n              C,\n              D,\n              E,\n              F,\n              G,\n              H,\n              I,\n              J,\n              K,\n              L,\n              M,\n              N,\n              O,\n              P,\n              Q,\n              R,\n              'lightgray',\n            )\n            const LabelsPtCorr = labelPoint(\n              A,\n              B,\n              C,\n              D,\n              E,\n              F,\n              G,\n              H,\n              I,\n              J,\n              K,\n              L,\n              M,\n              N,\n              O,\n              P,\n              Q,\n              R,\n              'lightgray',\n            )\n            objetsCorr.push(\n              PositionPtCorr,\n              LabelsPtCorr,\n              Grille,\n              VecDeplRep,\n              Seg,\n              SegSOL,\n            )\n\n            // Affichage du vecteur natif\n            // Cas pour les 4èmes et cas pour les 2ndes, affichage du vecteur ou pas\n            if (this.classe === 2) objetsCorr.push(nomVecDepl)\n\n            // Cas où les vecteurs se confondent partiellement\n            if (!VecDeplRep.estSecant(representant(VecDepl, OrigVec))) {\n              objetsCorr.push(labelPoint(OrigVec, ExtrVec, 'green'))\n              objetsCorr.push(representant(VecDepl, OrigVec, 'green'))\n            }\n\n            objetsCorr.push(\n              labelPoint(PtDepartSeg, PtArrivSeg, 'blue'),\n              tracePoint(PtDepartSeg, PtArrivSeg, 'blue'),\n            )\n            const ptSOLPDSeg = translation(PtDepartSeg, VecDepl, nomSOLPDSeg)\n            ptSOLPDSeg.positionLabel =\n              ptSOLPDSeg.y === 0\n                ? 'below'\n                : ptSOLPDSeg.y === 4\n                  ? 'above'\n                  : placementPoints\n            const ptSOLPASeg = translation(PtArrivSeg, VecDepl, nomSOLPASeg)\n            ptSOLPASeg.positionLabel =\n              ptSOLPASeg.y === 0\n                ? 'below'\n                : ptSOLPASeg.y === 4\n                  ? 'above'\n                  : placementPoints\n\n            objetsCorr.push(tracePoint(ptSOLPDSeg, '#f15929'))\n            objetsCorr.push(tracePoint(ptSOLPASeg, '#f15929'))\n            objetsCorr.push(labelPoint(ptSOLPDSeg, '#f15929'))\n            objetsCorr.push(labelPoint(ptSOLPASeg, '#f15929'))\n\n            texteCorr =\n              this.classe === 3\n                ? `Le segment $${miseEnEvidence(`[${nomSOLPDSeg}${nomSOLPASeg}]`)}$ est l'image du segment $[${nomPDSeg}${nomPASeg}]$ par la translation de vecteur $\\\\overrightarrow{${nomOR}${nomEXT}}$.`\n                : `Le segment $${miseEnEvidence(`[${nomSOLPDSeg}${nomSOLPASeg}]`)}$ est l'image du segment $[${nomPDSeg}${nomPASeg}]$ par la translation qui transforme $${nomOR}$ en $${nomEXT}$.`\n            texteCorr += mathalea2d(\n              {\n                xmin: -1,\n                ymin: -1,\n                xmax: 12,\n                ymax: 5,\n                pixelsParCm: 20,\n                scale: 0.5,\n                zoom: 1.75,\n              },\n              objetsCorr,\n            ) // On trace le graphique de la solution\n            const tousNomsSegments = [\n              `[${nomSOLPDSeg}${nomSOLPASeg}]`,\n              `[${nomSOLPASeg}${nomSOLPDSeg}]`,\n            ]\n            setReponse(this, i, tousNomsSegments, { formatInteractif: 'texte' })\n          }\n          break\n\n        case 'triangle':\n        default:\n          {\n            // À partir d'un triangle\n            const Pt1Triangle = choice([\n              A,\n              B,\n              C,\n              D,\n              E,\n              F,\n              G,\n              H,\n              I,\n              J,\n              K,\n              L,\n              M,\n              N,\n              O,\n              P,\n              Q,\n              R,\n            ])\n            PtDepart = Pt1Triangle\n            xPt2Triangle = Pt1Triangle.x + choice([-2, 0, 2])\n            let yPt2Triangle = Pt1Triangle.y + choice([-2, 0, 2])\n            let xPt3Triangle: number = -1 // j'initialise avec une valeur bidon, c'est assigné dans le while.\n            let yPt3Triangle: number = -1\n            while (\n              xPt2Triangle < 0 ||\n              xPt2Triangle > 10 ||\n              yPt2Triangle < 0 ||\n              yPt2Triangle > 4 ||\n              (xPt2Triangle === Pt1Triangle.x && yPt2Triangle === Pt1Triangle.y)\n            ) {\n              xPt2Triangle = Pt1Triangle.x + choice([-2, 0, 2])\n              yPt2Triangle = Pt1Triangle.y + choice([-2, 0, 2])\n            }\n            if (xPt2Triangle === Pt1Triangle.x) {\n              xPt3Triangle = xPt2Triangle + choice([-2, 2])\n              yPt3Triangle = yPt2Triangle\n            }\n            if (yPt2Triangle === Pt1Triangle.y) {\n              yPt3Triangle = yPt2Triangle + choice([-2, 2])\n              xPt3Triangle = xPt2Triangle\n            }\n            if (\n              xPt2Triangle !== Pt1Triangle.x &&\n              yPt2Triangle !== Pt1Triangle.y\n            ) {\n              xPt3Triangle = choice([Pt1Triangle.x, xPt2Triangle])\n              if (xPt3Triangle === Pt1Triangle.x) {\n                yPt3Triangle = yPt2Triangle\n              } else {\n                yPt3Triangle = Pt1Triangle.y\n              }\n            }\n            do {\n              if (xPt2Triangle === Pt1Triangle.x) {\n                xPt3Triangle = xPt2Triangle + choice([-2, 2])\n                yPt3Triangle = yPt2Triangle\n              }\n              if (yPt2Triangle === Pt1Triangle.y) {\n                yPt3Triangle = yPt2Triangle + choice([-2, 2])\n                xPt3Triangle = xPt2Triangle\n              }\n              if (\n                xPt2Triangle !== Pt1Triangle.x &&\n                yPt2Triangle !== Pt1Triangle.y\n              ) {\n                xPt3Triangle = choice([Pt1Triangle.x, xPt2Triangle])\n                if (xPt3Triangle === Pt1Triangle.x) {\n                  yPt3Triangle = yPt2Triangle\n                } else {\n                  yPt3Triangle = Pt1Triangle.y\n                }\n              }\n            } while (\n              xPt3Triangle < 0 ||\n              xPt3Triangle > 10 ||\n              yPt3Triangle < 0 ||\n              yPt3Triangle > 4\n            )\n            const nomPD1Tri = Pt1Triangle.nom\n            const nomPD2Tri =\n              NomPt[\n                CoorPt.findIndex(\n                  (couple) =>\n                    couple[0] === xPt2Triangle && couple[1] === yPt2Triangle,\n                )\n              ]\n            const Pt2Triangle =\n              Pt[\n                CoorPt.findIndex(\n                  (couple) =>\n                    couple[0] === xPt2Triangle && couple[1] === yPt2Triangle,\n                )\n              ]\n            const nomPD3Tri =\n              NomPt[\n                CoorPt.findIndex(\n                  (couple) =>\n                    couple[0] === xPt3Triangle && couple[1] === yPt3Triangle,\n                )\n              ]\n            const Pt3Triangle =\n              Pt[\n                CoorPt.findIndex(\n                  (couple) =>\n                    couple[0] === xPt3Triangle && couple[1] === yPt3Triangle,\n                )\n              ]\n            let OrigVec = choice(\n              [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R],\n              [Pt1Triangle, Pt2Triangle, Pt3Triangle],\n            )\n            let ExtrVec = choice(\n              [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R],\n              [Pt1Triangle, Pt2Triangle, Pt3Triangle, OrigVec],\n            )\n            let xSOLPA1Tri = Pt1Triangle.x + ExtrVec.x - OrigVec.x\n            let ySOLPA1Tri = Pt1Triangle.y + ExtrVec.y - OrigVec.y\n            let xSOLPA2Tri = xPt2Triangle + ExtrVec.x - OrigVec.x\n            let ySOLPA2Tri = yPt2Triangle + ExtrVec.y - OrigVec.y\n            let xSOLPA3Tri = xPt3Triangle + ExtrVec.x - OrigVec.x\n            let ySOLPA3Tri = yPt3Triangle + ExtrVec.y - OrigVec.y\n            while (\n              xSOLPA1Tri < 0 ||\n              xSOLPA2Tri < 0 ||\n              xSOLPA3Tri < 0 ||\n              ySOLPA1Tri < 0 ||\n              ySOLPA2Tri < 0 ||\n              ySOLPA3Tri < 0 ||\n              xSOLPA1Tri > 10 ||\n              xSOLPA2Tri > 10 ||\n              xSOLPA3Tri > 10 ||\n              ySOLPA1Tri > 4 ||\n              ySOLPA2Tri > 4 ||\n              ySOLPA3Tri > 4\n            ) {\n              OrigVec = choice(\n                [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R],\n                [Pt1Triangle, Pt2Triangle, Pt3Triangle],\n              )\n              ExtrVec = choice(\n                [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R],\n                [Pt1Triangle, Pt2Triangle, Pt3Triangle, OrigVec],\n              )\n              xSOLPA1Tri = Pt1Triangle.x + ExtrVec.x - OrigVec.x\n              ySOLPA1Tri = Pt1Triangle.y + ExtrVec.y - OrigVec.y\n              xSOLPA2Tri = xPt2Triangle + ExtrVec.x - OrigVec.x\n              ySOLPA2Tri = yPt2Triangle + ExtrVec.y - OrigVec.y\n              xSOLPA3Tri = xPt3Triangle + ExtrVec.x - OrigVec.x\n              ySOLPA3Tri = yPt3Triangle + ExtrVec.y - OrigVec.y\n            }\n\n            // Nom des points pertinents\n            const nomOR = OrigVec.nom\n            const nomEXT = ExtrVec.nom\n            const nomSOLPA1Tri =\n              NomPt[\n                CoorPt.findIndex(\n                  (couple) =>\n                    couple[0] === xSOLPA1Tri && couple[1] === ySOLPA1Tri,\n                )\n              ]\n            const nomSOLPA2Tri =\n              NomPt[\n                CoorPt.findIndex(\n                  (couple) =>\n                    couple[0] === xSOLPA2Tri && couple[1] === ySOLPA2Tri,\n                )\n              ]\n            const nomSOLPA3Tri =\n              NomPt[\n                CoorPt.findIndex(\n                  (couple) =>\n                    couple[0] === xSOLPA3Tri && couple[1] === ySOLPA3Tri,\n                )\n              ]\n\n            // Segments origines\n            const Seg1 = segment(\n              Pt1Triangle.x,\n              Pt1Triangle.y,\n              xPt2Triangle,\n              yPt2Triangle,\n              'blue',\n            )\n            Seg1.epaisseur = 2 // Variable qui grossit le tracé du segment\n            const Seg2 = segment(\n              Pt1Triangle.x,\n              Pt1Triangle.y,\n              xPt3Triangle,\n              yPt3Triangle,\n              'blue',\n            )\n            Seg2.epaisseur = 2 // Variable qui grossit le tracé du segment\n            const Seg3 = segment(\n              xPt2Triangle,\n              yPt2Triangle,\n              xPt3Triangle,\n              yPt3Triangle,\n              'blue',\n            )\n            Seg3.epaisseur = 2 // Variable qui grossit le tracé du segment\n\n            // Segment images\n            const SegSOL1 = segment(\n              xSOLPA1Tri,\n              ySOLPA1Tri,\n              xSOLPA2Tri,\n              ySOLPA2Tri,\n              '#f15929',\n            )\n            SegSOL1.epaisseur = 2 // Variable qui grossit le tracé du segment\n            const SegSOL2 = segment(\n              xSOLPA1Tri,\n              ySOLPA1Tri,\n              xSOLPA3Tri,\n              ySOLPA3Tri,\n              '#f15929',\n            )\n            SegSOL2.epaisseur = 2 // Variable qui grossit le tracé du segment\n            const SegSOL3 = segment(\n              xSOLPA2Tri,\n              ySOLPA2Tri,\n              xSOLPA3Tri,\n              ySOLPA3Tri,\n              '#f15929',\n            )\n            SegSOL3.epaisseur = 2 // Variable qui grossit le tracé du segment\n\n            // Recherche du meilleur placement des points G à L pour éviter chevauchement\n            const placementPoints =\n              coefDirVecteurEgaleA1(Seg1, Seg2, Seg3) ||\n              coefDirVecteurEgaleA1(SegSOL1, SegSOL2, SegSOL3)\n                ? 'below right'\n                : 'below left'\n            // G.positionLabel = placementPoints\n            H.positionLabel = placementPoints\n            I.positionLabel = placementPoints\n            J.positionLabel = placementPoints\n            K.positionLabel = placementPoints\n            // L.positionLabel = placementPoints\n            LabelsPt = labelPoint(\n              A,\n              B,\n              C,\n              D,\n              E,\n              F,\n              G,\n              H,\n              I,\n              J,\n              K,\n              L,\n              M,\n              N,\n              O,\n              P,\n              Q,\n              R,\n            )\n\n            objets.push(PositionPt, LabelsPt, Grille, Seg1, Seg2, Seg3)\n\n            // Cas pour les 4èmes et cas pour les 2ndes, vecteur ou pas\n            texte =\n              this.classe === 2\n                ? `Sans justifier, donner l'image du triangle $${nomPD1Tri}${nomPD2Tri}${nomPD3Tri}$ par la translation de vecteur $\\\\overrightarrow{${nomOR}${nomEXT}}$.`\n                : `Sans justifier, donner l'image du triangle $${nomPD1Tri}${nomPD2Tri}${nomPD3Tri}$ par la translation qui transforme $${nomOR}$ en $${nomEXT}$.`\n            texte += mathalea2d(\n              {\n                xmin: -1,\n                ymin: -1,\n                xmax: 12,\n                ymax: 5,\n                pixelsParCm: 20,\n                scale: 0.5,\n                zoom: 1.75,\n              },\n              objets,\n            ) // On trace le graphique de la solution\n\n            if (this.interactif) {\n              texte += ajouteChampTexteMathLive(\n                this,\n                i,\n                KeyboardType.alphanumeric,\n                {\n                  texteAvant: `<br><br>L'image du triangle $${nomPD1Tri}${nomPD2Tri}${nomPD3Tri}$ est :`,\n                  texteApres: '.',\n                },\n              )\n            }\n\n            // Vecteur natif\n            const VecDepl = vecteur(\n              ExtrVec.x - OrigVec.x,\n              ExtrVec.y - OrigVec.y,\n            ) // Crée le vecteur déplacement\n\n            // Vecteur issu d'un sommet du triangle (qui ne soit pas confondu avec un côté des deux triangles)\n            const sommetsTriangle = [Pt1Triangle, Pt2Triangle, Pt3Triangle]\n            let VecDeplRep = representant(VecDepl, Pt1Triangle, 'green') // Trace le vecteur déplacement\n            let ee = 0\n            while (\n              estEgalAUnAutreSegment(VecDeplRep, SegSOL1, SegSOL2, SegSOL3) ||\n              estEgalAUnAutreSegment(VecDeplRep, Seg1, Seg2, Seg3)\n            ) {\n              ee++\n              VecDeplRep = representant(VecDepl, sommetsTriangle[ee], 'green')\n            }\n            VecDeplRep.epaisseur = 2 // Variable qui grossit le tracé du vecteur\n            VecDeplRep.styleExtremites = '->' // Donne l'extrémité du vecteur\n            const nomVecDepl = representantNomme(\n              VecDepl,\n              sommetsTriangle[ee],\n              nomOR + nomEXT,\n              1,\n              'green',\n            ) // Affiche le nom du vecteur déplacement\n\n            // Les points de la grille correction\n            const PositionPtCorr = tracePoint(\n              A,\n              B,\n              C,\n              D,\n              E,\n              F,\n              G,\n              H,\n              I,\n              J,\n              K,\n              L,\n              M,\n              N,\n              O,\n              P,\n              Q,\n              R,\n              'lightgray',\n            )\n            const LabelsPtCorr = labelPoint(\n              A,\n              B,\n              C,\n              D,\n              E,\n              F,\n              G,\n              H,\n              I,\n              J,\n              K,\n              L,\n              M,\n              N,\n              O,\n              P,\n              Q,\n              R,\n              'lightgray',\n            )\n\n            // Creation du debut de l'objet Correction\n            objetsCorr.push(\n              PositionPtCorr,\n              LabelsPtCorr,\n              Grille,\n              VecDeplRep,\n              SegSOL1,\n              SegSOL2,\n              SegSOL3,\n              Seg1,\n              Seg2,\n              Seg3,\n            )\n\n            // Affichage du vecteur natif\n            // Cas pour les 4èmes et cas pour les 2ndes, affichage du vecteur ou pas\n            if (this.classe === 2) objetsCorr.push(nomVecDepl)\n\n            // Cas où les vecteurs se confondent partiellement\n            if (!VecDeplRep.estSecant(representant(VecDepl, OrigVec))) {\n              objetsCorr.push(labelPoint(OrigVec, ExtrVec, 'green'))\n              objetsCorr.push(representant(VecDepl, OrigVec, 'green'))\n            }\n\n            objetsCorr.push(\n              labelPoint(Pt1Triangle, Pt2Triangle, Pt3Triangle, 'blue'),\n              tracePoint(Pt1Triangle, Pt2Triangle, Pt3Triangle, 'blue'),\n            )\n\n            // Affichage des sommets du triangle image\n            const Pt1TriangleSOL = translation(\n              Pt1Triangle,\n              VecDepl,\n              nomSOLPA1Tri,\n            )\n            Pt1TriangleSOL.positionLabel =\n              Pt1TriangleSOL.y === 0\n                ? 'below'\n                : Pt1TriangleSOL.y === 4\n                  ? 'above'\n                  : placementPoints\n            objetsCorr.push(tracePoint(Pt1TriangleSOL, '#f15929'))\n            objetsCorr.push(labelPoint(Pt1TriangleSOL, '#f15929'))\n            const Pt2TriangleSOL = translation(\n              Pt2Triangle,\n              VecDepl,\n              nomSOLPA2Tri,\n            )\n            Pt2TriangleSOL.positionLabel =\n              Pt2TriangleSOL.y === 0\n                ? 'below'\n                : Pt2TriangleSOL.y === 4\n                  ? 'above'\n                  : placementPoints\n            objetsCorr.push(tracePoint(Pt2TriangleSOL, '#f15929'))\n            objetsCorr.push(labelPoint(Pt2TriangleSOL, '#f15929'))\n            const Pt3TriangleSOL = translation(\n              Pt3Triangle,\n              VecDepl,\n              nomSOLPA3Tri,\n            )\n            Pt3TriangleSOL.positionLabel =\n              Pt3TriangleSOL.y === 0\n                ? 'below'\n                : Pt3TriangleSOL.y === 4\n                  ? 'above'\n                  : placementPoints\n            objetsCorr.push(tracePoint(Pt3TriangleSOL, '#f15929'))\n            objetsCorr.push(labelPoint(Pt3TriangleSOL, '#f15929'))\n\n            texteCorr =\n              this.classe === 2\n                ? `Le triangle $${miseEnEvidence(`${nomSOLPA1Tri}${nomSOLPA2Tri}${nomSOLPA3Tri}`)}$ est l'image du triangle $${nomPD1Tri}${nomPD2Tri}${nomPD3Tri}$ par la translation de vecteur $\\\\overrightarrow{${nomOR}${nomEXT}}$.`\n                : `Le triangle $${miseEnEvidence(`${nomSOLPA1Tri}${nomSOLPA2Tri}${nomSOLPA3Tri}`)}$ est l'image du triangle $${nomPD1Tri}${nomPD2Tri}${nomPD3Tri}$ par la translation qui transforme $${nomOR}$ en $${nomEXT}$.`\n            texteCorr += mathalea2d(\n              {\n                xmin: -1,\n                ymin: -1,\n                xmax: 12,\n                ymax: 5,\n                pixelsParCm: 20,\n                scale: 0.5,\n                zoom: 1.75,\n              },\n              objetsCorr,\n            ) // On trace le graphique de la solution\n\n            setReponse(\n              this,\n              i,\n              allTrianglesNames(nomSOLPA1Tri, nomSOLPA2Tri, nomSOLPA3Tri),\n              { formatInteractif: 'texte' },\n            )\n          }\n          break\n      }\n      if (\n        this.questionJamaisPosee(\n          i,\n          xSOL,\n          xPtArrivSeg,\n          xPt2Triangle,\n          PtDepart.nom,\n        )\n      ) {\n        // Si la question n'a jamais été posée, on en créé une autre\n        this.listeQuestions[i] = texte\n        this.listeCorrections[i] = texteCorr\n        i++\n      }\n      cpt++\n    }\n    listeQuestionsToContenu(this)\n  }\n}\n"],"names":["interactifReady","interactifType","titre","dateDePublication","dateDeModifImportante","uuid","refs","allTrianglesNames","nomA","nomB","nomC","nomsSommets","noms","premierSommet","deuxiemmeSommet","troisiemeSommet","coefDirVecteurEgaleA1","seg1","seg2","seg3","coefDirVecteurSegEgaleA1","estEgalAUnAutreSegment","s","s1","s2","s3","ImagePtParTranslation","Exercice","__publicField","listeTypeDeQuestions","gestionnaireFormulaireTexte","i","texte","texteCorr","cpt","objets","objetsCorr","A","point","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","CoorPt","NomPt","Pt","PositionPt","tracePoint","LabelsPt","labelPoint","Grille","grille","xSOL","xPtArrivSeg","xPt2Triangle","PtDepart","choice","OrigVec","ExtrVec","ySOL","nomPD","nomOR","nomEXT","NomSOL","couple","trPtDepart","mathalea2d","ajouteChampTexteMathLive","KeyboardType","VecDepl","vecteur","VecDeplRep","representant","nomVecDepl","representantNomme","PositionPtCorr","LabelsPtCorr","ptSol","translation","trPtSol","miseEnEvidence","setReponse","PtDepartSeg","yPtArrivSeg","Seg","segment","nomPDSeg","nomPASeg","PtArrivSeg","xSOLPDSeg","ySOLPDSeg","xSOLPASeg","ySOLPASeg","nomSOLPDSeg","nomSOLPASeg","SegSOL","placementPoints","ptSOLPDSeg","ptSOLPASeg","tousNomsSegments","Pt1Triangle","yPt2Triangle","xPt3Triangle","yPt3Triangle","nomPD1Tri","nomPD2Tri","Pt2Triangle","nomPD3Tri","Pt3Triangle","xSOLPA1Tri","ySOLPA1Tri","xSOLPA2Tri","ySOLPA2Tri","xSOLPA3Tri","ySOLPA3Tri","nomSOLPA1Tri","nomSOLPA2Tri","nomSOLPA3Tri","Seg1","Seg2","Seg3","SegSOL1","SegSOL2","SegSOL3","sommetsTriangle","ee","Pt1TriangleSOL","Pt2TriangleSOL","Pt3TriangleSOL","listeQuestionsToContenu"],"mappings":"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"}