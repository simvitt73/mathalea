import{E as N,$ as L,r as u,ay as Q,a1 as s,u as C,o as O,W as y}from"./index-BB3ZcMz7.js";import{R as M}from"./Relatif-Cbr50-hq.js";/* empty css                         */import"./vendors/svelte-BrkG1v2Q.js";import"./vendors/clsx-B-dksMZM.js";import"./vendors/esm-env-rsSWfq8L.js";import"./vendors/ua-parser-js-D4W63oil.js";import"./vendors/three-DbtVOfJ6.js";import"./vendors/decimal.js-BceHFVC1.js";import"./vendors/katex-BSW5_u9c.js";import"./vendors/seedrandom-Cz-2rAdY.js";import"./vendors/apigeom-DuS4UMKQ.js";import"./vendors/mathjs-DKCMnljp.js";import"./vendors/babel_runtime-BFeZ_VDU.js";import"./vendors/javascript-natural-sort-QZS4Fyws.js";import"./vendors/escape-latex-BegatI0j.js";import"./vendors/complex.js-C1JbXRlX.js";import"./vendors/typed-function-CVM02vEe.js";import"./vendors/fraction.js-CYLvagDM.js";import"./vendors/tiny-emitter-DbO2P2s3.js";import"./vendors/xstate-BSXD3zxA.js";import"./vendors/crypto-js-DElKCTCw.js";import"./json/referentielStaticCH-DrWiqhRe.js";import"./json/referentielStaticFR-DTeSOhOd.js";import"./json/uuidsToUrlFR-Cc7zu7XX.js";import"./vendors/cortex-js_compute-engine-Bo_2zfG3.js";import"./vendors/jspreadsheet-ce-kKqtlqR-.js";import"./vendors/jsuites-D-TmSgJs.js";import"./vendors/jspreadsheet_formula-CXu1m5Ak.js";import"./vendors/mathlive-2YgxEGya.js";import"./vendors/bugsnag_js-B7oJ4uO9.js";import"./vendors/bugsnag_browser-CBi0d3dm.js";import"./vendors/big-integer-RrBdqg8C.js";import"./vendors/mixer_postmessage-rpc-JyZjM7pP.js";import"./vendors/eventemitter3-COjgItKg.js";import"./vendors/scratchblocks-BVPCj2Ee.js";import"./json/scratchFr-BNITwCy2.js";import"./json/refToUuidFR-fVupTN-r.js";import"./json/refToUuidCH-BX1ZhSY0.js";import"./json/codeToLevelList-BfkorBF2.js";import"./json/codeToThemeList-B4uzTsqe.js";import"./vendors/loadjs-Dy50zFDn.js";import"./json/referentielProfs-BdpwqI3j.js";import"./json/uuidsRessources-jdCgFfXb.js";import"./json/referentielBibliotheque-sQm1j5fm.js";import"./vendors/file-saver-Cqu1O8xU.js";import"./vendors/jszip-BuNf6wCF.js";import"./vendors/jszip-utils-DhFX1KUq.js";import"./vendors/copy-image-clipboard-Cf9y-QAU.js";import"./vendors/qrcode-BsrOgw3n.js";import"./vendors/dijkstrajs-COg3n3zL.js";import"./vendors/brace-DEOAbY2S.js";import"./json/referentielAppsTierce-SxU58PZT.js";import"./vendors/sortablejs-DdTU3J9A.js";import"./json/carouselContent-Bjt6Yxr-.js";import"./json/levelsThemesList-CXNnIZKX.js";import"./json/levelsThemesListCH-BErSids0.js";import"./json/referentiel2022CH-eCsKGSUT.js";import"./json/referentiel2022FR-noHHLeEt.js";import"./json/referentielGeometrieDynamique-BJ2PHXsv.js";import"./json/referentielRessources-BU2QQoSD.js";import"./json/referentielsActivation-CpD_hoec.js";const We=!0,je="qcm",ze=!0,Ae="qcmMono",Be="Déterminer le signe d'un facteur dans une multiplication ou un quotient de relatifs",He="18/09/2024",Ke="73187",Ue={"fr-fr":["4C10-6"],"fr-ch":["10NO4-8"]};class Xe extends N{constructor(){super(),this.besoinFormulaireNumerique=["Niveau de difficulté",5,`1 : Multiplications
2 : Quotients 
3 : Multiplications et quotients 
4 : Multiplications avec plusieurs fois la lettre (dont puissances) 
5 : Mélange `],this.sup=3,this.correctionDetailleeDisponible=!0,this.correctionDetaillee=!1,this.spacing=2,this.nbQuestions=3}nouvelleVersion(){let P;switch(this.sup){case 1:P=[1];break;case 2:P=[2];break;case 3:P=[1,2];break;case 4:P=[3,4];break;default:P=[1,2,3,4];break}const k=L(P,this.nbQuestions);for(let g=0,f,t,l,D,d,S,x=0;g<this.nbQuestions&&x<50;){this.autoCorrection[g]={};const q=20,i=new M(u(-1,1,[0])*u(1,q),u(-1,1,[0])*u(1,q),u(-1,1,[0])*u(1,q),u(-1,1,[0])*u(1,q),u(-1,1,[0])*u(1,q)),R=["n","x","y","a","m"],r=R[u(0,R.length-1)],n=y(g+1),c=u(-1,1,[0]),b=k[g]===1?u(3,5):u(4,6);let h=u(0,b-1);const e=i.relatifs.slice(0,b-1),a=[];for(let o=0;o<e.length;o++)a.push(Q(e[o]));a.splice(h,0,r);let $="",p,m;switch(f=`Donner le signe de $${r}$ pour que $${n}$ soit ${c===-1?"négatif":"positif"}. <br>`,t=`${s("Supposons que "+r+" soit positif : ","blue")}`,k[g]){case 1:$+=`${a[0]} `;for(let o=1;o<b;o++)$+=`\\times ${a[o]}`;f+=`$ ${n} =  ${$} $ <br>`,S=c===i.getSigneProduitNumber(...e)?"positif":"négatif",this.correctionDetaillee?(t+=`<br> ${i.setRegleSigneProduit(...e)}`,t+=`<br><br> Donc si ${s(r+" est positif","black")} $ ${$} $ est ${s(i.getSigneProduitString(...e),"black")}.`,t+=`<br><br> ${s("Supposons maintenant que "+r+" soit négatif : ","blue")}`,e.push(-1),t+=`<br><br> ${i.setRegleSigneProduit(...e,-1)}`,t+=`<br><br> Donc si ${s(r+" est négatif","black")} $ ${$} $ est ${s(i.getSigneProduitString(...e),"black")}.`,t+=`<br><br> ${s("Conclusion :","blue")} <br>Il faut donc que $ ${r} $ soit ${s(c===i.getSigneProduitNumber(...e)?"négatif":"positif")} pour que $${n}$ soit ${c===-1?"négatif":"positif"}.`):t=`Il faut que $ ${r} $ soit ${c===i.getSigneProduitNumber(...e)?"positif":"négatif"} pour que $${n}$ soit ${c===-1?"négatif":"positif"}.`;break;case 2:$+="\\dfrac {"+a[0],D=u(2,b-2);for(let o=1;o<D+1;o++)$+=`\\times ${a[o]}`;$+="}{"+a[D+1];for(let o=D+2;o<b;o++)$+=`\\times ${a[o]}`;$+="}",f+=`$ ${n} =  ${$} $ <br>`,S=c===i.getSigneProduitNumber(...e)?"positif":"négatif",this.correctionDetaillee?(t+=`<br> ${i.setRegleSigneQuotient(...e)}`,t+=`<br><br> Donc si ${s(r+" est positif","black")} $ ${$} $ est ${s(i.getSigneProduitString(...e),"black")}.`,t+=`<br><br> ${s("Supposons maintenant que "+r+" soit négatif : ","blue")}`,e.push(-1),t+=`<br> ${i.setRegleSigneQuotient(...e)}`,t+=`<br><br> Donc si ${s(r+" est négatif","black")} $ ${$} $ est ${s(i.getSigneProduitString(...e),"black")}.`,t+=`<br><br> ${s("Conclusion :","blue")} <br>Il faut donc que $ ${r} $ soit ${s(c===i.getSigneProduitNumber(...e)?"négatif":"positif")} pour que $${n}$ soit ${c===-1?"négatif":"positif"}.`):t=`Il faut que $ ${r} $ soit ${c===i.getSigneProduitNumber(...e)?"positif":"négatif"} pour que $${n}$ soit ${c===-1?"négatif":"positif"}.`;break;case 3:p=u(-1,1,[0]),f=`Donner le signe de ${n} si $ ${r} $ est ${p===-1?"négatif":"positif"}. <br>`,t="",l=u(1,3),h=u(0,b-1);for(let o=0;o<l;o++)a.splice(h,0,r);$+=`${a[0]} `;for(let o=1;o<b+l;o++)$+=`\\times ${a[o]}`;m=`${e[0]} `;for(let o=1;o<b-1;o++)m+=`\\times ${e[o]}`;f+=`$ ${n} = ${$} $ <br>`,this.correctionDetaillee?(l===1||l===3?(t+=`On trouve ${l+1} fois le facteur $ ${r} $.<br> Or ${l+1} est pair donc leur produit sera positif.`,t+=`<br>Le signe de l'expression a donc le signe de : $ ${m} $`,t+=`<br><br> ${i.setRegleSigneProduit(...e)}`,t+=`<br><br>Donc ${n} est ${s(i.getSigneProduitString(...e))} quel que soit le signe de $ ${r} $.`):(t+=`On trouve ${l+1} fois le facteur $ ${r} $. <br> Or ${l+1} est impair donc leur produit est du signe de $ ${r} $ soit ${p===-1?"négatif":"positif"}.`,p===-1?(t+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${m} $`,t+=`<br><br> ${i.setRegleSigneProduit(...e)}`,e.push(-1),t+=`<br><br>Donc ${n} est ${s(i.getSigneProduitString(...e))} quand $ ${r} $ est ${p===-1?"négatif":"positif"}.`):(t+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${m} $`,t+=`<br><br> ${i.setRegleSigneProduit(...e)}`,t+=`<br><br>Donc ${n} est ${s(i.getSigneProduitString(...e))} quand $ ${r} $ est ${p===-1?"négatif":"positif"}.`)),S=i.getSigneProduitString(...e)):(l===1||l===3?t=`Donc ${n} est ${s(i.getSigneProduitString(...e))} quel que soit le signe de $ ${r} $.`:p===-1?(e.push(-1),t=`Donc ${n} est ${s(i.getSigneProduitString(...e))} quand $ ${r} $ est ${p===-1?"négatif":"positif"}.`):t=`Donc ${n} est ${s(i.getSigneProduitString(...e))} quand $ ${r} $ est ${p===-1?"négatif":"positif"}.`,S=i.getSigneProduitString(...e));break;case 4:p=u(-1,1,[0]),f=`Donner le signe de ${n} si $ ${r} $ est ${p===-1?"négatif":"positif"}. <br>`,t="",d=u(2,7),h===0?$+=a[0]+"^{"+d+"}":$+=a[0];for(let o=1;o<b;o++)o===h?$+="\\times "+a[o]+"^{"+d+"}":$+="\\times "+a[o];m=`${e[0]} `;for(let o=1;o<b-1;o++)m+=`\\times ${e[o]}`;f+=`$ ${n} =  ${$} $ <br>`,this.correctionDetaillee?d%2===0?(t+=`On trouve ${d} fois le facteur $ ${r} $.<br> Or ${d} est pair donc leur produit sera positif.`,t+=`<br>Le signe de l'expression a donc le signe de : $ ${m} $`,t+=`<br><br> ${i.setRegleSigneProduit(...e)}`,t+=`<br><br>Donc ${n} est ${s(i.getSigneProduitString(...e))} quel que soit le signe de $ ${r} $.`,S=i.getSigneProduitString(...e)):(t+=`On trouve ${d} fois le facteur $ ${r} $. <br> Or ${d} est impair donc leur produit est du signe de $ ${r} $ soit ${p===-1?"négatif":"positif"}.`,p===-1?(t+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${m} $`,t+=`<br><br> ${i.setRegleSigneProduit(...e)}`,e.push(-1),t+=`<br><br>Donc ${n} est ${s(i.getSigneProduitString(...e))} quand $ ${r} $ est ${p===-1?"négatif":"positif"}.`):(t+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${m} $`,t+=`<br><br> ${i.setRegleSigneProduit(...e)}`,t+=`<br><br>Donc ${n} est ${s(i.getSigneProduitString(...e))} quand $ ${r} $ est ${p===-1?"négatif":"positif"}.`),S=i.getSigneProduitString(...e)):(d%2===0?t+=`Donc ${n} est ${s(i.getSigneProduitString(...e))} quel que soit le signe de $ ${r} $.`:p===-1?(e.push(-1),t=`Donc ${n} est ${s(i.getSigneProduitString(...e))} quand $ ${r} $ est ${p===-1?"négatif":"positif"}.`):t=`Donc ${n} est ${s(i.getSigneProduitString(...e))} quand $ ${r} $ est ${p===-1?"négatif":"positif"}.`,S=i.getSigneProduitString(...e));break}this.autoCorrection[g]={enonce:f,options:{ordered:!0},propositions:[{texte:"négatif",statut:S==="négatif"},{texte:"positif",statut:S==="positif"}]},f+=C(this,g).texte,this.questionJamaisPosee(g,k[g],...e)&&(this.listeQuestions[g]=f,this.listeCorrections[g]=t,g++),x++}O(this)}}export{ze as amcReady,Ae as amcType,He as dateDeModifImportante,Xe as default,We as interactifReady,je as interactifType,Ue as refs,Be as titre,Ke as uuid};
//# sourceMappingURL=4C10-6-C5PoxBBM.js.map
