{"version":3,"file":"vitest_utils-CmkFzQWi.js","sources":["../../../node_modules/.pnpm/@vitest+utils@4.0.18/node_modules/@vitest/utils/dist/display.js","../../../node_modules/.pnpm/@vitest+utils@4.0.18/node_modules/@vitest/utils/dist/helpers.js","../../../node_modules/.pnpm/@vitest+utils@4.0.18/node_modules/@vitest/utils/dist/chunk-_commonjsHelpers.js","../../../node_modules/.pnpm/@vitest+utils@4.0.18/node_modules/@vitest/utils/dist/diff.js","../../../node_modules/.pnpm/@vitest+utils@4.0.18/node_modules/@vitest/utils/dist/serialize.js","../../../node_modules/.pnpm/@vitest+utils@4.0.18/node_modules/@vitest/utils/dist/error.js","../../../node_modules/.pnpm/@vitest+utils@4.0.18/node_modules/@vitest/utils/dist/timers.js","../../../node_modules/.pnpm/@vitest+utils@4.0.18/node_modules/@vitest/utils/dist/chunk-pathe.M-eThtNZ.js","../../../node_modules/.pnpm/@vitest+utils@4.0.18/node_modules/@vitest/utils/dist/source-map.js"],"sourcesContent":["import { plugins, format as format$1 } from '@vitest/pretty-format';\n\nconst ansiColors = {\n    bold: ['1', '22'],\n    dim: ['2', '22'],\n    italic: ['3', '23'],\n    underline: ['4', '24'],\n    // 5 & 6 are blinking\n    inverse: ['7', '27'],\n    hidden: ['8', '28'],\n    strike: ['9', '29'],\n    // 10-20 are fonts\n    // 21-29 are resets for 1-9\n    black: ['30', '39'],\n    red: ['31', '39'],\n    green: ['32', '39'],\n    yellow: ['33', '39'],\n    blue: ['34', '39'],\n    magenta: ['35', '39'],\n    cyan: ['36', '39'],\n    white: ['37', '39'],\n    brightblack: ['30;1', '39'],\n    brightred: ['31;1', '39'],\n    brightgreen: ['32;1', '39'],\n    brightyellow: ['33;1', '39'],\n    brightblue: ['34;1', '39'],\n    brightmagenta: ['35;1', '39'],\n    brightcyan: ['36;1', '39'],\n    brightwhite: ['37;1', '39'],\n    grey: ['90', '39'],\n};\nconst styles = {\n    special: 'cyan',\n    number: 'yellow',\n    bigint: 'yellow',\n    boolean: 'yellow',\n    undefined: 'grey',\n    null: 'bold',\n    string: 'green',\n    symbol: 'green',\n    date: 'magenta',\n    regexp: 'red',\n};\nconst truncator = '…';\nfunction colorise(value, styleType) {\n    const color = ansiColors[styles[styleType]] || ansiColors[styleType] || '';\n    if (!color) {\n        return String(value);\n    }\n    return `\\u001b[${color[0]}m${String(value)}\\u001b[${color[1]}m`;\n}\nfunction normaliseOptions({ showHidden = false, depth = 2, colors = false, customInspect = true, showProxy = false, maxArrayLength = Infinity, breakLength = Infinity, seen = [], \n// eslint-disable-next-line no-shadow\ntruncate = Infinity, stylize = String, } = {}, inspect) {\n    const options = {\n        showHidden: Boolean(showHidden),\n        depth: Number(depth),\n        colors: Boolean(colors),\n        customInspect: Boolean(customInspect),\n        showProxy: Boolean(showProxy),\n        maxArrayLength: Number(maxArrayLength),\n        breakLength: Number(breakLength),\n        truncate: Number(truncate),\n        seen,\n        inspect,\n        stylize,\n    };\n    if (options.colors) {\n        options.stylize = colorise;\n    }\n    return options;\n}\nfunction isHighSurrogate(char) {\n    return char >= '\\ud800' && char <= '\\udbff';\n}\nfunction truncate(string, length, tail = truncator) {\n    string = String(string);\n    const tailLength = tail.length;\n    const stringLength = string.length;\n    if (tailLength > length && stringLength > tailLength) {\n        return tail;\n    }\n    if (stringLength > length && stringLength > tailLength) {\n        let end = length - tailLength;\n        if (end > 0 && isHighSurrogate(string[end - 1])) {\n            end = end - 1;\n        }\n        return `${string.slice(0, end)}${tail}`;\n    }\n    return string;\n}\n// eslint-disable-next-line complexity\nfunction inspectList(list, options, inspectItem, separator = ', ') {\n    inspectItem = inspectItem || options.inspect;\n    const size = list.length;\n    if (size === 0)\n        return '';\n    const originalLength = options.truncate;\n    let output = '';\n    let peek = '';\n    let truncated = '';\n    for (let i = 0; i < size; i += 1) {\n        const last = i + 1 === list.length;\n        const secondToLast = i + 2 === list.length;\n        truncated = `${truncator}(${list.length - i})`;\n        const value = list[i];\n        // If there is more than one remaining we need to account for a separator of `, `\n        options.truncate = originalLength - output.length - (last ? 0 : separator.length);\n        const string = peek || inspectItem(value, options) + (last ? '' : separator);\n        const nextLength = output.length + string.length;\n        const truncatedLength = nextLength + truncated.length;\n        // If this is the last element, and adding it would\n        // take us over length, but adding the truncator wouldn't - then break now\n        if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) {\n            break;\n        }\n        // If this isn't the last or second to last element to scan,\n        // but the string is already over length then break here\n        if (!last && !secondToLast && truncatedLength > originalLength) {\n            break;\n        }\n        // Peek at the next string to determine if we should\n        // break early before adding this item to the output\n        peek = last ? '' : inspectItem(list[i + 1], options) + (secondToLast ? '' : separator);\n        // If we have one element left, but this element and\n        // the next takes over length, the break early\n        if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) {\n            break;\n        }\n        output += string;\n        // If the next element takes us to length -\n        // but there are more after that, then we should truncate now\n        if (!last && !secondToLast && nextLength + peek.length >= originalLength) {\n            truncated = `${truncator}(${list.length - i - 1})`;\n            break;\n        }\n        truncated = '';\n    }\n    return `${output}${truncated}`;\n}\nfunction quoteComplexKey(key) {\n    if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {\n        return key;\n    }\n    return JSON.stringify(key)\n        .replace(/'/g, \"\\\\'\")\n        .replace(/\\\\\"/g, '\"')\n        .replace(/(^\"|\"$)/g, \"'\");\n}\nfunction inspectProperty([key, value], options) {\n    options.truncate -= 2;\n    if (typeof key === 'string') {\n        key = quoteComplexKey(key);\n    }\n    else if (typeof key !== 'number') {\n        key = `[${options.inspect(key, options)}]`;\n    }\n    options.truncate -= key.length;\n    value = options.inspect(value, options);\n    return `${key}: ${value}`;\n}\n\nfunction inspectArray(array, options) {\n    // Object.keys will always output the Array indices first, so we can slice by\n    // `array.length` to get non-index properties\n    const nonIndexProperties = Object.keys(array).slice(array.length);\n    if (!array.length && !nonIndexProperties.length)\n        return '[]';\n    options.truncate -= 4;\n    const listContents = inspectList(array, options);\n    options.truncate -= listContents.length;\n    let propertyContents = '';\n    if (nonIndexProperties.length) {\n        propertyContents = inspectList(nonIndexProperties.map(key => [key, array[key]]), options, inspectProperty);\n    }\n    return `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ''} ]`;\n}\n\nconst getArrayName = (array) => {\n    // We need to special case Node.js' Buffers, which report to be Uint8Array\n    // @ts-ignore\n    if (typeof Buffer === 'function' && array instanceof Buffer) {\n        return 'Buffer';\n    }\n    if (array[Symbol.toStringTag]) {\n        return array[Symbol.toStringTag];\n    }\n    return array.constructor.name;\n};\nfunction inspectTypedArray(array, options) {\n    const name = getArrayName(array);\n    options.truncate -= name.length + 4;\n    // Object.keys will always output the Array indices first, so we can slice by\n    // `array.length` to get non-index properties\n    const nonIndexProperties = Object.keys(array).slice(array.length);\n    if (!array.length && !nonIndexProperties.length)\n        return `${name}[]`;\n    // As we know TypedArrays only contain Unsigned Integers, we can skip inspecting each one and simply\n    // stylise the toString() value of them\n    let output = '';\n    for (let i = 0; i < array.length; i++) {\n        const string = `${options.stylize(truncate(array[i], options.truncate), 'number')}${i === array.length - 1 ? '' : ', '}`;\n        options.truncate -= string.length;\n        if (array[i] !== array.length && options.truncate <= 3) {\n            output += `${truncator}(${array.length - array[i] + 1})`;\n            break;\n        }\n        output += string;\n    }\n    let propertyContents = '';\n    if (nonIndexProperties.length) {\n        propertyContents = inspectList(nonIndexProperties.map(key => [key, array[key]]), options, inspectProperty);\n    }\n    return `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ''} ]`;\n}\n\nfunction inspectDate(dateObject, options) {\n    const stringRepresentation = dateObject.toJSON();\n    if (stringRepresentation === null) {\n        return 'Invalid Date';\n    }\n    const split = stringRepresentation.split('T');\n    const date = split[0];\n    // If we need to - truncate the time portion, but never the date\n    return options.stylize(`${date}T${truncate(split[1], options.truncate - date.length - 1)}`, 'date');\n}\n\nfunction inspectFunction(func, options) {\n    const functionType = func[Symbol.toStringTag] || 'Function';\n    const name = func.name;\n    if (!name) {\n        return options.stylize(`[${functionType}]`, 'special');\n    }\n    return options.stylize(`[${functionType} ${truncate(name, options.truncate - 11)}]`, 'special');\n}\n\nfunction inspectMapEntry([key, value], options) {\n    options.truncate -= 4;\n    key = options.inspect(key, options);\n    options.truncate -= key.length;\n    value = options.inspect(value, options);\n    return `${key} => ${value}`;\n}\n// IE11 doesn't support `map.entries()`\nfunction mapToEntries(map) {\n    const entries = [];\n    map.forEach((value, key) => {\n        entries.push([key, value]);\n    });\n    return entries;\n}\nfunction inspectMap(map, options) {\n    if (map.size === 0)\n        return 'Map{}';\n    options.truncate -= 7;\n    return `Map{ ${inspectList(mapToEntries(map), options, inspectMapEntry)} }`;\n}\n\nconst isNaN = Number.isNaN || (i => i !== i); // eslint-disable-line no-self-compare\nfunction inspectNumber(number, options) {\n    if (isNaN(number)) {\n        return options.stylize('NaN', 'number');\n    }\n    if (number === Infinity) {\n        return options.stylize('Infinity', 'number');\n    }\n    if (number === -Infinity) {\n        return options.stylize('-Infinity', 'number');\n    }\n    if (number === 0) {\n        return options.stylize(1 / number === Infinity ? '+0' : '-0', 'number');\n    }\n    return options.stylize(truncate(String(number), options.truncate), 'number');\n}\n\nfunction inspectBigInt(number, options) {\n    let nums = truncate(number.toString(), options.truncate - 1);\n    if (nums !== truncator)\n        nums += 'n';\n    return options.stylize(nums, 'bigint');\n}\n\nfunction inspectRegExp(value, options) {\n    const flags = value.toString().split('/')[2];\n    const sourceLength = options.truncate - (2 + flags.length);\n    const source = value.source;\n    return options.stylize(`/${truncate(source, sourceLength)}/${flags}`, 'regexp');\n}\n\n// IE11 doesn't support `Array.from(set)`\nfunction arrayFromSet(set) {\n    const values = [];\n    set.forEach(value => {\n        values.push(value);\n    });\n    return values;\n}\nfunction inspectSet(set, options) {\n    if (set.size === 0)\n        return 'Set{}';\n    options.truncate -= 7;\n    return `Set{ ${inspectList(arrayFromSet(set), options)} }`;\n}\n\nconst stringEscapeChars = new RegExp(\"['\\\\u0000-\\\\u001f\\\\u007f-\\\\u009f\\\\u00ad\\\\u0600-\\\\u0604\\\\u070f\\\\u17b4\\\\u17b5\" +\n    '\\\\u200c-\\\\u200f\\\\u2028-\\\\u202f\\\\u2060-\\\\u206f\\\\ufeff\\\\ufff0-\\\\uffff]', 'g');\nconst escapeCharacters = {\n    '\\b': '\\\\b',\n    '\\t': '\\\\t',\n    '\\n': '\\\\n',\n    '\\f': '\\\\f',\n    '\\r': '\\\\r',\n    \"'\": \"\\\\'\",\n    '\\\\': '\\\\\\\\',\n};\nconst hex = 16;\nfunction escape(char) {\n    return (escapeCharacters[char] ||\n        `\\\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-4)}`);\n}\nfunction inspectString(string, options) {\n    if (stringEscapeChars.test(string)) {\n        string = string.replace(stringEscapeChars, escape);\n    }\n    return options.stylize(`'${truncate(string, options.truncate - 2)}'`, 'string');\n}\n\nfunction inspectSymbol(value) {\n    if ('description' in Symbol.prototype) {\n        return value.description ? `Symbol(${value.description})` : 'Symbol()';\n    }\n    return value.toString();\n}\n\nconst getPromiseValue = () => 'Promise{…}';\n\nfunction inspectObject$1(object, options) {\n    const properties = Object.getOwnPropertyNames(object);\n    const symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];\n    if (properties.length === 0 && symbols.length === 0) {\n        return '{}';\n    }\n    options.truncate -= 4;\n    options.seen = options.seen || [];\n    if (options.seen.includes(object)) {\n        return '[Circular]';\n    }\n    options.seen.push(object);\n    const propertyContents = inspectList(properties.map(key => [key, object[key]]), options, inspectProperty);\n    const symbolContents = inspectList(symbols.map(key => [key, object[key]]), options, inspectProperty);\n    options.seen.pop();\n    let sep = '';\n    if (propertyContents && symbolContents) {\n        sep = ', ';\n    }\n    return `{ ${propertyContents}${sep}${symbolContents} }`;\n}\n\nconst toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag ? Symbol.toStringTag : false;\nfunction inspectClass(value, options) {\n    let name = '';\n    if (toStringTag && toStringTag in value) {\n        name = value[toStringTag];\n    }\n    name = name || value.constructor.name;\n    // Babel transforms anonymous classes to the name `_class`\n    if (!name || name === '_class') {\n        name = '<Anonymous Class>';\n    }\n    options.truncate -= name.length;\n    return `${name}${inspectObject$1(value, options)}`;\n}\n\nfunction inspectArguments(args, options) {\n    if (args.length === 0)\n        return 'Arguments[]';\n    options.truncate -= 13;\n    return `Arguments[ ${inspectList(args, options)} ]`;\n}\n\nconst errorKeys = [\n    'stack',\n    'line',\n    'column',\n    'name',\n    'message',\n    'fileName',\n    'lineNumber',\n    'columnNumber',\n    'number',\n    'description',\n    'cause',\n];\nfunction inspectObject(error, options) {\n    const properties = Object.getOwnPropertyNames(error).filter(key => errorKeys.indexOf(key) === -1);\n    const name = error.name;\n    options.truncate -= name.length;\n    let message = '';\n    if (typeof error.message === 'string') {\n        message = truncate(error.message, options.truncate);\n    }\n    else {\n        properties.unshift('message');\n    }\n    message = message ? `: ${message}` : '';\n    options.truncate -= message.length + 5;\n    options.seen = options.seen || [];\n    if (options.seen.includes(error)) {\n        return '[Circular]';\n    }\n    options.seen.push(error);\n    const propertyContents = inspectList(properties.map(key => [key, error[key]]), options, inspectProperty);\n    return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ''}`;\n}\n\nfunction inspectAttribute([key, value], options) {\n    options.truncate -= 3;\n    if (!value) {\n        return `${options.stylize(String(key), 'yellow')}`;\n    }\n    return `${options.stylize(String(key), 'yellow')}=${options.stylize(`\"${value}\"`, 'string')}`;\n}\nfunction inspectNodeCollection(collection, options) {\n    return inspectList(collection, options, inspectNode, '\\n');\n}\nfunction inspectNode(node, options) {\n    switch (node.nodeType) {\n        case 1:\n            return inspectHTML(node, options);\n        case 3:\n            return options.inspect(node.data, options);\n        default:\n            return options.inspect(node, options);\n    }\n}\n// @ts-ignore (Deno doesn't have Element)\nfunction inspectHTML(element, options) {\n    const properties = element.getAttributeNames();\n    const name = element.tagName.toLowerCase();\n    const head = options.stylize(`<${name}`, 'special');\n    const headClose = options.stylize(`>`, 'special');\n    const tail = options.stylize(`</${name}>`, 'special');\n    options.truncate -= name.length * 2 + 5;\n    let propertyContents = '';\n    if (properties.length > 0) {\n        propertyContents += ' ';\n        propertyContents += inspectList(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute, ' ');\n    }\n    options.truncate -= propertyContents.length;\n    const truncate = options.truncate;\n    let children = inspectNodeCollection(element.children, options);\n    if (children && children.length > truncate) {\n        children = `${truncator}(${element.children.length})`;\n    }\n    return `${head}${propertyContents}${headClose}${children}${tail}`;\n}\n\n/* !\n * loupe\n * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\nconst symbolsSupported = typeof Symbol === 'function' && typeof Symbol.for === 'function';\nconst chaiInspect = symbolsSupported ? Symbol.for('chai/inspect') : '@@chai/inspect';\nconst nodeInspect = Symbol.for('nodejs.util.inspect.custom');\nconst constructorMap = new WeakMap();\nconst stringTagMap = {};\nconst baseTypesMap = {\n    undefined: (value, options) => options.stylize('undefined', 'undefined'),\n    null: (value, options) => options.stylize('null', 'null'),\n    boolean: (value, options) => options.stylize(String(value), 'boolean'),\n    Boolean: (value, options) => options.stylize(String(value), 'boolean'),\n    number: inspectNumber,\n    Number: inspectNumber,\n    bigint: inspectBigInt,\n    BigInt: inspectBigInt,\n    string: inspectString,\n    String: inspectString,\n    function: inspectFunction,\n    Function: inspectFunction,\n    symbol: inspectSymbol,\n    // A Symbol polyfill will return `Symbol` not `symbol` from typedetect\n    Symbol: inspectSymbol,\n    Array: inspectArray,\n    Date: inspectDate,\n    Map: inspectMap,\n    Set: inspectSet,\n    RegExp: inspectRegExp,\n    Promise: getPromiseValue,\n    // WeakSet, WeakMap are totally opaque to us\n    WeakSet: (value, options) => options.stylize('WeakSet{…}', 'special'),\n    WeakMap: (value, options) => options.stylize('WeakMap{…}', 'special'),\n    Arguments: inspectArguments,\n    Int8Array: inspectTypedArray,\n    Uint8Array: inspectTypedArray,\n    Uint8ClampedArray: inspectTypedArray,\n    Int16Array: inspectTypedArray,\n    Uint16Array: inspectTypedArray,\n    Int32Array: inspectTypedArray,\n    Uint32Array: inspectTypedArray,\n    Float32Array: inspectTypedArray,\n    Float64Array: inspectTypedArray,\n    Generator: () => '',\n    DataView: () => '',\n    ArrayBuffer: () => '',\n    Error: inspectObject,\n    HTMLCollection: inspectNodeCollection,\n    NodeList: inspectNodeCollection,\n};\n// eslint-disable-next-line complexity\nconst inspectCustom = (value, options, type, inspectFn) => {\n    if (chaiInspect in value && typeof value[chaiInspect] === 'function') {\n        return value[chaiInspect](options);\n    }\n    if (nodeInspect in value && typeof value[nodeInspect] === 'function') {\n        return value[nodeInspect](options.depth, options, inspectFn);\n    }\n    if ('inspect' in value && typeof value.inspect === 'function') {\n        return value.inspect(options.depth, options);\n    }\n    if ('constructor' in value && constructorMap.has(value.constructor)) {\n        return constructorMap.get(value.constructor)(value, options);\n    }\n    if (stringTagMap[type]) {\n        return stringTagMap[type](value, options);\n    }\n    return '';\n};\nconst toString = Object.prototype.toString;\n// eslint-disable-next-line complexity\nfunction inspect$1(value, opts = {}) {\n    const options = normaliseOptions(opts, inspect$1);\n    const { customInspect } = options;\n    let type = value === null ? 'null' : typeof value;\n    if (type === 'object') {\n        type = toString.call(value).slice(8, -1);\n    }\n    // If it is a base value that we already support, then use Loupe's inspector\n    if (type in baseTypesMap) {\n        return baseTypesMap[type](value, options);\n    }\n    // If `options.customInspect` is set to true then try to use the custom inspector\n    if (customInspect && value) {\n        const output = inspectCustom(value, options, type, inspect$1);\n        if (output) {\n            if (typeof output === 'string')\n                return output;\n            return inspect$1(output, options);\n        }\n    }\n    const proto = value ? Object.getPrototypeOf(value) : false;\n    // If it's a plain Object then use Loupe's inspector\n    if (proto === Object.prototype || proto === null) {\n        return inspectObject$1(value, options);\n    }\n    // Specifically account for HTMLElements\n    // @ts-ignore\n    if (value && typeof HTMLElement === 'function' && value instanceof HTMLElement) {\n        return inspectHTML(value, options);\n    }\n    if ('constructor' in value) {\n        // If it is a class, inspect it like an object but add the constructor name\n        if (value.constructor !== Object) {\n            return inspectClass(value, options);\n        }\n        // If it is an object with an anonymous prototype, display it as an object.\n        return inspectObject$1(value, options);\n    }\n    // last chance to check if it's an object\n    if (value === Object(value)) {\n        return inspectObject$1(value, options);\n    }\n    // We have run out of options! Just stringify the value\n    return options.stylize(String(value), type);\n}\n\nconst { AsymmetricMatcher, DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent } = plugins;\nconst PLUGINS = [\n\tReactTestComponent,\n\tReactElement,\n\tDOMElement,\n\tDOMCollection,\n\tImmutable,\n\tAsymmetricMatcher\n];\nfunction stringify(object, maxDepth = 10, { maxLength, ...options } = {}) {\n\tconst MAX_LENGTH = maxLength ?? 1e4;\n\tlet result;\n\ttry {\n\t\tresult = format$1(object, {\n\t\t\tmaxDepth,\n\t\t\tescapeString: false,\n\t\t\tplugins: PLUGINS,\n\t\t\t...options\n\t\t});\n\t} catch {\n\t\tresult = format$1(object, {\n\t\t\tcallToJSON: false,\n\t\t\tmaxDepth,\n\t\t\tescapeString: false,\n\t\t\tplugins: PLUGINS,\n\t\t\t...options\n\t\t});\n\t}\n\t// Prevents infinite loop https://github.com/vitest-dev/vitest/issues/7249\n\treturn result.length >= MAX_LENGTH && maxDepth > 1 ? stringify(object, Math.floor(Math.min(maxDepth, Number.MAX_SAFE_INTEGER) / 2), {\n\t\tmaxLength,\n\t\t...options\n\t}) : result;\n}\nconst formatRegExp = /%[sdjifoOc%]/g;\nfunction baseFormat(args, options = {}) {\n\tconst formatArg = (item, inspecOptions) => {\n\t\tif (options.prettifyObject) {\n\t\t\treturn stringify(item, undefined, {\n\t\t\t\tprintBasicPrototype: false,\n\t\t\t\tescapeString: false\n\t\t\t});\n\t\t}\n\t\treturn inspect(item, inspecOptions);\n\t};\n\tif (typeof args[0] !== \"string\") {\n\t\tconst objects = [];\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\tobjects.push(formatArg(args[i], {\n\t\t\t\tdepth: 0,\n\t\t\t\tcolors: false\n\t\t\t}));\n\t\t}\n\t\treturn objects.join(\" \");\n\t}\n\tconst len = args.length;\n\tlet i = 1;\n\tconst template = args[0];\n\tlet str = String(template).replace(formatRegExp, (x) => {\n\t\tif (x === \"%%\") {\n\t\t\treturn \"%\";\n\t\t}\n\t\tif (i >= len) {\n\t\t\treturn x;\n\t\t}\n\t\tswitch (x) {\n\t\t\tcase \"%s\": {\n\t\t\t\tconst value = args[i++];\n\t\t\t\tif (typeof value === \"bigint\") {\n\t\t\t\t\treturn `${value.toString()}n`;\n\t\t\t\t}\n\t\t\t\tif (typeof value === \"number\" && value === 0 && 1 / value < 0) {\n\t\t\t\t\treturn \"-0\";\n\t\t\t\t}\n\t\t\t\tif (typeof value === \"object\" && value !== null) {\n\t\t\t\t\tif (typeof value.toString === \"function\" && value.toString !== Object.prototype.toString) {\n\t\t\t\t\t\treturn value.toString();\n\t\t\t\t\t}\n\t\t\t\t\treturn formatArg(value, {\n\t\t\t\t\t\tdepth: 0,\n\t\t\t\t\t\tcolors: false\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn String(value);\n\t\t\t}\n\t\t\tcase \"%d\": {\n\t\t\t\tconst value = args[i++];\n\t\t\t\tif (typeof value === \"bigint\") {\n\t\t\t\t\treturn `${value.toString()}n`;\n\t\t\t\t}\n\t\t\t\treturn Number(value).toString();\n\t\t\t}\n\t\t\tcase \"%i\": {\n\t\t\t\tconst value = args[i++];\n\t\t\t\tif (typeof value === \"bigint\") {\n\t\t\t\t\treturn `${value.toString()}n`;\n\t\t\t\t}\n\t\t\t\treturn Number.parseInt(String(value)).toString();\n\t\t\t}\n\t\t\tcase \"%f\": return Number.parseFloat(String(args[i++])).toString();\n\t\t\tcase \"%o\": return formatArg(args[i++], {\n\t\t\t\tshowHidden: true,\n\t\t\t\tshowProxy: true\n\t\t\t});\n\t\t\tcase \"%O\": return formatArg(args[i++]);\n\t\t\tcase \"%c\": {\n\t\t\t\ti++;\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\tcase \"%j\": try {\n\t\t\t\treturn JSON.stringify(args[i++]);\n\t\t\t} catch (err) {\n\t\t\t\tconst m = err.message;\n\t\t\t\tif (m.includes(\"circular structure\") || m.includes(\"cyclic structures\") || m.includes(\"cyclic object\")) {\n\t\t\t\t\treturn \"[Circular]\";\n\t\t\t\t}\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t\tdefault: return x;\n\t\t}\n\t});\n\tfor (let x = args[i]; i < len; x = args[++i]) {\n\t\tif (x === null || typeof x !== \"object\") {\n\t\t\tstr += ` ${x}`;\n\t\t} else {\n\t\t\tstr += ` ${formatArg(x)}`;\n\t\t}\n\t}\n\treturn str;\n}\nfunction format(...args) {\n\treturn baseFormat(args);\n}\nfunction browserFormat(...args) {\n\treturn baseFormat(args, { prettifyObject: true });\n}\nfunction inspect(obj, options = {}) {\n\tif (options.truncate === 0) {\n\t\toptions.truncate = Number.POSITIVE_INFINITY;\n\t}\n\treturn inspect$1(obj, options);\n}\nfunction objDisplay(obj, options = {}) {\n\tif (typeof options.truncate === \"undefined\") {\n\t\toptions.truncate = 40;\n\t}\n\tconst str = inspect(obj, options);\n\tconst type = Object.prototype.toString.call(obj);\n\tif (options.truncate && str.length >= options.truncate) {\n\t\tif (type === \"[object Function]\") {\n\t\t\tconst fn = obj;\n\t\t\treturn !fn.name ? \"[Function]\" : `[Function: ${fn.name}]`;\n\t\t} else if (type === \"[object Array]\") {\n\t\t\treturn `[ Array(${obj.length}) ]`;\n\t\t} else if (type === \"[object Object]\") {\n\t\t\tconst keys = Object.keys(obj);\n\t\t\tconst kstr = keys.length > 2 ? `${keys.splice(0, 2).join(\", \")}, ...` : keys.join(\", \");\n\t\t\treturn `{ Object (${kstr}) }`;\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t}\n\treturn str;\n}\n\nexport { browserFormat, format, formatRegExp, inspect, objDisplay, stringify };\n","import { VALID_ID_PREFIX, NULL_BYTE_PLACEHOLDER } from './constants.js';\n\n// port from nanoid\n// https://github.com/ai/nanoid\nconst urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nfunction nanoid(size = 21) {\n\tlet id = \"\";\n\tlet i = size;\n\twhile (i--) {\n\t\tid += urlAlphabet[Math.random() * 64 | 0];\n\t}\n\treturn id;\n}\n\nconst RealDate = Date;\nfunction random(seed) {\n\tconst x = Math.sin(seed++) * 1e4;\n\treturn x - Math.floor(x);\n}\nfunction shuffle(array, seed = RealDate.now()) {\n\tlet length = array.length;\n\twhile (length) {\n\t\tconst index = Math.floor(random(seed) * length--);\n\t\tconst previous = array[length];\n\t\tarray[length] = array[index];\n\t\tarray[index] = previous;\n\t\t++seed;\n\t}\n\treturn array;\n}\n\n/**\n* Get original stacktrace without source map support the most performant way.\n* - Create only 1 stack frame.\n* - Rewrite prepareStackTrace to bypass \"support-stack-trace\" (usually takes ~250ms).\n*/\nfunction createSimpleStackTrace(options) {\n\tconst { message = \"$$stack trace error\", stackTraceLimit = 1 } = options || {};\n\tconst limit = Error.stackTraceLimit;\n\tconst prepareStackTrace = Error.prepareStackTrace;\n\tError.stackTraceLimit = stackTraceLimit;\n\tError.prepareStackTrace = (e) => e.stack;\n\tconst err = new Error(message);\n\tconst stackTrace = err.stack || \"\";\n\tError.prepareStackTrace = prepareStackTrace;\n\tError.stackTraceLimit = limit;\n\treturn stackTrace;\n}\nfunction notNullish(v) {\n\treturn v != null;\n}\nfunction assertTypes(value, name, types) {\n\tconst receivedType = typeof value;\n\tconst pass = types.includes(receivedType);\n\tif (!pass) {\n\t\tthrow new TypeError(`${name} value must be ${types.join(\" or \")}, received \"${receivedType}\"`);\n\t}\n}\nfunction isPrimitive(value) {\n\treturn value === null || typeof value !== \"function\" && typeof value !== \"object\";\n}\nfunction slash(path) {\n\treturn path.replace(/\\\\/g, \"/\");\n}\nconst postfixRE = /[?#].*$/;\nfunction cleanUrl(url) {\n\treturn url.replace(postfixRE, \"\");\n}\nconst externalRE = /^(?:[a-z]+:)?\\/\\//;\nconst isExternalUrl = (url) => externalRE.test(url);\n/**\n* Prepend `/@id/` and replace null byte so the id is URL-safe.\n* This is prepended to resolved ids that are not valid browser\n* import specifiers by the importAnalysis plugin.\n*/\nfunction wrapId(id) {\n\treturn id.startsWith(VALID_ID_PREFIX) ? id : VALID_ID_PREFIX + id.replace(\"\\0\", NULL_BYTE_PLACEHOLDER);\n}\n/**\n* Undo {@link wrapId}'s `/@id/` and null byte replacements.\n*/\nfunction unwrapId(id) {\n\treturn id.startsWith(VALID_ID_PREFIX) ? id.slice(VALID_ID_PREFIX.length).replace(NULL_BYTE_PLACEHOLDER, \"\\0\") : id;\n}\nfunction withTrailingSlash(path) {\n\tif (path.at(-1) !== \"/\") {\n\t\treturn `${path}/`;\n\t}\n\treturn path;\n}\nconst bareImportRE = /^(?![a-z]:)[\\w@](?!.*:\\/\\/)/i;\nfunction isBareImport(id) {\n\treturn bareImportRE.test(id);\n}\nfunction toArray(array) {\n\tif (array === null || array === undefined) {\n\t\tarray = [];\n\t}\n\tif (Array.isArray(array)) {\n\t\treturn array;\n\t}\n\treturn [array];\n}\nfunction isObject(item) {\n\treturn item != null && typeof item === \"object\" && !Array.isArray(item);\n}\nfunction isFinalObj(obj) {\n\treturn obj === Object.prototype || obj === Function.prototype || obj === RegExp.prototype;\n}\nfunction getType(value) {\n\treturn Object.prototype.toString.apply(value).slice(8, -1);\n}\nfunction collectOwnProperties(obj, collector) {\n\tconst collect = typeof collector === \"function\" ? collector : (key) => collector.add(key);\n\tObject.getOwnPropertyNames(obj).forEach(collect);\n\tObject.getOwnPropertySymbols(obj).forEach(collect);\n}\nfunction getOwnProperties(obj) {\n\tconst ownProps = new Set();\n\tif (isFinalObj(obj)) {\n\t\treturn [];\n\t}\n\tcollectOwnProperties(obj, ownProps);\n\treturn Array.from(ownProps);\n}\nconst defaultCloneOptions = { forceWritable: false };\nfunction deepClone(val, options = defaultCloneOptions) {\n\tconst seen = new WeakMap();\n\treturn clone(val, seen, options);\n}\nfunction clone(val, seen, options = defaultCloneOptions) {\n\tlet k, out;\n\tif (seen.has(val)) {\n\t\treturn seen.get(val);\n\t}\n\tif (Array.isArray(val)) {\n\t\tout = Array.from({ length: k = val.length });\n\t\tseen.set(val, out);\n\t\twhile (k--) {\n\t\t\tout[k] = clone(val[k], seen, options);\n\t\t}\n\t\treturn out;\n\t}\n\tif (Object.prototype.toString.call(val) === \"[object Object]\") {\n\t\tout = Object.create(Object.getPrototypeOf(val));\n\t\tseen.set(val, out);\n\t\t// we don't need properties from prototype\n\t\tconst props = getOwnProperties(val);\n\t\tfor (const k of props) {\n\t\t\tconst descriptor = Object.getOwnPropertyDescriptor(val, k);\n\t\t\tif (!descriptor) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst cloned = clone(val[k], seen, options);\n\t\t\tif (options.forceWritable) {\n\t\t\t\tObject.defineProperty(out, k, {\n\t\t\t\t\tenumerable: descriptor.enumerable,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: cloned\n\t\t\t\t});\n\t\t\t} else if (\"get\" in descriptor) {\n\t\t\t\tObject.defineProperty(out, k, {\n\t\t\t\t\t...descriptor,\n\t\t\t\t\tget() {\n\t\t\t\t\t\treturn cloned;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tObject.defineProperty(out, k, {\n\t\t\t\t\t...descriptor,\n\t\t\t\t\tvalue: cloned\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\treturn val;\n}\nfunction noop() {}\nfunction objectAttr(source, path, defaultValue = undefined) {\n\t// a[3].b -> a.3.b\n\tconst paths = path.replace(/\\[(\\d+)\\]/g, \".$1\").split(\".\");\n\tlet result = source;\n\tfor (const p of paths) {\n\t\tresult = new Object(result)[p];\n\t\tif (result === undefined) {\n\t\t\treturn defaultValue;\n\t\t}\n\t}\n\treturn result;\n}\nfunction createDefer() {\n\tlet resolve = null;\n\tlet reject = null;\n\tconst p = new Promise((_resolve, _reject) => {\n\t\tresolve = _resolve;\n\t\treject = _reject;\n\t});\n\tp.resolve = resolve;\n\tp.reject = reject;\n\treturn p;\n}\n/**\n* If code starts with a function call, will return its last index, respecting arguments.\n* This will return 25 - last ending character of toMatch \")\"\n* Also works with callbacks\n* ```\n* toMatch({ test: '123' });\n* toBeAliased('123')\n* ```\n*/\nfunction getCallLastIndex(code) {\n\tlet charIndex = -1;\n\tlet inString = null;\n\tlet startedBracers = 0;\n\tlet endedBracers = 0;\n\tlet beforeChar = null;\n\twhile (charIndex <= code.length) {\n\t\tbeforeChar = code[charIndex];\n\t\tcharIndex++;\n\t\tconst char = code[charIndex];\n\t\tconst isCharString = char === \"\\\"\" || char === \"'\" || char === \"`\";\n\t\tif (isCharString && beforeChar !== \"\\\\\") {\n\t\t\tif (inString === char) {\n\t\t\t\tinString = null;\n\t\t\t} else if (!inString) {\n\t\t\t\tinString = char;\n\t\t\t}\n\t\t}\n\t\tif (!inString) {\n\t\t\tif (char === \"(\") {\n\t\t\t\tstartedBracers++;\n\t\t\t}\n\t\t\tif (char === \")\") {\n\t\t\t\tendedBracers++;\n\t\t\t}\n\t\t}\n\t\tif (startedBracers && endedBracers && startedBracers === endedBracers) {\n\t\t\treturn charIndex;\n\t\t}\n\t}\n\treturn null;\n}\nfunction isNegativeNaN(val) {\n\tif (!Number.isNaN(val)) {\n\t\treturn false;\n\t}\n\tconst f64 = new Float64Array(1);\n\tf64[0] = val;\n\tconst u32 = new Uint32Array(f64.buffer);\n\tconst isNegative = u32[1] >>> 31 === 1;\n\treturn isNegative;\n}\nfunction toString(v) {\n\treturn Object.prototype.toString.call(v);\n}\nfunction isPlainObject(val) {\n\treturn toString(val) === \"[object Object]\" && (!val.constructor || val.constructor.name === \"Object\");\n}\nfunction isMergeableObject(item) {\n\treturn isPlainObject(item) && !Array.isArray(item);\n}\n/**\n* Deep merge :P\n*\n* Will merge objects only if they are plain\n*\n* Do not merge types - it is very expensive and usually it's better to case a type here\n*/\nfunction deepMerge(target, ...sources) {\n\tif (!sources.length) {\n\t\treturn target;\n\t}\n\tconst source = sources.shift();\n\tif (source === undefined) {\n\t\treturn target;\n\t}\n\tif (isMergeableObject(target) && isMergeableObject(source)) {\n\t\tObject.keys(source).forEach((key) => {\n\t\t\tconst _source = source;\n\t\t\tif (isMergeableObject(_source[key])) {\n\t\t\t\tif (!target[key]) {\n\t\t\t\t\ttarget[key] = {};\n\t\t\t\t}\n\t\t\t\tdeepMerge(target[key], _source[key]);\n\t\t\t} else {\n\t\t\t\ttarget[key] = _source[key];\n\t\t\t}\n\t\t});\n\t}\n\treturn deepMerge(target, ...sources);\n}\n\nexport { assertTypes, cleanUrl, clone, createDefer, createSimpleStackTrace, deepClone, deepMerge, getCallLastIndex, getOwnProperties, getType, isBareImport, isExternalUrl, isNegativeNaN, isObject, isPrimitive, nanoid, noop, notNullish, objectAttr, shuffle, slash, toArray, unwrapId, withTrailingSlash, wrapId };\n","function getDefaultExportFromCjs(x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\n\nexport { getDefaultExportFromCjs as g };\n","import { plugins, format } from '@vitest/pretty-format';\nimport c from 'tinyrainbow';\nimport { stringify } from './display.js';\nimport { deepClone, getOwnProperties, getType as getType$1 } from './helpers.js';\nimport { g as getDefaultExportFromCjs } from './chunk-_commonjsHelpers.js';\nimport './constants.js';\n\n/**\n* Diff Match and Patch\n* Copyright 2018 The diff-match-patch Authors.\n* https://github.com/google/diff-match-patch\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n/**\n* @fileoverview Computes the difference between two texts to create a patch.\n* Applies the patch onto another text, allowing for errors.\n* @author fraser@google.com (Neil Fraser)\n*/\n/**\n* CHANGES by pedrottimark to diff_match_patch_uncompressed.ts file:\n*\n* 1. Delete anything not needed to use diff_cleanupSemantic method\n* 2. Convert from prototype properties to var declarations\n* 3. Convert Diff to class from constructor and prototype\n* 4. Add type annotations for arguments and return values\n* 5. Add exports\n*/\n/**\n* The data structure representing a diff is an array of tuples:\n* [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n* which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n*/\nconst DIFF_DELETE = -1;\nconst DIFF_INSERT = 1;\nconst DIFF_EQUAL = 0;\n/**\n* Class representing one diff tuple.\n* Attempts to look like a two-element array (which is what this used to be).\n* @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n* @param {string} text Text to be deleted, inserted, or retained.\n* @constructor\n*/\nclass Diff {\n\t0;\n\t1;\n\tconstructor(op, text) {\n\t\tthis[0] = op;\n\t\tthis[1] = text;\n\t}\n}\n/**\n* Determine the common prefix of two strings.\n* @param {string} text1 First string.\n* @param {string} text2 Second string.\n* @return {number} The number of characters common to the start of each\n*     string.\n*/\nfunction diff_commonPrefix(text1, text2) {\n\t// Quick check for common null cases.\n\tif (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {\n\t\treturn 0;\n\t}\n\t// Binary search.\n\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\tlet pointermin = 0;\n\tlet pointermax = Math.min(text1.length, text2.length);\n\tlet pointermid = pointermax;\n\tlet pointerstart = 0;\n\twhile (pointermin < pointermid) {\n\t\tif (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {\n\t\t\tpointermin = pointermid;\n\t\t\tpointerstart = pointermin;\n\t\t} else {\n\t\t\tpointermax = pointermid;\n\t\t}\n\t\tpointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n\t}\n\treturn pointermid;\n}\n/**\n* Determine the common suffix of two strings.\n* @param {string} text1 First string.\n* @param {string} text2 Second string.\n* @return {number} The number of characters common to the end of each string.\n*/\nfunction diff_commonSuffix(text1, text2) {\n\t// Quick check for common null cases.\n\tif (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {\n\t\treturn 0;\n\t}\n\t// Binary search.\n\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\tlet pointermin = 0;\n\tlet pointermax = Math.min(text1.length, text2.length);\n\tlet pointermid = pointermax;\n\tlet pointerend = 0;\n\twhile (pointermin < pointermid) {\n\t\tif (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n\t\t\tpointermin = pointermid;\n\t\t\tpointerend = pointermin;\n\t\t} else {\n\t\t\tpointermax = pointermid;\n\t\t}\n\t\tpointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n\t}\n\treturn pointermid;\n}\n/**\n* Determine if the suffix of one string is the prefix of another.\n* @param {string} text1 First string.\n* @param {string} text2 Second string.\n* @return {number} The number of characters common to the end of the first\n*     string and the start of the second string.\n* @private\n*/\nfunction diff_commonOverlap_(text1, text2) {\n\t// Cache the text lengths to prevent multiple calls.\n\tconst text1_length = text1.length;\n\tconst text2_length = text2.length;\n\t// Eliminate the null case.\n\tif (text1_length === 0 || text2_length === 0) {\n\t\treturn 0;\n\t}\n\t// Truncate the longer string.\n\tif (text1_length > text2_length) {\n\t\ttext1 = text1.substring(text1_length - text2_length);\n\t} else if (text1_length < text2_length) {\n\t\ttext2 = text2.substring(0, text1_length);\n\t}\n\tconst text_length = Math.min(text1_length, text2_length);\n\t// Quick check for the worst case.\n\tif (text1 === text2) {\n\t\treturn text_length;\n\t}\n\t// Start by looking for a single character match\n\t// and increase length until no match is found.\n\t// Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\tlet best = 0;\n\tlet length = 1;\n\twhile (true) {\n\t\tconst pattern = text1.substring(text_length - length);\n\t\tconst found = text2.indexOf(pattern);\n\t\tif (found === -1) {\n\t\t\treturn best;\n\t\t}\n\t\tlength += found;\n\t\tif (found === 0 || text1.substring(text_length - length) === text2.substring(0, length)) {\n\t\t\tbest = length;\n\t\t\tlength++;\n\t\t}\n\t}\n}\n/**\n* Reduce the number of edits by eliminating semantically trivial equalities.\n* @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n*/\nfunction diff_cleanupSemantic(diffs) {\n\tlet changes = false;\n\tconst equalities = [];\n\tlet equalitiesLength = 0;\n\t/** @type {?string} */\n\tlet lastEquality = null;\n\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\tlet pointer = 0;\n\t// Number of characters that changed prior to the equality.\n\tlet length_insertions1 = 0;\n\tlet length_deletions1 = 0;\n\t// Number of characters that changed after the equality.\n\tlet length_insertions2 = 0;\n\tlet length_deletions2 = 0;\n\twhile (pointer < diffs.length) {\n\t\tif (diffs[pointer][0] === DIFF_EQUAL) {\n\t\t\t// Equality found.\n\t\t\tequalities[equalitiesLength++] = pointer;\n\t\t\tlength_insertions1 = length_insertions2;\n\t\t\tlength_deletions1 = length_deletions2;\n\t\t\tlength_insertions2 = 0;\n\t\t\tlength_deletions2 = 0;\n\t\t\tlastEquality = diffs[pointer][1];\n\t\t} else {\n\t\t\t// An insertion or deletion.\n\t\t\tif (diffs[pointer][0] === DIFF_INSERT) {\n\t\t\t\tlength_insertions2 += diffs[pointer][1].length;\n\t\t\t} else {\n\t\t\t\tlength_deletions2 += diffs[pointer][1].length;\n\t\t\t}\n\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t// sides of it.\n\t\t\tif (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {\n\t\t\t\t// Duplicate record.\n\t\t\t\tdiffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality));\n\t\t\t\t// Change second copy to insert.\n\t\t\t\tdiffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n\t\t\t\t// Throw away the equality we just deleted.\n\t\t\t\tequalitiesLength--;\n\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n\t\t\t\tequalitiesLength--;\n\t\t\t\tpointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n\t\t\t\tlength_insertions1 = 0;\n\t\t\t\tlength_deletions1 = 0;\n\t\t\t\tlength_insertions2 = 0;\n\t\t\t\tlength_deletions2 = 0;\n\t\t\t\tlastEquality = null;\n\t\t\t\tchanges = true;\n\t\t\t}\n\t\t}\n\t\tpointer++;\n\t}\n\t// Normalize the diff.\n\tif (changes) {\n\t\tdiff_cleanupMerge(diffs);\n\t}\n\tdiff_cleanupSemanticLossless(diffs);\n\t// Find any overlaps between deletions and insertions.\n\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t//   -> <del>abc</del>xxx<ins>def</ins>\n\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t//   -> <ins>def</ins>xxx<del>abc</del>\n\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n\tpointer = 1;\n\twhile (pointer < diffs.length) {\n\t\tif (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n\t\t\tconst deletion = diffs[pointer - 1][1];\n\t\t\tconst insertion = diffs[pointer][1];\n\t\t\tconst overlap_length1 = diff_commonOverlap_(deletion, insertion);\n\t\t\tconst overlap_length2 = diff_commonOverlap_(insertion, deletion);\n\t\t\tif (overlap_length1 >= overlap_length2) {\n\t\t\t\tif (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {\n\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t\t\tdiffs.splice(pointer, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));\n\t\t\t\t\tdiffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);\n\t\t\t\t\tdiffs[pointer + 1][1] = insertion.substring(overlap_length1);\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {\n\t\t\t\t\t// Reverse overlap found.\n\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n\t\t\t\t\tdiffs.splice(pointer, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));\n\t\t\t\t\tdiffs[pointer - 1][0] = DIFF_INSERT;\n\t\t\t\t\tdiffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);\n\t\t\t\t\tdiffs[pointer + 1][0] = DIFF_DELETE;\n\t\t\t\t\tdiffs[pointer + 1][1] = deletion.substring(overlap_length2);\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\tpointer++;\n\t}\n}\n// Define some regex patterns for matching boundaries.\nconst nonAlphaNumericRegex_ = /[^a-z0-9]/i;\nconst whitespaceRegex_ = /\\s/;\nconst linebreakRegex_ = /[\\r\\n]/;\nconst blanklineEndRegex_ = /\\n\\r?\\n$/;\nconst blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n/**\n* Look for single edits surrounded on both sides by equalities\n* which can be shifted sideways to align the edit to a word boundary.\n* e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n* @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n*/\nfunction diff_cleanupSemanticLossless(diffs) {\n\tlet pointer = 1;\n\t// Intentionally ignore the first and last element (don't need checking).\n\twhile (pointer < diffs.length - 1) {\n\t\tif (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n\t\t\t// This is a single edit surrounded by equalities.\n\t\t\tlet equality1 = diffs[pointer - 1][1];\n\t\t\tlet edit = diffs[pointer][1];\n\t\t\tlet equality2 = diffs[pointer + 1][1];\n\t\t\t// First, shift the edit as far left as possible.\n\t\t\tconst commonOffset = diff_commonSuffix(equality1, edit);\n\t\t\tif (commonOffset) {\n\t\t\t\tconst commonString = edit.substring(edit.length - commonOffset);\n\t\t\t\tequality1 = equality1.substring(0, equality1.length - commonOffset);\n\t\t\t\tedit = commonString + edit.substring(0, edit.length - commonOffset);\n\t\t\t\tequality2 = commonString + equality2;\n\t\t\t}\n\t\t\t// Second, step character by character right, looking for the best fit.\n\t\t\tlet bestEquality1 = equality1;\n\t\t\tlet bestEdit = edit;\n\t\t\tlet bestEquality2 = equality2;\n\t\t\tlet bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);\n\t\t\twhile (edit.charAt(0) === equality2.charAt(0)) {\n\t\t\t\tequality1 += edit.charAt(0);\n\t\t\t\tedit = edit.substring(1) + equality2.charAt(0);\n\t\t\t\tequality2 = equality2.substring(1);\n\t\t\t\tconst score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);\n\t\t\t\t// The >= encourages trailing rather than leading whitespace on edits.\n\t\t\t\tif (score >= bestScore) {\n\t\t\t\t\tbestScore = score;\n\t\t\t\t\tbestEquality1 = equality1;\n\t\t\t\t\tbestEdit = edit;\n\t\t\t\t\tbestEquality2 = equality2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (diffs[pointer - 1][1] !== bestEquality1) {\n\t\t\t\t// We have an improvement, save it back to the diff.\n\t\t\t\tif (bestEquality1) {\n\t\t\t\t\tdiffs[pointer - 1][1] = bestEquality1;\n\t\t\t\t} else {\n\t\t\t\t\tdiffs.splice(pointer - 1, 1);\n\t\t\t\t\tpointer--;\n\t\t\t\t}\n\t\t\t\tdiffs[pointer][1] = bestEdit;\n\t\t\t\tif (bestEquality2) {\n\t\t\t\t\tdiffs[pointer + 1][1] = bestEquality2;\n\t\t\t\t} else {\n\t\t\t\t\tdiffs.splice(pointer + 1, 1);\n\t\t\t\t\tpointer--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpointer++;\n\t}\n}\n/**\n* Reorder and merge like edit sections.  Merge equalities.\n* Any edit section can move as long as it doesn't cross an equality.\n* @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n*/\nfunction diff_cleanupMerge(diffs) {\n\tvar _diffs$at;\n\t// Add a dummy entry at the end.\n\tdiffs.push(new Diff(DIFF_EQUAL, \"\"));\n\tlet pointer = 0;\n\tlet count_delete = 0;\n\tlet count_insert = 0;\n\tlet text_delete = \"\";\n\tlet text_insert = \"\";\n\tlet commonlength;\n\twhile (pointer < diffs.length) {\n\t\tswitch (diffs[pointer][0]) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcount_insert++;\n\t\t\t\ttext_insert += diffs[pointer][1];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcount_delete++;\n\t\t\t\ttext_delete += diffs[pointer][1];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif (count_delete + count_insert > 1) {\n\t\t\t\t\tif (count_delete !== 0 && count_insert !== 0) {\n\t\t\t\t\t\t// Factor out any common prefixes.\n\t\t\t\t\t\tcommonlength = diff_commonPrefix(text_insert, text_delete);\n\t\t\t\t\t\tif (commonlength !== 0) {\n\t\t\t\t\t\t\tif (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] === DIFF_EQUAL) {\n\t\t\t\t\t\t\t\tdiffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));\n\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttext_insert = text_insert.substring(commonlength);\n\t\t\t\t\t\t\ttext_delete = text_delete.substring(commonlength);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Factor out any common suffixes.\n\t\t\t\t\t\tcommonlength = diff_commonSuffix(text_insert, text_delete);\n\t\t\t\t\t\tif (commonlength !== 0) {\n\t\t\t\t\t\t\tdiffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];\n\t\t\t\t\t\t\ttext_insert = text_insert.substring(0, text_insert.length - commonlength);\n\t\t\t\t\t\t\ttext_delete = text_delete.substring(0, text_delete.length - commonlength);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tpointer -= count_delete + count_insert;\n\t\t\t\t\tdiffs.splice(pointer, count_delete + count_insert);\n\t\t\t\t\tif (text_delete.length) {\n\t\t\t\t\t\tdiffs.splice(pointer, 0, new Diff(DIFF_DELETE, text_delete));\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t\tif (text_insert.length) {\n\t\t\t\t\t\tdiffs.splice(pointer, 0, new Diff(DIFF_INSERT, text_insert));\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t\tpointer++;\n\t\t\t\t} else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n\t\t\t\t\t// Merge this equality with the previous one.\n\t\t\t\t\tdiffs[pointer - 1][1] += diffs[pointer][1];\n\t\t\t\t\tdiffs.splice(pointer, 1);\n\t\t\t\t} else {\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t\tcount_insert = 0;\n\t\t\t\tcount_delete = 0;\n\t\t\t\ttext_delete = \"\";\n\t\t\t\ttext_insert = \"\";\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (((_diffs$at = diffs.at(-1)) === null || _diffs$at === void 0 ? void 0 : _diffs$at[1]) === \"\") {\n\t\tdiffs.pop();\n\t}\n\t// Second pass: look for single edits surrounded on both sides by equalities\n\t// which can be shifted sideways to eliminate an equality.\n\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\tlet changes = false;\n\tpointer = 1;\n\t// Intentionally ignore the first and last element (don't need checking).\n\twhile (pointer < diffs.length - 1) {\n\t\tif (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n\t\t\t// This is a single edit surrounded by equalities.\n\t\t\tif (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {\n\t\t\t\t// Shift the edit over the previous equality.\n\t\t\t\tdiffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n\t\t\t\tdiffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n\t\t\t\tdiffs.splice(pointer - 1, 1);\n\t\t\t\tchanges = true;\n\t\t\t} else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {\n\t\t\t\t// Shift the edit over the next equality.\n\t\t\t\tdiffs[pointer - 1][1] += diffs[pointer + 1][1];\n\t\t\t\tdiffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n\t\t\t\tdiffs.splice(pointer + 1, 1);\n\t\t\t\tchanges = true;\n\t\t\t}\n\t\t}\n\t\tpointer++;\n\t}\n\t// If shifts were made, the diff needs reordering and another shift sweep.\n\tif (changes) {\n\t\tdiff_cleanupMerge(diffs);\n\t}\n}\n/**\n* Given two strings, compute a score representing whether the internal\n* boundary falls on logical boundaries.\n* Scores range from 6 (best) to 0 (worst).\n* Closure, but does not reference any external variables.\n* @param {string} one First string.\n* @param {string} two Second string.\n* @return {number} The score.\n* @private\n*/\nfunction diff_cleanupSemanticScore_(one, two) {\n\tif (!one || !two) {\n\t\t// Edges are the best.\n\t\treturn 6;\n\t}\n\t// Each port of this function behaves slightly differently due to\n\t// subtle differences in each language's definition of things like\n\t// 'whitespace'.  Since this function's purpose is largely cosmetic,\n\t// the choice has been made to use each language's native features\n\t// rather than force total conformity.\n\tconst char1 = one.charAt(one.length - 1);\n\tconst char2 = two.charAt(0);\n\tconst nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);\n\tconst nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);\n\tconst whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);\n\tconst whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);\n\tconst lineBreak1 = whitespace1 && char1.match(linebreakRegex_);\n\tconst lineBreak2 = whitespace2 && char2.match(linebreakRegex_);\n\tconst blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);\n\tconst blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);\n\tif (blankLine1 || blankLine2) {\n\t\t// Five points for blank lines.\n\t\treturn 5;\n\t} else if (lineBreak1 || lineBreak2) {\n\t\t// Four points for line breaks.\n\t\treturn 4;\n\t} else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n\t\t// Three points for end of sentences.\n\t\treturn 3;\n\t} else if (whitespace1 || whitespace2) {\n\t\t// Two points for whitespace.\n\t\treturn 2;\n\t} else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n\t\t// One point for non-alphanumeric.\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/**\n* Copyright (c) Meta Platforms, Inc. and affiliates.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\nconst NO_DIFF_MESSAGE = \"Compared values have no visual difference.\";\nconst SIMILAR_MESSAGE = \"Compared values serialize to the same structure.\\n\" + \"Printing internal object structure without calling `toJSON` instead.\";\n\nvar build = {};\n\nvar hasRequiredBuild;\n\nfunction requireBuild () {\n\tif (hasRequiredBuild) return build;\n\thasRequiredBuild = 1;\n\n\tObject.defineProperty(build, '__esModule', {\n\t  value: true\n\t});\n\tbuild.default = diffSequence;\n\t/**\n\t * Copyright (c) Meta Platforms, Inc. and affiliates.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t */\n\n\t// This diff-sequences package implements the linear space variation in\n\t// An O(ND) Difference Algorithm and Its Variations by Eugene W. Myers\n\n\t// Relationship in notation between Myers paper and this package:\n\t// A is a\n\t// N is aLength, aEnd - aStart, and so on\n\t// x is aIndex, aFirst, aLast, and so on\n\t// B is b\n\t// M is bLength, bEnd - bStart, and so on\n\t// y is bIndex, bFirst, bLast, and so on\n\t// Δ = N - M is negative of baDeltaLength = bLength - aLength\n\t// D is d\n\t// k is kF\n\t// k + Δ is kF = kR - baDeltaLength\n\t// V is aIndexesF or aIndexesR (see comment below about Indexes type)\n\t// index intervals [1, N] and [1, M] are [0, aLength) and [0, bLength)\n\t// starting point in forward direction (0, 0) is (-1, -1)\n\t// starting point in reverse direction (N + 1, M + 1) is (aLength, bLength)\n\n\t// The “edit graph” for sequences a and b corresponds to items:\n\t// in a on the horizontal axis\n\t// in b on the vertical axis\n\t//\n\t// Given a-coordinate of a point in a diagonal, you can compute b-coordinate.\n\t//\n\t// Forward diagonals kF:\n\t// zero diagonal intersects top left corner\n\t// positive diagonals intersect top edge\n\t// negative diagonals insersect left edge\n\t//\n\t// Reverse diagonals kR:\n\t// zero diagonal intersects bottom right corner\n\t// positive diagonals intersect right edge\n\t// negative diagonals intersect bottom edge\n\n\t// The graph contains a directed acyclic graph of edges:\n\t// horizontal: delete an item from a\n\t// vertical: insert an item from b\n\t// diagonal: common item in a and b\n\t//\n\t// The algorithm solves dual problems in the graph analogy:\n\t// Find longest common subsequence: path with maximum number of diagonal edges\n\t// Find shortest edit script: path with minimum number of non-diagonal edges\n\n\t// Input callback function compares items at indexes in the sequences.\n\n\t// Output callback function receives the number of adjacent items\n\t// and starting indexes of each common subsequence.\n\t// Either original functions or wrapped to swap indexes if graph is transposed.\n\t// Indexes in sequence a of last point of forward or reverse paths in graph.\n\t// Myers algorithm indexes by diagonal k which for negative is bad deopt in V8.\n\t// This package indexes by iF and iR which are greater than or equal to zero.\n\t// and also updates the index arrays in place to cut memory in half.\n\t// kF = 2 * iF - d\n\t// kR = d - 2 * iR\n\t// Division of index intervals in sequences a and b at the middle change.\n\t// Invariant: intervals do not have common items at the start or end.\n\tconst pkg = 'diff-sequences'; // for error messages\n\tconst NOT_YET_SET = 0; // small int instead of undefined to avoid deopt in V8\n\n\t// Return the number of common items that follow in forward direction.\n\t// The length of what Myers paper calls a “snake” in a forward path.\n\tconst countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon) => {\n\t  let nCommon = 0;\n\t  while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {\n\t    aIndex += 1;\n\t    bIndex += 1;\n\t    nCommon += 1;\n\t  }\n\t  return nCommon;\n\t};\n\n\t// Return the number of common items that precede in reverse direction.\n\t// The length of what Myers paper calls a “snake” in a reverse path.\n\tconst countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon) => {\n\t  let nCommon = 0;\n\t  while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {\n\t    aIndex -= 1;\n\t    bIndex -= 1;\n\t    nCommon += 1;\n\t  }\n\t  return nCommon;\n\t};\n\n\t// A simple function to extend forward paths from (d - 1) to d changes\n\t// when forward and reverse paths cannot yet overlap.\n\tconst extendPathsF = (\n\t  d,\n\t  aEnd,\n\t  bEnd,\n\t  bF,\n\t  isCommon,\n\t  aIndexesF,\n\t  iMaxF // return the value because optimization might decrease it\n\t) => {\n\t  // Unroll the first iteration.\n\t  let iF = 0;\n\t  let kF = -d; // kF = 2 * iF - d\n\t  let aFirst = aIndexesF[iF]; // in first iteration always insert\n\t  let aIndexPrev1 = aFirst; // prev value of [iF - 1] in next iteration\n\t  aIndexesF[iF] += countCommonItemsF(\n\t    aFirst + 1,\n\t    aEnd,\n\t    bF + aFirst - kF + 1,\n\t    bEnd,\n\t    isCommon\n\t  );\n\n\t  // Optimization: skip diagonals in which paths cannot ever overlap.\n\t  const nF = d < iMaxF ? d : iMaxF;\n\n\t  // The diagonals kF are odd when d is odd and even when d is even.\n\t  for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {\n\t    // To get first point of path segment, move one change in forward direction\n\t    // from last point of previous path segment in an adjacent diagonal.\n\t    // In last possible iteration when iF === d and kF === d always delete.\n\t    if (iF !== d && aIndexPrev1 < aIndexesF[iF]) {\n\t      aFirst = aIndexesF[iF]; // vertical to insert from b\n\t    } else {\n\t      aFirst = aIndexPrev1 + 1; // horizontal to delete from a\n\n\t      if (aEnd <= aFirst) {\n\t        // Optimization: delete moved past right of graph.\n\t        return iF - 1;\n\t      }\n\t    }\n\n\t    // To get last point of path segment, move along diagonal of common items.\n\t    aIndexPrev1 = aIndexesF[iF];\n\t    aIndexesF[iF] =\n\t      aFirst +\n\t      countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);\n\t  }\n\t  return iMaxF;\n\t};\n\n\t// A simple function to extend reverse paths from (d - 1) to d changes\n\t// when reverse and forward paths cannot yet overlap.\n\tconst extendPathsR = (\n\t  d,\n\t  aStart,\n\t  bStart,\n\t  bR,\n\t  isCommon,\n\t  aIndexesR,\n\t  iMaxR // return the value because optimization might decrease it\n\t) => {\n\t  // Unroll the first iteration.\n\t  let iR = 0;\n\t  let kR = d; // kR = d - 2 * iR\n\t  let aFirst = aIndexesR[iR]; // in first iteration always insert\n\t  let aIndexPrev1 = aFirst; // prev value of [iR - 1] in next iteration\n\t  aIndexesR[iR] -= countCommonItemsR(\n\t    aStart,\n\t    aFirst - 1,\n\t    bStart,\n\t    bR + aFirst - kR - 1,\n\t    isCommon\n\t  );\n\n\t  // Optimization: skip diagonals in which paths cannot ever overlap.\n\t  const nR = d < iMaxR ? d : iMaxR;\n\n\t  // The diagonals kR are odd when d is odd and even when d is even.\n\t  for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {\n\t    // To get first point of path segment, move one change in reverse direction\n\t    // from last point of previous path segment in an adjacent diagonal.\n\t    // In last possible iteration when iR === d and kR === -d always delete.\n\t    if (iR !== d && aIndexesR[iR] < aIndexPrev1) {\n\t      aFirst = aIndexesR[iR]; // vertical to insert from b\n\t    } else {\n\t      aFirst = aIndexPrev1 - 1; // horizontal to delete from a\n\n\t      if (aFirst < aStart) {\n\t        // Optimization: delete moved past left of graph.\n\t        return iR - 1;\n\t      }\n\t    }\n\n\t    // To get last point of path segment, move along diagonal of common items.\n\t    aIndexPrev1 = aIndexesR[iR];\n\t    aIndexesR[iR] =\n\t      aFirst -\n\t      countCommonItemsR(\n\t        aStart,\n\t        aFirst - 1,\n\t        bStart,\n\t        bR + aFirst - kR - 1,\n\t        isCommon\n\t      );\n\t  }\n\t  return iMaxR;\n\t};\n\n\t// A complete function to extend forward paths from (d - 1) to d changes.\n\t// Return true if a path overlaps reverse path of (d - 1) changes in its diagonal.\n\tconst extendOverlappablePathsF = (\n\t  d,\n\t  aStart,\n\t  aEnd,\n\t  bStart,\n\t  bEnd,\n\t  isCommon,\n\t  aIndexesF,\n\t  iMaxF,\n\t  aIndexesR,\n\t  iMaxR,\n\t  division // update prop values if return true\n\t) => {\n\t  const bF = bStart - aStart; // bIndex = bF + aIndex - kF\n\t  const aLength = aEnd - aStart;\n\t  const bLength = bEnd - bStart;\n\t  const baDeltaLength = bLength - aLength; // kF = kR - baDeltaLength\n\n\t  // Range of diagonals in which forward and reverse paths might overlap.\n\t  const kMinOverlapF = -baDeltaLength - (d - 1); // -(d - 1) <= kR\n\t  const kMaxOverlapF = -baDeltaLength + (d - 1); // kR <= (d - 1)\n\n\t  let aIndexPrev1 = NOT_YET_SET; // prev value of [iF - 1] in next iteration\n\n\t  // Optimization: skip diagonals in which paths cannot ever overlap.\n\t  const nF = d < iMaxF ? d : iMaxF;\n\n\t  // The diagonals kF = 2 * iF - d are odd when d is odd and even when d is even.\n\t  for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {\n\t    // To get first point of path segment, move one change in forward direction\n\t    // from last point of previous path segment in an adjacent diagonal.\n\t    // In first iteration when iF === 0 and kF === -d always insert.\n\t    // In last possible iteration when iF === d and kF === d always delete.\n\t    const insert = iF === 0 || (iF !== d && aIndexPrev1 < aIndexesF[iF]);\n\t    const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;\n\t    const aFirst = insert\n\t      ? aLastPrev // vertical to insert from b\n\t      : aLastPrev + 1; // horizontal to delete from a\n\n\t    // To get last point of path segment, move along diagonal of common items.\n\t    const bFirst = bF + aFirst - kF;\n\t    const nCommonF = countCommonItemsF(\n\t      aFirst + 1,\n\t      aEnd,\n\t      bFirst + 1,\n\t      bEnd,\n\t      isCommon\n\t    );\n\t    const aLast = aFirst + nCommonF;\n\t    aIndexPrev1 = aIndexesF[iF];\n\t    aIndexesF[iF] = aLast;\n\t    if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {\n\t      // Solve for iR of reverse path with (d - 1) changes in diagonal kF:\n\t      // kR = kF + baDeltaLength\n\t      // kR = (d - 1) - 2 * iR\n\t      const iR = (d - 1 - (kF + baDeltaLength)) / 2;\n\n\t      // If this forward path overlaps the reverse path in this diagonal,\n\t      // then this is the middle change of the index intervals.\n\t      if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {\n\t        // Unlike the Myers algorithm which finds only the middle “snake”\n\t        // this package can find two common subsequences per division.\n\t        // Last point of previous path segment is on an adjacent diagonal.\n\t        const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1);\n\n\t        // Because of invariant that intervals preceding the middle change\n\t        // cannot have common items at the end,\n\t        // move in reverse direction along a diagonal of common items.\n\t        const nCommonR = countCommonItemsR(\n\t          aStart,\n\t          aLastPrev,\n\t          bStart,\n\t          bLastPrev,\n\t          isCommon\n\t        );\n\t        const aIndexPrevFirst = aLastPrev - nCommonR;\n\t        const bIndexPrevFirst = bLastPrev - nCommonR;\n\t        const aEndPreceding = aIndexPrevFirst + 1;\n\t        const bEndPreceding = bIndexPrevFirst + 1;\n\t        division.nChangePreceding = d - 1;\n\t        if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {\n\t          // Optimization: number of preceding changes in forward direction\n\t          // is equal to number of items in preceding interval,\n\t          // therefore it cannot contain any common items.\n\t          division.aEndPreceding = aStart;\n\t          division.bEndPreceding = bStart;\n\t        } else {\n\t          division.aEndPreceding = aEndPreceding;\n\t          division.bEndPreceding = bEndPreceding;\n\t        }\n\t        division.nCommonPreceding = nCommonR;\n\t        if (nCommonR !== 0) {\n\t          division.aCommonPreceding = aEndPreceding;\n\t          division.bCommonPreceding = bEndPreceding;\n\t        }\n\t        division.nCommonFollowing = nCommonF;\n\t        if (nCommonF !== 0) {\n\t          division.aCommonFollowing = aFirst + 1;\n\t          division.bCommonFollowing = bFirst + 1;\n\t        }\n\t        const aStartFollowing = aLast + 1;\n\t        const bStartFollowing = bFirst + nCommonF + 1;\n\t        division.nChangeFollowing = d - 1;\n\t        if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n\t          // Optimization: number of changes in reverse direction\n\t          // is equal to number of items in following interval,\n\t          // therefore it cannot contain any common items.\n\t          division.aStartFollowing = aEnd;\n\t          division.bStartFollowing = bEnd;\n\t        } else {\n\t          division.aStartFollowing = aStartFollowing;\n\t          division.bStartFollowing = bStartFollowing;\n\t        }\n\t        return true;\n\t      }\n\t    }\n\t  }\n\t  return false;\n\t};\n\n\t// A complete function to extend reverse paths from (d - 1) to d changes.\n\t// Return true if a path overlaps forward path of d changes in its diagonal.\n\tconst extendOverlappablePathsR = (\n\t  d,\n\t  aStart,\n\t  aEnd,\n\t  bStart,\n\t  bEnd,\n\t  isCommon,\n\t  aIndexesF,\n\t  iMaxF,\n\t  aIndexesR,\n\t  iMaxR,\n\t  division // update prop values if return true\n\t) => {\n\t  const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR\n\t  const aLength = aEnd - aStart;\n\t  const bLength = bEnd - bStart;\n\t  const baDeltaLength = bLength - aLength; // kR = kF + baDeltaLength\n\n\t  // Range of diagonals in which forward and reverse paths might overlap.\n\t  const kMinOverlapR = baDeltaLength - d; // -d <= kF\n\t  const kMaxOverlapR = baDeltaLength + d; // kF <= d\n\n\t  let aIndexPrev1 = NOT_YET_SET; // prev value of [iR - 1] in next iteration\n\n\t  // Optimization: skip diagonals in which paths cannot ever overlap.\n\t  const nR = d < iMaxR ? d : iMaxR;\n\n\t  // The diagonals kR = d - 2 * iR are odd when d is odd and even when d is even.\n\t  for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {\n\t    // To get first point of path segment, move one change in reverse direction\n\t    // from last point of previous path segment in an adjacent diagonal.\n\t    // In first iteration when iR === 0 and kR === d always insert.\n\t    // In last possible iteration when iR === d and kR === -d always delete.\n\t    const insert = iR === 0 || (iR !== d && aIndexesR[iR] < aIndexPrev1);\n\t    const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;\n\t    const aFirst = insert\n\t      ? aLastPrev // vertical to insert from b\n\t      : aLastPrev - 1; // horizontal to delete from a\n\n\t    // To get last point of path segment, move along diagonal of common items.\n\t    const bFirst = bR + aFirst - kR;\n\t    const nCommonR = countCommonItemsR(\n\t      aStart,\n\t      aFirst - 1,\n\t      bStart,\n\t      bFirst - 1,\n\t      isCommon\n\t    );\n\t    const aLast = aFirst - nCommonR;\n\t    aIndexPrev1 = aIndexesR[iR];\n\t    aIndexesR[iR] = aLast;\n\t    if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {\n\t      // Solve for iF of forward path with d changes in diagonal kR:\n\t      // kF = kR - baDeltaLength\n\t      // kF = 2 * iF - d\n\t      const iF = (d + (kR - baDeltaLength)) / 2;\n\n\t      // If this reverse path overlaps the forward path in this diagonal,\n\t      // then this is a middle change of the index intervals.\n\t      if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {\n\t        const bLast = bFirst - nCommonR;\n\t        division.nChangePreceding = d;\n\t        if (d === aLast + bLast - aStart - bStart) {\n\t          // Optimization: number of changes in reverse direction\n\t          // is equal to number of items in preceding interval,\n\t          // therefore it cannot contain any common items.\n\t          division.aEndPreceding = aStart;\n\t          division.bEndPreceding = bStart;\n\t        } else {\n\t          division.aEndPreceding = aLast;\n\t          division.bEndPreceding = bLast;\n\t        }\n\t        division.nCommonPreceding = nCommonR;\n\t        if (nCommonR !== 0) {\n\t          // The last point of reverse path segment is start of common subsequence.\n\t          division.aCommonPreceding = aLast;\n\t          division.bCommonPreceding = bLast;\n\t        }\n\t        division.nChangeFollowing = d - 1;\n\t        if (d === 1) {\n\t          // There is no previous path segment.\n\t          division.nCommonFollowing = 0;\n\t          division.aStartFollowing = aEnd;\n\t          division.bStartFollowing = bEnd;\n\t        } else {\n\t          // Unlike the Myers algorithm which finds only the middle “snake”\n\t          // this package can find two common subsequences per division.\n\t          // Last point of previous path segment is on an adjacent diagonal.\n\t          const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1);\n\n\t          // Because of invariant that intervals following the middle change\n\t          // cannot have common items at the start,\n\t          // move in forward direction along a diagonal of common items.\n\t          const nCommonF = countCommonItemsF(\n\t            aLastPrev,\n\t            aEnd,\n\t            bLastPrev,\n\t            bEnd,\n\t            isCommon\n\t          );\n\t          division.nCommonFollowing = nCommonF;\n\t          if (nCommonF !== 0) {\n\t            // The last point of reverse path segment is start of common subsequence.\n\t            division.aCommonFollowing = aLastPrev;\n\t            division.bCommonFollowing = bLastPrev;\n\t          }\n\t          const aStartFollowing = aLastPrev + nCommonF; // aFirstPrev\n\t          const bStartFollowing = bLastPrev + nCommonF; // bFirstPrev\n\n\t          if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n\t            // Optimization: number of changes in forward direction\n\t            // is equal to number of items in following interval,\n\t            // therefore it cannot contain any common items.\n\t            division.aStartFollowing = aEnd;\n\t            division.bStartFollowing = bEnd;\n\t          } else {\n\t            division.aStartFollowing = aStartFollowing;\n\t            division.bStartFollowing = bStartFollowing;\n\t          }\n\t        }\n\t        return true;\n\t      }\n\t    }\n\t  }\n\t  return false;\n\t};\n\n\t// Given index intervals and input function to compare items at indexes,\n\t// divide at the middle change.\n\t//\n\t// DO NOT CALL if start === end, because interval cannot contain common items\n\t// and because this function will throw the “no overlap” error.\n\tconst divide = (\n\t  nChange,\n\t  aStart,\n\t  aEnd,\n\t  bStart,\n\t  bEnd,\n\t  isCommon,\n\t  aIndexesF,\n\t  aIndexesR,\n\t  division // output\n\t) => {\n\t  const bF = bStart - aStart; // bIndex = bF + aIndex - kF\n\t  const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR\n\t  const aLength = aEnd - aStart;\n\t  const bLength = bEnd - bStart;\n\n\t  // Because graph has square or portrait orientation,\n\t  // length difference is minimum number of items to insert from b.\n\t  // Corresponding forward and reverse diagonals in graph\n\t  // depend on length difference of the sequences:\n\t  // kF = kR - baDeltaLength\n\t  // kR = kF + baDeltaLength\n\t  const baDeltaLength = bLength - aLength;\n\n\t  // Optimization: max diagonal in graph intersects corner of shorter side.\n\t  let iMaxF = aLength;\n\t  let iMaxR = aLength;\n\n\t  // Initialize no changes yet in forward or reverse direction:\n\t  aIndexesF[0] = aStart - 1; // at open start of interval, outside closed start\n\t  aIndexesR[0] = aEnd; // at open end of interval\n\n\t  if (baDeltaLength % 2 === 0) {\n\t    // The number of changes in paths is 2 * d if length difference is even.\n\t    const dMin = (nChange || baDeltaLength) / 2;\n\t    const dMax = (aLength + bLength) / 2;\n\t    for (let d = 1; d <= dMax; d += 1) {\n\t      iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n\t      if (d < dMin) {\n\t        iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);\n\t      } else if (\n\t        // If a reverse path overlaps a forward path in the same diagonal,\n\t        // return a division of the index intervals at the middle change.\n\t        extendOverlappablePathsR(\n\t          d,\n\t          aStart,\n\t          aEnd,\n\t          bStart,\n\t          bEnd,\n\t          isCommon,\n\t          aIndexesF,\n\t          iMaxF,\n\t          aIndexesR,\n\t          iMaxR,\n\t          division\n\t        )\n\t      ) {\n\t        return;\n\t      }\n\t    }\n\t  } else {\n\t    // The number of changes in paths is 2 * d - 1 if length difference is odd.\n\t    const dMin = ((nChange || baDeltaLength) + 1) / 2;\n\t    const dMax = (aLength + bLength + 1) / 2;\n\n\t    // Unroll first half iteration so loop extends the relevant pairs of paths.\n\t    // Because of invariant that intervals have no common items at start or end,\n\t    // and limitation not to call divide with empty intervals,\n\t    // therefore it cannot be called if a forward path with one change\n\t    // would overlap a reverse path with no changes, even if dMin === 1.\n\t    let d = 1;\n\t    iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n\t    for (d += 1; d <= dMax; d += 1) {\n\t      iMaxR = extendPathsR(\n\t        d - 1,\n\t        aStart,\n\t        bStart,\n\t        bR,\n\t        isCommon,\n\t        aIndexesR,\n\t        iMaxR\n\t      );\n\t      if (d < dMin) {\n\t        iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n\t      } else if (\n\t        // If a forward path overlaps a reverse path in the same diagonal,\n\t        // return a division of the index intervals at the middle change.\n\t        extendOverlappablePathsF(\n\t          d,\n\t          aStart,\n\t          aEnd,\n\t          bStart,\n\t          bEnd,\n\t          isCommon,\n\t          aIndexesF,\n\t          iMaxF,\n\t          aIndexesR,\n\t          iMaxR,\n\t          division\n\t        )\n\t      ) {\n\t        return;\n\t      }\n\t    }\n\t  }\n\n\t  /* istanbul ignore next */\n\t  throw new Error(\n\t    `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`\n\t  );\n\t};\n\n\t// Given index intervals and input function to compare items at indexes,\n\t// return by output function the number of adjacent items and starting indexes\n\t// of each common subsequence. Divide and conquer with only linear space.\n\t//\n\t// The index intervals are half open [start, end) like array slice method.\n\t// DO NOT CALL if start === end, because interval cannot contain common items\n\t// and because divide function will throw the “no overlap” error.\n\tconst findSubsequences = (\n\t  nChange,\n\t  aStart,\n\t  aEnd,\n\t  bStart,\n\t  bEnd,\n\t  transposed,\n\t  callbacks,\n\t  aIndexesF,\n\t  aIndexesR,\n\t  division // temporary memory, not input nor output\n\t) => {\n\t  if (bEnd - bStart < aEnd - aStart) {\n\t    // Transpose graph so it has portrait instead of landscape orientation.\n\t    // Always compare shorter to longer sequence for consistency and optimization.\n\t    transposed = !transposed;\n\t    if (transposed && callbacks.length === 1) {\n\t      // Lazily wrap callback functions to swap args if graph is transposed.\n\t      const {foundSubsequence, isCommon} = callbacks[0];\n\t      callbacks[1] = {\n\t        foundSubsequence: (nCommon, bCommon, aCommon) => {\n\t          foundSubsequence(nCommon, aCommon, bCommon);\n\t        },\n\t        isCommon: (bIndex, aIndex) => isCommon(aIndex, bIndex)\n\t      };\n\t    }\n\t    const tStart = aStart;\n\t    const tEnd = aEnd;\n\t    aStart = bStart;\n\t    aEnd = bEnd;\n\t    bStart = tStart;\n\t    bEnd = tEnd;\n\t  }\n\t  const {foundSubsequence, isCommon} = callbacks[transposed ? 1 : 0];\n\n\t  // Divide the index intervals at the middle change.\n\t  divide(\n\t    nChange,\n\t    aStart,\n\t    aEnd,\n\t    bStart,\n\t    bEnd,\n\t    isCommon,\n\t    aIndexesF,\n\t    aIndexesR,\n\t    division\n\t  );\n\t  const {\n\t    nChangePreceding,\n\t    aEndPreceding,\n\t    bEndPreceding,\n\t    nCommonPreceding,\n\t    aCommonPreceding,\n\t    bCommonPreceding,\n\t    nCommonFollowing,\n\t    aCommonFollowing,\n\t    bCommonFollowing,\n\t    nChangeFollowing,\n\t    aStartFollowing,\n\t    bStartFollowing\n\t  } = division;\n\n\t  // Unless either index interval is empty, they might contain common items.\n\t  if (aStart < aEndPreceding && bStart < bEndPreceding) {\n\t    // Recursely find and return common subsequences preceding the division.\n\t    findSubsequences(\n\t      nChangePreceding,\n\t      aStart,\n\t      aEndPreceding,\n\t      bStart,\n\t      bEndPreceding,\n\t      transposed,\n\t      callbacks,\n\t      aIndexesF,\n\t      aIndexesR,\n\t      division\n\t    );\n\t  }\n\n\t  // Return common subsequences that are adjacent to the middle change.\n\t  if (nCommonPreceding !== 0) {\n\t    foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);\n\t  }\n\t  if (nCommonFollowing !== 0) {\n\t    foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);\n\t  }\n\n\t  // Unless either index interval is empty, they might contain common items.\n\t  if (aStartFollowing < aEnd && bStartFollowing < bEnd) {\n\t    // Recursely find and return common subsequences following the division.\n\t    findSubsequences(\n\t      nChangeFollowing,\n\t      aStartFollowing,\n\t      aEnd,\n\t      bStartFollowing,\n\t      bEnd,\n\t      transposed,\n\t      callbacks,\n\t      aIndexesF,\n\t      aIndexesR,\n\t      division\n\t    );\n\t  }\n\t};\n\tconst validateLength = (name, arg) => {\n\t  if (typeof arg !== 'number') {\n\t    throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);\n\t  }\n\t  if (!Number.isSafeInteger(arg)) {\n\t    throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);\n\t  }\n\t  if (arg < 0) {\n\t    throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);\n\t  }\n\t};\n\tconst validateCallback = (name, arg) => {\n\t  const type = typeof arg;\n\t  if (type !== 'function') {\n\t    throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);\n\t  }\n\t};\n\n\t// Compare items in two sequences to find a longest common subsequence.\n\t// Given lengths of sequences and input function to compare items at indexes,\n\t// return by output function the number of adjacent items and starting indexes\n\t// of each common subsequence.\n\tfunction diffSequence(aLength, bLength, isCommon, foundSubsequence) {\n\t  validateLength('aLength', aLength);\n\t  validateLength('bLength', bLength);\n\t  validateCallback('isCommon', isCommon);\n\t  validateCallback('foundSubsequence', foundSubsequence);\n\n\t  // Count common items from the start in the forward direction.\n\t  const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);\n\t  if (nCommonF !== 0) {\n\t    foundSubsequence(nCommonF, 0, 0);\n\t  }\n\n\t  // Unless both sequences consist of common items only,\n\t  // find common items in the half-trimmed index intervals.\n\t  if (aLength !== nCommonF || bLength !== nCommonF) {\n\t    // Invariant: intervals do not have common items at the start.\n\t    // The start of an index interval is closed like array slice method.\n\t    const aStart = nCommonF;\n\t    const bStart = nCommonF;\n\n\t    // Count common items from the end in the reverse direction.\n\t    const nCommonR = countCommonItemsR(\n\t      aStart,\n\t      aLength - 1,\n\t      bStart,\n\t      bLength - 1,\n\t      isCommon\n\t    );\n\n\t    // Invariant: intervals do not have common items at the end.\n\t    // The end of an index interval is open like array slice method.\n\t    const aEnd = aLength - nCommonR;\n\t    const bEnd = bLength - nCommonR;\n\n\t    // Unless one sequence consists of common items only,\n\t    // therefore the other trimmed index interval consists of changes only,\n\t    // find common items in the trimmed index intervals.\n\t    const nCommonFR = nCommonF + nCommonR;\n\t    if (aLength !== nCommonFR && bLength !== nCommonFR) {\n\t      const nChange = 0; // number of change items is not yet known\n\t      const transposed = false; // call the original unwrapped functions\n\t      const callbacks = [\n\t        {\n\t          foundSubsequence,\n\t          isCommon\n\t        }\n\t      ];\n\n\t      // Indexes in sequence a of last points in furthest reaching paths\n\t      // from outside the start at top left in the forward direction:\n\t      const aIndexesF = [NOT_YET_SET];\n\t      // from the end at bottom right in the reverse direction:\n\t      const aIndexesR = [NOT_YET_SET];\n\n\t      // Initialize one object as output of all calls to divide function.\n\t      const division = {\n\t        aCommonFollowing: NOT_YET_SET,\n\t        aCommonPreceding: NOT_YET_SET,\n\t        aEndPreceding: NOT_YET_SET,\n\t        aStartFollowing: NOT_YET_SET,\n\t        bCommonFollowing: NOT_YET_SET,\n\t        bCommonPreceding: NOT_YET_SET,\n\t        bEndPreceding: NOT_YET_SET,\n\t        bStartFollowing: NOT_YET_SET,\n\t        nChangeFollowing: NOT_YET_SET,\n\t        nChangePreceding: NOT_YET_SET,\n\t        nCommonFollowing: NOT_YET_SET,\n\t        nCommonPreceding: NOT_YET_SET\n\t      };\n\n\t      // Find and return common subsequences in the trimmed index intervals.\n\t      findSubsequences(\n\t        nChange,\n\t        aStart,\n\t        aEnd,\n\t        bStart,\n\t        bEnd,\n\t        transposed,\n\t        callbacks,\n\t        aIndexesF,\n\t        aIndexesR,\n\t        division\n\t      );\n\t    }\n\t    if (nCommonR !== 0) {\n\t      foundSubsequence(nCommonR, aEnd, bEnd);\n\t    }\n\t  }\n\t}\n\treturn build;\n}\n\nvar buildExports = /*@__PURE__*/ requireBuild();\nvar diffSequences = /*@__PURE__*/getDefaultExportFromCjs(buildExports);\n\nfunction formatTrailingSpaces(line, trailingSpaceFormatter) {\n\treturn line.replace(/\\s+$/, (match) => trailingSpaceFormatter(match));\n}\nfunction printDiffLine(line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {\n\treturn line.length !== 0 ? color(`${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`) : indicator !== \" \" ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : \"\";\n}\nfunction printDeleteLine(line, isFirstOrLast, { aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {\n\treturn printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n}\nfunction printInsertLine(line, isFirstOrLast, { bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {\n\treturn printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n}\nfunction printCommonLine(line, isFirstOrLast, { commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {\n\treturn printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n}\n// In GNU diff format, indexes are one-based instead of zero-based.\nfunction createPatchMark(aStart, aEnd, bStart, bEnd, { patchColor }) {\n\treturn patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);\n}\n// jest --no-expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting (and patch marks, if needed).\nfunction joinAlignedDiffsNoExpand(diffs, options) {\n\tconst iLength = diffs.length;\n\tconst nContextLines = options.contextLines;\n\tconst nContextLines2 = nContextLines + nContextLines;\n\t// First pass: count output lines and see if it has patches.\n\tlet jLength = iLength;\n\tlet hasExcessAtStartOrEnd = false;\n\tlet nExcessesBetweenChanges = 0;\n\tlet i = 0;\n\twhile (i !== iLength) {\n\t\tconst iStart = i;\n\t\twhile (i !== iLength && diffs[i][0] === DIFF_EQUAL) {\n\t\t\ti += 1;\n\t\t}\n\t\tif (iStart !== i) {\n\t\t\tif (iStart === 0) {\n\t\t\t\t// at start\n\t\t\t\tif (i > nContextLines) {\n\t\t\t\t\tjLength -= i - nContextLines;\n\t\t\t\t\thasExcessAtStartOrEnd = true;\n\t\t\t\t}\n\t\t\t} else if (i === iLength) {\n\t\t\t\t// at end\n\t\t\t\tconst n = i - iStart;\n\t\t\t\tif (n > nContextLines) {\n\t\t\t\t\tjLength -= n - nContextLines;\n\t\t\t\t\thasExcessAtStartOrEnd = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// between changes\n\t\t\t\tconst n = i - iStart;\n\t\t\t\tif (n > nContextLines2) {\n\t\t\t\t\tjLength -= n - nContextLines2;\n\t\t\t\t\tnExcessesBetweenChanges += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (i !== iLength && diffs[i][0] !== DIFF_EQUAL) {\n\t\t\ti += 1;\n\t\t}\n\t}\n\tconst hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;\n\tif (nExcessesBetweenChanges !== 0) {\n\t\tjLength += nExcessesBetweenChanges + 1;\n\t} else if (hasExcessAtStartOrEnd) {\n\t\tjLength += 1;\n\t}\n\tconst jLast = jLength - 1;\n\tconst lines = [];\n\tlet jPatchMark = 0;\n\tif (hasPatch) {\n\t\tlines.push(\"\");\n\t}\n\t// Indexes of expected or received lines in current patch:\n\tlet aStart = 0;\n\tlet bStart = 0;\n\tlet aEnd = 0;\n\tlet bEnd = 0;\n\tconst pushCommonLine = (line) => {\n\t\tconst j = lines.length;\n\t\tlines.push(printCommonLine(line, j === 0 || j === jLast, options));\n\t\taEnd += 1;\n\t\tbEnd += 1;\n\t};\n\tconst pushDeleteLine = (line) => {\n\t\tconst j = lines.length;\n\t\tlines.push(printDeleteLine(line, j === 0 || j === jLast, options));\n\t\taEnd += 1;\n\t};\n\tconst pushInsertLine = (line) => {\n\t\tconst j = lines.length;\n\t\tlines.push(printInsertLine(line, j === 0 || j === jLast, options));\n\t\tbEnd += 1;\n\t};\n\t// Second pass: push lines with diff formatting (and patch marks, if needed).\n\ti = 0;\n\twhile (i !== iLength) {\n\t\tlet iStart = i;\n\t\twhile (i !== iLength && diffs[i][0] === DIFF_EQUAL) {\n\t\t\ti += 1;\n\t\t}\n\t\tif (iStart !== i) {\n\t\t\tif (iStart === 0) {\n\t\t\t\t// at beginning\n\t\t\t\tif (i > nContextLines) {\n\t\t\t\t\tiStart = i - nContextLines;\n\t\t\t\t\taStart = iStart;\n\t\t\t\t\tbStart = iStart;\n\t\t\t\t\taEnd = aStart;\n\t\t\t\t\tbEnd = bStart;\n\t\t\t\t}\n\t\t\t\tfor (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n\t\t\t\t\tpushCommonLine(diffs[iCommon][1]);\n\t\t\t\t}\n\t\t\t} else if (i === iLength) {\n\t\t\t\t// at end\n\t\t\t\tconst iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;\n\t\t\t\tfor (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n\t\t\t\t\tpushCommonLine(diffs[iCommon][1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// between changes\n\t\t\t\tconst nCommon = i - iStart;\n\t\t\t\tif (nCommon > nContextLines2) {\n\t\t\t\t\tconst iEnd = iStart + nContextLines;\n\t\t\t\t\tfor (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n\t\t\t\t\t\tpushCommonLine(diffs[iCommon][1]);\n\t\t\t\t\t}\n\t\t\t\t\tlines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);\n\t\t\t\t\tjPatchMark = lines.length;\n\t\t\t\t\tlines.push(\"\");\n\t\t\t\t\tconst nOmit = nCommon - nContextLines2;\n\t\t\t\t\taStart = aEnd + nOmit;\n\t\t\t\t\tbStart = bEnd + nOmit;\n\t\t\t\t\taEnd = aStart;\n\t\t\t\t\tbEnd = bStart;\n\t\t\t\t\tfor (let iCommon = i - nContextLines; iCommon !== i; iCommon += 1) {\n\t\t\t\t\t\tpushCommonLine(diffs[iCommon][1]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n\t\t\t\t\t\tpushCommonLine(diffs[iCommon][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (i !== iLength && diffs[i][0] === DIFF_DELETE) {\n\t\t\tpushDeleteLine(diffs[i][1]);\n\t\t\ti += 1;\n\t\t}\n\t\twhile (i !== iLength && diffs[i][0] === DIFF_INSERT) {\n\t\t\tpushInsertLine(diffs[i][1]);\n\t\t\ti += 1;\n\t\t}\n\t}\n\tif (hasPatch) {\n\t\tlines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);\n\t}\n\treturn lines.join(\"\\n\");\n}\n// jest --expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting.\nfunction joinAlignedDiffsExpand(diffs, options) {\n\treturn diffs.map((diff, i, diffs) => {\n\t\tconst line = diff[1];\n\t\tconst isFirstOrLast = i === 0 || i === diffs.length - 1;\n\t\tswitch (diff[0]) {\n\t\t\tcase DIFF_DELETE: return printDeleteLine(line, isFirstOrLast, options);\n\t\t\tcase DIFF_INSERT: return printInsertLine(line, isFirstOrLast, options);\n\t\t\tdefault: return printCommonLine(line, isFirstOrLast, options);\n\t\t}\n\t}).join(\"\\n\");\n}\n\nconst noColor = (string) => string;\nconst DIFF_CONTEXT_DEFAULT = 5;\nconst DIFF_TRUNCATE_THRESHOLD_DEFAULT = 0;\nfunction getDefaultOptions() {\n\treturn {\n\t\taAnnotation: \"Expected\",\n\t\taColor: c.green,\n\t\taIndicator: \"-\",\n\t\tbAnnotation: \"Received\",\n\t\tbColor: c.red,\n\t\tbIndicator: \"+\",\n\t\tchangeColor: c.inverse,\n\t\tchangeLineTrailingSpaceColor: noColor,\n\t\tcommonColor: c.dim,\n\t\tcommonIndicator: \" \",\n\t\tcommonLineTrailingSpaceColor: noColor,\n\t\tcompareKeys: undefined,\n\t\tcontextLines: DIFF_CONTEXT_DEFAULT,\n\t\temptyFirstOrLastLinePlaceholder: \"\",\n\t\texpand: false,\n\t\tincludeChangeCounts: false,\n\t\tomitAnnotationLines: false,\n\t\tpatchColor: c.yellow,\n\t\tprintBasicPrototype: false,\n\t\ttruncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT,\n\t\ttruncateAnnotation: \"... Diff result is truncated\",\n\t\ttruncateAnnotationColor: noColor\n\t};\n}\nfunction getCompareKeys(compareKeys) {\n\treturn compareKeys && typeof compareKeys === \"function\" ? compareKeys : undefined;\n}\nfunction getContextLines(contextLines) {\n\treturn typeof contextLines === \"number\" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;\n}\n// Pure function returns options with all properties.\nfunction normalizeDiffOptions(options = {}) {\n\treturn {\n\t\t...getDefaultOptions(),\n\t\t...options,\n\t\tcompareKeys: getCompareKeys(options.compareKeys),\n\t\tcontextLines: getContextLines(options.contextLines)\n\t};\n}\n\nfunction isEmptyString(lines) {\n\treturn lines.length === 1 && lines[0].length === 0;\n}\nfunction countChanges(diffs) {\n\tlet a = 0;\n\tlet b = 0;\n\tdiffs.forEach((diff) => {\n\t\tswitch (diff[0]) {\n\t\t\tcase DIFF_DELETE:\n\t\t\t\ta += 1;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tb += 1;\n\t\t\t\tbreak;\n\t\t}\n\t});\n\treturn {\n\t\ta,\n\t\tb\n\t};\n}\nfunction printAnnotation({ aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator, includeChangeCounts, omitAnnotationLines }, changeCounts) {\n\tif (omitAnnotationLines) {\n\t\treturn \"\";\n\t}\n\tlet aRest = \"\";\n\tlet bRest = \"\";\n\tif (includeChangeCounts) {\n\t\tconst aCount = String(changeCounts.a);\n\t\tconst bCount = String(changeCounts.b);\n\t\t// Padding right aligns the ends of the annotations.\n\t\tconst baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;\n\t\tconst aAnnotationPadding = \" \".repeat(Math.max(0, baAnnotationLengthDiff));\n\t\tconst bAnnotationPadding = \" \".repeat(Math.max(0, -baAnnotationLengthDiff));\n\t\t// Padding left aligns the ends of the counts.\n\t\tconst baCountLengthDiff = bCount.length - aCount.length;\n\t\tconst aCountPadding = \" \".repeat(Math.max(0, baCountLengthDiff));\n\t\tconst bCountPadding = \" \".repeat(Math.max(0, -baCountLengthDiff));\n\t\taRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`;\n\t\tbRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;\n\t}\n\tconst a = `${aIndicator} ${aAnnotation}${aRest}`;\n\tconst b = `${bIndicator} ${bAnnotation}${bRest}`;\n\treturn `${aColor(a)}\\n${bColor(b)}\\n\\n`;\n}\nfunction printDiffLines(diffs, truncated, options) {\n\treturn printAnnotation(options, countChanges(diffs)) + (options.expand ? joinAlignedDiffsExpand(diffs, options) : joinAlignedDiffsNoExpand(diffs, options)) + (truncated ? options.truncateAnnotationColor(`\\n${options.truncateAnnotation}`) : \"\");\n}\n// Compare two arrays of strings line-by-line. Format as comparison lines.\nfunction diffLinesUnified(aLines, bLines, options) {\n\tconst normalizedOptions = normalizeDiffOptions(options);\n\tconst [diffs, truncated] = diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines, normalizedOptions);\n\treturn printDiffLines(diffs, truncated, normalizedOptions);\n}\n// Given two pairs of arrays of strings:\n// Compare the pair of comparison arrays line-by-line.\n// Format the corresponding lines in the pair of displayable arrays.\nfunction diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) {\n\tif (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {\n\t\taLinesDisplay = [];\n\t\taLinesCompare = [];\n\t}\n\tif (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {\n\t\tbLinesDisplay = [];\n\t\tbLinesCompare = [];\n\t}\n\tif (aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length) {\n\t\t// Fall back to diff of display lines.\n\t\treturn diffLinesUnified(aLinesDisplay, bLinesDisplay, options);\n\t}\n\tconst [diffs, truncated] = diffLinesRaw(aLinesCompare, bLinesCompare, options);\n\t// Replace comparison lines with displayable lines.\n\tlet aIndex = 0;\n\tlet bIndex = 0;\n\tdiffs.forEach((diff) => {\n\t\tswitch (diff[0]) {\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tdiff[1] = aLinesDisplay[aIndex];\n\t\t\t\taIndex += 1;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tdiff[1] = bLinesDisplay[bIndex];\n\t\t\t\tbIndex += 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdiff[1] = bLinesDisplay[bIndex];\n\t\t\t\taIndex += 1;\n\t\t\t\tbIndex += 1;\n\t\t}\n\t});\n\treturn printDiffLines(diffs, truncated, normalizeDiffOptions(options));\n}\n// Compare two arrays of strings line-by-line.\nfunction diffLinesRaw(aLines, bLines, options) {\n\tconst truncate = (options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? false;\n\tconst truncateThreshold = Math.max(Math.floor((options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? 0), 0);\n\tconst aLength = truncate ? Math.min(aLines.length, truncateThreshold) : aLines.length;\n\tconst bLength = truncate ? Math.min(bLines.length, truncateThreshold) : bLines.length;\n\tconst truncated = aLength !== aLines.length || bLength !== bLines.length;\n\tconst isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\tconst diffs = [];\n\tlet aIndex = 0;\n\tlet bIndex = 0;\n\tconst foundSubsequence = (nCommon, aCommon, bCommon) => {\n\t\tfor (; aIndex !== aCommon; aIndex += 1) {\n\t\t\tdiffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));\n\t\t}\n\t\tfor (; bIndex !== bCommon; bIndex += 1) {\n\t\t\tdiffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));\n\t\t}\n\t\tfor (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n\t\t\tdiffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));\n\t\t}\n\t};\n\tdiffSequences(aLength, bLength, isCommon, foundSubsequence);\n\t// After the last common subsequence, push remaining change items.\n\tfor (; aIndex !== aLength; aIndex += 1) {\n\t\tdiffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));\n\t}\n\tfor (; bIndex !== bLength; bIndex += 1) {\n\t\tdiffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));\n\t}\n\treturn [diffs, truncated];\n}\n\n// get the type of a value with handling the edge cases like `typeof []`\n// and `typeof null`\nfunction getType(value) {\n\tif (value === undefined) {\n\t\treturn \"undefined\";\n\t} else if (value === null) {\n\t\treturn \"null\";\n\t} else if (Array.isArray(value)) {\n\t\treturn \"array\";\n\t} else if (typeof value === \"boolean\") {\n\t\treturn \"boolean\";\n\t} else if (typeof value === \"function\") {\n\t\treturn \"function\";\n\t} else if (typeof value === \"number\") {\n\t\treturn \"number\";\n\t} else if (typeof value === \"string\") {\n\t\treturn \"string\";\n\t} else if (typeof value === \"bigint\") {\n\t\treturn \"bigint\";\n\t} else if (typeof value === \"object\") {\n\t\tif (value != null) {\n\t\t\tif (value.constructor === RegExp) {\n\t\t\t\treturn \"regexp\";\n\t\t\t} else if (value.constructor === Map) {\n\t\t\t\treturn \"map\";\n\t\t\t} else if (value.constructor === Set) {\n\t\t\t\treturn \"set\";\n\t\t\t} else if (value.constructor === Date) {\n\t\t\t\treturn \"date\";\n\t\t\t}\n\t\t}\n\t\treturn \"object\";\n\t} else if (typeof value === \"symbol\") {\n\t\treturn \"symbol\";\n\t}\n\tthrow new Error(`value of unknown type: ${value}`);\n}\n\n// platforms compatible\nfunction getNewLineSymbol(string) {\n\treturn string.includes(\"\\r\\n\") ? \"\\r\\n\" : \"\\n\";\n}\nfunction diffStrings(a, b, options) {\n\tconst truncate = (options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? false;\n\tconst truncateThreshold = Math.max(Math.floor((options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? 0), 0);\n\tlet aLength = a.length;\n\tlet bLength = b.length;\n\tif (truncate) {\n\t\tconst aMultipleLines = a.includes(\"\\n\");\n\t\tconst bMultipleLines = b.includes(\"\\n\");\n\t\tconst aNewLineSymbol = getNewLineSymbol(a);\n\t\tconst bNewLineSymbol = getNewLineSymbol(b);\n\t\t// multiple-lines string expects a newline to be appended at the end\n\t\tconst _a = aMultipleLines ? `${a.split(aNewLineSymbol, truncateThreshold).join(aNewLineSymbol)}\\n` : a;\n\t\tconst _b = bMultipleLines ? `${b.split(bNewLineSymbol, truncateThreshold).join(bNewLineSymbol)}\\n` : b;\n\t\taLength = _a.length;\n\t\tbLength = _b.length;\n\t}\n\tconst truncated = aLength !== a.length || bLength !== b.length;\n\tconst isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\tlet aIndex = 0;\n\tlet bIndex = 0;\n\tconst diffs = [];\n\tconst foundSubsequence = (nCommon, aCommon, bCommon) => {\n\t\tif (aIndex !== aCommon) {\n\t\t\tdiffs.push(new Diff(DIFF_DELETE, a.slice(aIndex, aCommon)));\n\t\t}\n\t\tif (bIndex !== bCommon) {\n\t\t\tdiffs.push(new Diff(DIFF_INSERT, b.slice(bIndex, bCommon)));\n\t\t}\n\t\taIndex = aCommon + nCommon;\n\t\tbIndex = bCommon + nCommon;\n\t\tdiffs.push(new Diff(DIFF_EQUAL, b.slice(bCommon, bIndex)));\n\t};\n\tdiffSequences(aLength, bLength, isCommon, foundSubsequence);\n\t// After the last common subsequence, push remaining change items.\n\tif (aIndex !== aLength) {\n\t\tdiffs.push(new Diff(DIFF_DELETE, a.slice(aIndex)));\n\t}\n\tif (bIndex !== bLength) {\n\t\tdiffs.push(new Diff(DIFF_INSERT, b.slice(bIndex)));\n\t}\n\treturn [diffs, truncated];\n}\n\n// Given change op and array of diffs, return concatenated string:\n// * include common strings\n// * include change strings which have argument op with changeColor\n// * exclude change strings which have opposite op\nfunction concatenateRelevantDiffs(op, diffs, changeColor) {\n\treturn diffs.reduce((reduced, diff) => reduced + (diff[0] === DIFF_EQUAL ? diff[1] : diff[0] === op && diff[1].length !== 0 ? changeColor(diff[1]) : \"\"), \"\");\n}\n// Encapsulate change lines until either a common newline or the end.\nclass ChangeBuffer {\n\top;\n\tline;\n\tlines;\n\tchangeColor;\n\tconstructor(op, changeColor) {\n\t\tthis.op = op;\n\t\tthis.line = [];\n\t\tthis.lines = [];\n\t\tthis.changeColor = changeColor;\n\t}\n\tpushSubstring(substring) {\n\t\tthis.pushDiff(new Diff(this.op, substring));\n\t}\n\tpushLine() {\n\t\t// Assume call only if line has at least one diff,\n\t\t// therefore an empty line must have a diff which has an empty string.\n\t\t// If line has multiple diffs, then assume it has a common diff,\n\t\t// therefore change diffs have change color;\n\t\t// otherwise then it has line color only.\n\t\tthis.lines.push(this.line.length !== 1 ? new Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Diff(this.op, this.line[0][1]));\n\t\tthis.line.length = 0;\n\t}\n\tisLineEmpty() {\n\t\treturn this.line.length === 0;\n\t}\n\t// Minor input to buffer.\n\tpushDiff(diff) {\n\t\tthis.line.push(diff);\n\t}\n\t// Main input to buffer.\n\talign(diff) {\n\t\tconst string = diff[1];\n\t\tif (string.includes(\"\\n\")) {\n\t\t\tconst substrings = string.split(\"\\n\");\n\t\t\tconst iLast = substrings.length - 1;\n\t\t\tsubstrings.forEach((substring, i) => {\n\t\t\t\tif (i < iLast) {\n\t\t\t\t\t// The first substring completes the current change line.\n\t\t\t\t\t// A middle substring is a change line.\n\t\t\t\t\tthis.pushSubstring(substring);\n\t\t\t\t\tthis.pushLine();\n\t\t\t\t} else if (substring.length !== 0) {\n\t\t\t\t\t// The last substring starts a change line, if it is not empty.\n\t\t\t\t\t// Important: This non-empty condition also automatically omits\n\t\t\t\t\t// the newline appended to the end of expected and received strings.\n\t\t\t\t\tthis.pushSubstring(substring);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\t// Append non-multiline string to current change line.\n\t\t\tthis.pushDiff(diff);\n\t\t}\n\t}\n\t// Output from buffer.\n\tmoveLinesTo(lines) {\n\t\tif (!this.isLineEmpty()) {\n\t\t\tthis.pushLine();\n\t\t}\n\t\tlines.push(...this.lines);\n\t\tthis.lines.length = 0;\n\t}\n}\n// Encapsulate common and change lines.\nclass CommonBuffer {\n\tdeleteBuffer;\n\tinsertBuffer;\n\tlines;\n\tconstructor(deleteBuffer, insertBuffer) {\n\t\tthis.deleteBuffer = deleteBuffer;\n\t\tthis.insertBuffer = insertBuffer;\n\t\tthis.lines = [];\n\t}\n\tpushDiffCommonLine(diff) {\n\t\tthis.lines.push(diff);\n\t}\n\tpushDiffChangeLines(diff) {\n\t\tconst isDiffEmpty = diff[1].length === 0;\n\t\t// An empty diff string is redundant, unless a change line is empty.\n\t\tif (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {\n\t\t\tthis.deleteBuffer.pushDiff(diff);\n\t\t}\n\t\tif (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {\n\t\t\tthis.insertBuffer.pushDiff(diff);\n\t\t}\n\t}\n\tflushChangeLines() {\n\t\tthis.deleteBuffer.moveLinesTo(this.lines);\n\t\tthis.insertBuffer.moveLinesTo(this.lines);\n\t}\n\t// Input to buffer.\n\talign(diff) {\n\t\tconst op = diff[0];\n\t\tconst string = diff[1];\n\t\tif (string.includes(\"\\n\")) {\n\t\t\tconst substrings = string.split(\"\\n\");\n\t\t\tconst iLast = substrings.length - 1;\n\t\t\tsubstrings.forEach((substring, i) => {\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tconst subdiff = new Diff(op, substring);\n\t\t\t\t\tif (this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()) {\n\t\t\t\t\t\t// If both current change lines are empty,\n\t\t\t\t\t\t// then the first substring is a common line.\n\t\t\t\t\t\tthis.flushChangeLines();\n\t\t\t\t\t\tthis.pushDiffCommonLine(subdiff);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If either current change line is non-empty,\n\t\t\t\t\t\t// then the first substring completes the change lines.\n\t\t\t\t\t\tthis.pushDiffChangeLines(subdiff);\n\t\t\t\t\t\tthis.flushChangeLines();\n\t\t\t\t\t}\n\t\t\t\t} else if (i < iLast) {\n\t\t\t\t\t// A middle substring is a common line.\n\t\t\t\t\tthis.pushDiffCommonLine(new Diff(op, substring));\n\t\t\t\t} else if (substring.length !== 0) {\n\t\t\t\t\t// The last substring starts a change line, if it is not empty.\n\t\t\t\t\t// Important: This non-empty condition also automatically omits\n\t\t\t\t\t// the newline appended to the end of expected and received strings.\n\t\t\t\t\tthis.pushDiffChangeLines(new Diff(op, substring));\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\t// Append non-multiline string to current change lines.\n\t\t\t// Important: It cannot be at the end following empty change lines,\n\t\t\t// because newline appended to the end of expected and received strings.\n\t\t\tthis.pushDiffChangeLines(diff);\n\t\t}\n\t}\n\t// Output from buffer.\n\tgetLines() {\n\t\tthis.flushChangeLines();\n\t\treturn this.lines;\n\t}\n}\n// Given diffs from expected and received strings,\n// return new array of diffs split or joined into lines.\n//\n// To correctly align a change line at the end, the algorithm:\n// * assumes that a newline was appended to the strings\n// * omits the last newline from the output array\n//\n// Assume the function is not called:\n// * if either expected or received is empty string\n// * if neither expected nor received is multiline string\nfunction getAlignedDiffs(diffs, changeColor) {\n\tconst deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor);\n\tconst insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor);\n\tconst commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);\n\tdiffs.forEach((diff) => {\n\t\tswitch (diff[0]) {\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tdeleteBuffer.align(diff);\n\t\t\t\tbreak;\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tinsertBuffer.align(diff);\n\t\t\t\tbreak;\n\t\t\tdefault: commonBuffer.align(diff);\n\t\t}\n\t});\n\treturn commonBuffer.getLines();\n}\n\nfunction hasCommonDiff(diffs, isMultiline) {\n\tif (isMultiline) {\n\t\t// Important: Ignore common newline that was appended to multiline strings!\n\t\tconst iLast = diffs.length - 1;\n\t\treturn diffs.some((diff, i) => diff[0] === DIFF_EQUAL && (i !== iLast || diff[1] !== \"\\n\"));\n\t}\n\treturn diffs.some((diff) => diff[0] === DIFF_EQUAL);\n}\n// Compare two strings character-by-character.\n// Format as comparison lines in which changed substrings have inverse colors.\nfunction diffStringsUnified(a, b, options) {\n\tif (a !== b && a.length !== 0 && b.length !== 0) {\n\t\tconst isMultiline = a.includes(\"\\n\") || b.includes(\"\\n\");\n\t\t// getAlignedDiffs assumes that a newline was appended to the strings.\n\t\tconst [diffs, truncated] = diffStringsRaw(isMultiline ? `${a}\\n` : a, isMultiline ? `${b}\\n` : b, true, options);\n\t\tif (hasCommonDiff(diffs, isMultiline)) {\n\t\t\tconst optionsNormalized = normalizeDiffOptions(options);\n\t\t\tconst lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);\n\t\t\treturn printDiffLines(lines, truncated, optionsNormalized);\n\t\t}\n\t}\n\t// Fall back to line-by-line diff.\n\treturn diffLinesUnified(a.split(\"\\n\"), b.split(\"\\n\"), options);\n}\n// Compare two strings character-by-character.\n// Optionally clean up small common substrings, also known as chaff.\nfunction diffStringsRaw(a, b, cleanup, options) {\n\tconst [diffs, truncated] = diffStrings(a, b, options);\n\tif (cleanup) {\n\t\tdiff_cleanupSemantic(diffs);\n\t}\n\treturn [diffs, truncated];\n}\n\nfunction getCommonMessage(message, options) {\n\tconst { commonColor } = normalizeDiffOptions(options);\n\treturn commonColor(message);\n}\nconst { AsymmetricMatcher, DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent } = plugins;\nconst PLUGINS = [\n\tReactTestComponent,\n\tReactElement,\n\tDOMElement,\n\tDOMCollection,\n\tImmutable,\n\tAsymmetricMatcher,\n\tplugins.Error\n];\nconst FORMAT_OPTIONS = {\n\tmaxDepth: 20,\n\tplugins: PLUGINS\n};\nconst FALLBACK_FORMAT_OPTIONS = {\n\tcallToJSON: false,\n\tmaxDepth: 8,\n\tplugins: PLUGINS\n};\n// Generate a string that will highlight the difference between two values\n// with green and red. (similar to how github does code diffing)\n/**\n* @param a Expected value\n* @param b Received value\n* @param options Diff options\n* @returns {string | null} a string diff\n*/\nfunction diff(a, b, options) {\n\tif (Object.is(a, b)) {\n\t\treturn \"\";\n\t}\n\tconst aType = getType(a);\n\tlet expectedType = aType;\n\tlet omitDifference = false;\n\tif (aType === \"object\" && typeof a.asymmetricMatch === \"function\") {\n\t\tif (a.$$typeof !== Symbol.for(\"jest.asymmetricMatcher\")) {\n\t\t\t// Do not know expected type of user-defined asymmetric matcher.\n\t\t\treturn undefined;\n\t\t}\n\t\tif (typeof a.getExpectedType !== \"function\") {\n\t\t\t// For example, expect.anything() matches either null or undefined\n\t\t\treturn undefined;\n\t\t}\n\t\texpectedType = a.getExpectedType();\n\t\t// Primitive types boolean and number omit difference below.\n\t\t// For example, omit difference for expect.stringMatching(regexp)\n\t\tomitDifference = expectedType === \"string\";\n\t}\n\tif (expectedType !== getType(b)) {\n\t\tconst { aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator } = normalizeDiffOptions(options);\n\t\tconst formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);\n\t\tlet aDisplay = format(a, formatOptions);\n\t\tlet bDisplay = format(b, formatOptions);\n\t\t// even if prettyFormat prints successfully big objects,\n\t\t// large string can choke later on (concatenation? RPC?),\n\t\t// so truncate it to a reasonable length here.\n\t\t// (For example, playwright's ElementHandle can become about 200_000_000 length string)\n\t\tconst MAX_LENGTH = 1e5;\n\t\tfunction truncate(s) {\n\t\t\treturn s.length <= MAX_LENGTH ? s : `${s.slice(0, MAX_LENGTH)}...`;\n\t\t}\n\t\taDisplay = truncate(aDisplay);\n\t\tbDisplay = truncate(bDisplay);\n\t\tconst aDiff = `${aColor(`${aIndicator} ${aAnnotation}:`)} \\n${aDisplay}`;\n\t\tconst bDiff = `${bColor(`${bIndicator} ${bAnnotation}:`)} \\n${bDisplay}`;\n\t\treturn `${aDiff}\\n\\n${bDiff}`;\n\t}\n\tif (omitDifference) {\n\t\treturn undefined;\n\t}\n\tswitch (aType) {\n\t\tcase \"string\": return diffLinesUnified(a.split(\"\\n\"), b.split(\"\\n\"), options);\n\t\tcase \"boolean\":\n\t\tcase \"number\": return comparePrimitive(a, b, options);\n\t\tcase \"map\": return compareObjects(sortMap(a), sortMap(b), options);\n\t\tcase \"set\": return compareObjects(sortSet(a), sortSet(b), options);\n\t\tdefault: return compareObjects(a, b, options);\n\t}\n}\nfunction comparePrimitive(a, b, options) {\n\tconst aFormat = format(a, FORMAT_OPTIONS);\n\tconst bFormat = format(b, FORMAT_OPTIONS);\n\treturn aFormat === bFormat ? \"\" : diffLinesUnified(aFormat.split(\"\\n\"), bFormat.split(\"\\n\"), options);\n}\nfunction sortMap(map) {\n\treturn new Map(Array.from(map.entries()).sort());\n}\nfunction sortSet(set) {\n\treturn new Set(Array.from(set.values()).sort());\n}\nfunction compareObjects(a, b, options) {\n\tlet difference;\n\tlet hasThrown = false;\n\ttry {\n\t\tconst formatOptions = getFormatOptions(FORMAT_OPTIONS, options);\n\t\tdifference = getObjectsDifference(a, b, formatOptions, options);\n\t} catch {\n\t\thasThrown = true;\n\t}\n\tconst noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options);\n\t// If the comparison yields no results, compare again but this time\n\t// without calling `toJSON`. It's also possible that toJSON might throw.\n\tif (difference === undefined || difference === noDiffMessage) {\n\t\tconst formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);\n\t\tdifference = getObjectsDifference(a, b, formatOptions, options);\n\t\tif (difference !== noDiffMessage && !hasThrown) {\n\t\t\tdifference = `${getCommonMessage(SIMILAR_MESSAGE, options)}\\n\\n${difference}`;\n\t\t}\n\t}\n\treturn difference;\n}\nfunction getFormatOptions(formatOptions, options) {\n\tconst { compareKeys, printBasicPrototype, maxDepth } = normalizeDiffOptions(options);\n\treturn {\n\t\t...formatOptions,\n\t\tcompareKeys,\n\t\tprintBasicPrototype,\n\t\tmaxDepth: maxDepth ?? formatOptions.maxDepth\n\t};\n}\nfunction getObjectsDifference(a, b, formatOptions, options) {\n\tconst formatOptionsZeroIndent = {\n\t\t...formatOptions,\n\t\tindent: 0\n\t};\n\tconst aCompare = format(a, formatOptionsZeroIndent);\n\tconst bCompare = format(b, formatOptionsZeroIndent);\n\tif (aCompare === bCompare) {\n\t\treturn getCommonMessage(NO_DIFF_MESSAGE, options);\n\t} else {\n\t\tconst aDisplay = format(a, formatOptions);\n\t\tconst bDisplay = format(b, formatOptions);\n\t\treturn diffLinesUnified2(aDisplay.split(\"\\n\"), bDisplay.split(\"\\n\"), aCompare.split(\"\\n\"), bCompare.split(\"\\n\"), options);\n\t}\n}\nconst MAX_DIFF_STRING_LENGTH = 2e4;\nfunction isAsymmetricMatcher(data) {\n\tconst type = getType$1(data);\n\treturn type === \"Object\" && typeof data.asymmetricMatch === \"function\";\n}\nfunction isReplaceable(obj1, obj2) {\n\tconst obj1Type = getType$1(obj1);\n\tconst obj2Type = getType$1(obj2);\n\treturn obj1Type === obj2Type && (obj1Type === \"Object\" || obj1Type === \"Array\");\n}\nfunction printDiffOrStringify(received, expected, options) {\n\tconst { aAnnotation, bAnnotation } = normalizeDiffOptions(options);\n\tif (typeof expected === \"string\" && typeof received === \"string\" && expected.length > 0 && received.length > 0 && expected.length <= MAX_DIFF_STRING_LENGTH && received.length <= MAX_DIFF_STRING_LENGTH && expected !== received) {\n\t\tif (expected.includes(\"\\n\") || received.includes(\"\\n\")) {\n\t\t\treturn diffStringsUnified(expected, received, options);\n\t\t}\n\t\tconst [diffs] = diffStringsRaw(expected, received, true);\n\t\tconst hasCommonDiff = diffs.some((diff) => diff[0] === DIFF_EQUAL);\n\t\tconst printLabel = getLabelPrinter(aAnnotation, bAnnotation);\n\t\tconst expectedLine = printLabel(aAnnotation) + printExpected(getCommonAndChangedSubstrings(diffs, DIFF_DELETE, hasCommonDiff));\n\t\tconst receivedLine = printLabel(bAnnotation) + printReceived(getCommonAndChangedSubstrings(diffs, DIFF_INSERT, hasCommonDiff));\n\t\treturn `${expectedLine}\\n${receivedLine}`;\n\t}\n\t// if (isLineDiffable(expected, received)) {\n\tconst clonedExpected = deepClone(expected, { forceWritable: true });\n\tconst clonedReceived = deepClone(received, { forceWritable: true });\n\tconst { replacedExpected, replacedActual } = replaceAsymmetricMatcher(clonedReceived, clonedExpected);\n\tconst difference = diff(replacedExpected, replacedActual, options);\n\treturn difference;\n\t// }\n\t// const printLabel = getLabelPrinter(aAnnotation, bAnnotation)\n\t// const expectedLine = printLabel(aAnnotation) + printExpected(expected)\n\t// const receivedLine\n\t//   = printLabel(bAnnotation)\n\t//   + (stringify(expected) === stringify(received)\n\t//     ? 'serializes to the same string'\n\t//     : printReceived(received))\n\t// return `${expectedLine}\\n${receivedLine}`\n}\nfunction replaceAsymmetricMatcher(actual, expected, actualReplaced = new WeakSet(), expectedReplaced = new WeakSet()) {\n\t// handle asymmetric Error.cause diff\n\tif (actual instanceof Error && expected instanceof Error && typeof actual.cause !== \"undefined\" && typeof expected.cause === \"undefined\") {\n\t\tdelete actual.cause;\n\t\treturn {\n\t\t\treplacedActual: actual,\n\t\t\treplacedExpected: expected\n\t\t};\n\t}\n\tif (!isReplaceable(actual, expected)) {\n\t\treturn {\n\t\t\treplacedActual: actual,\n\t\t\treplacedExpected: expected\n\t\t};\n\t}\n\tif (actualReplaced.has(actual) || expectedReplaced.has(expected)) {\n\t\treturn {\n\t\t\treplacedActual: actual,\n\t\t\treplacedExpected: expected\n\t\t};\n\t}\n\tactualReplaced.add(actual);\n\texpectedReplaced.add(expected);\n\tgetOwnProperties(expected).forEach((key) => {\n\t\tconst expectedValue = expected[key];\n\t\tconst actualValue = actual[key];\n\t\tif (isAsymmetricMatcher(expectedValue)) {\n\t\t\tif (expectedValue.asymmetricMatch(actualValue)) {\n\t\t\t\t// When matcher matches, replace expected with actual value\n\t\t\t\t// so they appear the same in the diff\n\t\t\t\texpected[key] = actualValue;\n\t\t\t} else if (\"sample\" in expectedValue && expectedValue.sample !== undefined && isReplaceable(actualValue, expectedValue.sample)) {\n\t\t\t\t// For container matchers (ArrayContaining, ObjectContaining), unwrap and recursively process\n\t\t\t\t// Matcher doesn't match: unwrap but keep structure to show mismatch\n\t\t\t\tconst replaced = replaceAsymmetricMatcher(actualValue, expectedValue.sample, actualReplaced, expectedReplaced);\n\t\t\t\tactual[key] = replaced.replacedActual;\n\t\t\t\texpected[key] = replaced.replacedExpected;\n\t\t\t}\n\t\t} else if (isAsymmetricMatcher(actualValue)) {\n\t\t\tif (actualValue.asymmetricMatch(expectedValue)) {\n\t\t\t\tactual[key] = expectedValue;\n\t\t\t} else if (\"sample\" in actualValue && actualValue.sample !== undefined && isReplaceable(actualValue.sample, expectedValue)) {\n\t\t\t\tconst replaced = replaceAsymmetricMatcher(actualValue.sample, expectedValue, actualReplaced, expectedReplaced);\n\t\t\t\tactual[key] = replaced.replacedActual;\n\t\t\t\texpected[key] = replaced.replacedExpected;\n\t\t\t}\n\t\t} else if (isReplaceable(actualValue, expectedValue)) {\n\t\t\tconst replaced = replaceAsymmetricMatcher(actualValue, expectedValue, actualReplaced, expectedReplaced);\n\t\t\tactual[key] = replaced.replacedActual;\n\t\t\texpected[key] = replaced.replacedExpected;\n\t\t}\n\t});\n\treturn {\n\t\treplacedActual: actual,\n\t\treplacedExpected: expected\n\t};\n}\nfunction getLabelPrinter(...strings) {\n\tconst maxLength = strings.reduce((max, string) => string.length > max ? string.length : max, 0);\n\treturn (string) => `${string}: ${\" \".repeat(maxLength - string.length)}`;\n}\nconst SPACE_SYMBOL = \"·\";\nfunction replaceTrailingSpaces(text) {\n\treturn text.replace(/\\s+$/gm, (spaces) => SPACE_SYMBOL.repeat(spaces.length));\n}\nfunction printReceived(object) {\n\treturn c.red(replaceTrailingSpaces(stringify(object)));\n}\nfunction printExpected(value) {\n\treturn c.green(replaceTrailingSpaces(stringify(value)));\n}\nfunction getCommonAndChangedSubstrings(diffs, op, hasCommonDiff) {\n\treturn diffs.reduce((reduced, diff) => reduced + (diff[0] === DIFF_EQUAL ? diff[1] : diff[0] === op ? hasCommonDiff ? c.inverse(diff[1]) : diff[1] : \"\"), \"\");\n}\n\nexport { DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff, diff, diffLinesRaw, diffLinesUnified, diffLinesUnified2, diffStringsRaw, diffStringsUnified, getLabelPrinter, printDiffOrStringify, replaceAsymmetricMatcher };\n","const IS_RECORD_SYMBOL = \"@@__IMMUTABLE_RECORD__@@\";\nconst IS_COLLECTION_SYMBOL = \"@@__IMMUTABLE_ITERABLE__@@\";\nfunction isImmutable(v) {\n\treturn v && (v[IS_COLLECTION_SYMBOL] || v[IS_RECORD_SYMBOL]);\n}\nconst OBJECT_PROTO = Object.getPrototypeOf({});\nfunction getUnserializableMessage(err) {\n\tif (err instanceof Error) {\n\t\treturn `<unserializable>: ${err.message}`;\n\t}\n\tif (typeof err === \"string\") {\n\t\treturn `<unserializable>: ${err}`;\n\t}\n\treturn \"<unserializable>\";\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\nfunction serializeValue(val, seen = new WeakMap()) {\n\tif (!val || typeof val === \"string\") {\n\t\treturn val;\n\t}\n\tif (val instanceof Error && \"toJSON\" in val && typeof val.toJSON === \"function\") {\n\t\tconst jsonValue = val.toJSON();\n\t\tif (jsonValue && jsonValue !== val && typeof jsonValue === \"object\") {\n\t\t\tif (typeof val.message === \"string\") {\n\t\t\t\tsafe(() => jsonValue.message ?? (jsonValue.message = normalizeErrorMessage(val.message)));\n\t\t\t}\n\t\t\tif (typeof val.stack === \"string\") {\n\t\t\t\tsafe(() => jsonValue.stack ?? (jsonValue.stack = val.stack));\n\t\t\t}\n\t\t\tif (typeof val.name === \"string\") {\n\t\t\t\tsafe(() => jsonValue.name ?? (jsonValue.name = val.name));\n\t\t\t}\n\t\t\tif (val.cause != null) {\n\t\t\t\tsafe(() => jsonValue.cause ?? (jsonValue.cause = serializeValue(val.cause, seen)));\n\t\t\t}\n\t\t}\n\t\treturn serializeValue(jsonValue, seen);\n\t}\n\tif (typeof val === \"function\") {\n\t\treturn `Function<${val.name || \"anonymous\"}>`;\n\t}\n\tif (typeof val === \"symbol\") {\n\t\treturn val.toString();\n\t}\n\tif (typeof val !== \"object\") {\n\t\treturn val;\n\t}\n\tif (typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n\t\treturn `<Buffer(${val.length}) ...>`;\n\t}\n\tif (typeof Uint8Array !== \"undefined\" && val instanceof Uint8Array) {\n\t\treturn `<Uint8Array(${val.length}) ...>`;\n\t}\n\t// cannot serialize immutables as immutables\n\tif (isImmutable(val)) {\n\t\treturn serializeValue(val.toJSON(), seen);\n\t}\n\tif (val instanceof Promise || val.constructor && val.constructor.prototype === \"AsyncFunction\") {\n\t\treturn \"Promise\";\n\t}\n\tif (typeof Element !== \"undefined\" && val instanceof Element) {\n\t\treturn val.tagName;\n\t}\n\tif (typeof val.toJSON === \"function\") {\n\t\treturn serializeValue(val.toJSON(), seen);\n\t}\n\tif (seen.has(val)) {\n\t\treturn seen.get(val);\n\t}\n\tif (Array.isArray(val)) {\n\t\t// eslint-disable-next-line unicorn/no-new-array -- we need to keep sparse arrays ([1,,3])\n\t\tconst clone = new Array(val.length);\n\t\tseen.set(val, clone);\n\t\tval.forEach((e, i) => {\n\t\t\ttry {\n\t\t\t\tclone[i] = serializeValue(e, seen);\n\t\t\t} catch (err) {\n\t\t\t\tclone[i] = getUnserializableMessage(err);\n\t\t\t}\n\t\t});\n\t\treturn clone;\n\t} else {\n\t\t// Objects with `Error` constructors appear to cause problems during worker communication\n\t\t// using `MessagePort`, so the serialized error object is being recreated as plain object.\n\t\tconst clone = Object.create(null);\n\t\tseen.set(val, clone);\n\t\tlet obj = val;\n\t\twhile (obj && obj !== OBJECT_PROTO) {\n\t\t\tObject.getOwnPropertyNames(obj).forEach((key) => {\n\t\t\t\tif (key in clone) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tclone[key] = serializeValue(val[key], seen);\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// delete in case it has a setter from prototype that might throw\n\t\t\t\t\tdelete clone[key];\n\t\t\t\t\tclone[key] = getUnserializableMessage(err);\n\t\t\t\t}\n\t\t\t});\n\t\t\tobj = Object.getPrototypeOf(obj);\n\t\t}\n\t\tif (val instanceof Error) {\n\t\t\tsafe(() => val.message = normalizeErrorMessage(val.message));\n\t\t}\n\t\treturn clone;\n\t}\n}\nfunction safe(fn) {\n\ttry {\n\t\treturn fn();\n\t} catch {}\n}\nfunction normalizeErrorMessage(message) {\n\treturn message.replace(/__(vite_ssr_import|vi_import)_\\d+__\\./g, \"\");\n}\n\nexport { serializeValue };\n","import { printDiffOrStringify } from './diff.js';\nimport { stringify } from './display.js';\nimport { serializeValue } from './serialize.js';\nimport '@vitest/pretty-format';\nimport 'tinyrainbow';\nimport './helpers.js';\nimport './constants.js';\nimport './chunk-_commonjsHelpers.js';\n\nfunction processError(_err, diffOptions, seen = new WeakSet()) {\n\tif (!_err || typeof _err !== \"object\") {\n\t\treturn { message: String(_err) };\n\t}\n\tconst err = _err;\n\tif (err.showDiff || err.showDiff === undefined && err.expected !== undefined && err.actual !== undefined) {\n\t\terr.diff = printDiffOrStringify(err.actual, err.expected, {\n\t\t\t...diffOptions,\n\t\t\t...err.diffOptions\n\t\t});\n\t}\n\tif (\"expected\" in err && typeof err.expected !== \"string\") {\n\t\terr.expected = stringify(err.expected, 10);\n\t}\n\tif (\"actual\" in err && typeof err.actual !== \"string\") {\n\t\terr.actual = stringify(err.actual, 10);\n\t}\n\t// some Error implementations may not allow rewriting cause\n\t// in most cases, the assignment will lead to \"err.cause = err.cause\"\n\ttry {\n\t\tif (!seen.has(err) && typeof err.cause === \"object\") {\n\t\t\tseen.add(err);\n\t\t\terr.cause = processError(err.cause, diffOptions, seen);\n\t\t}\n\t} catch {}\n\ttry {\n\t\treturn serializeValue(err);\n\t} catch (e) {\n\t\treturn serializeValue(new Error(`Failed to fully serialize error: ${e === null || e === void 0 ? void 0 : e.message}\\nInner error message: ${err === null || err === void 0 ? void 0 : err.message}`));\n\t}\n}\n\nexport { processError, serializeValue as serializeError };\n","const SAFE_TIMERS_SYMBOL = Symbol(\"vitest:SAFE_TIMERS\");\nfunction getSafeTimers() {\n\tconst { setTimeout: safeSetTimeout, setInterval: safeSetInterval, clearInterval: safeClearInterval, clearTimeout: safeClearTimeout, setImmediate: safeSetImmediate, clearImmediate: safeClearImmediate, queueMicrotask: safeQueueMicrotask } = globalThis[SAFE_TIMERS_SYMBOL] || globalThis;\n\tconst { nextTick: safeNextTick } = globalThis[SAFE_TIMERS_SYMBOL] || globalThis.process || {};\n\treturn {\n\t\tnextTick: safeNextTick,\n\t\tsetTimeout: safeSetTimeout,\n\t\tsetInterval: safeSetInterval,\n\t\tclearInterval: safeClearInterval,\n\t\tclearTimeout: safeClearTimeout,\n\t\tsetImmediate: safeSetImmediate,\n\t\tclearImmediate: safeClearImmediate,\n\t\tqueueMicrotask: safeQueueMicrotask\n\t};\n}\nfunction setSafeTimers() {\n\tconst { setTimeout: safeSetTimeout, setInterval: safeSetInterval, clearInterval: safeClearInterval, clearTimeout: safeClearTimeout, setImmediate: safeSetImmediate, clearImmediate: safeClearImmediate, queueMicrotask: safeQueueMicrotask } = globalThis;\n\tconst { nextTick: safeNextTick } = globalThis.process || {};\n\tconst timers = {\n\t\tnextTick: safeNextTick,\n\t\tsetTimeout: safeSetTimeout,\n\t\tsetInterval: safeSetInterval,\n\t\tclearInterval: safeClearInterval,\n\t\tclearTimeout: safeClearTimeout,\n\t\tsetImmediate: safeSetImmediate,\n\t\tclearImmediate: safeClearImmediate,\n\t\tqueueMicrotask: safeQueueMicrotask\n\t};\n\tglobalThis[SAFE_TIMERS_SYMBOL] = timers;\n}\n/**\n* Returns a promise that resolves after the specified duration.\n*\n* @param timeout - Delay in milliseconds\n* @param scheduler - Timer function to use, defaults to `setTimeout`. Useful for mocked timers.\n*\n* @example\n* await delay(100)\n*\n* @example\n* // With mocked timers\n* const { setTimeout } = getSafeTimers()\n* await delay(100, setTimeout)\n*/\nfunction delay(timeout, scheduler = setTimeout) {\n\treturn new Promise((resolve) => scheduler(resolve, timeout));\n}\n\nexport { delay, getSafeTimers, setSafeTimers };\n","const _DRIVE_LETTER_START_RE = /^[A-Za-z]:\\//;\nfunction normalizeWindowsPath(input = \"\") {\n  if (!input) {\n    return input;\n  }\n  return input.replace(/\\\\/g, \"/\").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());\n}\n\nconst _UNC_REGEX = /^[/\\\\]{2}/;\nconst _IS_ABSOLUTE_RE = /^[/\\\\](?![/\\\\])|^[/\\\\]{2}(?!\\.)|^[A-Za-z]:[/\\\\]/;\nconst _DRIVE_LETTER_RE = /^[A-Za-z]:$/;\nconst normalize = function(path) {\n  if (path.length === 0) {\n    return \".\";\n  }\n  path = normalizeWindowsPath(path);\n  const isUNCPath = path.match(_UNC_REGEX);\n  const isPathAbsolute = isAbsolute(path);\n  const trailingSeparator = path[path.length - 1] === \"/\";\n  path = normalizeString(path, !isPathAbsolute);\n  if (path.length === 0) {\n    if (isPathAbsolute) {\n      return \"/\";\n    }\n    return trailingSeparator ? \"./\" : \".\";\n  }\n  if (trailingSeparator) {\n    path += \"/\";\n  }\n  if (_DRIVE_LETTER_RE.test(path)) {\n    path += \"/\";\n  }\n  if (isUNCPath) {\n    if (!isPathAbsolute) {\n      return `//./${path}`;\n    }\n    return `//${path}`;\n  }\n  return isPathAbsolute && !isAbsolute(path) ? `/${path}` : path;\n};\nconst join = function(...segments) {\n  let path = \"\";\n  for (const seg of segments) {\n    if (!seg) {\n      continue;\n    }\n    if (path.length > 0) {\n      const pathTrailing = path[path.length - 1] === \"/\";\n      const segLeading = seg[0] === \"/\";\n      const both = pathTrailing && segLeading;\n      if (both) {\n        path += seg.slice(1);\n      } else {\n        path += pathTrailing || segLeading ? seg : `/${seg}`;\n      }\n    } else {\n      path += seg;\n    }\n  }\n  return normalize(path);\n};\nfunction cwd() {\n  if (typeof process !== \"undefined\" && typeof process.cwd === \"function\") {\n    return process.cwd().replace(/\\\\/g, \"/\");\n  }\n  return \"/\";\n}\nconst resolve = function(...arguments_) {\n  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));\n  let resolvedPath = \"\";\n  let resolvedAbsolute = false;\n  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {\n    const path = index >= 0 ? arguments_[index] : cwd();\n    if (!path || path.length === 0) {\n      continue;\n    }\n    resolvedPath = `${path}/${resolvedPath}`;\n    resolvedAbsolute = isAbsolute(path);\n  }\n  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);\n  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {\n    return `/${resolvedPath}`;\n  }\n  return resolvedPath.length > 0 ? resolvedPath : \".\";\n};\nfunction normalizeString(path, allowAboveRoot) {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let char = null;\n  for (let index = 0; index <= path.length; ++index) {\n    if (index < path.length) {\n      char = path[index];\n    } else if (char === \"/\") {\n      break;\n    } else {\n      char = \"/\";\n    }\n    if (char === \"/\") {\n      if (lastSlash === index - 1 || dots === 1) ; else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== \".\" || res[res.length - 2] !== \".\") {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(\"/\");\n            if (lastSlashIndex === -1) {\n              res = \"\";\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n            }\n            lastSlash = index;\n            dots = 0;\n            continue;\n          } else if (res.length > 0) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = index;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? \"/..\" : \"..\";\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path.slice(lastSlash + 1, index)}`;\n        } else {\n          res = path.slice(lastSlash + 1, index);\n        }\n        lastSegmentLength = index - lastSlash - 1;\n      }\n      lastSlash = index;\n      dots = 0;\n    } else if (char === \".\" && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst isAbsolute = function(p) {\n  return _IS_ABSOLUTE_RE.test(p);\n};\nconst dirname = function(p) {\n  const segments = normalizeWindowsPath(p).replace(/\\/$/, \"\").split(\"/\").slice(0, -1);\n  if (segments.length === 1 && _DRIVE_LETTER_RE.test(segments[0])) {\n    segments[0] += \"/\";\n  }\n  return segments.join(\"/\") || (isAbsolute(p) ? \"/\" : \".\");\n};\n\nexport { dirname as d, join as j, resolve as r };\n","import { isPrimitive, notNullish } from './helpers.js';\nimport { r as resolve } from './chunk-pathe.M-eThtNZ.js';\nimport './constants.js';\n\n// src/vlq.ts\nvar comma = \",\".charCodeAt(0);\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar intToChar = new Uint8Array(64);\nvar charToInt = new Uint8Array(128);\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\nfunction decodeInteger(reader, relative) {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n  const shouldNegate = value & 1;\n  value >>>= 1;\n  if (shouldNegate) {\n    value = -2147483648 | -value;\n  }\n  return relative + value;\n}\nfunction hasMoreVlq(reader, max) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}\nvar StringReader = class {\n  constructor(buffer) {\n    this.pos = 0;\n    this.buffer = buffer;\n  }\n  next() {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n  peek() {\n    return this.buffer.charCodeAt(this.pos);\n  }\n  indexOf(char) {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n};\n\n// src/sourcemap-codec.ts\nfunction decode(mappings) {\n  const { length } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  do {\n    const semi = reader.indexOf(\";\");\n    const line = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n    while (reader.pos < semi) {\n      let seg;\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n      line.push(seg);\n      reader.pos++;\n    }\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n  return decoded;\n}\nfunction sort(line) {\n  line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[0] - b[0];\n}\n\n// src/trace-mapping.ts\n\n// src/sourcemap-segment.ts\nvar COLUMN = 0;\nvar SOURCES_INDEX = 1;\nvar SOURCE_LINE = 2;\nvar SOURCE_COLUMN = 3;\nvar NAMES_INDEX = 4;\n\n// src/binary-search.ts\nvar found = false;\nfunction binarySearch(haystack, needle, low, high) {\n  while (low <= high) {\n    const mid = low + (high - low >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  found = false;\n  return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction lowerBound(haystack, needle, index) {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n  const { lastKey, lastNeedle, lastIndex } = state;\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n    if (needle >= lastNeedle) {\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n  return state.lastIndex = binarySearch(haystack, needle, low, high);\n}\n\n// src/trace-mapping.ts\nvar LINE_GTR_ZERO = \"`line` must be greater than 0 (lines start at line 1)\";\nvar COL_GTR_EQ_ZERO = \"`column` must be greater than or equal to 0 (columns start at column 0)\";\nvar LEAST_UPPER_BOUND = -1;\nvar GREATEST_LOWER_BOUND = 1;\nfunction cast(map) {\n  return map;\n}\nfunction decodedMappings(map) {\n  var _a;\n  return (_a = cast(map))._decoded || (_a._decoded = decode(cast(map)._encoded));\n}\nfunction originalPositionFor(map, needle) {\n  let { line, column, bias } = needle;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n  const decoded = decodedMappings(map);\n  if (line >= decoded.length) return OMapping(null, null, null, null);\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    bias || GREATEST_LOWER_BOUND\n  );\n  if (index === -1) return OMapping(null, null, null, null);\n  const segment = segments[index];\n  if (segment.length === 1) return OMapping(null, null, null, null);\n  const { names, resolvedSources } = map;\n  return OMapping(\n    resolvedSources[segment[SOURCES_INDEX]],\n    segment[SOURCE_LINE] + 1,\n    segment[SOURCE_COLUMN],\n    segment.length === 5 ? names[segment[NAMES_INDEX]] : null\n  );\n}\nfunction OMapping(source, line, column, name) {\n  return { source, line, column, name };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (found) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\n\nconst CHROME_IE_STACK_REGEXP = /^\\s*at .*(?:\\S:\\d+|\\(native\\))/m;\nconst SAFARI_NATIVE_CODE_REGEXP = /^(?:eval@)?(?:\\[native code\\])?$/;\nconst stackIgnorePatterns = [\n\t\"node:internal\",\n\t/\\/packages\\/\\w+\\/dist\\//,\n\t/\\/@vitest\\/\\w+\\/dist\\//,\n\t\"/vitest/dist/\",\n\t\"/vitest/src/\",\n\t\"/node_modules/chai/\",\n\t\"/node_modules/tinyspy/\",\n\t\"/vite/dist/node/module-runner\",\n\t\"/rolldown-vite/dist/node/module-runner\",\n\t\"/deps/chunk-\",\n\t\"/deps/@vitest\",\n\t\"/deps/loupe\",\n\t\"/deps/chai\",\n\t\"/browser-playwright/dist/locators.js\",\n\t\"/browser-webdriverio/dist/locators.js\",\n\t\"/browser-preview/dist/locators.js\",\n\t/node:\\w+/,\n\t/__vitest_test__/,\n\t/__vitest_browser__/,\n\t/\\/deps\\/vitest_/\n];\nfunction extractLocation(urlLike) {\n\t// Fail-fast but return locations like \"(native)\"\n\tif (!urlLike.includes(\":\")) {\n\t\treturn [urlLike];\n\t}\n\tconst regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n\tconst parts = regExp.exec(urlLike.replace(/^\\(|\\)$/g, \"\"));\n\tif (!parts) {\n\t\treturn [urlLike];\n\t}\n\tlet url = parts[1];\n\tif (url.startsWith(\"async \")) {\n\t\turl = url.slice(6);\n\t}\n\tif (url.startsWith(\"http:\") || url.startsWith(\"https:\")) {\n\t\tconst urlObj = new URL(url);\n\t\turlObj.searchParams.delete(\"import\");\n\t\turlObj.searchParams.delete(\"browserv\");\n\t\turl = urlObj.pathname + urlObj.hash + urlObj.search;\n\t}\n\tif (url.startsWith(\"/@fs/\")) {\n\t\tconst isWindows = /^\\/@fs\\/[a-zA-Z]:\\//.test(url);\n\t\turl = url.slice(isWindows ? 5 : 4);\n\t}\n\treturn [\n\t\turl,\n\t\tparts[2] || undefined,\n\t\tparts[3] || undefined\n\t];\n}\nfunction parseSingleFFOrSafariStack(raw) {\n\tlet line = raw.trim();\n\tif (SAFARI_NATIVE_CODE_REGEXP.test(line)) {\n\t\treturn null;\n\t}\n\tif (line.includes(\" > eval\")) {\n\t\tline = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, \":$1\");\n\t}\n\t// Early return for lines that don't look like Firefox/Safari stack traces\n\t// Firefox/Safari stack traces must contain '@' and should have location info after it\n\tif (!line.includes(\"@\")) {\n\t\treturn null;\n\t}\n\t// Find the correct @ that separates function name from location\n\t// For cases like '@https://@fs/path' or 'functionName@https://@fs/path'\n\t// we need to find the first @ that precedes a valid location (containing :)\n\tlet atIndex = -1;\n\tlet locationPart = \"\";\n\tlet functionName;\n\t// Try each @ from left to right to find the one that gives us a valid location\n\tfor (let i = 0; i < line.length; i++) {\n\t\tif (line[i] === \"@\") {\n\t\t\tconst candidateLocation = line.slice(i + 1);\n\t\t\t// Minimum length 3 for valid location: 1 for filename + 1 for colon + 1 for line number (e.g., \"a:1\")\n\t\t\tif (candidateLocation.includes(\":\") && candidateLocation.length >= 3) {\n\t\t\t\tatIndex = i;\n\t\t\t\tlocationPart = candidateLocation;\n\t\t\t\tfunctionName = i > 0 ? line.slice(0, i) : undefined;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t// Validate we found a valid location with minimum length (filename:line format)\n\tif (atIndex === -1 || !locationPart.includes(\":\") || locationPart.length < 3) {\n\t\treturn null;\n\t}\n\tconst [url, lineNumber, columnNumber] = extractLocation(locationPart);\n\tif (!url || !lineNumber || !columnNumber) {\n\t\treturn null;\n\t}\n\treturn {\n\t\tfile: url,\n\t\tmethod: functionName || \"\",\n\t\tline: Number.parseInt(lineNumber),\n\t\tcolumn: Number.parseInt(columnNumber)\n\t};\n}\nfunction parseSingleStack(raw) {\n\tconst line = raw.trim();\n\tif (!CHROME_IE_STACK_REGEXP.test(line)) {\n\t\treturn parseSingleFFOrSafariStack(line);\n\t}\n\treturn parseSingleV8Stack(line);\n}\n// Based on https://github.com/stacktracejs/error-stack-parser\n// Credit to stacktracejs\nfunction parseSingleV8Stack(raw) {\n\tlet line = raw.trim();\n\tif (!CHROME_IE_STACK_REGEXP.test(line)) {\n\t\treturn null;\n\t}\n\tif (line.includes(\"(eval \")) {\n\t\tline = line.replace(/eval code/g, \"eval\").replace(/(\\(eval at [^()]*)|(,.*$)/g, \"\");\n\t}\n\tlet sanitizedLine = line.replace(/^\\s+/, \"\").replace(/\\(eval code/g, \"(\").replace(/^.*?\\s+/, \"\");\n\t// capture and preserve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n\t// case it has spaces in it, as the string is split on \\s+ later on\n\tconst location = sanitizedLine.match(/ (\\(.+\\)$)/);\n\t// remove the parenthesized location from the line, if it was matched\n\tsanitizedLine = location ? sanitizedLine.replace(location[0], \"\") : sanitizedLine;\n\t// if a location was matched, pass it to extractLocation() otherwise pass all sanitizedLine\n\t// because this line doesn't have function name\n\tconst [url, lineNumber, columnNumber] = extractLocation(location ? location[1] : sanitizedLine);\n\tlet method = location && sanitizedLine || \"\";\n\tlet file = url && [\"eval\", \"<anonymous>\"].includes(url) ? undefined : url;\n\tif (!file || !lineNumber || !columnNumber) {\n\t\treturn null;\n\t}\n\tif (method.startsWith(\"async \")) {\n\t\tmethod = method.slice(6);\n\t}\n\tif (file.startsWith(\"file://\")) {\n\t\tfile = file.slice(7);\n\t}\n\t// normalize Windows path (\\ -> /)\n\tfile = file.startsWith(\"node:\") || file.startsWith(\"internal:\") ? file : resolve(file);\n\tif (method) {\n\t\tmethod = method.replace(/__vite_ssr_import_\\d+__\\./g, \"\").replace(/(Object\\.)?__vite_ssr_export_default__\\s?/g, \"\");\n\t}\n\treturn {\n\t\tmethod,\n\t\tfile,\n\t\tline: Number.parseInt(lineNumber),\n\t\tcolumn: Number.parseInt(columnNumber)\n\t};\n}\nfunction createStackString(stacks) {\n\treturn stacks.map((stack) => {\n\t\tconst line = `${stack.file}:${stack.line}:${stack.column}`;\n\t\tif (stack.method) {\n\t\t\treturn `    at ${stack.method}(${line})`;\n\t\t}\n\t\treturn `    at ${line}`;\n\t}).join(\"\\n\");\n}\nfunction parseStacktrace(stack, options = {}) {\n\tconst { ignoreStackEntries = stackIgnorePatterns } = options;\n\tconst stacks = !CHROME_IE_STACK_REGEXP.test(stack) ? parseFFOrSafariStackTrace(stack) : parseV8Stacktrace(stack);\n\treturn stacks.map((stack) => {\n\t\tvar _options$getSourceMap;\n\t\tif (options.getUrlId) {\n\t\t\tstack.file = options.getUrlId(stack.file);\n\t\t}\n\t\tconst map = (_options$getSourceMap = options.getSourceMap) === null || _options$getSourceMap === void 0 ? void 0 : _options$getSourceMap.call(options, stack.file);\n\t\tif (!map || typeof map !== \"object\" || !map.version) {\n\t\t\treturn shouldFilter(ignoreStackEntries, stack.file) ? null : stack;\n\t\t}\n\t\tconst traceMap = new DecodedMap(map, stack.file);\n\t\tconst position = getOriginalPosition(traceMap, stack);\n\t\tif (!position) {\n\t\t\treturn stack;\n\t\t}\n\t\tconst { line, column, source, name } = position;\n\t\tlet file = source || stack.file;\n\t\tif (file.match(/\\/\\w:\\//)) {\n\t\t\tfile = file.slice(1);\n\t\t}\n\t\tif (shouldFilter(ignoreStackEntries, file)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (line != null && column != null) {\n\t\t\treturn {\n\t\t\t\tline,\n\t\t\t\tcolumn,\n\t\t\t\tfile,\n\t\t\t\tmethod: name || stack.method\n\t\t\t};\n\t\t}\n\t\treturn stack;\n\t}).filter((s) => s != null);\n}\nfunction shouldFilter(ignoreStackEntries, file) {\n\treturn ignoreStackEntries.some((p) => file.match(p));\n}\nfunction parseFFOrSafariStackTrace(stack) {\n\treturn stack.split(\"\\n\").map((line) => parseSingleFFOrSafariStack(line)).filter(notNullish);\n}\nfunction parseV8Stacktrace(stack) {\n\treturn stack.split(\"\\n\").map((line) => parseSingleV8Stack(line)).filter(notNullish);\n}\nfunction parseErrorStacktrace(e, options = {}) {\n\tif (!e || isPrimitive(e)) {\n\t\treturn [];\n\t}\n\tif (\"stacks\" in e && e.stacks) {\n\t\treturn e.stacks;\n\t}\n\tconst stackStr = e.stack || \"\";\n\t// if \"stack\" property was overwritten at runtime to be something else,\n\t// ignore the value because we don't know how to process it\n\tlet stackFrames = typeof stackStr === \"string\" ? parseStacktrace(stackStr, options) : [];\n\tif (!stackFrames.length) {\n\t\tconst e_ = e;\n\t\tif (e_.fileName != null && e_.lineNumber != null && e_.columnNumber != null) {\n\t\t\tstackFrames = parseStacktrace(`${e_.fileName}:${e_.lineNumber}:${e_.columnNumber}`, options);\n\t\t}\n\t\tif (e_.sourceURL != null && e_.line != null && e_._column != null) {\n\t\t\tstackFrames = parseStacktrace(`${e_.sourceURL}:${e_.line}:${e_.column}`, options);\n\t\t}\n\t}\n\tif (options.frameFilter) {\n\t\tstackFrames = stackFrames.filter((f) => options.frameFilter(e, f) !== false);\n\t}\n\te.stacks = stackFrames;\n\treturn stackFrames;\n}\nclass DecodedMap {\n\t_encoded;\n\t_decoded;\n\t_decodedMemo;\n\turl;\n\tversion;\n\tnames = [];\n\tresolvedSources;\n\tconstructor(map, from) {\n\t\tthis.map = map;\n\t\tconst { mappings, names, sources } = map;\n\t\tthis.version = map.version;\n\t\tthis.names = names || [];\n\t\tthis._encoded = mappings || \"\";\n\t\tthis._decodedMemo = memoizedState();\n\t\tthis.url = from;\n\t\tthis.resolvedSources = (sources || []).map((s) => resolve(s || \"\", from));\n\t}\n}\nfunction memoizedState() {\n\treturn {\n\t\tlastKey: -1,\n\t\tlastNeedle: -1,\n\t\tlastIndex: -1\n\t};\n}\nfunction getOriginalPosition(map, needle) {\n\tconst result = originalPositionFor(map, needle);\n\tif (result.column == null) {\n\t\treturn null;\n\t}\n\treturn result;\n}\n\nexport { DecodedMap, createStackString, stackIgnorePatterns as defaultStackIgnorePatterns, getOriginalPosition, parseErrorStacktrace, parseSingleFFOrSafariStack, parseSingleStack, parseSingleV8Stack, parseStacktrace };\n"],"names":["ansiColors","styles","truncator","colorise","value","styleType","color","normaliseOptions","showHidden","depth","colors","customInspect","showProxy","maxArrayLength","breakLength","seen","truncate","stylize","inspect","options","isHighSurrogate","char","string","length","tail","tailLength","stringLength","end","inspectList","list","inspectItem","separator","size","originalLength","output","peek","truncated","i","last","secondToLast","nextLength","truncatedLength","quoteComplexKey","key","inspectProperty","inspectArray","array","nonIndexProperties","listContents","propertyContents","getArrayName","inspectTypedArray","name","inspectDate","dateObject","stringRepresentation","split","date","inspectFunction","func","functionType","inspectMapEntry","mapToEntries","map","entries","inspectMap","isNaN","inspectNumber","number","inspectBigInt","nums","inspectRegExp","flags","sourceLength","source","arrayFromSet","set","values","inspectSet","stringEscapeChars","escapeCharacters","hex","escape","inspectString","inspectSymbol","getPromiseValue","inspectObject$1","object","properties","symbols","symbolContents","sep","toStringTag","inspectClass","inspectArguments","args","errorKeys","inspectObject","error","message","inspectAttribute","inspectNodeCollection","collection","inspectNode","node","inspectHTML","element","head","headClose","children","symbolsSupported","chaiInspect","nodeInspect","constructorMap","stringTagMap","baseTypesMap","inspectCustom","type","inspectFn","toString","inspect$1","opts","proto","AsymmetricMatcher","DOMCollection","DOMElement","Immutable","ReactElement","ReactTestComponent","plugins","PLUGINS","stringify","maxDepth","maxLength","MAX_LENGTH","result","format$1","formatRegExp","baseFormat","formatArg","item","inspecOptions","objects","len","template","str","x","err","m","format","obj","objDisplay","fn","keys","assertTypes","types","receivedType","toArray","isObject","isFinalObj","getType","collectOwnProperties","collector","collect","getOwnProperties","ownProps","defaultCloneOptions","deepClone","val","clone","k","out","props","descriptor","cloned","noop","objectAttr","path","defaultValue","paths","p","createDefer","resolve","reject","_resolve","_reject","isNegativeNaN","f64","getDefaultExportFromCjs","DIFF_DELETE","DIFF_INSERT","DIFF_EQUAL","Diff","op","text","__publicField","diff_commonPrefix","text1","text2","pointermin","pointermax","pointermid","pointerstart","diff_commonSuffix","pointerend","diff_commonOverlap_","text1_length","text2_length","text_length","best","pattern","found","diff_cleanupSemantic","diffs","changes","equalities","equalitiesLength","lastEquality","pointer","length_insertions1","length_deletions1","length_insertions2","length_deletions2","diff_cleanupMerge","diff_cleanupSemanticLossless","deletion","insertion","overlap_length1","overlap_length2","nonAlphaNumericRegex_","whitespaceRegex_","linebreakRegex_","blanklineEndRegex_","blanklineStartRegex_","equality1","edit","equality2","commonOffset","commonString","bestEquality1","bestEdit","bestEquality2","bestScore","diff_cleanupSemanticScore_","score","_diffs$at","count_delete","count_insert","text_delete","text_insert","commonlength","one","two","char1","char2","nonAlphaNumeric1","nonAlphaNumeric2","whitespace1","whitespace2","lineBreak1","lineBreak2","blankLine1","blankLine2","NO_DIFF_MESSAGE","SIMILAR_MESSAGE","build","hasRequiredBuild","requireBuild","diffSequence","pkg","NOT_YET_SET","countCommonItemsF","aIndex","aEnd","bIndex","bEnd","isCommon","nCommon","countCommonItemsR","aStart","bStart","extendPathsF","d","bF","aIndexesF","iMaxF","iF","kF","aFirst","aIndexPrev1","nF","extendPathsR","bR","aIndexesR","iMaxR","iR","kR","nR","extendOverlappablePathsF","division","aLength","baDeltaLength","kMinOverlapF","kMaxOverlapF","insert","aLastPrev","bFirst","nCommonF","aLast","bLastPrev","nCommonR","aIndexPrevFirst","bIndexPrevFirst","aEndPreceding","bEndPreceding","aStartFollowing","bStartFollowing","extendOverlappablePathsR","kMinOverlapR","kMaxOverlapR","bLast","divide","nChange","bLength","dMin","dMax","findSubsequences","transposed","callbacks","foundSubsequence","bCommon","aCommon","tStart","tEnd","nChangePreceding","nCommonPreceding","aCommonPreceding","bCommonPreceding","nCommonFollowing","aCommonFollowing","bCommonFollowing","nChangeFollowing","validateLength","arg","validateCallback","nCommonFR","buildExports","diffSequences","formatTrailingSpaces","line","trailingSpaceFormatter","match","printDiffLine","isFirstOrLast","indicator","emptyFirstOrLastLinePlaceholder","printDeleteLine","aColor","aIndicator","changeLineTrailingSpaceColor","printInsertLine","bColor","bIndicator","printCommonLine","commonColor","commonIndicator","commonLineTrailingSpaceColor","createPatchMark","patchColor","joinAlignedDiffsNoExpand","iLength","nContextLines","nContextLines2","jLength","hasExcessAtStartOrEnd","nExcessesBetweenChanges","iStart","n","hasPatch","jLast","lines","jPatchMark","pushCommonLine","j","pushDeleteLine","pushInsertLine","iCommon","iEnd","nOmit","joinAlignedDiffsExpand","diff","noColor","DIFF_CONTEXT_DEFAULT","DIFF_TRUNCATE_THRESHOLD_DEFAULT","getDefaultOptions","c","getCompareKeys","compareKeys","getContextLines","contextLines","normalizeDiffOptions","isEmptyString","countChanges","a","b","printAnnotation","aAnnotation","bAnnotation","includeChangeCounts","omitAnnotationLines","changeCounts","aRest","bRest","aCount","bCount","baAnnotationLengthDiff","aAnnotationPadding","bAnnotationPadding","baCountLengthDiff","aCountPadding","bCountPadding","printDiffLines","diffLinesUnified","aLines","bLines","normalizedOptions","diffLinesRaw","diffLinesUnified2","aLinesDisplay","bLinesDisplay","aLinesCompare","bLinesCompare","truncateThreshold","getNewLineSymbol","diffStrings","aMultipleLines","bMultipleLines","aNewLineSymbol","bNewLineSymbol","_a","_b","concatenateRelevantDiffs","changeColor","reduced","ChangeBuffer","substring","substrings","iLast","CommonBuffer","deleteBuffer","insertBuffer","isDiffEmpty","subdiff","getAlignedDiffs","commonBuffer","hasCommonDiff","isMultiline","diffStringsUnified","diffStringsRaw","optionsNormalized","cleanup","getCommonMessage","FORMAT_OPTIONS","FALLBACK_FORMAT_OPTIONS","aType","expectedType","omitDifference","s","formatOptions","getFormatOptions","aDisplay","bDisplay","aDiff","bDiff","comparePrimitive","compareObjects","sortMap","sortSet","aFormat","bFormat","difference","hasThrown","getObjectsDifference","noDiffMessage","printBasicPrototype","formatOptionsZeroIndent","aCompare","bCompare","MAX_DIFF_STRING_LENGTH","isAsymmetricMatcher","data","getType$1","isReplaceable","obj1","obj2","obj1Type","obj2Type","printDiffOrStringify","received","expected","printLabel","getLabelPrinter","expectedLine","printExpected","getCommonAndChangedSubstrings","receivedLine","printReceived","clonedExpected","clonedReceived","replacedExpected","replacedActual","replaceAsymmetricMatcher","actual","actualReplaced","expectedReplaced","expectedValue","actualValue","replaced","strings","max","SPACE_SYMBOL","replaceTrailingSpaces","spaces","IS_RECORD_SYMBOL","IS_COLLECTION_SYMBOL","isImmutable","v","OBJECT_PROTO","getUnserializableMessage","serializeValue","jsonValue","safe","normalizeErrorMessage","e","processError","_err","diffOptions","SAFE_TIMERS_SYMBOL","getSafeTimers","safeSetTimeout","safeSetInterval","safeClearInterval","safeClearTimeout","safeSetImmediate","safeClearImmediate","safeQueueMicrotask","safeNextTick","delay","timeout","scheduler","_DRIVE_LETTER_START_RE","normalizeWindowsPath","input","r","_IS_ABSOLUTE_RE","cwd","arguments_","argument","resolvedPath","resolvedAbsolute","index","isAbsolute","normalizeString","allowAboveRoot","res","lastSegmentLength","lastSlash","dots","lastSlashIndex","chars","intToChar","charToInt","CHROME_IE_STACK_REGEXP","SAFARI_NATIVE_CODE_REGEXP","extractLocation","urlLike","parts","url","urlObj","isWindows","parseSingleFFOrSafariStack","raw","atIndex","locationPart","functionName","candidateLocation","lineNumber","columnNumber","parseSingleStack","parseSingleV8Stack","sanitizedLine","location","method","file"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8]}