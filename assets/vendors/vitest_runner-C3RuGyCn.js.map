{"version":3,"file":"vitest_runner-C3RuGyCn.js","sources":["../../../node_modules/.pnpm/@vitest+runner@4.0.18/node_modules/@vitest/runner/dist/chunk-tasks.js","../../../node_modules/.pnpm/@vitest+runner@4.0.18/node_modules/@vitest/runner/dist/index.js"],"sourcesContent":["import { processError } from '@vitest/utils/error';\nimport { parseSingleStack } from '@vitest/utils/source-map';\nimport { relative } from 'pathe';\nimport { toArray } from '@vitest/utils/helpers';\n\nfunction createChainable(keys, fn) {\n\tfunction create(context) {\n\t\tconst chain = function(...args) {\n\t\t\treturn fn.apply(context, args);\n\t\t};\n\t\tObject.assign(chain, fn);\n\t\tchain.withContext = () => chain.bind(context);\n\t\tchain.setContext = (key, value) => {\n\t\t\tcontext[key] = value;\n\t\t};\n\t\tchain.mergeContext = (ctx) => {\n\t\t\tObject.assign(context, ctx);\n\t\t};\n\t\tfor (const key of keys) {\n\t\t\tObject.defineProperty(chain, key, { get() {\n\t\t\t\treturn create({\n\t\t\t\t\t...context,\n\t\t\t\t\t[key]: true\n\t\t\t\t});\n\t\t\t} });\n\t\t}\n\t\treturn chain;\n\t}\n\tconst chain = create({});\n\tchain.fn = fn;\n\treturn chain;\n}\n\n/**\n* If any tasks been marked as `only`, mark all other tasks as `skip`.\n*/\nfunction interpretTaskModes(file, namePattern, testLocations, onlyMode, parentIsOnly, allowOnly) {\n\tconst matchedLocations = [];\n\tconst traverseSuite = (suite, parentIsOnly, parentMatchedWithLocation) => {\n\t\tconst suiteIsOnly = parentIsOnly || suite.mode === \"only\";\n\t\t// Check if any tasks in this suite have `.only` - if so, only those should run\n\t\tconst hasSomeTasksOnly = onlyMode && suite.tasks.some((t) => t.mode === \"only\" || t.type === \"suite\" && someTasksAreOnly(t));\n\t\tsuite.tasks.forEach((t) => {\n\t\t\t// Check if either the parent suite or the task itself are marked as included\n\t\t\t// If there are tasks with `.only` in this suite, only include those (not all tasks from describe.only)\n\t\t\tconst includeTask = hasSomeTasksOnly ? t.mode === \"only\" || t.type === \"suite\" && someTasksAreOnly(t) : suiteIsOnly || t.mode === \"only\";\n\t\t\tif (onlyMode) {\n\t\t\t\tif (t.type === \"suite\" && (includeTask || someTasksAreOnly(t))) {\n\t\t\t\t\t// Don't skip this suite\n\t\t\t\t\tif (t.mode === \"only\") {\n\t\t\t\t\t\tcheckAllowOnly(t, allowOnly);\n\t\t\t\t\t\tt.mode = \"run\";\n\t\t\t\t\t}\n\t\t\t\t} else if (t.mode === \"run\" && !includeTask) {\n\t\t\t\t\tt.mode = \"skip\";\n\t\t\t\t} else if (t.mode === \"only\") {\n\t\t\t\t\tcheckAllowOnly(t, allowOnly);\n\t\t\t\t\tt.mode = \"run\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet hasLocationMatch = parentMatchedWithLocation;\n\t\t\t// Match test location against provided locations, only run if present\n\t\t\t// in `testLocations`. Note: if `includeTaskLocations` is not enabled,\n\t\t\t// all test will be skipped.\n\t\t\tif (testLocations !== undefined && testLocations.length !== 0) {\n\t\t\t\tif (t.location && (testLocations === null || testLocations === void 0 ? void 0 : testLocations.includes(t.location.line))) {\n\t\t\t\t\tt.mode = \"run\";\n\t\t\t\t\tmatchedLocations.push(t.location.line);\n\t\t\t\t\thasLocationMatch = true;\n\t\t\t\t} else if (parentMatchedWithLocation) {\n\t\t\t\t\tt.mode = \"run\";\n\t\t\t\t} else if (t.type === \"test\") {\n\t\t\t\t\tt.mode = \"skip\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t.type === \"test\") {\n\t\t\t\tif (namePattern && !getTaskFullName(t).match(namePattern)) {\n\t\t\t\t\tt.mode = \"skip\";\n\t\t\t\t}\n\t\t\t} else if (t.type === \"suite\") {\n\t\t\t\tif (t.mode === \"skip\") {\n\t\t\t\t\tskipAllTasks(t);\n\t\t\t\t} else if (t.mode === \"todo\") {\n\t\t\t\t\ttodoAllTasks(t);\n\t\t\t\t} else {\n\t\t\t\t\ttraverseSuite(t, includeTask, hasLocationMatch);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t// if all subtasks are skipped, mark as skip\n\t\tif (suite.mode === \"run\" || suite.mode === \"queued\") {\n\t\t\tif (suite.tasks.length && suite.tasks.every((i) => i.mode !== \"run\" && i.mode !== \"queued\")) {\n\t\t\t\tsuite.mode = \"skip\";\n\t\t\t}\n\t\t}\n\t};\n\ttraverseSuite(file, parentIsOnly, false);\n\tconst nonMatching = testLocations === null || testLocations === void 0 ? void 0 : testLocations.filter((loc) => !matchedLocations.includes(loc));\n\tif (nonMatching && nonMatching.length !== 0) {\n\t\tconst message = nonMatching.length === 1 ? `line ${nonMatching[0]}` : `lines ${nonMatching.join(\", \")}`;\n\t\tif (file.result === undefined) {\n\t\t\tfile.result = {\n\t\t\t\tstate: \"fail\",\n\t\t\t\terrors: []\n\t\t\t};\n\t\t}\n\t\tif (file.result.errors === undefined) {\n\t\t\tfile.result.errors = [];\n\t\t}\n\t\tfile.result.errors.push(processError(new Error(`No test found in ${file.name} in ${message}`)));\n\t}\n}\nfunction getTaskFullName(task) {\n\treturn `${task.suite ? `${getTaskFullName(task.suite)} ` : \"\"}${task.name}`;\n}\nfunction someTasksAreOnly(suite) {\n\treturn suite.tasks.some((t) => t.mode === \"only\" || t.type === \"suite\" && someTasksAreOnly(t));\n}\nfunction skipAllTasks(suite) {\n\tsuite.tasks.forEach((t) => {\n\t\tif (t.mode === \"run\" || t.mode === \"queued\") {\n\t\t\tt.mode = \"skip\";\n\t\t\tif (t.type === \"suite\") {\n\t\t\t\tskipAllTasks(t);\n\t\t\t}\n\t\t}\n\t});\n}\nfunction todoAllTasks(suite) {\n\tsuite.tasks.forEach((t) => {\n\t\tif (t.mode === \"run\" || t.mode === \"queued\") {\n\t\t\tt.mode = \"todo\";\n\t\t\tif (t.type === \"suite\") {\n\t\t\t\ttodoAllTasks(t);\n\t\t\t}\n\t\t}\n\t});\n}\nfunction checkAllowOnly(task, allowOnly) {\n\tif (allowOnly) {\n\t\treturn;\n\t}\n\tconst error = processError(new Error(\"[Vitest] Unexpected .only modifier. Remove it or pass --allowOnly argument to bypass this error\"));\n\ttask.result = {\n\t\tstate: \"fail\",\n\t\terrors: [error]\n\t};\n}\n/* @__NO_SIDE_EFFECTS__ */\nfunction generateHash(str) {\n\tlet hash = 0;\n\tif (str.length === 0) {\n\t\treturn `${hash}`;\n\t}\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst char = str.charCodeAt(i);\n\t\thash = (hash << 5) - hash + char;\n\t\thash = hash & hash;\n\t}\n\treturn `${hash}`;\n}\nfunction calculateSuiteHash(parent) {\n\tparent.tasks.forEach((t, idx) => {\n\t\tt.id = `${parent.id}_${idx}`;\n\t\tif (t.type === \"suite\") {\n\t\t\tcalculateSuiteHash(t);\n\t\t}\n\t});\n}\nfunction createFileTask(filepath, root, projectName, pool, viteEnvironment) {\n\tconst path = relative(root, filepath);\n\tconst file = {\n\t\tid: generateFileHash(path, projectName),\n\t\tname: path,\n\t\tfullName: path,\n\t\ttype: \"suite\",\n\t\tmode: \"queued\",\n\t\tfilepath,\n\t\ttasks: [],\n\t\tmeta: Object.create(null),\n\t\tprojectName,\n\t\tfile: undefined,\n\t\tpool,\n\t\tviteEnvironment\n\t};\n\tfile.file = file;\n\treturn file;\n}\n/**\n* Generate a unique ID for a file based on its path and project name\n* @param file File relative to the root of the project to keep ID the same between different machines\n* @param projectName The name of the test project\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction generateFileHash(file, projectName) {\n\treturn /* @__PURE__ */ generateHash(`${file}${projectName || \"\"}`);\n}\nfunction findTestFileStackTrace(testFilePath, error) {\n\t// first line is the error message\n\tconst lines = error.split(\"\\n\").slice(1);\n\tfor (const line of lines) {\n\t\tconst stack = parseSingleStack(line);\n\t\tif (stack && stack.file === testFilePath) {\n\t\t\treturn stack;\n\t\t}\n\t}\n}\n\n/**\n* Return a function for running multiple async operations with limited concurrency.\n*/\nfunction limitConcurrency(concurrency = Infinity) {\n\t// The number of currently active + pending tasks.\n\tlet count = 0;\n\t// The head and tail of the pending task queue, built using a singly linked list.\n\t// Both head and tail are initially undefined, signifying an empty queue.\n\t// They both become undefined again whenever there are no pending tasks.\n\tlet head;\n\tlet tail;\n\t// A bookkeeping function executed whenever a task has been run to completion.\n\tconst finish = () => {\n\t\tcount--;\n\t\t// Check if there are further pending tasks in the queue.\n\t\tif (head) {\n\t\t\t// Allow the next pending task to run and pop it from the queue.\n\t\t\thead[0]();\n\t\t\thead = head[1];\n\t\t\t// The head may now be undefined if there are no further pending tasks.\n\t\t\t// In that case, set tail to undefined as well.\n\t\t\ttail = head && tail;\n\t\t}\n\t};\n\treturn (func, ...args) => {\n\t\t// Create a promise chain that:\n\t\t//  1. Waits for its turn in the task queue (if necessary).\n\t\t//  2. Runs the task.\n\t\t//  3. Allows the next pending task (if any) to run.\n\t\treturn new Promise((resolve) => {\n\t\t\tif (count++ < concurrency) {\n\t\t\t\t// No need to queue if fewer than maxConcurrency tasks are running.\n\t\t\t\tresolve();\n\t\t\t} else if (tail) {\n\t\t\t\t// There are pending tasks, so append to the queue.\n\t\t\t\ttail = tail[1] = [resolve];\n\t\t\t} else {\n\t\t\t\t// No other pending tasks, initialize the queue with a new tail and head.\n\t\t\t\thead = tail = [resolve];\n\t\t\t}\n\t\t}).then(() => {\n\t\t\t// Running func here ensures that even a non-thenable result or an\n\t\t\t// immediately thrown error gets wrapped into a Promise.\n\t\t\treturn func(...args);\n\t\t}).finally(finish);\n\t};\n}\n\n/**\n* Partition in tasks groups by consecutive concurrent\n*/\nfunction partitionSuiteChildren(suite) {\n\tlet tasksGroup = [];\n\tconst tasksGroups = [];\n\tfor (const c of suite.tasks) {\n\t\tif (tasksGroup.length === 0 || c.concurrent === tasksGroup[0].concurrent) {\n\t\t\ttasksGroup.push(c);\n\t\t} else {\n\t\t\ttasksGroups.push(tasksGroup);\n\t\t\ttasksGroup = [c];\n\t\t}\n\t}\n\tif (tasksGroup.length > 0) {\n\t\ttasksGroups.push(tasksGroup);\n\t}\n\treturn tasksGroups;\n}\n\nfunction isTestCase(s) {\n\treturn s.type === \"test\";\n}\nfunction getTests(suite) {\n\tconst tests = [];\n\tconst arraySuites = toArray(suite);\n\tfor (const s of arraySuites) {\n\t\tif (isTestCase(s)) {\n\t\t\ttests.push(s);\n\t\t} else {\n\t\t\tfor (const task of s.tasks) {\n\t\t\t\tif (isTestCase(task)) {\n\t\t\t\t\ttests.push(task);\n\t\t\t\t} else {\n\t\t\t\t\tconst taskTests = getTests(task);\n\t\t\t\t\tfor (const test of taskTests) {\n\t\t\t\t\t\ttests.push(test);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn tests;\n}\nfunction getTasks(tasks = []) {\n\treturn toArray(tasks).flatMap((s) => isTestCase(s) ? [s] : [s, ...getTasks(s.tasks)]);\n}\nfunction getSuites(suite) {\n\treturn toArray(suite).flatMap((s) => s.type === \"suite\" ? [s, ...getSuites(s.tasks)] : []);\n}\nfunction hasTests(suite) {\n\treturn toArray(suite).some((s) => s.tasks.some((c) => isTestCase(c) || hasTests(c)));\n}\nfunction hasFailed(suite) {\n\treturn toArray(suite).some((s) => {\n\t\tvar _s$result;\n\t\treturn ((_s$result = s.result) === null || _s$result === void 0 ? void 0 : _s$result.state) === \"fail\" || s.type === \"suite\" && hasFailed(s.tasks);\n\t});\n}\nfunction getNames(task) {\n\tconst names = [task.name];\n\tlet current = task;\n\twhile (current === null || current === void 0 ? void 0 : current.suite) {\n\t\tcurrent = current.suite;\n\t\tif (current === null || current === void 0 ? void 0 : current.name) {\n\t\t\tnames.unshift(current.name);\n\t\t}\n\t}\n\tif (current !== task.file) {\n\t\tnames.unshift(task.file.name);\n\t}\n\treturn names;\n}\nfunction getFullName(task, separator = \" > \") {\n\treturn getNames(task).join(separator);\n}\nfunction getTestName(task, separator = \" > \") {\n\treturn getNames(task).slice(1).join(separator);\n}\nfunction createTaskName(names, separator = \" > \") {\n\treturn names.filter((name) => name !== undefined).join(separator);\n}\n\nexport { calculateSuiteHash as a, createFileTask as b, createChainable as c, generateHash as d, createTaskName as e, findTestFileStackTrace as f, generateFileHash as g, getFullName as h, interpretTaskModes as i, getNames as j, getSuites as k, limitConcurrency as l, getTasks as m, getTestName as n, getTests as o, partitionSuiteChildren as p, hasFailed as q, hasTests as r, someTasksAreOnly as s, isTestCase as t };\n","import { processError } from '@vitest/utils/error';\nimport { isObject, createDefer, assertTypes, toArray, isNegativeNaN, objectAttr, shuffle } from '@vitest/utils/helpers';\nimport { getSafeTimers } from '@vitest/utils/timers';\nimport { format, formatRegExp, objDisplay } from '@vitest/utils/display';\nimport { c as createChainable, e as createTaskName, f as findTestFileStackTrace, b as createFileTask, a as calculateSuiteHash, s as someTasksAreOnly, i as interpretTaskModes, l as limitConcurrency, p as partitionSuiteChildren, r as hasTests, q as hasFailed } from './chunk-tasks.js';\nimport '@vitest/utils/source-map';\nimport 'pathe';\n\nclass PendingError extends Error {\n\tcode = \"VITEST_PENDING\";\n\ttaskId;\n\tconstructor(message, task, note) {\n\t\tsuper(message);\n\t\tthis.message = message;\n\t\tthis.note = note;\n\t\tthis.taskId = task.id;\n\t}\n}\nclass TestRunAbortError extends Error {\n\tname = \"TestRunAbortError\";\n\treason;\n\tconstructor(message, reason) {\n\t\tsuper(message);\n\t\tthis.reason = reason;\n\t}\n}\n\n// use WeakMap here to make the Test and Suite object serializable\nconst fnMap = new WeakMap();\nconst testFixtureMap = new WeakMap();\nconst hooksMap = new WeakMap();\nfunction setFn(key, fn) {\n\tfnMap.set(key, fn);\n}\nfunction getFn(key) {\n\treturn fnMap.get(key);\n}\nfunction setTestFixture(key, fixture) {\n\ttestFixtureMap.set(key, fixture);\n}\nfunction getTestFixture(key) {\n\treturn testFixtureMap.get(key);\n}\nfunction setHooks(key, hooks) {\n\thooksMap.set(key, hooks);\n}\nfunction getHooks(key) {\n\treturn hooksMap.get(key);\n}\n\nfunction mergeScopedFixtures(testFixtures, scopedFixtures) {\n\tconst scopedFixturesMap = scopedFixtures.reduce((map, fixture) => {\n\t\tmap[fixture.prop] = fixture;\n\t\treturn map;\n\t}, {});\n\tconst newFixtures = {};\n\ttestFixtures.forEach((fixture) => {\n\t\tconst useFixture = scopedFixturesMap[fixture.prop] || { ...fixture };\n\t\tnewFixtures[useFixture.prop] = useFixture;\n\t});\n\tfor (const fixtureKep in newFixtures) {\n\t\tvar _fixture$deps;\n\t\tconst fixture = newFixtures[fixtureKep];\n\t\t// if the fixture was define before the scope, then its dep\n\t\t// will reference the original fixture instead of the scope\n\t\tfixture.deps = (_fixture$deps = fixture.deps) === null || _fixture$deps === void 0 ? void 0 : _fixture$deps.map((dep) => newFixtures[dep.prop]);\n\t}\n\treturn Object.values(newFixtures);\n}\nfunction mergeContextFixtures(fixtures, context, runner) {\n\tconst fixtureOptionKeys = [\n\t\t\"auto\",\n\t\t\"injected\",\n\t\t\"scope\"\n\t];\n\tconst fixtureArray = Object.entries(fixtures).map(([prop, value]) => {\n\t\tconst fixtureItem = { value };\n\t\tif (Array.isArray(value) && value.length >= 2 && isObject(value[1]) && Object.keys(value[1]).some((key) => fixtureOptionKeys.includes(key))) {\n\t\t\tvar _runner$injectValue;\n\t\t\t// fixture with options\n\t\t\tObject.assign(fixtureItem, value[1]);\n\t\t\tconst userValue = value[0];\n\t\t\tfixtureItem.value = fixtureItem.injected ? ((_runner$injectValue = runner.injectValue) === null || _runner$injectValue === void 0 ? void 0 : _runner$injectValue.call(runner, prop)) ?? userValue : userValue;\n\t\t}\n\t\tfixtureItem.scope = fixtureItem.scope || \"test\";\n\t\tif (fixtureItem.scope === \"worker\" && !runner.getWorkerContext) {\n\t\t\tfixtureItem.scope = \"file\";\n\t\t}\n\t\tfixtureItem.prop = prop;\n\t\tfixtureItem.isFn = typeof fixtureItem.value === \"function\";\n\t\treturn fixtureItem;\n\t});\n\tif (Array.isArray(context.fixtures)) {\n\t\tcontext.fixtures = context.fixtures.concat(fixtureArray);\n\t} else {\n\t\tcontext.fixtures = fixtureArray;\n\t}\n\t// Update dependencies of fixture functions\n\tfixtureArray.forEach((fixture) => {\n\t\tif (fixture.isFn) {\n\t\t\tconst usedProps = getUsedProps(fixture.value);\n\t\t\tif (usedProps.length) {\n\t\t\t\tfixture.deps = context.fixtures.filter(({ prop }) => prop !== fixture.prop && usedProps.includes(prop));\n\t\t\t}\n\t\t\t// test can access anything, so we ignore it\n\t\t\tif (fixture.scope !== \"test\") {\n\t\t\t\tvar _fixture$deps2;\n\t\t\t\t(_fixture$deps2 = fixture.deps) === null || _fixture$deps2 === void 0 ? void 0 : _fixture$deps2.forEach((dep) => {\n\t\t\t\t\tif (!dep.isFn) {\n\t\t\t\t\t\t// non fn fixtures are always resolved and available to anyone\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// worker scope can only import from worker scope\n\t\t\t\t\tif (fixture.scope === \"worker\" && dep.scope === \"worker\") {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// file scope an import from file and worker scopes\n\t\t\t\t\tif (fixture.scope === \"file\" && dep.scope !== \"test\") {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthrow new SyntaxError(`cannot use the ${dep.scope} fixture \"${dep.prop}\" inside the ${fixture.scope} fixture \"${fixture.prop}\"`);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n\treturn context;\n}\nconst fixtureValueMaps = new Map();\nconst cleanupFnArrayMap = new Map();\nasync function callFixtureCleanup(context) {\n\tconst cleanupFnArray = cleanupFnArrayMap.get(context) ?? [];\n\tfor (const cleanup of cleanupFnArray.reverse()) {\n\t\tawait cleanup();\n\t}\n\tcleanupFnArrayMap.delete(context);\n}\nfunction withFixtures(runner, fn, testContext) {\n\treturn (hookContext) => {\n\t\tconst context = hookContext || testContext;\n\t\tif (!context) {\n\t\t\treturn fn({});\n\t\t}\n\t\tconst fixtures = getTestFixture(context);\n\t\tif (!(fixtures === null || fixtures === void 0 ? void 0 : fixtures.length)) {\n\t\t\treturn fn(context);\n\t\t}\n\t\tconst usedProps = getUsedProps(fn);\n\t\tconst hasAutoFixture = fixtures.some(({ auto }) => auto);\n\t\tif (!usedProps.length && !hasAutoFixture) {\n\t\t\treturn fn(context);\n\t\t}\n\t\tif (!fixtureValueMaps.get(context)) {\n\t\t\tfixtureValueMaps.set(context, new Map());\n\t\t}\n\t\tconst fixtureValueMap = fixtureValueMaps.get(context);\n\t\tif (!cleanupFnArrayMap.has(context)) {\n\t\t\tcleanupFnArrayMap.set(context, []);\n\t\t}\n\t\tconst cleanupFnArray = cleanupFnArrayMap.get(context);\n\t\tconst usedFixtures = fixtures.filter(({ prop, auto }) => auto || usedProps.includes(prop));\n\t\tconst pendingFixtures = resolveDeps(usedFixtures);\n\t\tif (!pendingFixtures.length) {\n\t\t\treturn fn(context);\n\t\t}\n\t\tasync function resolveFixtures() {\n\t\t\tfor (const fixture of pendingFixtures) {\n\t\t\t\t// fixture could be already initialized during \"before\" hook\n\t\t\t\tif (fixtureValueMap.has(fixture)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst resolvedValue = await resolveFixtureValue(runner, fixture, context, cleanupFnArray);\n\t\t\t\tcontext[fixture.prop] = resolvedValue;\n\t\t\t\tfixtureValueMap.set(fixture, resolvedValue);\n\t\t\t\tif (fixture.scope === \"test\") {\n\t\t\t\t\tcleanupFnArray.unshift(() => {\n\t\t\t\t\t\tfixtureValueMap.delete(fixture);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn resolveFixtures().then(() => fn(context));\n\t};\n}\nconst globalFixturePromise = new WeakMap();\nfunction resolveFixtureValue(runner, fixture, context, cleanupFnArray) {\n\tvar _runner$getWorkerCont;\n\tconst fileContext = getFileContext(context.task.file);\n\tconst workerContext = (_runner$getWorkerCont = runner.getWorkerContext) === null || _runner$getWorkerCont === void 0 ? void 0 : _runner$getWorkerCont.call(runner);\n\tif (!fixture.isFn) {\n\t\tvar _fixture$prop;\n\t\tfileContext[_fixture$prop = fixture.prop] ?? (fileContext[_fixture$prop] = fixture.value);\n\t\tif (workerContext) {\n\t\t\tvar _fixture$prop2;\n\t\t\tworkerContext[_fixture$prop2 = fixture.prop] ?? (workerContext[_fixture$prop2] = fixture.value);\n\t\t}\n\t\treturn fixture.value;\n\t}\n\tif (fixture.scope === \"test\") {\n\t\treturn resolveFixtureFunction(fixture.value, context, cleanupFnArray);\n\t}\n\t// in case the test runs in parallel\n\tif (globalFixturePromise.has(fixture)) {\n\t\treturn globalFixturePromise.get(fixture);\n\t}\n\tlet fixtureContext;\n\tif (fixture.scope === \"worker\") {\n\t\tif (!workerContext) {\n\t\t\tthrow new TypeError(\"[@vitest/runner] The worker context is not available in the current test runner. Please, provide the `getWorkerContext` method when initiating the runner.\");\n\t\t}\n\t\tfixtureContext = workerContext;\n\t} else {\n\t\tfixtureContext = fileContext;\n\t}\n\tif (fixture.prop in fixtureContext) {\n\t\treturn fixtureContext[fixture.prop];\n\t}\n\tif (!cleanupFnArrayMap.has(fixtureContext)) {\n\t\tcleanupFnArrayMap.set(fixtureContext, []);\n\t}\n\tconst cleanupFnFileArray = cleanupFnArrayMap.get(fixtureContext);\n\tconst promise = resolveFixtureFunction(fixture.value, fixtureContext, cleanupFnFileArray).then((value) => {\n\t\tfixtureContext[fixture.prop] = value;\n\t\tglobalFixturePromise.delete(fixture);\n\t\treturn value;\n\t});\n\tglobalFixturePromise.set(fixture, promise);\n\treturn promise;\n}\nasync function resolveFixtureFunction(fixtureFn, context, cleanupFnArray) {\n\t// wait for `use` call to extract fixture value\n\tconst useFnArgPromise = createDefer();\n\tlet isUseFnArgResolved = false;\n\tconst fixtureReturn = fixtureFn(context, async (useFnArg) => {\n\t\t// extract `use` argument\n\t\tisUseFnArgResolved = true;\n\t\tuseFnArgPromise.resolve(useFnArg);\n\t\t// suspend fixture teardown by holding off `useReturnPromise` resolution until cleanup\n\t\tconst useReturnPromise = createDefer();\n\t\tcleanupFnArray.push(async () => {\n\t\t\t// start teardown by resolving `use` Promise\n\t\t\tuseReturnPromise.resolve();\n\t\t\t// wait for finishing teardown\n\t\t\tawait fixtureReturn;\n\t\t});\n\t\tawait useReturnPromise;\n\t}).catch((e) => {\n\t\t// treat fixture setup error as test failure\n\t\tif (!isUseFnArgResolved) {\n\t\t\tuseFnArgPromise.reject(e);\n\t\t\treturn;\n\t\t}\n\t\t// otherwise re-throw to avoid silencing error during cleanup\n\t\tthrow e;\n\t});\n\treturn useFnArgPromise;\n}\nfunction resolveDeps(fixtures, depSet = new Set(), pendingFixtures = []) {\n\tfixtures.forEach((fixture) => {\n\t\tif (pendingFixtures.includes(fixture)) {\n\t\t\treturn;\n\t\t}\n\t\tif (!fixture.isFn || !fixture.deps) {\n\t\t\tpendingFixtures.push(fixture);\n\t\t\treturn;\n\t\t}\n\t\tif (depSet.has(fixture)) {\n\t\t\tthrow new Error(`Circular fixture dependency detected: ${fixture.prop} <- ${[...depSet].reverse().map((d) => d.prop).join(\" <- \")}`);\n\t\t}\n\t\tdepSet.add(fixture);\n\t\tresolveDeps(fixture.deps, depSet, pendingFixtures);\n\t\tpendingFixtures.push(fixture);\n\t\tdepSet.clear();\n\t});\n\treturn pendingFixtures;\n}\nfunction getUsedProps(fn) {\n\tlet fnString = filterOutComments(fn.toString());\n\t// match lowered async function and strip it off\n\t// example code on esbuild-try https://esbuild.github.io/try/#YgAwLjI0LjAALS1zdXBwb3J0ZWQ6YXN5bmMtYXdhaXQ9ZmFsc2UAZQBlbnRyeS50cwBjb25zdCBvID0gewogIGYxOiBhc3luYyAoKSA9PiB7fSwKICBmMjogYXN5bmMgKGEpID0+IHt9LAogIGYzOiBhc3luYyAoYSwgYikgPT4ge30sCiAgZjQ6IGFzeW5jIGZ1bmN0aW9uKGEpIHt9LAogIGY1OiBhc3luYyBmdW5jdGlvbiBmZihhKSB7fSwKICBhc3luYyBmNihhKSB7fSwKCiAgZzE6IGFzeW5jICgpID0+IHt9LAogIGcyOiBhc3luYyAoeyBhIH0pID0+IHt9LAogIGczOiBhc3luYyAoeyBhIH0sIGIpID0+IHt9LAogIGc0OiBhc3luYyBmdW5jdGlvbiAoeyBhIH0pIHt9LAogIGc1OiBhc3luYyBmdW5jdGlvbiBnZyh7IGEgfSkge30sCiAgYXN5bmMgZzYoeyBhIH0pIHt9LAoKICBoMTogYXN5bmMgKCkgPT4ge30sCiAgLy8gY29tbWVudCBiZXR3ZWVuCiAgaDI6IGFzeW5jIChhKSA9PiB7fSwKfQ\n\t//   __async(this, null, function*\n\t//   __async(this, arguments, function*\n\t//   __async(this, [_0, _1], function*\n\tif (/__async\\((?:this|null), (?:null|arguments|\\[[_0-9, ]*\\]), function\\*/.test(fnString)) {\n\t\tfnString = fnString.split(/__async\\((?:this|null),/)[1];\n\t}\n\tconst match = fnString.match(/[^(]*\\(([^)]*)/);\n\tif (!match) {\n\t\treturn [];\n\t}\n\tconst args = splitByComma(match[1]);\n\tif (!args.length) {\n\t\treturn [];\n\t}\n\tlet first = args[0];\n\tif (\"__VITEST_FIXTURE_INDEX__\" in fn) {\n\t\tfirst = args[fn.__VITEST_FIXTURE_INDEX__];\n\t\tif (!first) {\n\t\t\treturn [];\n\t\t}\n\t}\n\tif (!(first[0] === \"{\" && first.endsWith(\"}\"))) {\n\t\tthrow new Error(`The first argument inside a fixture must use object destructuring pattern, e.g. ({ test } => {}). Instead, received \"${first}\".`);\n\t}\n\tconst _first = first.slice(1, -1).replace(/\\s/g, \"\");\n\tconst props = splitByComma(_first).map((prop) => {\n\t\treturn prop.replace(/:.*|=.*/g, \"\");\n\t});\n\tconst last = props.at(-1);\n\tif (last && last.startsWith(\"...\")) {\n\t\tthrow new Error(`Rest parameters are not supported in fixtures, received \"${last}\".`);\n\t}\n\treturn props;\n}\nfunction filterOutComments(s) {\n\tconst result = [];\n\tlet commentState = \"none\";\n\tfor (let i = 0; i < s.length; ++i) {\n\t\tif (commentState === \"singleline\") {\n\t\t\tif (s[i] === \"\\n\") {\n\t\t\t\tcommentState = \"none\";\n\t\t\t}\n\t\t} else if (commentState === \"multiline\") {\n\t\t\tif (s[i - 1] === \"*\" && s[i] === \"/\") {\n\t\t\t\tcommentState = \"none\";\n\t\t\t}\n\t\t} else if (commentState === \"none\") {\n\t\t\tif (s[i] === \"/\" && s[i + 1] === \"/\") {\n\t\t\t\tcommentState = \"singleline\";\n\t\t\t} else if (s[i] === \"/\" && s[i + 1] === \"*\") {\n\t\t\t\tcommentState = \"multiline\";\n\t\t\t\ti += 2;\n\t\t\t} else {\n\t\t\t\tresult.push(s[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn result.join(\"\");\n}\nfunction splitByComma(s) {\n\tconst result = [];\n\tconst stack = [];\n\tlet start = 0;\n\tfor (let i = 0; i < s.length; i++) {\n\t\tif (s[i] === \"{\" || s[i] === \"[\") {\n\t\t\tstack.push(s[i] === \"{\" ? \"}\" : \"]\");\n\t\t} else if (s[i] === stack.at(-1)) {\n\t\t\tstack.pop();\n\t\t} else if (!stack.length && s[i] === \",\") {\n\t\t\tconst token = s.substring(start, i).trim();\n\t\t\tif (token) {\n\t\t\t\tresult.push(token);\n\t\t\t}\n\t\t\tstart = i + 1;\n\t\t}\n\t}\n\tconst lastToken = s.substring(start).trim();\n\tif (lastToken) {\n\t\tresult.push(lastToken);\n\t}\n\treturn result;\n}\n\nlet _test;\nfunction setCurrentTest(test) {\n\t_test = test;\n}\nfunction getCurrentTest() {\n\treturn _test;\n}\nconst tests = [];\nfunction addRunningTest(test) {\n\ttests.push(test);\n\treturn () => {\n\t\ttests.splice(tests.indexOf(test));\n\t};\n}\nfunction getRunningTests() {\n\treturn tests;\n}\n\nfunction getDefaultHookTimeout() {\n\treturn getRunner().config.hookTimeout;\n}\nconst CLEANUP_TIMEOUT_KEY = Symbol.for(\"VITEST_CLEANUP_TIMEOUT\");\nconst CLEANUP_STACK_TRACE_KEY = Symbol.for(\"VITEST_CLEANUP_STACK_TRACE\");\nfunction getBeforeHookCleanupCallback(hook, result, context) {\n\tif (typeof result === \"function\") {\n\t\tconst timeout = CLEANUP_TIMEOUT_KEY in hook && typeof hook[CLEANUP_TIMEOUT_KEY] === \"number\" ? hook[CLEANUP_TIMEOUT_KEY] : getDefaultHookTimeout();\n\t\tconst stackTraceError = CLEANUP_STACK_TRACE_KEY in hook && hook[CLEANUP_STACK_TRACE_KEY] instanceof Error ? hook[CLEANUP_STACK_TRACE_KEY] : undefined;\n\t\treturn withTimeout(result, timeout, true, stackTraceError, (_, error) => {\n\t\t\tif (context) {\n\t\t\t\tabortContextSignal(context, error);\n\t\t\t}\n\t\t});\n\t}\n}\n/**\n* Registers a callback function to be executed once before all tests within the current suite.\n* This hook is useful for scenarios where you need to perform setup operations that are common to all tests in a suite, such as initializing a database connection or setting up a test environment.\n*\n* **Note:** The `beforeAll` hooks are executed in the order they are defined one after another. You can configure this by changing the `sequence.hooks` option in the config file.\n*\n* @param {Function} fn - The callback function to be executed before all tests.\n* @param {number} [timeout] - Optional timeout in milliseconds for the hook. If not provided, the default hook timeout from the runner's configuration is used.\n* @returns {void}\n* @example\n* ```ts\n* // Example of using beforeAll to set up a database connection\n* beforeAll(async () => {\n*   await database.connect();\n* });\n* ```\n*/\nfunction beforeAll(fn, timeout = getDefaultHookTimeout()) {\n\tassertTypes(fn, \"\\\"beforeAll\\\" callback\", [\"function\"]);\n\tconst stackTraceError = new Error(\"STACK_TRACE_ERROR\");\n\treturn getCurrentSuite().on(\"beforeAll\", Object.assign(withTimeout(fn, timeout, true, stackTraceError), {\n\t\t[CLEANUP_TIMEOUT_KEY]: timeout,\n\t\t[CLEANUP_STACK_TRACE_KEY]: stackTraceError\n\t}));\n}\n/**\n* Registers a callback function to be executed once after all tests within the current suite have completed.\n* This hook is useful for scenarios where you need to perform cleanup operations after all tests in a suite have run, such as closing database connections or cleaning up temporary files.\n*\n* **Note:** The `afterAll` hooks are running in reverse order of their registration. You can configure this by changing the `sequence.hooks` option in the config file.\n*\n* @param {Function} fn - The callback function to be executed after all tests.\n* @param {number} [timeout] - Optional timeout in milliseconds for the hook. If not provided, the default hook timeout from the runner's configuration is used.\n* @returns {void}\n* @example\n* ```ts\n* // Example of using afterAll to close a database connection\n* afterAll(async () => {\n*   await database.disconnect();\n* });\n* ```\n*/\nfunction afterAll(fn, timeout) {\n\tassertTypes(fn, \"\\\"afterAll\\\" callback\", [\"function\"]);\n\treturn getCurrentSuite().on(\"afterAll\", withTimeout(fn, timeout ?? getDefaultHookTimeout(), true, new Error(\"STACK_TRACE_ERROR\")));\n}\n/**\n* Registers a callback function to be executed before each test within the current suite.\n* This hook is useful for scenarios where you need to reset or reinitialize the test environment before each test runs, such as resetting database states, clearing caches, or reinitializing variables.\n*\n* **Note:** The `beforeEach` hooks are executed in the order they are defined one after another. You can configure this by changing the `sequence.hooks` option in the config file.\n*\n* @param {Function} fn - The callback function to be executed before each test. This function receives an `TestContext` parameter if additional test context is needed.\n* @param {number} [timeout] - Optional timeout in milliseconds for the hook. If not provided, the default hook timeout from the runner's configuration is used.\n* @returns {void}\n* @example\n* ```ts\n* // Example of using beforeEach to reset a database state\n* beforeEach(async () => {\n*   await database.reset();\n* });\n* ```\n*/\nfunction beforeEach(fn, timeout = getDefaultHookTimeout()) {\n\tassertTypes(fn, \"\\\"beforeEach\\\" callback\", [\"function\"]);\n\tconst stackTraceError = new Error(\"STACK_TRACE_ERROR\");\n\tconst runner = getRunner();\n\treturn getCurrentSuite().on(\"beforeEach\", Object.assign(withTimeout(withFixtures(runner, fn), timeout ?? getDefaultHookTimeout(), true, stackTraceError, abortIfTimeout), {\n\t\t[CLEANUP_TIMEOUT_KEY]: timeout,\n\t\t[CLEANUP_STACK_TRACE_KEY]: stackTraceError\n\t}));\n}\n/**\n* Registers a callback function to be executed after each test within the current suite has completed.\n* This hook is useful for scenarios where you need to clean up or reset the test environment after each test runs, such as deleting temporary files, clearing test-specific database entries, or resetting mocked functions.\n*\n* **Note:** The `afterEach` hooks are running in reverse order of their registration. You can configure this by changing the `sequence.hooks` option in the config file.\n*\n* @param {Function} fn - The callback function to be executed after each test. This function receives an `TestContext` parameter if additional test context is needed.\n* @param {number} [timeout] - Optional timeout in milliseconds for the hook. If not provided, the default hook timeout from the runner's configuration is used.\n* @returns {void}\n* @example\n* ```ts\n* // Example of using afterEach to delete temporary files created during a test\n* afterEach(async () => {\n*   await fileSystem.deleteTempFiles();\n* });\n* ```\n*/\nfunction afterEach(fn, timeout) {\n\tassertTypes(fn, \"\\\"afterEach\\\" callback\", [\"function\"]);\n\tconst runner = getRunner();\n\treturn getCurrentSuite().on(\"afterEach\", withTimeout(withFixtures(runner, fn), timeout ?? getDefaultHookTimeout(), true, new Error(\"STACK_TRACE_ERROR\"), abortIfTimeout));\n}\n/**\n* Registers a callback function to be executed when a test fails within the current suite.\n* This function allows for custom actions to be performed in response to test failures, such as logging, cleanup, or additional diagnostics.\n*\n* **Note:** The `onTestFailed` hooks are running in reverse order of their registration. You can configure this by changing the `sequence.hooks` option in the config file.\n*\n* @param {Function} fn - The callback function to be executed upon a test failure. The function receives the test result (including errors).\n* @param {number} [timeout] - Optional timeout in milliseconds for the hook. If not provided, the default hook timeout from the runner's configuration is used.\n* @throws {Error} Throws an error if the function is not called within a test.\n* @returns {void}\n* @example\n* ```ts\n* // Example of using onTestFailed to log failure details\n* onTestFailed(({ errors }) => {\n*   console.log(`Test failed: ${test.name}`, errors);\n* });\n* ```\n*/\nconst onTestFailed = createTestHook(\"onTestFailed\", (test, handler, timeout) => {\n\ttest.onFailed || (test.onFailed = []);\n\ttest.onFailed.push(withTimeout(handler, timeout ?? getDefaultHookTimeout(), true, new Error(\"STACK_TRACE_ERROR\"), abortIfTimeout));\n});\n/**\n* Registers a callback function to be executed when the current test finishes, regardless of the outcome (pass or fail).\n* This function is ideal for performing actions that should occur after every test execution, such as cleanup, logging, or resetting shared resources.\n*\n* This hook is useful if you have access to a resource in the test itself and you want to clean it up after the test finishes. It is a more compact way to clean up resources than using the combination of `beforeEach` and `afterEach`.\n*\n* **Note:** The `onTestFinished` hooks are running in reverse order of their registration. You can configure this by changing the `sequence.hooks` option in the config file.\n*\n* **Note:** The `onTestFinished` hook is not called if the test is canceled with a dynamic `ctx.skip()` call.\n*\n* @param {Function} fn - The callback function to be executed after a test finishes. The function can receive parameters providing details about the completed test, including its success or failure status.\n* @param {number} [timeout] - Optional timeout in milliseconds for the hook. If not provided, the default hook timeout from the runner's configuration is used.\n* @throws {Error} Throws an error if the function is not called within a test.\n* @returns {void}\n* @example\n* ```ts\n* // Example of using onTestFinished for cleanup\n* const db = await connectToDatabase();\n* onTestFinished(async () => {\n*   await db.disconnect();\n* });\n* ```\n*/\nconst onTestFinished = createTestHook(\"onTestFinished\", (test, handler, timeout) => {\n\ttest.onFinished || (test.onFinished = []);\n\ttest.onFinished.push(withTimeout(handler, timeout ?? getDefaultHookTimeout(), true, new Error(\"STACK_TRACE_ERROR\"), abortIfTimeout));\n});\nfunction createTestHook(name, handler) {\n\treturn (fn, timeout) => {\n\t\tassertTypes(fn, `\"${name}\" callback`, [\"function\"]);\n\t\tconst current = getCurrentTest();\n\t\tif (!current) {\n\t\t\tthrow new Error(`Hook ${name}() can only be called inside a test`);\n\t\t}\n\t\treturn handler(current, fn, timeout);\n\t};\n}\n\n/**\n* Creates a suite of tests, allowing for grouping and hierarchical organization of tests.\n* Suites can contain both tests and other suites, enabling complex test structures.\n*\n* @param {string} name - The name of the suite, used for identification and reporting.\n* @param {Function} fn - A function that defines the tests and suites within this suite.\n* @example\n* ```ts\n* // Define a suite with two tests\n* suite('Math operations', () => {\n*   test('should add two numbers', () => {\n*     expect(add(1, 2)).toBe(3);\n*   });\n*\n*   test('should subtract two numbers', () => {\n*     expect(subtract(5, 2)).toBe(3);\n*   });\n* });\n* ```\n* @example\n* ```ts\n* // Define nested suites\n* suite('String operations', () => {\n*   suite('Trimming', () => {\n*     test('should trim whitespace from start and end', () => {\n*       expect('  hello  '.trim()).toBe('hello');\n*     });\n*   });\n*\n*   suite('Concatenation', () => {\n*     test('should concatenate two strings', () => {\n*       expect('hello' + ' ' + 'world').toBe('hello world');\n*     });\n*   });\n* });\n* ```\n*/\nconst suite = createSuite();\n/**\n* Defines a test case with a given name and test function. The test function can optionally be configured with test options.\n*\n* @param {string | Function} name - The name of the test or a function that will be used as a test name.\n* @param {TestOptions | TestFunction} [optionsOrFn] - Optional. The test options or the test function if no explicit name is provided.\n* @param {number | TestOptions | TestFunction} [optionsOrTest] - Optional. The test function or options, depending on the previous parameters.\n* @throws {Error} If called inside another test function.\n* @example\n* ```ts\n* // Define a simple test\n* test('should add two numbers', () => {\n*   expect(add(1, 2)).toBe(3);\n* });\n* ```\n* @example\n* ```ts\n* // Define a test with options\n* test('should subtract two numbers', { retry: 3 }, () => {\n*   expect(subtract(5, 2)).toBe(3);\n* });\n* ```\n*/\nconst test = createTest(function(name, optionsOrFn, optionsOrTest) {\n\tif (getCurrentTest()) {\n\t\tthrow new Error(\"Calling the test function inside another test function is not allowed. Please put it inside \\\"describe\\\" or \\\"suite\\\" so it can be properly collected.\");\n\t}\n\tgetCurrentSuite().test.fn.call(this, formatName(name), optionsOrFn, optionsOrTest);\n});\n/**\n* Creates a suite of tests, allowing for grouping and hierarchical organization of tests.\n* Suites can contain both tests and other suites, enabling complex test structures.\n*\n* @param {string} name - The name of the suite, used for identification and reporting.\n* @param {Function} fn - A function that defines the tests and suites within this suite.\n* @example\n* ```ts\n* // Define a suite with two tests\n* describe('Math operations', () => {\n*   test('should add two numbers', () => {\n*     expect(add(1, 2)).toBe(3);\n*   });\n*\n*   test('should subtract two numbers', () => {\n*     expect(subtract(5, 2)).toBe(3);\n*   });\n* });\n* ```\n* @example\n* ```ts\n* // Define nested suites\n* describe('String operations', () => {\n*   describe('Trimming', () => {\n*     test('should trim whitespace from start and end', () => {\n*       expect('  hello  '.trim()).toBe('hello');\n*     });\n*   });\n*\n*   describe('Concatenation', () => {\n*     test('should concatenate two strings', () => {\n*       expect('hello' + ' ' + 'world').toBe('hello world');\n*     });\n*   });\n* });\n* ```\n*/\nconst describe = suite;\n/**\n* Defines a test case with a given name and test function. The test function can optionally be configured with test options.\n*\n* @param {string | Function} name - The name of the test or a function that will be used as a test name.\n* @param {TestOptions | TestFunction} [optionsOrFn] - Optional. The test options or the test function if no explicit name is provided.\n* @param {number | TestOptions | TestFunction} [optionsOrTest] - Optional. The test function or options, depending on the previous parameters.\n* @throws {Error} If called inside another test function.\n* @example\n* ```ts\n* // Define a simple test\n* it('adds two numbers', () => {\n*   expect(add(1, 2)).toBe(3);\n* });\n* ```\n* @example\n* ```ts\n* // Define a test with options\n* it('subtracts two numbers', { retry: 3 }, () => {\n*   expect(subtract(5, 2)).toBe(3);\n* });\n* ```\n*/\nconst it = test;\nlet runner;\nlet defaultSuite;\nlet currentTestFilepath;\nfunction assert(condition, message) {\n\tif (!condition) {\n\t\tthrow new Error(`Vitest failed to find ${message}. One of the following is possible:` + \"\\n- \\\"vitest\\\" is imported directly without running \\\"vitest\\\" command\" + \"\\n- \\\"vitest\\\" is imported inside \\\"globalSetup\\\" (to fix this, use \\\"setupFiles\\\" instead, because \\\"globalSetup\\\" runs in a different context)\" + \"\\n- \\\"vitest\\\" is imported inside Vite / Vitest config file\" + \"\\n- Otherwise, it might be a Vitest bug. Please report it to https://github.com/vitest-dev/vitest/issues\\n\");\n\t}\n}\nfunction getDefaultSuite() {\n\tassert(defaultSuite, \"the default suite\");\n\treturn defaultSuite;\n}\nfunction getRunner() {\n\tassert(runner, \"the runner\");\n\treturn runner;\n}\nfunction createDefaultSuite(runner) {\n\tconst config = runner.config.sequence;\n\tconst collector = suite(\"\", { concurrent: config.concurrent }, () => {});\n\t// no parent suite for top-level tests\n\tdelete collector.suite;\n\treturn collector;\n}\nfunction clearCollectorContext(file, currentRunner) {\n\tif (!defaultSuite) {\n\t\tdefaultSuite = createDefaultSuite(currentRunner);\n\t}\n\tdefaultSuite.file = file;\n\trunner = currentRunner;\n\tcurrentTestFilepath = file.filepath;\n\tcollectorContext.tasks.length = 0;\n\tdefaultSuite.clear();\n\tcollectorContext.currentSuite = defaultSuite;\n}\nfunction getCurrentSuite() {\n\tconst currentSuite = collectorContext.currentSuite || defaultSuite;\n\tassert(currentSuite, \"the current suite\");\n\treturn currentSuite;\n}\nfunction createSuiteHooks() {\n\treturn {\n\t\tbeforeAll: [],\n\t\tafterAll: [],\n\t\tbeforeEach: [],\n\t\tafterEach: []\n\t};\n}\nfunction parseArguments(optionsOrFn, timeoutOrTest) {\n\tif (timeoutOrTest != null && typeof timeoutOrTest === \"object\") {\n\t\tthrow new TypeError(`Signature \"test(name, fn, { ... })\" was deprecated in Vitest 3 and removed in Vitest 4. Please, provide options as a second argument instead.`);\n\t}\n\tlet options = {};\n\tlet fn;\n\t// it('', () => {}, 1000)\n\tif (typeof timeoutOrTest === \"number\") {\n\t\toptions = { timeout: timeoutOrTest };\n\t} else if (typeof optionsOrFn === \"object\") {\n\t\toptions = optionsOrFn;\n\t}\n\tif (typeof optionsOrFn === \"function\") {\n\t\tif (typeof timeoutOrTest === \"function\") {\n\t\t\tthrow new TypeError(\"Cannot use two functions as arguments. Please use the second argument for options.\");\n\t\t}\n\t\tfn = optionsOrFn;\n\t} else if (typeof timeoutOrTest === \"function\") {\n\t\tfn = timeoutOrTest;\n\t}\n\treturn {\n\t\toptions,\n\t\thandler: fn\n\t};\n}\n// implementations\nfunction createSuiteCollector(name, factory = () => {}, mode, each, suiteOptions, parentCollectorFixtures) {\n\tconst tasks = [];\n\tlet suite;\n\tinitSuite(true);\n\tconst task = function(name = \"\", options = {}) {\n\t\tvar _collectorContext$cur, _collectorContext$cur2, _collectorContext$cur3;\n\t\tconst timeout = (options === null || options === void 0 ? void 0 : options.timeout) ?? runner.config.testTimeout;\n\t\tconst currentSuite = (_collectorContext$cur = collectorContext.currentSuite) === null || _collectorContext$cur === void 0 ? void 0 : _collectorContext$cur.suite;\n\t\tconst task = {\n\t\t\tid: \"\",\n\t\t\tname,\n\t\t\tfullName: createTaskName([(currentSuite === null || currentSuite === void 0 ? void 0 : currentSuite.fullName) ?? ((_collectorContext$cur2 = collectorContext.currentSuite) === null || _collectorContext$cur2 === void 0 || (_collectorContext$cur2 = _collectorContext$cur2.file) === null || _collectorContext$cur2 === void 0 ? void 0 : _collectorContext$cur2.fullName), name]),\n\t\t\tfullTestName: createTaskName([currentSuite === null || currentSuite === void 0 ? void 0 : currentSuite.fullTestName, name]),\n\t\t\tsuite: currentSuite,\n\t\t\teach: options.each,\n\t\t\tfails: options.fails,\n\t\t\tcontext: undefined,\n\t\t\ttype: \"test\",\n\t\t\tfile: (currentSuite === null || currentSuite === void 0 ? void 0 : currentSuite.file) ?? ((_collectorContext$cur3 = collectorContext.currentSuite) === null || _collectorContext$cur3 === void 0 ? void 0 : _collectorContext$cur3.file),\n\t\t\ttimeout,\n\t\t\tretry: options.retry ?? runner.config.retry,\n\t\t\trepeats: options.repeats,\n\t\t\tmode: options.only ? \"only\" : options.skip ? \"skip\" : options.todo ? \"todo\" : \"run\",\n\t\t\tmeta: options.meta ?? Object.create(null),\n\t\t\tannotations: [],\n\t\t\tartifacts: []\n\t\t};\n\t\tconst handler = options.handler;\n\t\tif (task.mode === \"run\" && !handler) {\n\t\t\ttask.mode = \"todo\";\n\t\t}\n\t\tif (options.concurrent || !options.sequential && runner.config.sequence.concurrent) {\n\t\t\ttask.concurrent = true;\n\t\t}\n\t\ttask.shuffle = suiteOptions === null || suiteOptions === void 0 ? void 0 : suiteOptions.shuffle;\n\t\tconst context = createTestContext(task, runner);\n\t\t// create test context\n\t\tObject.defineProperty(task, \"context\", {\n\t\t\tvalue: context,\n\t\t\tenumerable: false\n\t\t});\n\t\tsetTestFixture(context, options.fixtures);\n\t\t// custom can be called from any place, let's assume the limit is 15 stacks\n\t\tconst limit = Error.stackTraceLimit;\n\t\tError.stackTraceLimit = 15;\n\t\tconst stackTraceError = new Error(\"STACK_TRACE_ERROR\");\n\t\tError.stackTraceLimit = limit;\n\t\tif (handler) {\n\t\t\tsetFn(task, withTimeout(withAwaitAsyncAssertions(withFixtures(runner, handler, context), task), timeout, false, stackTraceError, (_, error) => abortIfTimeout([context], error)));\n\t\t}\n\t\tif (runner.config.includeTaskLocation) {\n\t\t\tconst error = stackTraceError.stack;\n\t\t\tconst stack = findTestFileStackTrace(currentTestFilepath, error);\n\t\t\tif (stack) {\n\t\t\t\ttask.location = {\n\t\t\t\t\tline: stack.line,\n\t\t\t\t\tcolumn: stack.column\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\ttasks.push(task);\n\t\treturn task;\n\t};\n\tconst test = createTest(function(name, optionsOrFn, timeoutOrTest) {\n\t\tlet { options, handler } = parseArguments(optionsOrFn, timeoutOrTest);\n\t\t// inherit repeats, retry, timeout from suite\n\t\tif (typeof suiteOptions === \"object\") {\n\t\t\toptions = Object.assign({}, suiteOptions, options);\n\t\t}\n\t\t// inherit concurrent / sequential from suite\n\t\toptions.concurrent = this.concurrent || !this.sequential && (options === null || options === void 0 ? void 0 : options.concurrent);\n\t\toptions.sequential = this.sequential || !this.concurrent && (options === null || options === void 0 ? void 0 : options.sequential);\n\t\tconst test = task(formatName(name), {\n\t\t\t...this,\n\t\t\t...options,\n\t\t\thandler\n\t\t});\n\t\ttest.type = \"test\";\n\t});\n\tlet collectorFixtures = parentCollectorFixtures;\n\tconst collector = {\n\t\ttype: \"collector\",\n\t\tname,\n\t\tmode,\n\t\tsuite,\n\t\toptions: suiteOptions,\n\t\ttest,\n\t\ttasks,\n\t\tcollect,\n\t\ttask,\n\t\tclear,\n\t\ton: addHook,\n\t\tfixtures() {\n\t\t\treturn collectorFixtures;\n\t\t},\n\t\tscoped(fixtures) {\n\t\t\tconst parsed = mergeContextFixtures(fixtures, { fixtures: collectorFixtures }, runner);\n\t\t\tif (parsed.fixtures) {\n\t\t\t\tcollectorFixtures = parsed.fixtures;\n\t\t\t}\n\t\t}\n\t};\n\tfunction addHook(name, ...fn) {\n\t\tgetHooks(suite)[name].push(...fn);\n\t}\n\tfunction initSuite(includeLocation) {\n\t\tvar _collectorContext$cur4, _collectorContext$cur5, _collectorContext$cur6;\n\t\tif (typeof suiteOptions === \"number\") {\n\t\t\tsuiteOptions = { timeout: suiteOptions };\n\t\t}\n\t\tconst currentSuite = (_collectorContext$cur4 = collectorContext.currentSuite) === null || _collectorContext$cur4 === void 0 ? void 0 : _collectorContext$cur4.suite;\n\t\tsuite = {\n\t\t\tid: \"\",\n\t\t\ttype: \"suite\",\n\t\t\tname,\n\t\t\tfullName: createTaskName([(currentSuite === null || currentSuite === void 0 ? void 0 : currentSuite.fullName) ?? ((_collectorContext$cur5 = collectorContext.currentSuite) === null || _collectorContext$cur5 === void 0 || (_collectorContext$cur5 = _collectorContext$cur5.file) === null || _collectorContext$cur5 === void 0 ? void 0 : _collectorContext$cur5.fullName), name]),\n\t\t\tfullTestName: createTaskName([currentSuite === null || currentSuite === void 0 ? void 0 : currentSuite.fullTestName, name]),\n\t\t\tsuite: currentSuite,\n\t\t\tmode,\n\t\t\teach,\n\t\t\tfile: (currentSuite === null || currentSuite === void 0 ? void 0 : currentSuite.file) ?? ((_collectorContext$cur6 = collectorContext.currentSuite) === null || _collectorContext$cur6 === void 0 ? void 0 : _collectorContext$cur6.file),\n\t\t\tshuffle: suiteOptions === null || suiteOptions === void 0 ? void 0 : suiteOptions.shuffle,\n\t\t\ttasks: [],\n\t\t\tmeta: Object.create(null),\n\t\t\tconcurrent: suiteOptions === null || suiteOptions === void 0 ? void 0 : suiteOptions.concurrent\n\t\t};\n\t\tif (runner && includeLocation && runner.config.includeTaskLocation) {\n\t\t\tconst limit = Error.stackTraceLimit;\n\t\t\tError.stackTraceLimit = 15;\n\t\t\tconst error = new Error(\"stacktrace\").stack;\n\t\t\tError.stackTraceLimit = limit;\n\t\t\tconst stack = findTestFileStackTrace(currentTestFilepath, error);\n\t\t\tif (stack) {\n\t\t\t\tsuite.location = {\n\t\t\t\t\tline: stack.line,\n\t\t\t\t\tcolumn: stack.column\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tsetHooks(suite, createSuiteHooks());\n\t}\n\tfunction clear() {\n\t\ttasks.length = 0;\n\t\tinitSuite(false);\n\t}\n\tasync function collect(file) {\n\t\tif (!file) {\n\t\t\tthrow new TypeError(\"File is required to collect tasks.\");\n\t\t}\n\t\tif (factory) {\n\t\t\tawait runWithSuite(collector, () => factory(test));\n\t\t}\n\t\tconst allChildren = [];\n\t\tfor (const i of tasks) {\n\t\t\tallChildren.push(i.type === \"collector\" ? await i.collect(file) : i);\n\t\t}\n\t\tsuite.tasks = allChildren;\n\t\treturn suite;\n\t}\n\tcollectTask(collector);\n\treturn collector;\n}\nfunction withAwaitAsyncAssertions(fn, task) {\n\treturn (async (...args) => {\n\t\tconst fnResult = await fn(...args);\n\t\t// some async expect will be added to this array, in case user forget to await them\n\t\tif (task.promises) {\n\t\t\tconst result = await Promise.allSettled(task.promises);\n\t\t\tconst errors = result.map((r) => r.status === \"rejected\" ? r.reason : undefined).filter(Boolean);\n\t\t\tif (errors.length) {\n\t\t\t\tthrow errors;\n\t\t\t}\n\t\t}\n\t\treturn fnResult;\n\t});\n}\nfunction createSuite() {\n\tfunction suiteFn(name, factoryOrOptions, optionsOrFactory) {\n\t\tvar _currentSuite$options;\n\t\tif (getCurrentTest()) {\n\t\t\tthrow new Error(\"Calling the suite function inside test function is not allowed. It can be only called at the top level or inside another suite function.\");\n\t\t}\n\t\tlet mode = this.only ? \"only\" : this.skip ? \"skip\" : this.todo ? \"todo\" : \"run\";\n\t\tconst currentSuite = collectorContext.currentSuite || defaultSuite;\n\t\tlet { options, handler: factory } = parseArguments(factoryOrOptions, optionsOrFactory);\n\t\tif (mode === \"run\" && !factory) {\n\t\t\tmode = \"todo\";\n\t\t}\n\t\tconst isConcurrentSpecified = options.concurrent || this.concurrent || options.sequential === false;\n\t\tconst isSequentialSpecified = options.sequential || this.sequential || options.concurrent === false;\n\t\t// inherit options from current suite\n\t\toptions = {\n\t\t\t...currentSuite === null || currentSuite === void 0 ? void 0 : currentSuite.options,\n\t\t\t...options,\n\t\t\tshuffle: this.shuffle ?? options.shuffle ?? (currentSuite === null || currentSuite === void 0 || (_currentSuite$options = currentSuite.options) === null || _currentSuite$options === void 0 ? void 0 : _currentSuite$options.shuffle) ?? (runner === null || runner === void 0 ? void 0 : runner.config.sequence.shuffle)\n\t\t};\n\t\t// inherit concurrent / sequential from suite\n\t\tconst isConcurrent = isConcurrentSpecified || options.concurrent && !isSequentialSpecified;\n\t\tconst isSequential = isSequentialSpecified || options.sequential && !isConcurrentSpecified;\n\t\toptions.concurrent = isConcurrent && !isSequential;\n\t\toptions.sequential = isSequential && !isConcurrent;\n\t\treturn createSuiteCollector(formatName(name), factory, mode, this.each, options, currentSuite === null || currentSuite === void 0 ? void 0 : currentSuite.fixtures());\n\t}\n\tsuiteFn.each = function(cases, ...args) {\n\t\tconst suite = this.withContext();\n\t\tthis.setContext(\"each\", true);\n\t\tif (Array.isArray(cases) && args.length) {\n\t\t\tcases = formatTemplateString(cases, args);\n\t\t}\n\t\treturn (name, optionsOrFn, fnOrOptions) => {\n\t\t\tconst _name = formatName(name);\n\t\t\tconst arrayOnlyCases = cases.every(Array.isArray);\n\t\t\tconst { options, handler } = parseArguments(optionsOrFn, fnOrOptions);\n\t\t\tconst fnFirst = typeof optionsOrFn === \"function\";\n\t\t\tcases.forEach((i, idx) => {\n\t\t\t\tconst items = Array.isArray(i) ? i : [i];\n\t\t\t\tif (fnFirst) {\n\t\t\t\t\tif (arrayOnlyCases) {\n\t\t\t\t\t\tsuite(formatTitle(_name, items, idx), handler ? () => handler(...items) : undefined, options.timeout);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsuite(formatTitle(_name, items, idx), handler ? () => handler(i) : undefined, options.timeout);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (arrayOnlyCases) {\n\t\t\t\t\t\tsuite(formatTitle(_name, items, idx), options, handler ? () => handler(...items) : undefined);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsuite(formatTitle(_name, items, idx), options, handler ? () => handler(i) : undefined);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.setContext(\"each\", undefined);\n\t\t};\n\t};\n\tsuiteFn.for = function(cases, ...args) {\n\t\tif (Array.isArray(cases) && args.length) {\n\t\t\tcases = formatTemplateString(cases, args);\n\t\t}\n\t\treturn (name, optionsOrFn, fnOrOptions) => {\n\t\t\tconst name_ = formatName(name);\n\t\t\tconst { options, handler } = parseArguments(optionsOrFn, fnOrOptions);\n\t\t\tcases.forEach((item, idx) => {\n\t\t\t\tsuite(formatTitle(name_, toArray(item), idx), options, handler ? () => handler(item) : undefined);\n\t\t\t});\n\t\t};\n\t};\n\tsuiteFn.skipIf = (condition) => condition ? suite.skip : suite;\n\tsuiteFn.runIf = (condition) => condition ? suite : suite.skip;\n\treturn createChainable([\n\t\t\"concurrent\",\n\t\t\"sequential\",\n\t\t\"shuffle\",\n\t\t\"skip\",\n\t\t\"only\",\n\t\t\"todo\"\n\t], suiteFn);\n}\nfunction createTaskCollector(fn, context) {\n\tconst taskFn = fn;\n\ttaskFn.each = function(cases, ...args) {\n\t\tconst test = this.withContext();\n\t\tthis.setContext(\"each\", true);\n\t\tif (Array.isArray(cases) && args.length) {\n\t\t\tcases = formatTemplateString(cases, args);\n\t\t}\n\t\treturn (name, optionsOrFn, fnOrOptions) => {\n\t\t\tconst _name = formatName(name);\n\t\t\tconst arrayOnlyCases = cases.every(Array.isArray);\n\t\t\tconst { options, handler } = parseArguments(optionsOrFn, fnOrOptions);\n\t\t\tconst fnFirst = typeof optionsOrFn === \"function\";\n\t\t\tcases.forEach((i, idx) => {\n\t\t\t\tconst items = Array.isArray(i) ? i : [i];\n\t\t\t\tif (fnFirst) {\n\t\t\t\t\tif (arrayOnlyCases) {\n\t\t\t\t\t\ttest(formatTitle(_name, items, idx), handler ? () => handler(...items) : undefined, options.timeout);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttest(formatTitle(_name, items, idx), handler ? () => handler(i) : undefined, options.timeout);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (arrayOnlyCases) {\n\t\t\t\t\t\ttest(formatTitle(_name, items, idx), options, handler ? () => handler(...items) : undefined);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttest(formatTitle(_name, items, idx), options, handler ? () => handler(i) : undefined);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.setContext(\"each\", undefined);\n\t\t};\n\t};\n\ttaskFn.for = function(cases, ...args) {\n\t\tconst test = this.withContext();\n\t\tif (Array.isArray(cases) && args.length) {\n\t\t\tcases = formatTemplateString(cases, args);\n\t\t}\n\t\treturn (name, optionsOrFn, fnOrOptions) => {\n\t\t\tconst _name = formatName(name);\n\t\t\tconst { options, handler } = parseArguments(optionsOrFn, fnOrOptions);\n\t\t\tcases.forEach((item, idx) => {\n\t\t\t\t// monkey-patch handler to allow parsing fixture\n\t\t\t\tconst handlerWrapper = handler ? (ctx) => handler(item, ctx) : undefined;\n\t\t\t\tif (handlerWrapper) {\n\t\t\t\t\thandlerWrapper.__VITEST_FIXTURE_INDEX__ = 1;\n\t\t\t\t\thandlerWrapper.toString = () => handler.toString();\n\t\t\t\t}\n\t\t\t\ttest(formatTitle(_name, toArray(item), idx), options, handlerWrapper);\n\t\t\t});\n\t\t};\n\t};\n\ttaskFn.skipIf = function(condition) {\n\t\treturn condition ? this.skip : this;\n\t};\n\ttaskFn.runIf = function(condition) {\n\t\treturn condition ? this : this.skip;\n\t};\n\ttaskFn.scoped = function(fixtures) {\n\t\tconst collector = getCurrentSuite();\n\t\tcollector.scoped(fixtures);\n\t};\n\ttaskFn.extend = function(fixtures) {\n\t\tconst _context = mergeContextFixtures(fixtures, context || {}, runner);\n\t\tconst originalWrapper = fn;\n\t\treturn createTest(function(name, optionsOrFn, optionsOrTest) {\n\t\t\tconst collector = getCurrentSuite();\n\t\t\tconst scopedFixtures = collector.fixtures();\n\t\t\tconst context = { ...this };\n\t\t\tif (scopedFixtures) {\n\t\t\t\tcontext.fixtures = mergeScopedFixtures(context.fixtures || [], scopedFixtures);\n\t\t\t}\n\t\t\toriginalWrapper.call(context, formatName(name), optionsOrFn, optionsOrTest);\n\t\t}, _context);\n\t};\n\ttaskFn.beforeEach = beforeEach;\n\ttaskFn.afterEach = afterEach;\n\ttaskFn.beforeAll = beforeAll;\n\ttaskFn.afterAll = afterAll;\n\tconst _test = createChainable([\n\t\t\"concurrent\",\n\t\t\"sequential\",\n\t\t\"skip\",\n\t\t\"only\",\n\t\t\"todo\",\n\t\t\"fails\"\n\t], taskFn);\n\tif (context) {\n\t\t_test.mergeContext(context);\n\t}\n\treturn _test;\n}\nfunction createTest(fn, context) {\n\treturn createTaskCollector(fn, context);\n}\nfunction formatName(name) {\n\treturn typeof name === \"string\" ? name : typeof name === \"function\" ? name.name || \"<anonymous>\" : String(name);\n}\nfunction formatTitle(template, items, idx) {\n\tif (template.includes(\"%#\") || template.includes(\"%$\")) {\n\t\t// '%#' match index of the test case\n\t\ttemplate = template.replace(/%%/g, \"__vitest_escaped_%__\").replace(/%#/g, `${idx}`).replace(/%\\$/g, `${idx + 1}`).replace(/__vitest_escaped_%__/g, \"%%\");\n\t}\n\tconst count = template.split(\"%\").length - 1;\n\tif (template.includes(\"%f\")) {\n\t\tconst placeholders = template.match(/%f/g) || [];\n\t\tplaceholders.forEach((_, i) => {\n\t\t\tif (isNegativeNaN(items[i]) || Object.is(items[i], -0)) {\n\t\t\t\t// Replace the i-th occurrence of '%f' with '-%f'\n\t\t\t\tlet occurrence = 0;\n\t\t\t\ttemplate = template.replace(/%f/g, (match) => {\n\t\t\t\t\toccurrence++;\n\t\t\t\t\treturn occurrence === i + 1 ? \"-%f\" : match;\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\tconst isObjectItem = isObject(items[0]);\n\tfunction formatAttribute(s) {\n\t\treturn s.replace(/\\$([$\\w.]+)/g, (_, key) => {\n\t\t\tvar _runner$config;\n\t\t\tconst isArrayKey = /^\\d+$/.test(key);\n\t\t\tif (!isObjectItem && !isArrayKey) {\n\t\t\t\treturn `$${key}`;\n\t\t\t}\n\t\t\tconst arrayElement = isArrayKey ? objectAttr(items, key) : undefined;\n\t\t\tconst value = isObjectItem ? objectAttr(items[0], key, arrayElement) : arrayElement;\n\t\t\treturn objDisplay(value, { truncate: runner === null || runner === void 0 || (_runner$config = runner.config) === null || _runner$config === void 0 || (_runner$config = _runner$config.chaiConfig) === null || _runner$config === void 0 ? void 0 : _runner$config.truncateThreshold });\n\t\t});\n\t}\n\tlet output = \"\";\n\tlet i = 0;\n\thandleRegexMatch(\n\t\ttemplate,\n\t\tformatRegExp,\n\t\t// format \"%\"\n\t\t(match) => {\n\t\t\tif (i < count) {\n\t\t\t\toutput += format(match[0], items[i++]);\n\t\t\t} else {\n\t\t\t\toutput += match[0];\n\t\t\t}\n\t\t},\n\t\t// format \"$\"\n\t\t(nonMatch) => {\n\t\t\toutput += formatAttribute(nonMatch);\n\t\t}\n\t);\n\treturn output;\n}\n// based on https://github.com/unocss/unocss/blob/2e74b31625bbe3b9c8351570749aa2d3f799d919/packages/autocomplete/src/parse.ts#L11\nfunction handleRegexMatch(input, regex, onMatch, onNonMatch) {\n\tlet lastIndex = 0;\n\tfor (const m of input.matchAll(regex)) {\n\t\tif (lastIndex < m.index) {\n\t\t\tonNonMatch(input.slice(lastIndex, m.index));\n\t\t}\n\t\tonMatch(m);\n\t\tlastIndex = m.index + m[0].length;\n\t}\n\tif (lastIndex < input.length) {\n\t\tonNonMatch(input.slice(lastIndex));\n\t}\n}\nfunction formatTemplateString(cases, args) {\n\tconst header = cases.join(\"\").trim().replace(/ /g, \"\").split(\"\\n\").map((i) => i.split(\"|\"))[0];\n\tconst res = [];\n\tfor (let i = 0; i < Math.floor(args.length / header.length); i++) {\n\t\tconst oneCase = {};\n\t\tfor (let j = 0; j < header.length; j++) {\n\t\t\toneCase[header[j]] = args[i * header.length + j];\n\t\t}\n\t\tres.push(oneCase);\n\t}\n\treturn res;\n}\n\nconst now$2 = Date.now;\nconst collectorContext = {\n\ttasks: [],\n\tcurrentSuite: null\n};\nfunction collectTask(task) {\n\tvar _collectorContext$cur;\n\t(_collectorContext$cur = collectorContext.currentSuite) === null || _collectorContext$cur === void 0 ? void 0 : _collectorContext$cur.tasks.push(task);\n}\nasync function runWithSuite(suite, fn) {\n\tconst prev = collectorContext.currentSuite;\n\tcollectorContext.currentSuite = suite;\n\tawait fn();\n\tcollectorContext.currentSuite = prev;\n}\nfunction withTimeout(fn, timeout, isHook = false, stackTraceError, onTimeout) {\n\tif (timeout <= 0 || timeout === Number.POSITIVE_INFINITY) {\n\t\treturn fn;\n\t}\n\tconst { setTimeout, clearTimeout } = getSafeTimers();\n\t// this function name is used to filter error in test/cli/test/fails.test.ts\n\treturn (function runWithTimeout(...args) {\n\t\tconst startTime = now$2();\n\t\tconst runner = getRunner();\n\t\trunner._currentTaskStartTime = startTime;\n\t\trunner._currentTaskTimeout = timeout;\n\t\treturn new Promise((resolve_, reject_) => {\n\t\t\tvar _timer$unref;\n\t\t\tconst timer = setTimeout(() => {\n\t\t\t\tclearTimeout(timer);\n\t\t\t\trejectTimeoutError();\n\t\t\t}, timeout);\n\t\t\t// `unref` might not exist in browser\n\t\t\t(_timer$unref = timer.unref) === null || _timer$unref === void 0 ? void 0 : _timer$unref.call(timer);\n\t\t\tfunction rejectTimeoutError() {\n\t\t\t\tconst error = makeTimeoutError(isHook, timeout, stackTraceError);\n\t\t\t\tonTimeout === null || onTimeout === void 0 ? void 0 : onTimeout(args, error);\n\t\t\t\treject_(error);\n\t\t\t}\n\t\t\tfunction resolve(result) {\n\t\t\t\trunner._currentTaskStartTime = undefined;\n\t\t\t\trunner._currentTaskTimeout = undefined;\n\t\t\t\tclearTimeout(timer);\n\t\t\t\t// if test/hook took too long in microtask, setTimeout won't be triggered,\n\t\t\t\t// but we still need to fail the test, see\n\t\t\t\t// https://github.com/vitest-dev/vitest/issues/2920\n\t\t\t\tif (now$2() - startTime >= timeout) {\n\t\t\t\t\trejectTimeoutError();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolve_(result);\n\t\t\t}\n\t\t\tfunction reject(error) {\n\t\t\t\trunner._currentTaskStartTime = undefined;\n\t\t\t\trunner._currentTaskTimeout = undefined;\n\t\t\t\tclearTimeout(timer);\n\t\t\t\treject_(error);\n\t\t\t}\n\t\t\t// sync test/hook will be caught by try/catch\n\t\t\ttry {\n\t\t\t\tconst result = fn(...args);\n\t\t\t\t// the result is a thenable, we don't wrap this in Promise.resolve\n\t\t\t\t// to avoid creating new promises\n\t\t\t\tif (typeof result === \"object\" && result != null && typeof result.then === \"function\") {\n\t\t\t\t\tresult.then(resolve, reject);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t} \n\t\t\t// user sync test/hook throws an error\ncatch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t});\n}\nconst abortControllers = new WeakMap();\nfunction abortIfTimeout([context], error) {\n\tif (context) {\n\t\tabortContextSignal(context, error);\n\t}\n}\nfunction abortContextSignal(context, error) {\n\tconst abortController = abortControllers.get(context);\n\tabortController === null || abortController === void 0 ? void 0 : abortController.abort(error);\n}\nfunction createTestContext(test, runner) {\n\tvar _runner$extendTaskCon;\n\tconst context = function() {\n\t\tthrow new Error(\"done() callback is deprecated, use promise instead\");\n\t};\n\tlet abortController = abortControllers.get(context);\n\tif (!abortController) {\n\t\tabortController = new AbortController();\n\t\tabortControllers.set(context, abortController);\n\t}\n\tcontext.signal = abortController.signal;\n\tcontext.task = test;\n\tcontext.skip = (condition, note) => {\n\t\tif (condition === false) {\n\t\t\t// do nothing\n\t\t\treturn undefined;\n\t\t}\n\t\ttest.result ?? (test.result = { state: \"skip\" });\n\t\ttest.result.pending = true;\n\t\tthrow new PendingError(\"test is skipped; abort execution\", test, typeof condition === \"string\" ? condition : note);\n\t};\n\tcontext.annotate = ((message, type, attachment) => {\n\t\tif (test.result && test.result.state !== \"run\") {\n\t\t\tthrow new Error(`Cannot annotate tests outside of the test run. The test \"${test.name}\" finished running with the \"${test.result.state}\" state already.`);\n\t\t}\n\t\tconst annotation = {\n\t\t\tmessage,\n\t\t\ttype: typeof type === \"object\" || type === undefined ? \"notice\" : type\n\t\t};\n\t\tconst annotationAttachment = typeof type === \"object\" ? type : attachment;\n\t\tif (annotationAttachment) {\n\t\t\tannotation.attachment = annotationAttachment;\n\t\t\tmanageArtifactAttachment(annotation.attachment);\n\t\t}\n\t\treturn recordAsyncOperation(test, recordArtifact(test, {\n\t\t\ttype: \"internal:annotation\",\n\t\t\tannotation\n\t\t}).then(async ({ annotation }) => {\n\t\t\tif (!runner.onTestAnnotate) {\n\t\t\t\tthrow new Error(`Test runner doesn't support test annotations.`);\n\t\t\t}\n\t\t\tawait finishSendTasksUpdate(runner);\n\t\t\tconst resolvedAnnotation = await runner.onTestAnnotate(test, annotation);\n\t\t\ttest.annotations.push(resolvedAnnotation);\n\t\t\treturn resolvedAnnotation;\n\t\t}));\n\t});\n\tcontext.onTestFailed = (handler, timeout) => {\n\t\ttest.onFailed || (test.onFailed = []);\n\t\ttest.onFailed.push(withTimeout(handler, timeout ?? runner.config.hookTimeout, true, new Error(\"STACK_TRACE_ERROR\"), (_, error) => abortController.abort(error)));\n\t};\n\tcontext.onTestFinished = (handler, timeout) => {\n\t\ttest.onFinished || (test.onFinished = []);\n\t\ttest.onFinished.push(withTimeout(handler, timeout ?? runner.config.hookTimeout, true, new Error(\"STACK_TRACE_ERROR\"), (_, error) => abortController.abort(error)));\n\t};\n\treturn ((_runner$extendTaskCon = runner.extendTaskContext) === null || _runner$extendTaskCon === void 0 ? void 0 : _runner$extendTaskCon.call(runner, context)) || context;\n}\nfunction makeTimeoutError(isHook, timeout, stackTraceError) {\n\tconst message = `${isHook ? \"Hook\" : \"Test\"} timed out in ${timeout}ms.\\nIf this is a long-running ${isHook ? \"hook\" : \"test\"}, pass a timeout value as the last argument or configure it globally with \"${isHook ? \"hookTimeout\" : \"testTimeout\"}\".`;\n\tconst error = new Error(message);\n\tif (stackTraceError === null || stackTraceError === void 0 ? void 0 : stackTraceError.stack) {\n\t\terror.stack = stackTraceError.stack.replace(error.message, stackTraceError.message);\n\t}\n\treturn error;\n}\nconst fileContexts = new WeakMap();\nfunction getFileContext(file) {\n\tconst context = fileContexts.get(file);\n\tif (!context) {\n\t\tthrow new Error(`Cannot find file context for ${file.name}`);\n\t}\n\treturn context;\n}\nfunction setFileContext(file, context) {\n\tfileContexts.set(file, context);\n}\n\nasync function runSetupFiles(config, files, runner) {\n\tif (config.sequence.setupFiles === \"parallel\") {\n\t\tawait Promise.all(files.map(async (fsPath) => {\n\t\t\tawait runner.importFile(fsPath, \"setup\");\n\t\t}));\n\t} else {\n\t\tfor (const fsPath of files) {\n\t\t\tawait runner.importFile(fsPath, \"setup\");\n\t\t}\n\t}\n}\n\nconst now$1 = globalThis.performance ? globalThis.performance.now.bind(globalThis.performance) : Date.now;\nasync function collectTests(specs, runner) {\n\tconst files = [];\n\tconst config = runner.config;\n\tconst $ = runner.trace;\n\tfor (const spec of specs) {\n\t\tconst filepath = typeof spec === \"string\" ? spec : spec.filepath;\n\t\tawait $(\"collect_spec\", { \"code.file.path\": filepath }, async () => {\n\t\t\tvar _runner$onCollectStar;\n\t\t\tconst testLocations = typeof spec === \"string\" ? undefined : spec.testLocations;\n\t\t\tconst file = createFileTask(filepath, config.root, config.name, runner.pool, runner.viteEnvironment);\n\t\t\tsetFileContext(file, Object.create(null));\n\t\t\tfile.shuffle = config.sequence.shuffle;\n\t\t\t(_runner$onCollectStar = runner.onCollectStart) === null || _runner$onCollectStar === void 0 ? void 0 : _runner$onCollectStar.call(runner, file);\n\t\t\tclearCollectorContext(file, runner);\n\t\t\ttry {\n\t\t\t\tvar _runner$getImportDura;\n\t\t\t\tconst setupFiles = toArray(config.setupFiles);\n\t\t\t\tif (setupFiles.length) {\n\t\t\t\t\tconst setupStart = now$1();\n\t\t\t\t\tawait runSetupFiles(config, setupFiles, runner);\n\t\t\t\t\tconst setupEnd = now$1();\n\t\t\t\t\tfile.setupDuration = setupEnd - setupStart;\n\t\t\t\t} else {\n\t\t\t\t\tfile.setupDuration = 0;\n\t\t\t\t}\n\t\t\t\tconst collectStart = now$1();\n\t\t\t\tawait runner.importFile(filepath, \"collect\");\n\t\t\t\tconst durations = (_runner$getImportDura = runner.getImportDurations) === null || _runner$getImportDura === void 0 ? void 0 : _runner$getImportDura.call(runner);\n\t\t\t\tif (durations) {\n\t\t\t\t\tfile.importDurations = durations;\n\t\t\t\t}\n\t\t\t\tconst defaultTasks = await getDefaultSuite().collect(file);\n\t\t\t\tconst fileHooks = createSuiteHooks();\n\t\t\t\tmergeHooks(fileHooks, getHooks(defaultTasks));\n\t\t\t\tfor (const c of [...defaultTasks.tasks, ...collectorContext.tasks]) {\n\t\t\t\t\tif (c.type === \"test\" || c.type === \"suite\") {\n\t\t\t\t\t\tfile.tasks.push(c);\n\t\t\t\t\t} else if (c.type === \"collector\") {\n\t\t\t\t\t\tconst suite = await c.collect(file);\n\t\t\t\t\t\tif (suite.name || suite.tasks.length) {\n\t\t\t\t\t\t\tmergeHooks(fileHooks, getHooks(suite));\n\t\t\t\t\t\t\tfile.tasks.push(suite);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// check that types are exhausted\n\t\t\t\t\t\tc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsetHooks(file, fileHooks);\n\t\t\t\tfile.collectDuration = now$1() - collectStart;\n\t\t\t} catch (e) {\n\t\t\t\tvar _runner$getImportDura2;\n\t\t\t\tconst error = processError(e);\n\t\t\t\tfile.result = {\n\t\t\t\t\tstate: \"fail\",\n\t\t\t\t\terrors: [error]\n\t\t\t\t};\n\t\t\t\tconst durations = (_runner$getImportDura2 = runner.getImportDurations) === null || _runner$getImportDura2 === void 0 ? void 0 : _runner$getImportDura2.call(runner);\n\t\t\t\tif (durations) {\n\t\t\t\t\tfile.importDurations = durations;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcalculateSuiteHash(file);\n\t\t\tconst hasOnlyTasks = someTasksAreOnly(file);\n\t\t\tinterpretTaskModes(file, config.testNamePattern, testLocations, hasOnlyTasks, false, config.allowOnly);\n\t\t\tif (file.mode === \"queued\") {\n\t\t\t\tfile.mode = \"run\";\n\t\t\t}\n\t\t\tfiles.push(file);\n\t\t});\n\t}\n\treturn files;\n}\nfunction mergeHooks(baseHooks, hooks) {\n\tfor (const _key in hooks) {\n\t\tconst key = _key;\n\t\tbaseHooks[key].push(...hooks[key]);\n\t}\n\treturn baseHooks;\n}\n\nconst now = globalThis.performance ? globalThis.performance.now.bind(globalThis.performance) : Date.now;\nconst unixNow = Date.now;\nconst { clearTimeout, setTimeout } = getSafeTimers();\nfunction updateSuiteHookState(task, name, state, runner) {\n\tif (!task.result) {\n\t\ttask.result = { state: \"run\" };\n\t}\n\tif (!task.result.hooks) {\n\t\ttask.result.hooks = {};\n\t}\n\tconst suiteHooks = task.result.hooks;\n\tif (suiteHooks) {\n\t\tsuiteHooks[name] = state;\n\t\tlet event = state === \"run\" ? \"before-hook-start\" : \"before-hook-end\";\n\t\tif (name === \"afterAll\" || name === \"afterEach\") {\n\t\t\tevent = state === \"run\" ? \"after-hook-start\" : \"after-hook-end\";\n\t\t}\n\t\tupdateTask(event, task, runner);\n\t}\n}\nfunction getSuiteHooks(suite, name, sequence) {\n\tconst hooks = getHooks(suite)[name];\n\tif (sequence === \"stack\" && (name === \"afterAll\" || name === \"afterEach\")) {\n\t\treturn hooks.slice().reverse();\n\t}\n\treturn hooks;\n}\nasync function callTestHooks(runner, test, hooks, sequence) {\n\tif (sequence === \"stack\") {\n\t\thooks = hooks.slice().reverse();\n\t}\n\tif (!hooks.length) {\n\t\treturn;\n\t}\n\tconst context = test.context;\n\tconst onTestFailed = test.context.onTestFailed;\n\tconst onTestFinished = test.context.onTestFinished;\n\tcontext.onTestFailed = () => {\n\t\tthrow new Error(`Cannot call \"onTestFailed\" inside a test hook.`);\n\t};\n\tcontext.onTestFinished = () => {\n\t\tthrow new Error(`Cannot call \"onTestFinished\" inside a test hook.`);\n\t};\n\tif (sequence === \"parallel\") {\n\t\ttry {\n\t\t\tawait Promise.all(hooks.map((fn) => fn(test.context)));\n\t\t} catch (e) {\n\t\t\tfailTask(test.result, e, runner.config.diffOptions);\n\t\t}\n\t} else {\n\t\tfor (const fn of hooks) {\n\t\t\ttry {\n\t\t\t\tawait fn(test.context);\n\t\t\t} catch (e) {\n\t\t\t\tfailTask(test.result, e, runner.config.diffOptions);\n\t\t\t}\n\t\t}\n\t}\n\tcontext.onTestFailed = onTestFailed;\n\tcontext.onTestFinished = onTestFinished;\n}\nasync function callSuiteHook(suite, currentTask, name, runner, args) {\n\tconst sequence = runner.config.sequence.hooks;\n\tconst callbacks = [];\n\t// stop at file level\n\tconst parentSuite = \"filepath\" in suite ? null : suite.suite || suite.file;\n\tif (name === \"beforeEach\" && parentSuite) {\n\t\tcallbacks.push(...await callSuiteHook(parentSuite, currentTask, name, runner, args));\n\t}\n\tconst hooks = getSuiteHooks(suite, name, sequence);\n\tif (hooks.length > 0) {\n\t\tupdateSuiteHookState(currentTask, name, \"run\", runner);\n\t}\n\tasync function runHook(hook) {\n\t\treturn getBeforeHookCleanupCallback(hook, await hook(...args), name === \"beforeEach\" ? args[0] : undefined);\n\t}\n\tif (sequence === \"parallel\") {\n\t\tcallbacks.push(...await Promise.all(hooks.map((hook) => runHook(hook))));\n\t} else {\n\t\tfor (const hook of hooks) {\n\t\t\tcallbacks.push(await runHook(hook));\n\t\t}\n\t}\n\tif (hooks.length > 0) {\n\t\tupdateSuiteHookState(currentTask, name, \"pass\", runner);\n\t}\n\tif (name === \"afterEach\" && parentSuite) {\n\t\tcallbacks.push(...await callSuiteHook(parentSuite, currentTask, name, runner, args));\n\t}\n\treturn callbacks;\n}\nconst packs = new Map();\nconst eventsPacks = [];\nconst pendingTasksUpdates = [];\nfunction sendTasksUpdate(runner) {\n\tif (packs.size) {\n\t\tvar _runner$onTaskUpdate;\n\t\tconst taskPacks = Array.from(packs).map(([id, task]) => {\n\t\t\treturn [\n\t\t\t\tid,\n\t\t\t\ttask[0],\n\t\t\t\ttask[1]\n\t\t\t];\n\t\t});\n\t\tconst p = (_runner$onTaskUpdate = runner.onTaskUpdate) === null || _runner$onTaskUpdate === void 0 ? void 0 : _runner$onTaskUpdate.call(runner, taskPacks, eventsPacks);\n\t\tif (p) {\n\t\t\tpendingTasksUpdates.push(p);\n\t\t\t// remove successful promise to not grow array indefnitely,\n\t\t\t// but keep rejections so finishSendTasksUpdate can handle them\n\t\t\tp.then(() => pendingTasksUpdates.splice(pendingTasksUpdates.indexOf(p), 1), () => {});\n\t\t}\n\t\teventsPacks.length = 0;\n\t\tpacks.clear();\n\t}\n}\nasync function finishSendTasksUpdate(runner) {\n\tsendTasksUpdate(runner);\n\tawait Promise.all(pendingTasksUpdates);\n}\nfunction throttle(fn, ms) {\n\tlet last = 0;\n\tlet pendingCall;\n\treturn function call(...args) {\n\t\tconst now = unixNow();\n\t\tif (now - last > ms) {\n\t\t\tlast = now;\n\t\t\tclearTimeout(pendingCall);\n\t\t\tpendingCall = undefined;\n\t\t\treturn fn.apply(this, args);\n\t\t}\n\t\t// Make sure fn is still called even if there are no further calls\n\t\tpendingCall ?? (pendingCall = setTimeout(() => call.bind(this)(...args), ms));\n\t};\n}\n// throttle based on summary reporter's DURATION_UPDATE_INTERVAL_MS\nconst sendTasksUpdateThrottled = throttle(sendTasksUpdate, 100);\nfunction updateTask(event, task, runner) {\n\teventsPacks.push([\n\t\ttask.id,\n\t\tevent,\n\t\tundefined\n\t]);\n\tpacks.set(task.id, [task.result, task.meta]);\n\tsendTasksUpdateThrottled(runner);\n}\nasync function callCleanupHooks(runner, cleanups) {\n\tconst sequence = runner.config.sequence.hooks;\n\tif (sequence === \"stack\") {\n\t\tcleanups = cleanups.slice().reverse();\n\t}\n\tif (sequence === \"parallel\") {\n\t\tawait Promise.all(cleanups.map(async (fn) => {\n\t\t\tif (typeof fn !== \"function\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tawait fn();\n\t\t}));\n\t} else {\n\t\tfor (const fn of cleanups) {\n\t\t\tif (typeof fn !== \"function\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tawait fn();\n\t\t}\n\t}\n}\nasync function runTest(test, runner) {\n\tvar _runner$onBeforeRunTa, _test$result, _runner$onAfterRunTas;\n\tawait ((_runner$onBeforeRunTa = runner.onBeforeRunTask) === null || _runner$onBeforeRunTa === void 0 ? void 0 : _runner$onBeforeRunTa.call(runner, test));\n\tif (test.mode !== \"run\" && test.mode !== \"queued\") {\n\t\tupdateTask(\"test-prepare\", test, runner);\n\t\tupdateTask(\"test-finished\", test, runner);\n\t\treturn;\n\t}\n\tif (((_test$result = test.result) === null || _test$result === void 0 ? void 0 : _test$result.state) === \"fail\") {\n\t\t// should not be possible to get here, I think this is just copy pasted from suite\n\t\t// TODO: maybe someone fails tests in `beforeAll` hooks?\n\t\t// https://github.com/vitest-dev/vitest/pull/7069\n\t\tupdateTask(\"test-failed-early\", test, runner);\n\t\treturn;\n\t}\n\tconst start = now();\n\ttest.result = {\n\t\tstate: \"run\",\n\t\tstartTime: unixNow(),\n\t\tretryCount: 0\n\t};\n\tupdateTask(\"test-prepare\", test, runner);\n\tconst cleanupRunningTest = addRunningTest(test);\n\tsetCurrentTest(test);\n\tconst suite = test.suite || test.file;\n\tconst $ = runner.trace;\n\tconst repeats = test.repeats ?? 0;\n\tfor (let repeatCount = 0; repeatCount <= repeats; repeatCount++) {\n\t\tconst retry = test.retry ?? 0;\n\t\tfor (let retryCount = 0; retryCount <= retry; retryCount++) {\n\t\t\tvar _test$onFinished, _test$onFailed, _runner$onAfterRetryT, _test$result2, _test$result3;\n\t\t\tlet beforeEachCleanups = [];\n\t\t\ttry {\n\t\t\t\tvar _runner$onBeforeTryTa, _runner$onAfterTryTas;\n\t\t\t\tawait ((_runner$onBeforeTryTa = runner.onBeforeTryTask) === null || _runner$onBeforeTryTa === void 0 ? void 0 : _runner$onBeforeTryTa.call(runner, test, {\n\t\t\t\t\tretry: retryCount,\n\t\t\t\t\trepeats: repeatCount\n\t\t\t\t}));\n\t\t\t\ttest.result.repeatCount = repeatCount;\n\t\t\t\tbeforeEachCleanups = await $(\"test.beforeEach\", () => callSuiteHook(suite, test, \"beforeEach\", runner, [test.context, suite]));\n\t\t\t\tif (runner.runTask) {\n\t\t\t\t\tawait $(\"test.callback\", () => runner.runTask(test));\n\t\t\t\t} else {\n\t\t\t\t\tconst fn = getFn(test);\n\t\t\t\t\tif (!fn) {\n\t\t\t\t\t\tthrow new Error(\"Test function is not found. Did you add it using `setFn`?\");\n\t\t\t\t\t}\n\t\t\t\t\tawait $(\"test.callback\", () => fn());\n\t\t\t\t}\n\t\t\t\tawait ((_runner$onAfterTryTas = runner.onAfterTryTask) === null || _runner$onAfterTryTas === void 0 ? void 0 : _runner$onAfterTryTas.call(runner, test, {\n\t\t\t\t\tretry: retryCount,\n\t\t\t\t\trepeats: repeatCount\n\t\t\t\t}));\n\t\t\t\tif (test.result.state !== \"fail\") {\n\t\t\t\t\tif (!test.repeats) {\n\t\t\t\t\t\ttest.result.state = \"pass\";\n\t\t\t\t\t} else if (test.repeats && retry === retryCount) {\n\t\t\t\t\t\ttest.result.state = \"pass\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tfailTask(test.result, e, runner.config.diffOptions);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tvar _runner$onTaskFinishe;\n\t\t\t\tawait ((_runner$onTaskFinishe = runner.onTaskFinished) === null || _runner$onTaskFinishe === void 0 ? void 0 : _runner$onTaskFinishe.call(runner, test));\n\t\t\t} catch (e) {\n\t\t\t\tfailTask(test.result, e, runner.config.diffOptions);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tawait $(\"test.afterEach\", () => callSuiteHook(suite, test, \"afterEach\", runner, [test.context, suite]));\n\t\t\t\tif (beforeEachCleanups.length) {\n\t\t\t\t\tawait $(\"test.cleanup\", () => callCleanupHooks(runner, beforeEachCleanups));\n\t\t\t\t}\n\t\t\t\tawait callFixtureCleanup(test.context);\n\t\t\t} catch (e) {\n\t\t\t\tfailTask(test.result, e, runner.config.diffOptions);\n\t\t\t}\n\t\t\tif ((_test$onFinished = test.onFinished) === null || _test$onFinished === void 0 ? void 0 : _test$onFinished.length) {\n\t\t\t\tawait $(\"test.onFinished\", () => callTestHooks(runner, test, test.onFinished, \"stack\"));\n\t\t\t}\n\t\t\tif (test.result.state === \"fail\" && ((_test$onFailed = test.onFailed) === null || _test$onFailed === void 0 ? void 0 : _test$onFailed.length)) {\n\t\t\t\tawait $(\"test.onFailed\", () => callTestHooks(runner, test, test.onFailed, runner.config.sequence.hooks));\n\t\t\t}\n\t\t\ttest.onFailed = undefined;\n\t\t\ttest.onFinished = undefined;\n\t\t\tawait ((_runner$onAfterRetryT = runner.onAfterRetryTask) === null || _runner$onAfterRetryT === void 0 ? void 0 : _runner$onAfterRetryT.call(runner, test, {\n\t\t\t\tretry: retryCount,\n\t\t\t\trepeats: repeatCount\n\t\t\t}));\n\t\t\t// skipped with new PendingError\n\t\t\tif (((_test$result2 = test.result) === null || _test$result2 === void 0 ? void 0 : _test$result2.pending) || ((_test$result3 = test.result) === null || _test$result3 === void 0 ? void 0 : _test$result3.state) === \"skip\") {\n\t\t\t\tvar _test$result4;\n\t\t\t\ttest.mode = \"skip\";\n\t\t\t\ttest.result = {\n\t\t\t\t\tstate: \"skip\",\n\t\t\t\t\tnote: (_test$result4 = test.result) === null || _test$result4 === void 0 ? void 0 : _test$result4.note,\n\t\t\t\t\tpending: true,\n\t\t\t\t\tduration: now() - start\n\t\t\t\t};\n\t\t\t\tupdateTask(\"test-finished\", test, runner);\n\t\t\t\tsetCurrentTest(undefined);\n\t\t\t\tcleanupRunningTest();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (test.result.state === \"pass\") {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (retryCount < retry) {\n\t\t\t\t// reset state when retry test\n\t\t\t\ttest.result.state = \"run\";\n\t\t\t\ttest.result.retryCount = (test.result.retryCount ?? 0) + 1;\n\t\t\t}\n\t\t\t// update retry info\n\t\t\tupdateTask(\"test-retried\", test, runner);\n\t\t}\n\t}\n\t// if test is marked to be failed, flip the result\n\tif (test.fails) {\n\t\tif (test.result.state === \"pass\") {\n\t\t\tconst error = processError(new Error(\"Expect test to fail\"));\n\t\t\ttest.result.state = \"fail\";\n\t\t\ttest.result.errors = [error];\n\t\t} else {\n\t\t\ttest.result.state = \"pass\";\n\t\t\ttest.result.errors = undefined;\n\t\t}\n\t}\n\tcleanupRunningTest();\n\tsetCurrentTest(undefined);\n\ttest.result.duration = now() - start;\n\tawait ((_runner$onAfterRunTas = runner.onAfterRunTask) === null || _runner$onAfterRunTas === void 0 ? void 0 : _runner$onAfterRunTas.call(runner, test));\n\tupdateTask(\"test-finished\", test, runner);\n}\nfunction failTask(result, err, diffOptions) {\n\tif (err instanceof PendingError) {\n\t\tresult.state = \"skip\";\n\t\tresult.note = err.note;\n\t\tresult.pending = true;\n\t\treturn;\n\t}\n\tresult.state = \"fail\";\n\tconst errors = Array.isArray(err) ? err : [err];\n\tfor (const e of errors) {\n\t\tconst error = processError(e, diffOptions);\n\t\tresult.errors ?? (result.errors = []);\n\t\tresult.errors.push(error);\n\t}\n}\nfunction markTasksAsSkipped(suite, runner) {\n\tsuite.tasks.forEach((t) => {\n\t\tt.mode = \"skip\";\n\t\tt.result = {\n\t\t\t...t.result,\n\t\t\tstate: \"skip\"\n\t\t};\n\t\tupdateTask(\"test-finished\", t, runner);\n\t\tif (t.type === \"suite\") {\n\t\t\tmarkTasksAsSkipped(t, runner);\n\t\t}\n\t});\n}\nasync function runSuite(suite, runner) {\n\tvar _runner$onBeforeRunSu, _suite$result;\n\tawait ((_runner$onBeforeRunSu = runner.onBeforeRunSuite) === null || _runner$onBeforeRunSu === void 0 ? void 0 : _runner$onBeforeRunSu.call(runner, suite));\n\tif (((_suite$result = suite.result) === null || _suite$result === void 0 ? void 0 : _suite$result.state) === \"fail\") {\n\t\tmarkTasksAsSkipped(suite, runner);\n\t\t// failed during collection\n\t\tupdateTask(\"suite-failed-early\", suite, runner);\n\t\treturn;\n\t}\n\tconst start = now();\n\tconst mode = suite.mode;\n\tsuite.result = {\n\t\tstate: mode === \"skip\" || mode === \"todo\" ? mode : \"run\",\n\t\tstartTime: unixNow()\n\t};\n\tconst $ = runner.trace;\n\tupdateTask(\"suite-prepare\", suite, runner);\n\tlet beforeAllCleanups = [];\n\tif (suite.mode === \"skip\") {\n\t\tsuite.result.state = \"skip\";\n\t\tupdateTask(\"suite-finished\", suite, runner);\n\t} else if (suite.mode === \"todo\") {\n\t\tsuite.result.state = \"todo\";\n\t\tupdateTask(\"suite-finished\", suite, runner);\n\t} else {\n\t\tvar _runner$onAfterRunSui;\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tbeforeAllCleanups = await $(\"suite.beforeAll\", () => callSuiteHook(suite, suite, \"beforeAll\", runner, [suite]));\n\t\t\t} catch (e) {\n\t\t\t\tmarkTasksAsSkipped(suite, runner);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tif (runner.runSuite) {\n\t\t\t\tawait runner.runSuite(suite);\n\t\t\t} else {\n\t\t\t\tfor (let tasksGroup of partitionSuiteChildren(suite)) {\n\t\t\t\t\tif (tasksGroup[0].concurrent === true) {\n\t\t\t\t\t\tawait Promise.all(tasksGroup.map((c) => runSuiteChild(c, runner)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst { sequence } = runner.config;\n\t\t\t\t\t\tif (suite.shuffle) {\n\t\t\t\t\t\t\t// run describe block independently from tests\n\t\t\t\t\t\t\tconst suites = tasksGroup.filter((group) => group.type === \"suite\");\n\t\t\t\t\t\t\tconst tests = tasksGroup.filter((group) => group.type === \"test\");\n\t\t\t\t\t\t\tconst groups = shuffle([suites, tests], sequence.seed);\n\t\t\t\t\t\t\ttasksGroup = groups.flatMap((group) => shuffle(group, sequence.seed));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const c of tasksGroup) {\n\t\t\t\t\t\t\tawait runSuiteChild(c, runner);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tfailTask(suite.result, e, runner.config.diffOptions);\n\t\t}\n\t\ttry {\n\t\t\tawait $(\"suite.afterAll\", () => callSuiteHook(suite, suite, \"afterAll\", runner, [suite]));\n\t\t\tif (beforeAllCleanups.length) {\n\t\t\t\tawait $(\"suite.cleanup\", () => callCleanupHooks(runner, beforeAllCleanups));\n\t\t\t}\n\t\t\tif (suite.file === suite) {\n\t\t\t\tconst context = getFileContext(suite);\n\t\t\t\tawait callFixtureCleanup(context);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tfailTask(suite.result, e, runner.config.diffOptions);\n\t\t}\n\t\tif (suite.mode === \"run\" || suite.mode === \"queued\") {\n\t\t\tif (!runner.config.passWithNoTests && !hasTests(suite)) {\n\t\t\t\tvar _suite$result$errors;\n\t\t\t\tsuite.result.state = \"fail\";\n\t\t\t\tif (!((_suite$result$errors = suite.result.errors) === null || _suite$result$errors === void 0 ? void 0 : _suite$result$errors.length)) {\n\t\t\t\t\tconst error = processError(new Error(`No test found in suite ${suite.name}`));\n\t\t\t\t\tsuite.result.errors = [error];\n\t\t\t\t}\n\t\t\t} else if (hasFailed(suite)) {\n\t\t\t\tsuite.result.state = \"fail\";\n\t\t\t} else {\n\t\t\t\tsuite.result.state = \"pass\";\n\t\t\t}\n\t\t}\n\t\tsuite.result.duration = now() - start;\n\t\tawait ((_runner$onAfterRunSui = runner.onAfterRunSuite) === null || _runner$onAfterRunSui === void 0 ? void 0 : _runner$onAfterRunSui.call(runner, suite));\n\t\tupdateTask(\"suite-finished\", suite, runner);\n\t}\n}\nlet limitMaxConcurrency;\nasync function runSuiteChild(c, runner) {\n\tconst $ = runner.trace;\n\tif (c.type === \"test\") {\n\t\treturn limitMaxConcurrency(() => {\n\t\t\tvar _c$location, _c$location2;\n\t\t\treturn $(\"run.test\", {\n\t\t\t\t\"vitest.test.id\": c.id,\n\t\t\t\t\"vitest.test.name\": c.name,\n\t\t\t\t\"vitest.test.mode\": c.mode,\n\t\t\t\t\"vitest.test.timeout\": c.timeout,\n\t\t\t\t\"code.file.path\": c.file.filepath,\n\t\t\t\t\"code.line.number\": (_c$location = c.location) === null || _c$location === void 0 ? void 0 : _c$location.line,\n\t\t\t\t\"code.column.number\": (_c$location2 = c.location) === null || _c$location2 === void 0 ? void 0 : _c$location2.column\n\t\t\t}, () => runTest(c, runner));\n\t\t});\n\t} else if (c.type === \"suite\") {\n\t\tvar _c$location3, _c$location4;\n\t\treturn $(\"run.suite\", {\n\t\t\t\"vitest.suite.id\": c.id,\n\t\t\t\"vitest.suite.name\": c.name,\n\t\t\t\"vitest.suite.mode\": c.mode,\n\t\t\t\"code.file.path\": c.file.filepath,\n\t\t\t\"code.line.number\": (_c$location3 = c.location) === null || _c$location3 === void 0 ? void 0 : _c$location3.line,\n\t\t\t\"code.column.number\": (_c$location4 = c.location) === null || _c$location4 === void 0 ? void 0 : _c$location4.column\n\t\t}, () => runSuite(c, runner));\n\t}\n}\nasync function runFiles(files, runner) {\n\tlimitMaxConcurrency ?? (limitMaxConcurrency = limitConcurrency(runner.config.maxConcurrency));\n\tfor (const file of files) {\n\t\tif (!file.tasks.length && !runner.config.passWithNoTests) {\n\t\t\tvar _file$result;\n\t\t\tif (!((_file$result = file.result) === null || _file$result === void 0 || (_file$result = _file$result.errors) === null || _file$result === void 0 ? void 0 : _file$result.length)) {\n\t\t\t\tconst error = processError(new Error(`No test suite found in file ${file.filepath}`));\n\t\t\t\tfile.result = {\n\t\t\t\t\tstate: \"fail\",\n\t\t\t\t\terrors: [error]\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tawait runner.trace(\"run.spec\", {\n\t\t\t\"code.file.path\": file.filepath,\n\t\t\t\"vitest.suite.tasks.length\": file.tasks.length\n\t\t}, () => runSuite(file, runner));\n\t}\n}\nconst workerRunners = new WeakSet();\nfunction defaultTrace(_, attributes, cb) {\n\tif (typeof attributes === \"function\") {\n\t\treturn attributes();\n\t}\n\treturn cb();\n}\nasync function startTests(specs, runner) {\n\tvar _runner$cancel;\n\trunner.trace ?? (runner.trace = defaultTrace);\n\tconst cancel = (_runner$cancel = runner.cancel) === null || _runner$cancel === void 0 ? void 0 : _runner$cancel.bind(runner);\n\t// Ideally, we need to have an event listener for this, but only have a runner here.\n\t// Adding another onCancel felt wrong (maybe it needs to be refactored)\n\trunner.cancel = (reason) => {\n\t\t// We intentionally create only one error since there is only one test run that can be cancelled\n\t\tconst error = new TestRunAbortError(\"The test run was aborted by the user.\", reason);\n\t\tgetRunningTests().forEach((test) => abortContextSignal(test.context, error));\n\t\treturn cancel === null || cancel === void 0 ? void 0 : cancel(reason);\n\t};\n\tif (!workerRunners.has(runner)) {\n\t\tvar _runner$onCleanupWork;\n\t\t(_runner$onCleanupWork = runner.onCleanupWorkerContext) === null || _runner$onCleanupWork === void 0 ? void 0 : _runner$onCleanupWork.call(runner, async () => {\n\t\t\tvar _runner$getWorkerCont;\n\t\t\tconst context = (_runner$getWorkerCont = runner.getWorkerContext) === null || _runner$getWorkerCont === void 0 ? void 0 : _runner$getWorkerCont.call(runner);\n\t\t\tif (context) {\n\t\t\t\tawait callFixtureCleanup(context);\n\t\t\t}\n\t\t});\n\t\tworkerRunners.add(runner);\n\t}\n\ttry {\n\t\tvar _runner$onBeforeColle, _runner$onCollected, _runner$onBeforeRunFi, _runner$onAfterRunFil;\n\t\tconst paths = specs.map((f) => typeof f === \"string\" ? f : f.filepath);\n\t\tawait ((_runner$onBeforeColle = runner.onBeforeCollect) === null || _runner$onBeforeColle === void 0 ? void 0 : _runner$onBeforeColle.call(runner, paths));\n\t\tconst files = await collectTests(specs, runner);\n\t\tawait ((_runner$onCollected = runner.onCollected) === null || _runner$onCollected === void 0 ? void 0 : _runner$onCollected.call(runner, files));\n\t\tawait ((_runner$onBeforeRunFi = runner.onBeforeRunFiles) === null || _runner$onBeforeRunFi === void 0 ? void 0 : _runner$onBeforeRunFi.call(runner, files));\n\t\tawait runFiles(files, runner);\n\t\tawait ((_runner$onAfterRunFil = runner.onAfterRunFiles) === null || _runner$onAfterRunFil === void 0 ? void 0 : _runner$onAfterRunFil.call(runner, files));\n\t\tawait finishSendTasksUpdate(runner);\n\t\treturn files;\n\t} finally {\n\t\trunner.cancel = cancel;\n\t}\n}\nasync function publicCollect(specs, runner) {\n\tvar _runner$onBeforeColle2, _runner$onCollected2;\n\trunner.trace ?? (runner.trace = defaultTrace);\n\tconst paths = specs.map((f) => typeof f === \"string\" ? f : f.filepath);\n\tawait ((_runner$onBeforeColle2 = runner.onBeforeCollect) === null || _runner$onBeforeColle2 === void 0 ? void 0 : _runner$onBeforeColle2.call(runner, paths));\n\tconst files = await collectTests(specs, runner);\n\tawait ((_runner$onCollected2 = runner.onCollected) === null || _runner$onCollected2 === void 0 ? void 0 : _runner$onCollected2.call(runner, files));\n\treturn files;\n}\n\n/**\n* @experimental\n* @advanced\n*\n* Records a custom test artifact during test execution.\n*\n* This function allows you to attach structured data, files, or metadata to a test.\n*\n* Vitest automatically injects the source location where the artifact was created and manages any attachments you include.\n*\n* @param task - The test task context, typically accessed via `this.task` in custom matchers or `context.task` in tests\n* @param artifact - The artifact to record. Must extend {@linkcode TestArtifactBase}\n*\n* @returns A promise that resolves to the recorded artifact with location injected\n*\n* @throws {Error} If called after the test has finished running\n* @throws {Error} If the test runner doesn't support artifacts\n*\n* @example\n* ```ts\n* // In a custom assertion\n* async function toHaveValidSchema(this: MatcherState, actual: unknown) {\n*   const validation = validateSchema(actual)\n*\n*   await recordArtifact(this.task, {\n*     type: 'my-plugin:schema-validation',\n*     passed: validation.valid,\n*     errors: validation.errors,\n*   })\n*\n*   return { pass: validation.valid, message: () => '...' }\n* }\n* ```\n*/\nasync function recordArtifact(task, artifact) {\n\tconst runner = getRunner();\n\tif (task.result && task.result.state !== \"run\") {\n\t\tthrow new Error(`Cannot record a test artifact outside of the test run. The test \"${task.name}\" finished running with the \"${task.result.state}\" state already.`);\n\t}\n\tconst stack = findTestFileStackTrace(task.file.filepath, new Error(\"STACK_TRACE\").stack);\n\tif (stack) {\n\t\tartifact.location = {\n\t\t\tfile: stack.file,\n\t\t\tline: stack.line,\n\t\t\tcolumn: stack.column\n\t\t};\n\t\tif (artifact.type === \"internal:annotation\") {\n\t\t\tartifact.annotation.location = artifact.location;\n\t\t}\n\t}\n\tif (Array.isArray(artifact.attachments)) {\n\t\tfor (const attachment of artifact.attachments) {\n\t\t\tmanageArtifactAttachment(attachment);\n\t\t}\n\t}\n\t// annotations won't resolve as artifacts for backwards compatibility until next major\n\tif (artifact.type === \"internal:annotation\") {\n\t\treturn artifact;\n\t}\n\tif (!runner.onTestArtifactRecord) {\n\t\tthrow new Error(`Test runner doesn't support test artifacts.`);\n\t}\n\tawait finishSendTasksUpdate(runner);\n\tconst resolvedArtifact = await runner.onTestArtifactRecord(task, artifact);\n\ttask.artifacts.push(resolvedArtifact);\n\treturn resolvedArtifact;\n}\nconst table = [];\nfor (let i = 65; i < 91; i++) {\n\ttable.push(String.fromCharCode(i));\n}\nfor (let i = 97; i < 123; i++) {\n\ttable.push(String.fromCharCode(i));\n}\nfor (let i = 0; i < 10; i++) {\n\ttable.push(i.toString(10));\n}\ntable.push(\"+\", \"/\");\nfunction encodeUint8Array(bytes) {\n\tlet base64 = \"\";\n\tconst len = bytes.byteLength;\n\tfor (let i = 0; i < len; i += 3) {\n\t\tif (len === i + 1) {\n\t\t\tconst a = (bytes[i] & 252) >> 2;\n\t\t\tconst b = (bytes[i] & 3) << 4;\n\t\t\tbase64 += table[a];\n\t\t\tbase64 += table[b];\n\t\t\tbase64 += \"==\";\n\t\t} else if (len === i + 2) {\n\t\t\tconst a = (bytes[i] & 252) >> 2;\n\t\t\tconst b = (bytes[i] & 3) << 4 | (bytes[i + 1] & 240) >> 4;\n\t\t\tconst c = (bytes[i + 1] & 15) << 2;\n\t\t\tbase64 += table[a];\n\t\t\tbase64 += table[b];\n\t\t\tbase64 += table[c];\n\t\t\tbase64 += \"=\";\n\t\t} else {\n\t\t\tconst a = (bytes[i] & 252) >> 2;\n\t\t\tconst b = (bytes[i] & 3) << 4 | (bytes[i + 1] & 240) >> 4;\n\t\t\tconst c = (bytes[i + 1] & 15) << 2 | (bytes[i + 2] & 192) >> 6;\n\t\t\tconst d = bytes[i + 2] & 63;\n\t\t\tbase64 += table[a];\n\t\t\tbase64 += table[b];\n\t\t\tbase64 += table[c];\n\t\t\tbase64 += table[d];\n\t\t}\n\t}\n\treturn base64;\n}\n/**\n* Records an async operation associated with a test task.\n*\n* This function tracks promises that should be awaited before a test completes.\n* The promise is automatically removed from the test's promise list once it settles.\n*/\nfunction recordAsyncOperation(test, promise) {\n\t// if promise is explicitly awaited, remove it from the list\n\tpromise = promise.finally(() => {\n\t\tif (!test.promises) {\n\t\t\treturn;\n\t\t}\n\t\tconst index = test.promises.indexOf(promise);\n\t\tif (index !== -1) {\n\t\t\ttest.promises.splice(index, 1);\n\t\t}\n\t});\n\t// record promise\n\tif (!test.promises) {\n\t\ttest.promises = [];\n\t}\n\ttest.promises.push(promise);\n\treturn promise;\n}\n/**\n* Validates and prepares a test attachment for serialization.\n*\n* This function ensures attachments have either `body` or `path` set (but not both), and converts `Uint8Array` bodies to base64-encoded strings for easier serialization.\n*\n* @param attachment - The attachment to validate and prepare\n*\n* @throws {TypeError} If neither `body` nor `path` is provided\n* @throws {TypeError} If both `body` and `path` are provided\n*/\nfunction manageArtifactAttachment(attachment) {\n\tif (attachment.body == null && !attachment.path) {\n\t\tthrow new TypeError(`Test attachment requires \"body\" or \"path\" to be set. Both are missing.`);\n\t}\n\tif (attachment.body && attachment.path) {\n\t\tthrow new TypeError(`Test attachment requires only one of \"body\" or \"path\" to be set. Both are specified.`);\n\t}\n\t// convert to a string so it's easier to serialise\n\tif (attachment.body instanceof Uint8Array) {\n\t\tattachment.body = encodeUint8Array(attachment.body);\n\t}\n}\n\nexport { afterAll, afterEach, beforeAll, beforeEach, publicCollect as collectTests, createTaskCollector, describe, getCurrentSuite, getCurrentTest, getFn, getHooks, it, onTestFailed, onTestFinished, recordArtifact, setFn, setHooks, startTests, suite, test, updateTask };\n"],"names":["createChainable","keys","fn","create","context","chain","args","key","value","ctx","findTestFileStackTrace","testFilePath","error","lines","line","stack","parseSingleStack","getNames","task","names","current","createTaskName","separator","name","PendingError","message","note","__publicField","fnMap","testFixtureMap","hooksMap","setFn","setTestFixture","fixture","getTestFixture","setHooks","hooks","getHooks","mergeScopedFixtures","testFixtures","scopedFixtures","scopedFixturesMap","map","newFixtures","useFixture","fixtureKep","_fixture$deps","dep","mergeContextFixtures","fixtures","runner","fixtureOptionKeys","fixtureArray","prop","fixtureItem","isObject","_runner$injectValue","userValue","usedProps","getUsedProps","_fixture$deps2","fixtureValueMaps","cleanupFnArrayMap","withFixtures","testContext","hookContext","hasAutoFixture","auto","fixtureValueMap","cleanupFnArray","usedFixtures","pendingFixtures","resolveDeps","resolveFixtures","resolvedValue","resolveFixtureValue","globalFixturePromise","_runner$getWorkerCont","fileContext","getFileContext","workerContext","_fixture$prop","_fixture$prop2","resolveFixtureFunction","fixtureContext","cleanupFnFileArray","promise","fixtureFn","useFnArgPromise","createDefer","isUseFnArgResolved","fixtureReturn","useFnArg","useReturnPromise","e","depSet","d","fnString","filterOutComments","match","splitByComma","first","_first","props","last","s","result","commentState","i","start","token","lastToken","getDefaultHookTimeout","getRunner","CLEANUP_TIMEOUT_KEY","CLEANUP_STACK_TRACE_KEY","beforeAll","timeout","assertTypes","stackTraceError","getCurrentSuite","withTimeout","afterAll","beforeEach","abortIfTimeout","afterEach","suite","createSuite","test","createTest","optionsOrFn","optionsOrTest","formatName","describe","it","defaultSuite","currentTestFilepath","assert","condition","currentSuite","collectorContext","createSuiteHooks","parseArguments","timeoutOrTest","options","createSuiteCollector","factory","mode","each","suiteOptions","parentCollectorFixtures","tasks","initSuite","_collectorContext$cur","_collectorContext$cur2","_collectorContext$cur3","handler","createTestContext","limit","withAwaitAsyncAssertions","_","collectorFixtures","collector","collect","clear","addHook","parsed","includeLocation","_collectorContext$cur4","_collectorContext$cur5","_collectorContext$cur6","file","runWithSuite","allChildren","collectTask","fnResult","errors","r","suiteFn","factoryOrOptions","optionsOrFactory","_currentSuite$options","isConcurrentSpecified","isSequentialSpecified","isConcurrent","isSequential","cases","formatTemplateString","fnOrOptions","_name","arrayOnlyCases","fnFirst","idx","items","formatTitle","name_","item","toArray","createTaskCollector","taskFn","handlerWrapper","_context","originalWrapper","_test","template","count","isNegativeNaN","occurrence","isObjectItem","formatAttribute","isArrayKey","arrayElement","objectAttr","objDisplay","output","handleRegexMatch","formatRegExp","format","nonMatch","input","regex","onMatch","onNonMatch","lastIndex","m","header","res","oneCase","j","now$2","prev","isHook","onTimeout","setTimeout","clearTimeout","getSafeTimers","startTime","resolve_","reject_","_timer$unref","timer","rejectTimeoutError","makeTimeoutError","resolve","reject","abortControllers","abortContextSignal","abortController","_runner$extendTaskCon","type","attachment","annotation","annotationAttachment","manageArtifactAttachment","recordAsyncOperation","recordArtifact","finishSendTasksUpdate","resolvedAnnotation","fileContexts","packs","eventsPacks","pendingTasksUpdates","sendTasksUpdate","_runner$onTaskUpdate","taskPacks","id","p","artifact","resolvedArtifact","table","encodeUint8Array","bytes","base64","len","a","b","c","index"],"mappings":"sSAKA,SAASA,GAAgBC,EAAMC,EAAI,CAClC,SAASC,EAAOC,EAAS,CACxB,MAAMC,EAAQ,YAAYC,EAAM,CAC/B,OAAOJ,EAAG,MAAME,EAASE,CAAI,CAC9B,EACA,OAAO,OAAOD,EAAOH,CAAE,EACvBG,EAAM,YAAc,IAAMA,EAAM,KAAKD,CAAO,EAC5CC,EAAM,WAAa,CAACE,EAAKC,IAAU,CAClCJ,EAAQG,CAAG,EAAIC,CAChB,EACAH,EAAM,aAAgBI,GAAQ,CAC7B,OAAO,OAAOL,EAASK,CAAG,CAC3B,EACA,UAAWF,KAAON,EACjB,OAAO,eAAeI,EAAOE,EAAK,CAAE,KAAM,CACzC,OAAOJ,EAAO,CACb,GAAGC,EACH,CAACG,CAAG,EAAG,EACZ,CAAK,CACF,EAAG,EAEJ,OAAOF,CACR,CACA,MAAMA,EAAQF,EAAO,EAAE,EACvB,OAAAE,EAAM,GAAKH,EACJG,CACR,CAsKA,SAASK,GAAuBC,EAAcC,EAAO,CAEpD,MAAMC,EAAQD,EAAM,MAAM;AAAA,CAAI,EAAE,MAAM,CAAC,EACvC,UAAWE,KAAQD,EAAO,CACzB,MAAME,EAAQC,GAAiBF,CAAI,EACnC,GAAIC,GAASA,EAAM,OAASJ,EAC3B,OAAOI,CAET,CACD,CA6GA,SAASE,GAASC,EAAM,CACvB,MAAMC,EAAQ,CAACD,EAAK,IAAI,EACxB,IAAIE,EAAUF,EACd,KAAOE,GAAY,MAAsCA,EAAQ,OAChEA,EAAUA,EAAQ,MACdA,GAAY,MAAsCA,EAAQ,MAC7DD,EAAM,QAAQC,EAAQ,IAAI,EAG5B,OAAIA,IAAYF,EAAK,MACpBC,EAAM,QAAQD,EAAK,KAAK,IAAI,EAEtBC,CACR,CAOA,SAASE,EAAeF,EAAOG,EAAY,MAAO,CACjD,OAAOH,EAAM,OAAQI,GAASA,IAAS,MAAS,EAAE,KAAKD,CAAS,CACjE,CCzUA,MAAME,WAAqB,KAAM,CAGhC,YAAYC,EAASP,EAAMQ,EAAM,CAChC,MAAMD,CAAO,EAHdE,EAAA,YAAO,kBACPA,EAAA,eAGC,KAAK,QAAUF,EACf,KAAK,KAAOC,EACZ,KAAK,OAASR,EAAK,EACpB,CACD,CAWA,MAAMU,GAAQ,IAAI,QACZC,GAAiB,IAAI,QACrBC,GAAW,IAAI,QACrB,SAASC,GAAMxB,EAAKL,EAAI,CACvB0B,GAAM,IAAIrB,EAAKL,CAAE,CAClB,CAIA,SAAS8B,GAAezB,EAAK0B,EAAS,CACrCJ,GAAe,IAAItB,EAAK0B,CAAO,CAChC,CACA,SAASC,GAAe3B,EAAK,CAC5B,OAAOsB,GAAe,IAAItB,CAAG,CAC9B,CACA,SAAS4B,GAAS5B,EAAK6B,EAAO,CAC7BN,GAAS,IAAIvB,EAAK6B,CAAK,CACxB,CACA,SAASC,GAAS9B,EAAK,CACtB,OAAOuB,GAAS,IAAIvB,CAAG,CACxB,CAEA,SAAS+B,GAAoBC,EAAcC,EAAgB,CAC1D,MAAMC,EAAoBD,EAAe,OAAO,CAACE,EAAKT,KACrDS,EAAIT,EAAQ,IAAI,EAAIA,EACbS,GACL,CAAA,CAAE,EACCC,EAAc,CAAA,EACpBJ,EAAa,QAASN,GAAY,CACjC,MAAMW,EAAaH,EAAkBR,EAAQ,IAAI,GAAK,CAAE,GAAGA,CAAO,EAClEU,EAAYC,EAAW,IAAI,EAAIA,CAChC,CAAC,EACD,UAAWC,KAAcF,EAAa,CACrC,IAAIG,EACJ,MAAMb,EAAUU,EAAYE,CAAU,EAGtCZ,EAAQ,MAAQa,EAAgBb,EAAQ,QAAU,MAAQa,IAAkB,OAAS,OAASA,EAAc,IAAKC,GAAQJ,EAAYI,EAAI,IAAI,CAAC,CAC/I,CACA,OAAO,OAAO,OAAOJ,CAAW,CACjC,CACA,SAASK,GAAqBC,EAAU7C,EAAS8C,EAAQ,CACxD,MAAMC,EAAoB,CACzB,OACA,WACA,OACF,EACOC,EAAe,OAAO,QAAQH,CAAQ,EAAE,IAAI,CAAC,CAACI,EAAM7C,CAAK,IAAM,CACpE,MAAM8C,EAAc,CAAE,MAAA9C,CAAK,EAC3B,GAAI,MAAM,QAAQA,CAAK,GAAKA,EAAM,QAAU,GAAK+C,GAAS/C,EAAM,CAAC,CAAC,GAAK,OAAO,KAAKA,EAAM,CAAC,CAAC,EAAE,KAAMD,GAAQ4C,EAAkB,SAAS5C,CAAG,CAAC,EAAG,CAC5I,IAAIiD,EAEJ,OAAO,OAAOF,EAAa9C,EAAM,CAAC,CAAC,EACnC,MAAMiD,EAAYjD,EAAM,CAAC,EACzB8C,EAAY,MAAQA,EAAY,WAAaE,EAAsBN,EAAO,eAAiB,MAAQM,IAAwB,OAAS,OAASA,EAAoB,KAAKN,EAAQG,CAAI,IAAMI,EAAYA,CACrM,CACA,OAAAH,EAAY,MAAQA,EAAY,OAAS,OACrCA,EAAY,QAAU,UAAY,CAACJ,EAAO,mBAC7CI,EAAY,MAAQ,QAErBA,EAAY,KAAOD,EACnBC,EAAY,KAAO,OAAOA,EAAY,OAAU,WACzCA,CACR,CAAC,EACD,OAAI,MAAM,QAAQlD,EAAQ,QAAQ,EACjCA,EAAQ,SAAWA,EAAQ,SAAS,OAAOgD,CAAY,EAEvDhD,EAAQ,SAAWgD,EAGpBA,EAAa,QAASnB,GAAY,CACjC,GAAIA,EAAQ,KAAM,CACjB,MAAMyB,EAAYC,GAAa1B,EAAQ,KAAK,EAK5C,GAJIyB,EAAU,SACbzB,EAAQ,KAAO7B,EAAQ,SAAS,OAAO,CAAC,CAAE,KAAAiD,CAAI,IAAOA,IAASpB,EAAQ,MAAQyB,EAAU,SAASL,CAAI,CAAC,GAGnGpB,EAAQ,QAAU,OAAQ,CAC7B,IAAI2B,GACHA,EAAiB3B,EAAQ,QAAU,MAAQ2B,IAAmB,QAAkBA,EAAe,QAASb,GAAQ,CAChH,GAAKA,EAAI,MAKL,EAAAd,EAAQ,QAAU,UAAYc,EAAI,QAAU,WAI5C,EAAAd,EAAQ,QAAU,QAAUc,EAAI,QAAU,QAG9C,MAAM,IAAI,YAAY,kBAAkBA,EAAI,KAAK,aAAaA,EAAI,IAAI,gBAAgBd,EAAQ,KAAK,aAAaA,EAAQ,IAAI,GAAG,CAChI,CAAC,CACF,CACD,CACD,CAAC,EACM7B,CACR,CACA,MAAMyD,EAAmB,IAAI,IACvBC,EAAoB,IAAI,IAQ9B,SAASC,EAAab,EAAQhD,EAAI8D,EAAa,CAC9C,OAAQC,GAAgB,CACvB,MAAM7D,EAAU6D,GAAeD,EAC/B,GAAI,CAAC5D,EACJ,OAAOF,EAAG,CAAA,CAAE,EAEb,MAAM+C,EAAWf,GAAe9B,CAAO,EACvC,GAAI,EAAE6C,GAAa,MAAuCA,EAAS,QAClE,OAAO/C,EAAGE,CAAO,EAElB,MAAMsD,EAAYC,GAAazD,CAAE,EAC3BgE,EAAiBjB,EAAS,KAAK,CAAC,CAAE,KAAAkB,CAAI,IAAOA,CAAI,EACvD,GAAI,CAACT,EAAU,QAAU,CAACQ,EACzB,OAAOhE,EAAGE,CAAO,EAEbyD,EAAiB,IAAIzD,CAAO,GAChCyD,EAAiB,IAAIzD,EAAS,IAAI,GAAK,EAExC,MAAMgE,EAAkBP,EAAiB,IAAIzD,CAAO,EAC/C0D,EAAkB,IAAI1D,CAAO,GACjC0D,EAAkB,IAAI1D,EAAS,EAAE,EAElC,MAAMiE,EAAiBP,EAAkB,IAAI1D,CAAO,EAC9CkE,EAAerB,EAAS,OAAO,CAAC,CAAE,KAAAI,EAAM,KAAAc,CAAI,IAAOA,GAAQT,EAAU,SAASL,CAAI,CAAC,EACnFkB,EAAkBC,GAAYF,CAAY,EAChD,GAAI,CAACC,EAAgB,OACpB,OAAOrE,EAAGE,CAAO,EAElB,eAAeqE,GAAkB,CAChC,UAAWxC,KAAWsC,EAAiB,CAEtC,GAAIH,EAAgB,IAAInC,CAAO,EAC9B,SAED,MAAMyC,EAAgB,MAAMC,GAAoBzB,EAAQjB,EAAS7B,EAASiE,CAAc,EACxFjE,EAAQ6B,EAAQ,IAAI,EAAIyC,EACxBN,EAAgB,IAAInC,EAASyC,CAAa,EACtCzC,EAAQ,QAAU,QACrBoC,EAAe,QAAQ,IAAM,CAC5BD,EAAgB,OAAOnC,CAAO,CAC/B,CAAC,CAEH,CACD,CACA,OAAOwC,EAAe,EAAG,KAAK,IAAMvE,EAAGE,CAAO,CAAC,CAChD,CACD,CACA,MAAMwE,EAAuB,IAAI,QACjC,SAASD,GAAoBzB,EAAQjB,EAAS7B,EAASiE,EAAgB,CACtE,IAAIQ,EACJ,MAAMC,EAAcC,GAAe3E,EAAQ,KAAK,IAAI,EAC9C4E,GAAiBH,EAAwB3B,EAAO,oBAAsB,MAAQ2B,IAA0B,OAAS,OAASA,EAAsB,KAAK3B,CAAM,EACjK,GAAI,CAACjB,EAAQ,KAAM,CAClB,IAAIgD,EAEJ,GADAH,EAAYG,EAAgBhD,EAAQ,IAAI,IAAM6C,EAAYG,CAAa,EAAIhD,EAAQ,OAC/E+C,EAAe,CAClB,IAAIE,EACJF,EAAcE,EAAiBjD,EAAQ,IAAI,IAAM+C,EAAcE,CAAc,EAAIjD,EAAQ,MAC1F,CACA,OAAOA,EAAQ,KAChB,CACA,GAAIA,EAAQ,QAAU,OACrB,OAAOkD,GAAuBlD,EAAQ,MAAO7B,EAASiE,CAAc,EAGrE,GAAIO,EAAqB,IAAI3C,CAAO,EACnC,OAAO2C,EAAqB,IAAI3C,CAAO,EAExC,IAAImD,EACJ,GAAInD,EAAQ,QAAU,SAAU,CAC/B,GAAI,CAAC+C,EACJ,MAAM,IAAI,UAAU,4JAA4J,EAEjLI,EAAiBJ,CAClB,MACCI,EAAiBN,EAElB,GAAI7C,EAAQ,QAAQmD,EACnB,OAAOA,EAAenD,EAAQ,IAAI,EAE9B6B,EAAkB,IAAIsB,CAAc,GACxCtB,EAAkB,IAAIsB,EAAgB,EAAE,EAEzC,MAAMC,EAAqBvB,EAAkB,IAAIsB,CAAc,EACzDE,EAAUH,GAAuBlD,EAAQ,MAAOmD,EAAgBC,CAAkB,EAAE,KAAM7E,IAC/F4E,EAAenD,EAAQ,IAAI,EAAIzB,EAC/BoE,EAAqB,OAAO3C,CAAO,EAC5BzB,EACP,EACD,OAAAoE,EAAqB,IAAI3C,EAASqD,CAAO,EAClCA,CACR,CACA,eAAeH,GAAuBI,EAAWnF,EAASiE,EAAgB,CAEzE,MAAMmB,EAAkBC,EAAW,EACnC,IAAIC,EAAqB,GACzB,MAAMC,EAAgBJ,EAAUnF,EAAS,MAAOwF,GAAa,CAE5DF,EAAqB,GACrBF,EAAgB,QAAQI,CAAQ,EAEhC,MAAMC,EAAmBJ,EAAW,EACpCpB,EAAe,KAAK,SAAY,CAE/BwB,EAAiB,QAAO,EAExB,MAAMF,CACP,CAAC,EACD,MAAME,CACP,CAAC,EAAE,MAAOC,GAAM,CAEf,GAAI,CAACJ,EAAoB,CACxBF,EAAgB,OAAOM,CAAC,EACxB,MACD,CAEA,MAAMA,CACP,CAAC,EACD,OAAON,CACR,CACA,SAAShB,GAAYvB,EAAU8C,EAAS,IAAI,IAAOxB,EAAkB,GAAI,CACxE,OAAAtB,EAAS,QAAShB,GAAY,CAC7B,GAAI,CAAAsC,EAAgB,SAAStC,CAAO,EAGpC,IAAI,CAACA,EAAQ,MAAQ,CAACA,EAAQ,KAAM,CACnCsC,EAAgB,KAAKtC,CAAO,EAC5B,MACD,CACA,GAAI8D,EAAO,IAAI9D,CAAO,EACrB,MAAM,IAAI,MAAM,yCAAyCA,EAAQ,IAAI,OAAO,CAAC,GAAG8D,CAAM,EAAE,QAAO,EAAG,IAAKC,GAAMA,EAAE,IAAI,EAAE,KAAK,MAAM,CAAC,EAAE,EAEpID,EAAO,IAAI9D,CAAO,EAClBuC,GAAYvC,EAAQ,KAAM8D,EAAQxB,CAAe,EACjDA,EAAgB,KAAKtC,CAAO,EAC5B8D,EAAO,MAAK,EACb,CAAC,EACMxB,CACR,CACA,SAASZ,GAAazD,EAAI,CACzB,IAAI+F,EAAWC,GAAkBhG,EAAG,SAAQ,CAAE,EAM1C,uEAAuE,KAAK+F,CAAQ,IACvFA,EAAWA,EAAS,MAAM,yBAAyB,EAAE,CAAC,GAEvD,MAAME,EAAQF,EAAS,MAAM,gBAAgB,EAC7C,GAAI,CAACE,EACJ,MAAO,CAAA,EAER,MAAM7F,EAAO8F,GAAaD,EAAM,CAAC,CAAC,EAClC,GAAI,CAAC7F,EAAK,OACT,MAAO,CAAA,EAER,IAAI+F,EAAQ/F,EAAK,CAAC,EAClB,GAAI,6BAA8BJ,IACjCmG,EAAQ/F,EAAKJ,EAAG,wBAAwB,EACpC,CAACmG,GACJ,MAAO,CAAA,EAGT,GAAI,EAAEA,EAAM,CAAC,IAAM,KAAOA,EAAM,SAAS,GAAG,GAC3C,MAAM,IAAI,MAAM,wHAAwHA,CAAK,IAAI,EAElJ,MAAMC,EAASD,EAAM,MAAM,EAAG,EAAE,EAAE,QAAQ,MAAO,EAAE,EAC7CE,EAAQH,GAAaE,CAAM,EAAE,IAAKjD,GAChCA,EAAK,QAAQ,WAAY,EAAE,CAClC,EACKmD,EAAOD,EAAM,GAAG,EAAE,EACxB,GAAIC,GAAQA,EAAK,WAAW,KAAK,EAChC,MAAM,IAAI,MAAM,4DAA4DA,CAAI,IAAI,EAErF,OAAOD,CACR,CACA,SAASL,GAAkBO,EAAG,CAC7B,MAAMC,EAAS,CAAA,EACf,IAAIC,EAAe,OACnB,QAASC,EAAI,EAAGA,EAAIH,EAAE,OAAQ,EAAEG,EAC3BD,IAAiB,aAChBF,EAAEG,CAAC,IAAM;AAAA,IACZD,EAAe,QAENA,IAAiB,YACvBF,EAAEG,EAAI,CAAC,IAAM,KAAOH,EAAEG,CAAC,IAAM,MAChCD,EAAe,QAENA,IAAiB,SACvBF,EAAEG,CAAC,IAAM,KAAOH,EAAEG,EAAI,CAAC,IAAM,IAChCD,EAAe,aACLF,EAAEG,CAAC,IAAM,KAAOH,EAAEG,EAAI,CAAC,IAAM,KACvCD,EAAe,YACfC,GAAK,GAELF,EAAO,KAAKD,EAAEG,CAAC,CAAC,GAInB,OAAOF,EAAO,KAAK,EAAE,CACtB,CACA,SAASN,GAAaK,EAAG,CACxB,MAAMC,EAAS,CAAA,EACT3F,EAAQ,CAAA,EACd,IAAI8F,EAAQ,EACZ,QAAS,EAAI,EAAG,EAAIJ,EAAE,OAAQ,IAC7B,GAAIA,EAAE,CAAC,IAAM,KAAOA,EAAE,CAAC,IAAM,IAC5B1F,EAAM,KAAK0F,EAAE,CAAC,IAAM,IAAM,IAAM,GAAG,UACzBA,EAAE,CAAC,IAAM1F,EAAM,GAAG,EAAE,EAC9BA,EAAM,IAAG,UACC,CAACA,EAAM,QAAU0F,EAAE,CAAC,IAAM,IAAK,CACzC,MAAMK,EAAQL,EAAE,UAAUI,EAAO,CAAC,EAAE,KAAI,EACpCC,GACHJ,EAAO,KAAKI,CAAK,EAElBD,EAAQ,EAAI,CACb,CAED,MAAME,EAAYN,EAAE,UAAUI,CAAK,EAAE,KAAI,EACzC,OAAIE,GACHL,EAAO,KAAKK,CAAS,EAEfL,CACR,CAoBA,SAASM,GAAwB,CAChC,OAAOC,EAAS,EAAG,OAAO,WAC3B,CACA,MAAMC,GAAsB,OAAO,IAAI,wBAAwB,EACzDC,GAA0B,OAAO,IAAI,4BAA4B,EA6BvE,SAASC,GAAUlH,EAAImH,EAAUL,IAAyB,CACzDM,EAAYpH,EAAI,uBAA0B,CAAC,UAAU,CAAC,EACtD,MAAMqH,EAAkB,IAAI,MAAM,mBAAmB,EACrD,OAAOC,EAAe,EAAG,GAAG,YAAa,OAAO,OAAOC,EAAYvH,EAAImH,EAAS,GAAME,CAAe,EAAG,CACvG,CAACL,EAAmB,EAAGG,EACvB,CAACF,EAAuB,EAAGI,CAC7B,CAAE,CAAC,CACH,CAkBA,SAASG,GAASxH,EAAImH,EAAS,CAC9B,OAAAC,EAAYpH,EAAI,sBAAyB,CAAC,UAAU,CAAC,EAC9CsH,EAAe,EAAG,GAAG,WAAYC,EAAYvH,EAAImH,GAAWL,EAAqB,EAAI,GAAM,IAAI,MAAM,mBAAmB,CAAC,CAAC,CAClI,CAkBA,SAASW,GAAWzH,EAAImH,EAAUL,IAAyB,CAC1DM,EAAYpH,EAAI,wBAA2B,CAAC,UAAU,CAAC,EACvD,MAAMqH,EAAkB,IAAI,MAAM,mBAAmB,EAC/CrE,EAAS+D,EAAS,EACxB,OAAOO,EAAe,EAAG,GAAG,aAAc,OAAO,OAAOC,EAAY1D,EAAab,EAAQhD,CAAE,EAAGmH,GAAWL,EAAqB,EAAI,GAAMO,EAAiBK,CAAc,EAAG,CACzK,CAACV,EAAmB,EAAGG,EACvB,CAACF,EAAuB,EAAGI,CAC7B,CAAE,CAAC,CACH,CAkBA,SAASM,GAAU3H,EAAImH,EAAS,CAC/BC,EAAYpH,EAAI,uBAA0B,CAAC,UAAU,CAAC,EACtD,MAAMgD,EAAS+D,EAAS,EACxB,OAAOO,EAAe,EAAG,GAAG,YAAaC,EAAY1D,EAAab,EAAQhD,CAAE,EAAGmH,GAAWL,EAAqB,EAAI,GAAM,IAAI,MAAM,mBAAmB,EAAGY,CAAc,CAAC,CACzK,CAkGA,MAAME,EAAQC,GAAW,EAuBnBC,GAAOC,EAAW,SAAS1G,EAAM2G,EAAaC,EAAe,CAIlEX,EAAe,EAAG,KAAK,GAAG,KAAK,KAAMY,EAAW7G,CAAI,EAAG2G,EAAaC,CAAa,CAClF,CAAC,EAsCKE,GAAWP,EAuBXQ,GAAKN,GACX,IAAI9E,EACAqF,GACAC,GACJ,SAASC,GAAOC,EAAWjH,EAAS,CACnC,GAAI,CAACiH,EACJ,MAAM,IAAI,MAAM,yBAAyBjH,CAAO;AAAA;AAAA;AAAA;AAAA;AAAA,CAAob,CAEte,CAKA,SAASwF,GAAY,CACpB,OAAAwB,GAAOvF,EAAQ,YAAY,EACpBA,CACR,CAmBA,SAASsE,GAAkB,CAC1B,MAAMmB,EAAeC,EAAiB,cAAgBL,GACtD,OAAAE,GAAOE,EAAc,mBAAmB,EACjCA,CACR,CACA,SAASE,IAAmB,CAC3B,MAAO,CACN,UAAW,CAAA,EACX,SAAU,CAAA,EACV,WAAY,CAAA,EACZ,UAAW,CAAA,CACb,CACA,CACA,SAASC,EAAeZ,EAAaa,EAAe,CACnD,GAAIA,GAAiB,MAAQ,OAAOA,GAAkB,SACrD,MAAM,IAAI,UAAU,+IAA+I,EAEpK,IAAIC,EAAU,CAAA,EACV9I,EAOJ,GALI,OAAO6I,GAAkB,SAC5BC,EAAU,CAAE,QAASD,CAAa,EACxB,OAAOb,GAAgB,WACjCc,EAAUd,GAEP,OAAOA,GAAgB,WAAY,CACtC,GAAI,OAAOa,GAAkB,WAC5B,MAAM,IAAI,UAAU,oFAAoF,EAEzG7I,EAAKgI,CACN,MAAW,OAAOa,GAAkB,aACnC7I,EAAK6I,GAEN,MAAO,CACN,QAAAC,EACA,QAAS9I,CACX,CACA,CAEA,SAAS+I,GAAqB1H,EAAM2H,EAAU,IAAM,CAAC,EAAGC,EAAMC,EAAMC,EAAcC,EAAyB,CAC1G,MAAMC,EAAQ,CAAA,EACd,IAAIzB,EACJ0B,EAAc,EACd,MAAMtI,EAAO,SAASK,EAAO,GAAIyH,EAAU,CAAA,EAAI,CAC9C,IAAIS,EAAuBC,EAAwBC,EACnD,MAAMtC,GAAW2B,GAAY,KAA6B,OAASA,EAAQ,UAAY9F,EAAO,OAAO,YAC/FyF,GAAgBc,EAAwBb,EAAiB,gBAAkB,MAAQa,IAA0B,OAAS,OAASA,EAAsB,MACrJvI,EAAO,CACZ,GAAI,GACJ,KAAAK,EACA,SAAUF,EAAe,EAAEsH,GAAiB,KAAkC,OAASA,EAAa,aAAee,EAAyBd,EAAiB,gBAAkB,MAAQc,IAA2B,SAAWA,EAAyBA,EAAuB,QAAU,MAAQA,IAA2B,OAAS,OAASA,EAAuB,UAAWnI,CAAI,CAAC,EACnX,aAAcF,EAAe,CAACsH,GAAiB,KAAkC,OAASA,EAAa,aAAcpH,CAAI,CAAC,EAC1H,MAAOoH,EACP,KAAMK,EAAQ,KACd,MAAOA,EAAQ,MACf,QAAS,OACT,KAAM,OACN,MAAOL,GAAiB,KAAkC,OAASA,EAAa,SAAWgB,EAAyBf,EAAiB,gBAAkB,MAAQe,IAA2B,OAAS,OAASA,EAAuB,MACnO,QAAAtC,EACA,MAAO2B,EAAQ,OAAS9F,EAAO,OAAO,MACtC,QAAS8F,EAAQ,QACjB,KAAMA,EAAQ,KAAO,OAASA,EAAQ,KAAO,OAASA,EAAQ,KAAO,OAAS,MAC9E,KAAMA,EAAQ,MAAQ,OAAO,OAAO,IAAI,EACxC,YAAa,CAAA,EACb,UAAW,CAAA,CACd,EACQY,EAAUZ,EAAQ,QACpB9H,EAAK,OAAS,OAAS,CAAC0I,IAC3B1I,EAAK,KAAO,SAET8H,EAAQ,YAAc,CAACA,EAAQ,YAAc9F,EAAO,OAAO,SAAS,cACvEhC,EAAK,WAAa,IAEnBA,EAAK,QAAUmI,GAAiB,KAAkC,OAASA,EAAa,QACxF,MAAMjJ,EAAUyJ,GAAkB3I,EAAMgC,CAAM,EAE9C,OAAO,eAAehC,EAAM,UAAW,CACtC,MAAOd,EACP,WAAY,EACf,CAAG,EACD4B,GAAe5B,EAAS4I,EAAQ,QAAQ,EAExC,MAAMc,GAAQ,MAAM,gBACpB,MAAM,gBAAkB,GACxB,MAAMvC,EAAkB,IAAI,MAAM,mBAAmB,EAKrD,GAJA,MAAM,gBAAkBuC,GACpBF,GACH7H,GAAMb,EAAMuG,EAAYsC,GAAyBhG,EAAab,EAAQ0G,EAASxJ,CAAO,EAAGc,CAAI,EAAGmG,EAAS,GAAOE,EAAiB,CAACyC,EAAGpJ,IAAUgH,EAAe,CAACxH,CAAO,EAAGQ,CAAK,CAAC,CAAC,EAE7KsC,EAAO,OAAO,oBAAqB,CACtC,MAAMtC,EAAQ2G,EAAgB,MACxBxG,EAAQL,GAAuB8H,GAAqB5H,CAAK,EAC3DG,IACHG,EAAK,SAAW,CACf,KAAMH,EAAM,KACZ,OAAQA,EAAM,MACnB,EAEE,CACA,OAAAwI,EAAM,KAAKrI,CAAI,EACRA,CACR,EACM8G,EAAOC,EAAW,SAAS1G,EAAM2G,EAAaa,EAAe,CAClE,GAAI,CAAE,QAAAC,EAAS,QAAAY,CAAO,EAAKd,EAAeZ,EAAaa,CAAa,EAEhE,OAAOM,GAAiB,WAC3BL,EAAU,OAAO,OAAO,CAAA,EAAIK,EAAcL,CAAO,GAGlDA,EAAQ,WAAa,KAAK,YAAc,CAAC,KAAK,aAAeA,GAAY,KAA6B,OAASA,EAAQ,YACvHA,EAAQ,WAAa,KAAK,YAAc,CAAC,KAAK,aAAeA,GAAY,KAA6B,OAASA,EAAQ,YACvH,MAAMhB,EAAO9G,EAAKkH,EAAW7G,CAAI,EAAG,CACnC,GAAG,KACH,GAAGyH,EACH,QAAAY,CACH,CAAG,EACD5B,EAAK,KAAO,MACb,CAAC,EACD,IAAIiC,EAAoBX,EACxB,MAAMY,EAAY,CACjB,KAAM,YACN,KAAA3I,EACA,KAAA4H,EACA,MAAArB,EACA,QAASuB,EACT,KAAArB,EACA,MAAAuB,EACA,QAAAY,EACA,KAAAjJ,EACA,MAAAkJ,EACA,GAAIC,EACJ,UAAW,CACV,OAAOJ,CACR,EACA,OAAOhH,EAAU,CAChB,MAAMqH,EAAStH,GAAqBC,EAAU,CAAE,SAAUgH,CAAiB,EAAI/G,CAAM,EACjFoH,EAAO,WACVL,EAAoBK,EAAO,SAE7B,CACF,EACC,SAASD,EAAQ9I,KAASrB,EAAI,CAC7BmC,GAASyF,CAAK,EAAEvG,CAAI,EAAE,KAAK,GAAGrB,CAAE,CACjC,CACA,SAASsJ,EAAUe,EAAiB,CACnC,IAAIC,EAAwBC,EAAwBC,EAChD,OAAOrB,GAAiB,WAC3BA,EAAe,CAAE,QAASA,CAAY,GAEvC,MAAMV,GAAgB6B,EAAyB5B,EAAiB,gBAAkB,MAAQ4B,IAA2B,OAAS,OAASA,EAAuB,MAC9J1C,EAAQ,CACP,GAAI,GACJ,KAAM,QACN,KAAAvG,EACA,SAAUF,EAAe,EAAEsH,GAAiB,KAAkC,OAASA,EAAa,aAAe8B,EAAyB7B,EAAiB,gBAAkB,MAAQ6B,IAA2B,SAAWA,EAAyBA,EAAuB,QAAU,MAAQA,IAA2B,OAAS,OAASA,EAAuB,UAAWlJ,CAAI,CAAC,EACnX,aAAcF,EAAe,CAACsH,GAAiB,KAAkC,OAASA,EAAa,aAAcpH,CAAI,CAAC,EAC1H,MAAOoH,EACP,KAAAQ,EACA,KAAAC,EACA,MAAOT,GAAiB,KAAkC,OAASA,EAAa,SAAW+B,EAAyB9B,EAAiB,gBAAkB,MAAQ8B,IAA2B,OAAS,OAASA,EAAuB,MACnO,QAASrB,GAAiB,KAAkC,OAASA,EAAa,QAClF,MAAO,CAAA,EACP,KAAM,OAAO,OAAO,IAAI,EACxB,WAAYA,GAAiB,KAAkC,OAASA,EAAa,UACxF,EAcElH,GAAS2F,EAAOe,IAAkB,CACnC,CACA,SAASuB,GAAQ,CAChBb,EAAM,OAAS,EACfC,EAAe,CAChB,CACA,eAAeW,EAAQQ,EAAM,CAC5B,GAAI,CAACA,EACJ,MAAM,IAAI,UAAU,oCAAoC,EAErDzB,GACH,MAAM0B,GAAaV,EAAW,IAAMhB,EAAQlB,CAAI,CAAC,EAElD,MAAM6C,EAAc,CAAA,EACpB,UAAWjE,KAAK2C,EACfsB,EAAY,KAAKjE,EAAE,OAAS,YAAc,MAAMA,EAAE,QAAQ+D,CAAI,EAAI/D,CAAC,EAEpE,OAAAkB,EAAM,MAAQ+C,EACP/C,CACR,CACA,OAAAgD,GAAYZ,CAAS,EACdA,CACR,CACA,SAASH,GAAyB7J,EAAIgB,EAAM,CAC3C,OAAQ,SAAUZ,IAAS,CAC1B,MAAMyK,EAAW,MAAM7K,EAAG,GAAGI,CAAI,EAEjC,GAAIY,EAAK,SAAU,CAElB,MAAM8J,GADS,MAAM,QAAQ,WAAW9J,EAAK,QAAQ,GAC/B,IAAK+J,GAAMA,EAAE,SAAW,WAAaA,EAAE,OAAS,MAAS,EAAE,OAAO,OAAO,EAC/F,GAAID,EAAO,OACV,MAAMA,CAER,CACA,OAAOD,CACR,EACD,CACA,SAAShD,IAAc,CACtB,SAASmD,EAAQ3J,EAAM4J,EAAkBC,EAAkB,CAC1D,IAAIC,EAIJ,IAAIlC,EAAO,KAAK,KAAO,OAAS,KAAK,KAAO,OAAS,KAAK,KAAO,OAAS,MAC1E,MAAMR,EAAeC,EAAiB,cAAgBL,GACtD,GAAI,CAAE,QAAAS,EAAS,QAASE,CAAO,EAAKJ,EAAeqC,EAAkBC,CAAgB,EACjFjC,IAAS,OAAS,CAACD,IACtBC,EAAO,QAER,MAAMmC,EAAwBtC,EAAQ,YAAc,KAAK,YAAcA,EAAQ,aAAe,GACxFuC,EAAwBvC,EAAQ,YAAc,KAAK,YAAcA,EAAQ,aAAe,GAE9FA,EAAU,CACT,GAAGL,GAAiB,KAAkC,OAASA,EAAa,QAC5E,GAAGK,EACH,QAAS,KAAK,SAAWA,EAAQ,UAAYL,GAAiB,OAAoC0C,EAAwB1C,EAAa,WAAa,MAAQ0C,IAA0B,OAAS,OAASA,EAAsB,UAAoD,MACrR,EAEE,MAAMG,EAAeF,GAAyBtC,EAAQ,YAAc,CAACuC,EAC/DE,EAAeF,GAAyBvC,EAAQ,YAAc,CAACsC,EACrE,OAAAtC,EAAQ,WAAawC,GAAgB,CAACC,EACtCzC,EAAQ,WAAayC,GAAgB,CAACD,EAC/BvC,GAAqBb,EAAW7G,CAAI,EAAG2H,EAASC,EAAM,KAAK,KAAMH,EAASL,GAAiB,KAAkC,OAASA,EAAa,UAAU,CACrK,CACA,OAAAuC,EAAQ,KAAO,SAASQ,KAAUpL,EAAM,CACvC,MAAMwH,EAAQ,KAAK,YAAW,EAC9B,YAAK,WAAW,OAAQ,EAAI,EACxB,MAAM,QAAQ4D,CAAK,GAAKpL,EAAK,SAChCoL,EAAQC,EAAqBD,EAAOpL,CAAI,GAElC,CAACiB,EAAM2G,EAAa0D,IAAgB,CAC1C,MAAMC,EAAQzD,EAAW7G,CAAI,EACvBuK,EAAiBJ,EAAM,MAAM,MAAM,OAAO,EAC1C,CAAE,QAAA1C,EAAS,QAAAY,CAAO,EAAKd,EAAeZ,EAAa0D,CAAW,EAC9DG,EAAU,OAAO7D,GAAgB,WACvCwD,EAAM,QAAQ,CAAC9E,EAAGoF,IAAQ,CACzB,MAAMC,EAAQ,MAAM,QAAQrF,CAAC,EAAIA,EAAI,CAACA,CAAC,EACnCmF,EACCD,EACHhE,EAAMoE,EAAYL,EAAOI,EAAOD,CAAG,EAAGpC,EAAU,IAAMA,EAAQ,GAAGqC,CAAK,EAAI,OAAWjD,EAAQ,OAAO,EAEpGlB,EAAMoE,EAAYL,EAAOI,EAAOD,CAAG,EAAGpC,EAAU,IAAMA,EAAQhD,CAAC,EAAI,OAAWoC,EAAQ,OAAO,EAG1F8C,EACHhE,EAAMoE,EAAYL,EAAOI,EAAOD,CAAG,EAAGhD,EAASY,EAAU,IAAMA,EAAQ,GAAGqC,CAAK,EAAI,MAAS,EAE5FnE,EAAMoE,EAAYL,EAAOI,EAAOD,CAAG,EAAGhD,EAASY,EAAU,IAAMA,EAAQhD,CAAC,EAAI,MAAS,CAGxF,CAAC,EACD,KAAK,WAAW,OAAQ,MAAS,CAClC,CACD,EACAsE,EAAQ,IAAM,SAASQ,KAAUpL,EAAM,CACtC,OAAI,MAAM,QAAQoL,CAAK,GAAKpL,EAAK,SAChCoL,EAAQC,EAAqBD,EAAOpL,CAAI,GAElC,CAACiB,EAAM2G,EAAa0D,IAAgB,CAC1C,MAAMO,EAAQ/D,EAAW7G,CAAI,EACvB,CAAE,QAAAyH,EAAS,QAAAY,CAAO,EAAKd,EAAeZ,EAAa0D,CAAW,EACpEF,EAAM,QAAQ,CAACU,EAAMJ,IAAQ,CAC5BlE,EAAMoE,EAAYC,EAAOE,GAAQD,CAAI,EAAGJ,CAAG,EAAGhD,EAASY,EAAU,IAAMA,EAAQwC,CAAI,EAAI,MAAS,CACjG,CAAC,CACF,CACD,EACAlB,EAAQ,OAAUxC,GAAcA,EAAYZ,EAAM,KAAOA,EACzDoD,EAAQ,MAASxC,GAAcA,EAAYZ,EAAQA,EAAM,KAClD9H,GAAgB,CACtB,aACA,aACA,UACA,OACA,OACA,MACF,EAAIkL,CAAO,CACX,CACA,SAASoB,GAAoBpM,EAAIE,EAAS,CACzC,MAAMmM,EAASrM,EACfqM,EAAO,KAAO,SAASb,KAAUpL,EAAM,CACtC,MAAM0H,EAAO,KAAK,YAAW,EAC7B,YAAK,WAAW,OAAQ,EAAI,EACxB,MAAM,QAAQ0D,CAAK,GAAKpL,EAAK,SAChCoL,EAAQC,EAAqBD,EAAOpL,CAAI,GAElC,CAACiB,EAAM2G,EAAa0D,IAAgB,CAC1C,MAAMC,EAAQzD,EAAW7G,CAAI,EACvBuK,EAAiBJ,EAAM,MAAM,MAAM,OAAO,EAC1C,CAAE,QAAA1C,EAAS,QAAAY,CAAO,EAAKd,EAAeZ,EAAa0D,CAAW,EAC9DG,EAAU,OAAO7D,GAAgB,WACvCwD,EAAM,QAAQ,CAAC9E,EAAGoF,IAAQ,CACzB,MAAMC,EAAQ,MAAM,QAAQrF,CAAC,EAAIA,EAAI,CAACA,CAAC,EACnCmF,EACCD,EACH9D,EAAKkE,EAAYL,EAAOI,EAAOD,CAAG,EAAGpC,EAAU,IAAMA,EAAQ,GAAGqC,CAAK,EAAI,OAAWjD,EAAQ,OAAO,EAEnGhB,EAAKkE,EAAYL,EAAOI,EAAOD,CAAG,EAAGpC,EAAU,IAAMA,EAAQhD,CAAC,EAAI,OAAWoC,EAAQ,OAAO,EAGzF8C,EACH9D,EAAKkE,EAAYL,EAAOI,EAAOD,CAAG,EAAGhD,EAASY,EAAU,IAAMA,EAAQ,GAAGqC,CAAK,EAAI,MAAS,EAE3FjE,EAAKkE,EAAYL,EAAOI,EAAOD,CAAG,EAAGhD,EAASY,EAAU,IAAMA,EAAQhD,CAAC,EAAI,MAAS,CAGvF,CAAC,EACD,KAAK,WAAW,OAAQ,MAAS,CAClC,CACD,EACA2F,EAAO,IAAM,SAASb,KAAUpL,EAAM,CACrC,MAAM0H,EAAO,KAAK,YAAW,EAC7B,OAAI,MAAM,QAAQ0D,CAAK,GAAKpL,EAAK,SAChCoL,EAAQC,EAAqBD,EAAOpL,CAAI,GAElC,CAACiB,EAAM2G,EAAa0D,IAAgB,CAC1C,MAAMC,EAAQzD,EAAW7G,CAAI,EACvB,CAAE,QAAAyH,EAAS,QAAAY,CAAO,EAAKd,EAAeZ,EAAa0D,CAAW,EACpEF,EAAM,QAAQ,CAACU,EAAMJ,IAAQ,CAE5B,MAAMQ,EAAiB5C,EAAWnJ,GAAQmJ,EAAQwC,EAAM3L,CAAG,EAAI,OAC3D+L,IACHA,EAAe,yBAA2B,EAC1CA,EAAe,SAAW,IAAM5C,EAAQ,SAAQ,GAEjD5B,EAAKkE,EAAYL,EAAOQ,GAAQD,CAAI,EAAGJ,CAAG,EAAGhD,EAASwD,CAAc,CACrE,CAAC,CACF,CACD,EACAD,EAAO,OAAS,SAAS7D,EAAW,CACnC,OAAOA,EAAY,KAAK,KAAO,IAChC,EACA6D,EAAO,MAAQ,SAAS7D,EAAW,CAClC,OAAOA,EAAY,KAAO,KAAK,IAChC,EACA6D,EAAO,OAAS,SAAStJ,EAAU,CAChBuE,EAAe,EACvB,OAAOvE,CAAQ,CAC1B,EACAsJ,EAAO,OAAS,SAAStJ,EAAU,CAClC,MAAMwJ,EAAWzJ,GAAqBC,EAAU7C,GAAW,CAAA,EAAI8C,CAAM,EAC/DwJ,EAAkBxM,EACxB,OAAO+H,EAAW,SAAS1G,EAAM2G,EAAaC,EAAe,CAE5D,MAAM3F,EADYgF,EAAe,EACA,SAAQ,EACnCpH,EAAU,CAAE,GAAG,IAAI,EACrBoC,IACHpC,EAAQ,SAAWkC,GAAoBlC,EAAQ,UAAY,CAAA,EAAIoC,CAAc,GAE9EkK,EAAgB,KAAKtM,EAASgI,EAAW7G,CAAI,EAAG2G,EAAaC,CAAa,CAC3E,EAAGsE,CAAQ,CACZ,EACAF,EAAO,WAAa5E,GACpB4E,EAAO,UAAY1E,GACnB0E,EAAO,UAAYnF,GACnBmF,EAAO,SAAW7E,GAClB,MAAMiF,EAAQ3M,GAAgB,CAC7B,aACA,aACA,OACA,OACA,OACA,OACF,EAAIuM,CAAM,EACT,OAAInM,GACHuM,EAAM,aAAavM,CAAO,EAEpBuM,CACR,CACA,SAAS1E,EAAW/H,EAAIE,EAAS,CAChC,OAAOkM,GAAoBpM,EAAIE,CAAO,CACvC,CACA,SAASgI,EAAW7G,EAAM,CACzB,OAAO,OAAOA,GAAS,SAAWA,EAAO,OAAOA,GAAS,WAAaA,EAAK,MAAQ,cAAgB,OAAOA,CAAI,CAC/G,CACA,SAAS2K,EAAYU,EAAUX,EAAOD,EAAK,EACtCY,EAAS,SAAS,IAAI,GAAKA,EAAS,SAAS,IAAI,KAEpDA,EAAWA,EAAS,QAAQ,MAAO,sBAAsB,EAAE,QAAQ,MAAO,GAAGZ,CAAG,EAAE,EAAE,QAAQ,OAAQ,GAAGA,EAAM,CAAC,EAAE,EAAE,QAAQ,wBAAyB,IAAI,GAExJ,MAAMa,EAAQD,EAAS,MAAM,GAAG,EAAE,OAAS,EACvCA,EAAS,SAAS,IAAI,IACJA,EAAS,MAAM,KAAK,GAAK,CAAA,GACjC,QAAQ,CAAC5C,EAAGpD,IAAM,CAC9B,GAAIkG,GAAcb,EAAMrF,CAAC,CAAC,GAAK,OAAO,GAAGqF,EAAMrF,CAAC,EAAG,EAAE,EAAG,CAEvD,IAAImG,EAAa,EACjBH,EAAWA,EAAS,QAAQ,MAAQzG,IACnC4G,IACOA,IAAenG,EAAI,EAAI,MAAQT,EACtC,CACF,CACD,CAAC,EAEF,MAAM6G,EAAezJ,GAAS0I,EAAM,CAAC,CAAC,EACtC,SAASgB,EAAgBxG,EAAG,CAC3B,OAAOA,EAAE,QAAQ,eAAgB,CAACuD,EAAGzJ,IAAQ,CAE5C,MAAM2M,EAAa,QAAQ,KAAK3M,CAAG,EACnC,GAAI,CAACyM,GAAgB,CAACE,EACrB,MAAO,IAAI3M,CAAG,GAEf,MAAM4M,EAAeD,EAAaE,GAAWnB,EAAO1L,CAAG,EAAI,OACrDC,EAAQwM,EAAeI,GAAWnB,EAAM,CAAC,EAAG1L,EAAK4M,CAAY,EAAIA,EACvE,OAAOE,GAAW7M,EAAO,CAAE,SAAiN,MAAyC,CAAE,CACxR,CAAC,CACF,CACA,IAAI8M,EAAS,GACT1G,EAAI,EACR,OAAA2G,GACCX,EACAY,GAECrH,GAAU,CACNS,EAAIiG,EACPS,GAAUG,GAAOtH,EAAM,CAAC,EAAG8F,EAAMrF,GAAG,CAAC,EAErC0G,GAAUnH,EAAM,CAAC,CAEnB,EAECuH,GAAa,CACbJ,GAAUL,EAAgBS,CAAQ,CACnC,CACF,EACQJ,CACR,CAEA,SAASC,GAAiBI,EAAOC,EAAOC,EAASC,EAAY,CAC5D,IAAIC,EAAY,EAChB,UAAWC,KAAKL,EAAM,SAASC,CAAK,EAC/BG,EAAYC,EAAE,OACjBF,EAAWH,EAAM,MAAMI,EAAWC,EAAE,KAAK,CAAC,EAE3CH,EAAQG,CAAC,EACTD,EAAYC,EAAE,MAAQA,EAAE,CAAC,EAAE,OAExBD,EAAYJ,EAAM,QACrBG,EAAWH,EAAM,MAAMI,CAAS,CAAC,CAEnC,CACA,SAASpC,EAAqBD,EAAOpL,EAAM,CAC1C,MAAM2N,EAASvC,EAAM,KAAK,EAAE,EAAE,KAAI,EAAG,QAAQ,KAAM,EAAE,EAAE,MAAM;AAAA,CAAI,EAAE,IAAK9E,GAAMA,EAAE,MAAM,GAAG,CAAC,EAAE,CAAC,EACvFsH,EAAM,CAAA,EACZ,QAAStH,EAAI,EAAGA,EAAI,KAAK,MAAMtG,EAAK,OAAS2N,EAAO,MAAM,EAAGrH,IAAK,CACjE,MAAMuH,EAAU,CAAA,EAChB,QAASC,EAAI,EAAGA,EAAIH,EAAO,OAAQG,IAClCD,EAAQF,EAAOG,CAAC,CAAC,EAAI9N,EAAKsG,EAAIqH,EAAO,OAASG,CAAC,EAEhDF,EAAI,KAAKC,CAAO,CACjB,CACA,OAAOD,CACR,CAEA,MAAMG,GAAQ,KAAK,IACbzF,EAAmB,CAExB,aAAc,IACf,EACA,SAASkC,GAAY5J,EAAM,CAC1B,IAAIuI,GACHA,EAAwBb,EAAiB,gBAAkB,MAAQa,IAA0B,QAAkBA,EAAsB,MAAM,KAAKvI,CAAI,CACtJ,CACA,eAAe0J,GAAa9C,EAAO5H,EAAI,CACtC,MAAMoO,EAAO1F,EAAiB,aAC9BA,EAAiB,aAAed,EAChC,MAAM5H,EAAE,EACR0I,EAAiB,aAAe0F,CACjC,CACA,SAAS7G,EAAYvH,EAAImH,EAASkH,EAAS,GAAOhH,EAAiBiH,EAAW,CAC7E,GAAInH,GAAW,GAAKA,IAAY,OAAO,kBACtC,OAAOnH,EAER,KAAM,CAAE,WAAAuO,EAAY,aAAAC,CAAY,EAAKC,GAAa,EAElD,OAAQ,YAA2BrO,EAAM,CACxC,MAAMsO,EAAYP,GAAK,EACjBnL,EAAS+D,EAAS,EACxB,OAAA/D,EAAO,sBAAwB0L,EAC/B1L,EAAO,oBAAsBmE,EACtB,IAAI,QAAQ,CAACwH,EAAUC,IAAY,CACzC,IAAIC,EACJ,MAAMC,EAAQP,EAAW,IAAM,CAC9BC,EAAaM,CAAK,EAClBC,EAAkB,CACnB,EAAG5H,CAAO,GAET0H,EAAeC,EAAM,SAAW,MAAQD,IAAiB,QAAkBA,EAAa,KAAKC,CAAK,EACnG,SAASC,GAAqB,CAC7B,MAAMrO,EAAQsO,GAAiBX,EAAQlH,EAASE,CAAe,EAC/DiH,GAAc,MAAwCA,EAAUlO,EAAMM,CAAK,EAC3EkO,EAAQlO,CAAK,CACd,CACA,SAASuO,EAAQzI,EAAQ,CAOxB,GANAxD,EAAO,sBAAwB,OAC/BA,EAAO,oBAAsB,OAC7BwL,EAAaM,CAAK,EAIdX,GAAK,EAAKO,GAAavH,EAAS,CACnC4H,EAAkB,EAClB,MACD,CACAJ,EAASnI,CAAM,CAChB,CACA,SAAS0I,EAAOxO,EAAO,CACtBsC,EAAO,sBAAwB,OAC/BA,EAAO,oBAAsB,OAC7BwL,EAAaM,CAAK,EAClBF,EAAQlO,CAAK,CACd,CAEA,GAAI,CACH,MAAM8F,EAASxG,EAAG,GAAGI,CAAI,EAGrB,OAAOoG,GAAW,UAAYA,GAAU,MAAQ,OAAOA,EAAO,MAAS,WAC1EA,EAAO,KAAKyI,EAASC,CAAM,EAE3BD,EAAQzI,CAAM,CAEhB,OAEI9F,EAAO,CACVwO,EAAOxO,CAAK,CACb,CACD,CAAC,CACF,EACD,CACA,MAAMyO,EAAmB,IAAI,QAC7B,SAASzH,EAAe,CAACxH,CAAO,EAAGQ,EAAO,CACrCR,GACHkP,GAAmBlP,EAASQ,CAAK,CAEnC,CACA,SAAS0O,GAAmBlP,EAASQ,EAAO,CAC3C,MAAM2O,EAAkBF,EAAiB,IAAIjP,CAAO,EACpDmP,GAAoB,MAA8CA,EAAgB,MAAM3O,CAAK,CAC9F,CACA,SAASiJ,GAAkB7B,EAAM9E,EAAQ,CACxC,IAAIsM,EACJ,MAAMpP,EAAU,UAAW,CAC1B,MAAM,IAAI,MAAM,oDAAoD,CACrE,EACA,IAAImP,EAAkBF,EAAiB,IAAIjP,CAAO,EAClD,OAAKmP,IACJA,EAAkB,IAAI,gBACtBF,EAAiB,IAAIjP,EAASmP,CAAe,GAE9CnP,EAAQ,OAASmP,EAAgB,OACjCnP,EAAQ,KAAO4H,EACf5H,EAAQ,KAAO,CAACsI,EAAWhH,IAAS,CACnC,GAAIgH,IAAc,GAIlB,MAAAV,EAAK,SAAWA,EAAK,OAAS,CAAE,MAAO,SACvCA,EAAK,OAAO,QAAU,GAChB,IAAIxG,GAAa,mCAAoCwG,EAAM,OAAOU,GAAc,SAAWA,EAAYhH,CAAI,CAClH,EACAtB,EAAQ,UAAY,CAACqB,EAASgO,EAAMC,IAAe,CAClD,GAAI1H,EAAK,QAAUA,EAAK,OAAO,QAAU,MACxC,MAAM,IAAI,MAAM,4DAA4DA,EAAK,IAAI,gCAAgCA,EAAK,OAAO,KAAK,kBAAkB,EAEzJ,MAAM2H,EAAa,CAClB,QAAAlO,EACA,KAAM,OAAOgO,GAAS,UAAYA,IAAS,OAAY,SAAWA,CACrE,EACQG,EAAuB,OAAOH,GAAS,SAAWA,EAAOC,EAC/D,OAAIE,IACHD,EAAW,WAAaC,EACxBC,GAAyBF,EAAW,UAAU,GAExCG,GAAqB9H,EAAM+H,GAAe/H,EAAM,CACtD,KAAM,sBACN,WAAA2H,CACH,CAAG,EAAE,KAAK,MAAO,CAAE,WAAAA,KAAiB,CACjC,GAAI,CAACzM,EAAO,eACX,MAAM,IAAI,MAAM,+CAA+C,EAEhE,MAAM8M,GAAsB9M,CAAM,EAClC,MAAM+M,EAAqB,MAAM/M,EAAO,eAAe8E,EAAM2H,CAAU,EACvE,OAAA3H,EAAK,YAAY,KAAKiI,CAAkB,EACjCA,CACR,CAAC,CAAC,CACH,GACA7P,EAAQ,aAAe,CAACwJ,EAASvC,IAAY,CAC5CW,EAAK,WAAaA,EAAK,SAAW,CAAA,GAClCA,EAAK,SAAS,KAAKP,EAAYmC,EAASvC,GAAWnE,EAAO,OAAO,YAAa,GAAM,IAAI,MAAM,mBAAmB,EAAG,CAAC8G,EAAGpJ,IAAU2O,EAAgB,MAAM3O,CAAK,CAAC,CAAC,CAChK,EACAR,EAAQ,eAAiB,CAACwJ,EAASvC,IAAY,CAC9CW,EAAK,aAAeA,EAAK,WAAa,CAAA,GACtCA,EAAK,WAAW,KAAKP,EAAYmC,EAASvC,GAAWnE,EAAO,OAAO,YAAa,GAAM,IAAI,MAAM,mBAAmB,EAAG,CAAC8G,EAAGpJ,IAAU2O,EAAgB,MAAM3O,CAAK,CAAC,CAAC,CAClK,IACS4O,EAAwBtM,EAAO,qBAAuB,MAAQsM,IAA0B,OAAS,OAASA,EAAsB,KAAKtM,EAAQ9C,CAAO,IAAMA,CACpK,CACA,SAAS8O,GAAiBX,EAAQlH,EAASE,EAAiB,CAC3D,MAAM9F,EAAU,GAAG8M,EAAS,OAAS,MAAM,iBAAiBlH,CAAO;AAAA,4BAAkCkH,EAAS,OAAS,MAAM,8EAA8EA,EAAS,cAAgB,aAAa,KAC3O3N,EAAQ,IAAI,MAAMa,CAAO,EAC/B,OAAI8F,GAAoB,MAA8CA,EAAgB,QACrF3G,EAAM,MAAQ2G,EAAgB,MAAM,QAAQ3G,EAAM,QAAS2G,EAAgB,OAAO,GAE5E3G,CACR,CACA,MAAMsP,GAAe,IAAI,QACzB,SAASnL,GAAe4F,EAAM,CAC7B,MAAMvK,EAAU8P,GAAa,IAAIvF,CAAI,EACrC,GAAI,CAACvK,EACJ,MAAM,IAAI,MAAM,gCAAgCuK,EAAK,IAAI,EAAE,EAE5D,OAAOvK,CACR,CAiBc,WAAW,YAAc,WAAW,YAAY,IAAI,KAAK,WAAW,WAAW,EAAI,KAAK,IAkF1F,WAAW,YAAc,WAAW,YAAY,IAAI,KAAK,WAAW,WAAW,EAAI,KAAK,IAE/DuO,GAAa,EAyFlD,MAAMwB,EAAQ,IAAI,IACZC,GAAc,CAAA,EACdC,EAAsB,CAAA,EAC5B,SAASC,GAAgBpN,EAAQ,CAChC,GAAIiN,EAAM,KAAM,CACf,IAAII,EACJ,MAAMC,EAAY,MAAM,KAAKL,CAAK,EAAE,IAAI,CAAC,CAACM,EAAIvP,CAAI,IAC1C,CACNuP,EACAvP,EAAK,CAAC,EACNA,EAAK,CAAC,CACV,CACG,EACKwP,GAAKH,EAAuBrN,EAAO,gBAAkB,MAAQqN,IAAyB,OAAS,OAASA,EAAqB,KAAKrN,EAAQsN,EAAWJ,EAAW,EAClKM,IACHL,EAAoB,KAAKK,CAAC,EAG1BA,EAAE,KAAK,IAAML,EAAoB,OAAOA,EAAoB,QAAQK,CAAC,EAAG,CAAC,EAAG,IAAM,CAAC,CAAC,GAErFN,GAAY,OAAS,EACrBD,EAAM,MAAK,CACZ,CACD,CACA,eAAeH,GAAsB9M,EAAQ,CAC5CoN,GAAgBpN,CAAM,EACtB,MAAM,QAAQ,IAAImN,CAAmB,CACtC,CAkbA,eAAeN,GAAe7O,EAAMyP,EAAU,CAC7C,MAAMzN,EAAS+D,EAAS,EACxB,GAAI/F,EAAK,QAAUA,EAAK,OAAO,QAAU,MACxC,MAAM,IAAI,MAAM,oEAAoEA,EAAK,IAAI,gCAAgCA,EAAK,OAAO,KAAK,kBAAkB,EAEjK,MAAMH,EAAQL,GAAuBQ,EAAK,KAAK,SAAU,IAAI,MAAM,aAAa,EAAE,KAAK,EAWvF,GAVIH,IACH4P,EAAS,SAAW,CACnB,KAAM5P,EAAM,KACZ,KAAMA,EAAM,KACZ,OAAQA,EAAM,MACjB,EACM4P,EAAS,OAAS,wBACrBA,EAAS,WAAW,SAAWA,EAAS,WAGtC,MAAM,QAAQA,EAAS,WAAW,EACrC,UAAWjB,KAAciB,EAAS,YACjCd,GAAyBH,CAAU,EAIrC,GAAIiB,EAAS,OAAS,sBACrB,OAAOA,EAER,GAAI,CAACzN,EAAO,qBACX,MAAM,IAAI,MAAM,6CAA6C,EAE9D,MAAM8M,GAAsB9M,CAAM,EAClC,MAAM0N,EAAmB,MAAM1N,EAAO,qBAAqBhC,EAAMyP,CAAQ,EACzE,OAAAzP,EAAK,UAAU,KAAK0P,CAAgB,EAC7BA,CACR,CACA,MAAMC,EAAQ,CAAA,EACd,QAASjK,EAAI,GAAIA,EAAI,GAAIA,IACxBiK,EAAM,KAAK,OAAO,aAAajK,CAAC,CAAC,EAElC,QAASA,EAAI,GAAIA,EAAI,IAAKA,IACzBiK,EAAM,KAAK,OAAO,aAAajK,CAAC,CAAC,EAElC,QAASA,EAAI,EAAGA,EAAI,GAAIA,IACvBiK,EAAM,KAAKjK,EAAE,SAAS,EAAE,CAAC,EAE1BiK,EAAM,KAAK,IAAK,GAAG,EACnB,SAASC,GAAiBC,EAAO,CAChC,IAAIC,EAAS,GACb,MAAMC,EAAMF,EAAM,WAClB,QAASnK,EAAI,EAAGA,EAAIqK,EAAKrK,GAAK,EAC7B,GAAIqK,IAAQrK,EAAI,EAAG,CAClB,MAAMsK,GAAKH,EAAMnK,CAAC,EAAI,MAAQ,EACxBuK,GAAKJ,EAAMnK,CAAC,EAAI,IAAM,EAC5BoK,GAAUH,EAAMK,CAAC,EACjBF,GAAUH,EAAMM,CAAC,EACjBH,GAAU,IACX,SAAWC,IAAQrK,EAAI,EAAG,CACzB,MAAMsK,GAAKH,EAAMnK,CAAC,EAAI,MAAQ,EACxBuK,GAAKJ,EAAMnK,CAAC,EAAI,IAAM,GAAKmK,EAAMnK,EAAI,CAAC,EAAI,MAAQ,EAClDwK,GAAKL,EAAMnK,EAAI,CAAC,EAAI,KAAO,EACjCoK,GAAUH,EAAMK,CAAC,EACjBF,GAAUH,EAAMM,CAAC,EACjBH,GAAUH,EAAMO,CAAC,EACjBJ,GAAU,GACX,KAAO,CACN,MAAME,GAAKH,EAAMnK,CAAC,EAAI,MAAQ,EACxBuK,GAAKJ,EAAMnK,CAAC,EAAI,IAAM,GAAKmK,EAAMnK,EAAI,CAAC,EAAI,MAAQ,EAClDwK,GAAKL,EAAMnK,EAAI,CAAC,EAAI,KAAO,GAAKmK,EAAMnK,EAAI,CAAC,EAAI,MAAQ,EACvDZ,EAAI+K,EAAMnK,EAAI,CAAC,EAAI,GACzBoK,GAAUH,EAAMK,CAAC,EACjBF,GAAUH,EAAMM,CAAC,EACjBH,GAAUH,EAAMO,CAAC,EACjBJ,GAAUH,EAAM7K,CAAC,CAClB,CAED,OAAOgL,CACR,CAOA,SAASlB,GAAqB9H,EAAM1C,EAAS,CAE5C,OAAAA,EAAUA,EAAQ,QAAQ,IAAM,CAC/B,GAAI,CAAC0C,EAAK,SACT,OAED,MAAMqJ,EAAQrJ,EAAK,SAAS,QAAQ1C,CAAO,EACvC+L,IAAU,IACbrJ,EAAK,SAAS,OAAOqJ,EAAO,CAAC,CAE/B,CAAC,EAEIrJ,EAAK,WACTA,EAAK,SAAW,CAAA,GAEjBA,EAAK,SAAS,KAAK1C,CAAO,EACnBA,CACR,CAWA,SAASuK,GAAyBH,EAAY,CAC7C,GAAIA,EAAW,MAAQ,MAAQ,CAACA,EAAW,KAC1C,MAAM,IAAI,UAAU,wEAAwE,EAE7F,GAAIA,EAAW,MAAQA,EAAW,KACjC,MAAM,IAAI,UAAU,sFAAsF,EAGvGA,EAAW,gBAAgB,aAC9BA,EAAW,KAAOoB,GAAiBpB,EAAW,IAAI,EAEpD","x_google_ignoreList":[0,1]}