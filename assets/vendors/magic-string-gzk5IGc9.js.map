{"version":3,"file":"magic-string-gzk5IGc9.js","sources":["../../../node_modules/.pnpm/magic-string@0.30.21/node_modules/magic-string/dist/magic-string.es.mjs"],"sourcesContent":["import { encode } from '@jridgewell/sourcemap-codec';\n\nclass BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n\nclass Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t{\n\t\t\tthis.previous = null;\n\t\t\tthis.next = null;\n\t\t}\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\treset() {\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\t\tif (this.edited) {\n\t\t\tthis.content = this.original;\n\t\t\tthis.storeName = false;\n\t\t\tthis.edited = false;\n\t\t}\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// after split we should save the edit content record into the correct chunk\n\t\t\t// to make sure sourcemap correct\n\t\t\t// For example:\n\t\t\t// '  test'.trim()\n\t\t\t//     split   -> '  ' + 'test'\n\t\t\t//   ✔️ edit    -> '' + 'test'\n\t\t\t//   ✖️ edit    -> 'test' + ''\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tthis.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tconst newChunk = this.split(this.end - trimmed.length);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tnewChunk.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n\nfunction getBtoa() {\n\tif (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {\n\t\treturn (str) => globalThis.btoa(unescape(encodeURIComponent(str)));\n\t} else if (typeof Buffer === 'function') {\n\t\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\n\t} else {\n\t\treturn () => {\n\t\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t\t};\n\t}\n}\n\nconst btoa = /*#__PURE__*/ getBtoa();\n\nclass SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t\tif (typeof properties.x_google_ignoreList !== 'undefined') {\n\t\t\tthis.x_google_ignoreList = properties.x_google_ignoreList;\n\t\t}\n\t\tif (typeof properties.debugId !== 'undefined') {\n\t\t\tthis.debugId = properties.debugId;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n\nfunction guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n\nconst toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n\nconst wordRegex = /\\w/;\n\nclass Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst contentLengthMinusOne = content.length - 1;\n\t\t\tlet contentLineEnd = content.indexOf('\\n', 0);\n\t\t\tlet previousContentLineEnd = -1;\n\t\t\t// Loop through each line in the content and add a segment, but stop if the last line is empty,\n\t\t\t// else code afterwards would fill one line too many\n\t\t\twhile (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {\n\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\t\tif (nameIndex >= 0) {\n\t\t\t\t\tsegment.push(nameIndex);\n\t\t\t\t}\n\t\t\t\tthis.rawSegments.push(segment);\n\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\n\t\t\t\tpreviousContentLineEnd = contentLineEnd;\n\t\t\t\tcontentLineEnd = content.indexOf('\\n', contentLineEnd + 1);\n\t\t\t}\n\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\n\t\t\tthis.advance(content.slice(previousContentLineEnd + 1));\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t\tthis.advance(content);\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\t\t// when iterating each char, check if it's in a word boundary\n\t\tlet charInHiresBoundary = false;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t\tcharInHiresBoundary = false;\n\t\t\t} else {\n\t\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\n\t\t\t\t\tif (this.hires === 'boundary') {\n\t\t\t\t\t\t// in hires \"boundary\", group segments per word boundary than per char\n\t\t\t\t\t\tif (wordRegex.test(original[originalCharIndex])) {\n\t\t\t\t\t\t\t// for first char in the boundary found, start the boundary by pushing a segment\n\t\t\t\t\t\t\tif (!charInHiresBoundary) {\n\t\t\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\t\t\tcharInHiresBoundary = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// for non-word char, end the boundary by pushing a segment\n\t\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\t\tcharInHiresBoundary = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nclass MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: undefined },\n\t\t\tignoreList: { writable: true, value: options.ignoreList },\n\t\t\toffset: { writable: true, value: options.offset || 0 },\n\t\t});\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename, offset: this.offset });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\tif (this.outro) {\n\t\t\tmappings.advance(this.outro);\n\t\t}\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: [\n\t\t\t\toptions.source ? getRelativePath(options.file || '', options.source) : options.file || '',\n\t\t\t],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : undefined,\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\t_ensureindentStr() {\n\t\tif (this.indentStr === undefined) {\n\t\t\tthis.indentStr = guessIndent(this.original);\n\t\t}\n\t}\n\n\t_getRawIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr;\n\t}\n\n\tgetIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tif (indentStr === undefined) {\n\t\t\tthis._ensureindentStr();\n\t\t\tindentStr = this.indentStr || '\\t';\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',\n\t\t\t);\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',\n\t\t\t);\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\t\tindex = index + this.offset;\n\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\toptions = options || {};\n\t\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n\t}\n\n\tupdate(start, end, content, options) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead',\n\t\t\t);\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',\n\t\t\t\t);\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst overwrite = options !== undefined ? options.overwrite : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: true,\n\t\t\t\tenumerable: true,\n\t\t\t});\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, !overwrite);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\treset(start, end) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.reset();\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length - this.offset) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tlet previousChunk = chunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\n\t\t\t// Prevent infinite loop (e.g. via empty chunks, where start === end)\n\t\t\tif (chunk === previousChunk) return;\n\n\t\t\tpreviousChunk = chunk;\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`,\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n\n\thasChanged() {\n\t\treturn this.original !== this.toString();\n\t}\n\n\t_replaceRegexp(searchValue, replacement) {\n\t\tfunction getReplacement(match, str) {\n\t\t\tif (typeof replacement === 'string') {\n\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\tconst num = +i;\n\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\treturn `$${i}`;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t}\n\t\t}\n\t\tfunction matchAll(re, str) {\n\t\t\tlet match;\n\t\t\tconst matches = [];\n\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\t\tif (searchValue.global) {\n\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\tmatches.forEach((match) => {\n\t\t\t\tif (match.index != null) {\n\t\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\t\tthis.overwrite(match.index, match.index + match[0].length, replacement);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tconst match = this.original.match(searchValue);\n\t\t\tif (match && match.index != null) {\n\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\tthis.overwrite(match.index, match.index + match[0].length, replacement);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t_replaceString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst index = original.indexOf(string);\n\n\t\tif (index !== -1) {\n\t\t\tif (typeof replacement === 'function') {\n\t\t\t\treplacement = replacement(string, index, original);\n\t\t\t}\n\t\t\tif (string !== replacement) {\n\t\t\t\tthis.overwrite(index, index + string.length, replacement);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplace(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceString(searchValue, replacement);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n\n\t_replaceAllString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst stringLength = string.length;\n\t\tfor (\n\t\t\tlet index = original.indexOf(string);\n\t\t\tindex !== -1;\n\t\t\tindex = original.indexOf(string, index + stringLength)\n\t\t) {\n\t\t\tconst previous = original.slice(index, index + stringLength);\n\t\t\tlet _replacement = replacement;\n\t\t\tif (typeof replacement === 'function') {\n\t\t\t\t_replacement = replacement(previous, index, original);\n\t\t\t}\n\t\t\tif (previous !== _replacement) this.overwrite(index, index + stringLength, _replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplaceAll(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceAllString(searchValue, replacement);\n\t\t}\n\n\t\tif (!searchValue.global) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'MagicString.prototype.replaceAll called with a non-global RegExp argument',\n\t\t\t);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n}\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nclass Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`',\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'ignoreList', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tlet x_google_ignoreList = undefined;\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\n\t\t\tif (source.ignoreList && sourceIndex !== -1) {\n\t\t\t\tif (x_google_ignoreList === undefined) {\n\t\t\t\t\tx_google_ignoreList = [];\n\t\t\t\t}\n\t\t\t\tx_google_ignoreList.push(sourceIndex);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content._getRawIndentString();\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length,\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n\nexport { Bundle, SourceMap, MagicString as default };\n//# sourceMappingURL=magic-string.es.mjs.map\n"],"names":["BitSet","arg","n","Chunk","start","end","content","chunk","index","fn","storeName","contentOnly","sliceIndex","originalBefore","originalAfter","newChunk","rx","trimmed","getBtoa","str","btoa","SourceMap","properties","encode","guessIndent","code","lines","tabbed","line","spaced","min","previous","current","numSpaces","getRelativePath","from","to","fromParts","toParts","i","toString","isObject","thing","getLocator","source","originalLines","lineOffsets","pos","j","m","column","wordRegex","Mappings","hires","sourceIndex","loc","nameIndex","contentLengthMinusOne","contentLineEnd","previousContentLineEnd","segment","original","sourcemapLocations","originalCharIndex","first","charInHiresBoundary","warned","MagicString","string","options","char","cloned","originalChunk","clonedChunk","nextOriginalChunk","nextClonedChunk","names","mappings","locate","indentStr","pattern","isExcluded","exclusion","shouldIndentNextCharacter","replacer","match","charIndex","last","oldLeft","oldRight","newRight","newLeft","overwrite","lineIndex","lineStr","result","startChunk","containsEnd","sliceStart","sliceEnd","clone","previousChunk","searchForward","length","charType","aborted","searchValue","replacement","getReplacement","_","matchAll","re","matches","stringLength","_replacement"],"mappings":"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","x_google_ignoreList":[0]}