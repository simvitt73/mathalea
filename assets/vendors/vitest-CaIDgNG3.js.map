{"version":3,"file":"vitest-CaIDgNG3.js","sources":["../../../node_modules/.pnpm/vitest@4.0.18_@types+node@25.2.0_@vitest+ui@4.0.18_jiti@2.6.1_jsdom@27.4.0_lightningcss@1.30.2_sass@1.97.3_yaml@2.8.2/node_modules/vitest/dist/chunks/utils.DvEY5TfP.js","../../../node_modules/.pnpm/vitest@4.0.18_@types+node@25.2.0_@vitest+ui@4.0.18_jiti@2.6.1_jsdom@27.4.0_lightningcss@1.30.2_sass@1.97.3_yaml@2.8.2/node_modules/vitest/dist/chunks/_commonjsHelpers.D26ty3Ew.js","../../../node_modules/.pnpm/vitest@4.0.18_@types+node@25.2.0_@vitest+ui@4.0.18_jiti@2.6.1_jsdom@27.4.0_lightningcss@1.30.2_sass@1.97.3_yaml@2.8.2/node_modules/vitest/dist/chunks/vi.2VT5v0um.js"],"sourcesContent":["import { getSafeTimers } from '@vitest/utils/timers';\n\nconst NAME_WORKER_STATE = \"__vitest_worker__\";\nfunction getWorkerState() {\n\t// @ts-expect-error untyped global\n\tconst workerState = globalThis[NAME_WORKER_STATE];\n\tif (!workerState) throw new Error(\"Vitest failed to access its internal state.\\n\\nOne of the following is possible:\\n- \\\"vitest\\\" is imported directly without running \\\"vitest\\\" command\\n- \\\"vitest\\\" is imported inside \\\"globalSetup\\\" (to fix this, use \\\"setupFiles\\\" instead, because \\\"globalSetup\\\" runs in a different context)\\n- \\\"vitest\\\" is imported inside Vite / Vitest config file\\n- Otherwise, it might be a Vitest bug. Please report it to https://github.com/vitest-dev/vitest/issues\\n\");\n\treturn workerState;\n}\nfunction provideWorkerState(context, state) {\n\tObject.defineProperty(context, NAME_WORKER_STATE, {\n\t\tvalue: state,\n\t\tconfigurable: true,\n\t\twritable: true,\n\t\tenumerable: false\n\t});\n\treturn state;\n}\nfunction isChildProcess() {\n\treturn typeof process !== \"undefined\" && !!process.send;\n}\nfunction resetModules(modules, resetMocks = false) {\n\tconst skipPaths = [\n\t\t/\\/vitest\\/dist\\//,\n\t\t/vitest-virtual-\\w+\\/dist/,\n\t\t/@vitest\\/dist/,\n\t\t...!resetMocks ? [/^mock:/] : []\n\t];\n\tmodules.idToModuleMap.forEach((node, path) => {\n\t\tif (skipPaths.some((re) => re.test(path))) return;\n\t\tnode.promise = void 0;\n\t\tnode.exports = void 0;\n\t\tnode.evaluated = false;\n\t\tnode.importers.clear();\n\t});\n}\nfunction waitNextTick() {\n\tconst { setTimeout } = getSafeTimers();\n\treturn new Promise((resolve) => setTimeout(resolve, 0));\n}\nasync function waitForImportsToResolve() {\n\tawait waitNextTick();\n\tconst state = getWorkerState();\n\tconst promises = [];\n\tconst resolvingCount = state.resolvingModules.size;\n\tfor (const [_, mod] of state.evaluatedModules.idToModuleMap) if (mod.promise && !mod.evaluated) promises.push(mod.promise);\n\tif (!promises.length && !resolvingCount) return;\n\tawait Promise.allSettled(promises);\n\tawait waitForImportsToResolve();\n}\n\nexport { getWorkerState as g, isChildProcess as i, provideWorkerState as p, resetModules as r, waitForImportsToResolve as w };\n","var commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nfunction getDefaultExportFromCjs(x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\n\nexport { commonjsGlobal as c, getDefaultExportFromCjs as g };\n","import { chai, equals, iterableEquality, subsetEquality, JestExtend, JestChaiExpect, JestAsymmetricMatchers, GLOBAL_EXPECT, ASYMMETRIC_MATCHERS_OBJECT, getState, setState, addCustomEqualityTesters, customMatchers } from '@vitest/expect';\nimport { getCurrentTest } from '@vitest/runner';\nimport { g as getWorkerState, i as isChildProcess, w as waitForImportsToResolve, r as resetModules } from './utils.DvEY5TfP.js';\nimport { getSafeTimers, delay } from '@vitest/utils/timers';\nimport { getNames } from '@vitest/runner/utils';\nimport { stripSnapshotIndentation, addSerializer, SnapshotClient } from '@vitest/snapshot';\nimport '@vitest/utils/error';\nimport { assertTypes, createSimpleStackTrace } from '@vitest/utils/helpers';\nimport { fn, spyOn, restoreAllMocks, resetAllMocks, clearAllMocks, isMockFunction } from '@vitest/spy';\nimport '@vitest/utils/offset';\nimport { parseSingleStack } from '@vitest/utils/source-map';\nimport { c as commonjsGlobal } from './_commonjsHelpers.D26ty3Ew.js';\nimport { R as RealDate, r as resetDate, m as mockDate } from './date.Bq6ZW5rf.js';\n\n// these matchers are not supported because they don't make sense with poll\nconst unsupported = [\n\t\"matchSnapshot\",\n\t\"toMatchSnapshot\",\n\t\"toMatchInlineSnapshot\",\n\t\"toThrowErrorMatchingSnapshot\",\n\t\"toThrowErrorMatchingInlineSnapshot\",\n\t\"throws\",\n\t\"Throw\",\n\t\"throw\",\n\t\"toThrow\",\n\t\"toThrowError\"\n];\n/**\n* Attaches a `cause` property to the error if missing, copies the stack trace from the source, and throws.\n*\n* @param error - The error to throw\n* @param source - Error to copy the stack trace from\n*\n* @throws Always throws the provided error with an amended stack trace\n*/\nfunction throwWithCause(error, source) {\n\tif (error.cause == null) error.cause = /* @__PURE__ */ new Error(\"Matcher did not succeed in time.\");\n\tthrow copyStackTrace$1(error, source);\n}\nfunction createExpectPoll(expect) {\n\treturn function poll(fn, options = {}) {\n\t\tconst defaults = getWorkerState().config.expect?.poll ?? {};\n\t\tconst { interval = defaults.interval ?? 50, timeout = defaults.timeout ?? 1e3, message } = options;\n\t\t// @ts-expect-error private poll access\n\t\tconst assertion = expect(null, message).withContext({ poll: true });\n\t\tfn = fn.bind(assertion);\n\t\tconst test = chai.util.flag(assertion, \"vitest-test\");\n\t\tif (!test) throw new Error(\"expect.poll() must be called inside a test\");\n\t\tconst proxy = new Proxy(assertion, { get(target, key, receiver) {\n\t\t\tconst assertionFunction = Reflect.get(target, key, receiver);\n\t\t\tif (typeof assertionFunction !== \"function\") return assertionFunction instanceof chai.Assertion ? proxy : assertionFunction;\n\t\t\tif (key === \"assert\") return assertionFunction;\n\t\t\tif (typeof key === \"string\" && unsupported.includes(key)) throw new SyntaxError(`expect.poll() is not supported in combination with .${key}(). Use vi.waitFor() if your assertion condition is unstable.`);\n\t\t\treturn function(...args) {\n\t\t\t\tconst STACK_TRACE_ERROR = /* @__PURE__ */ new Error(\"STACK_TRACE_ERROR\");\n\t\t\t\tconst promise = async () => {\n\t\t\t\t\tconst { setTimeout, clearTimeout } = getSafeTimers();\n\t\t\t\t\tlet executionPhase = \"fn\";\n\t\t\t\t\tlet hasTimedOut = false;\n\t\t\t\t\tconst timerId = setTimeout(() => {\n\t\t\t\t\t\thasTimedOut = true;\n\t\t\t\t\t}, timeout);\n\t\t\t\t\tchai.util.flag(assertion, \"_name\", key);\n\t\t\t\t\ttry {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tconst isLastAttempt = hasTimedOut;\n\t\t\t\t\t\t\tif (isLastAttempt) chai.util.flag(assertion, \"_isLastPollAttempt\", true);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\texecutionPhase = \"fn\";\n\t\t\t\t\t\t\t\tconst obj = await fn();\n\t\t\t\t\t\t\t\tchai.util.flag(assertion, \"object\", obj);\n\t\t\t\t\t\t\t\texecutionPhase = \"assertion\";\n\t\t\t\t\t\t\t\treturn await assertionFunction.call(assertion, ...args);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\tif (isLastAttempt || executionPhase === \"assertion\" && chai.util.flag(assertion, \"_poll.assert_once\")) throwWithCause(err, STACK_TRACE_ERROR);\n\t\t\t\t\t\t\t\tawait delay(interval, setTimeout);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tclearTimeout(timerId);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tlet awaited = false;\n\t\t\t\ttest.onFinished ??= [];\n\t\t\t\ttest.onFinished.push(() => {\n\t\t\t\t\tif (!awaited) {\n\t\t\t\t\t\tconst negated = chai.util.flag(assertion, \"negate\") ? \"not.\" : \"\";\n\t\t\t\t\t\tconst assertionString = `expect.${chai.util.flag(assertion, \"_poll.element\") ? \"element(locator)\" : \"poll(assertion)\"}.${negated}${String(key)}()`;\n\t\t\t\t\t\tthrow copyStackTrace$1(/* @__PURE__ */ new Error(`${assertionString} was not awaited. This assertion is asynchronous and must be awaited; otherwise, it is not executed to avoid unhandled rejections:\\n\\nawait ${assertionString}\\n`), STACK_TRACE_ERROR);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tlet resultPromise;\n\t\t\t\t// only .then is enough to check awaited, but we type this as `Promise<void>` in global types\n\t\t\t\t// so let's follow it\n\t\t\t\treturn {\n\t\t\t\t\tthen(onFulfilled, onRejected) {\n\t\t\t\t\t\tawaited = true;\n\t\t\t\t\t\treturn (resultPromise ||= promise()).then(onFulfilled, onRejected);\n\t\t\t\t\t},\n\t\t\t\t\tcatch(onRejected) {\n\t\t\t\t\t\treturn (resultPromise ||= promise()).catch(onRejected);\n\t\t\t\t\t},\n\t\t\t\t\tfinally(onFinally) {\n\t\t\t\t\t\treturn (resultPromise ||= promise()).finally(onFinally);\n\t\t\t\t\t},\n\t\t\t\t\t[Symbol.toStringTag]: \"Promise\"\n\t\t\t\t};\n\t\t\t};\n\t\t} });\n\t\treturn proxy;\n\t};\n}\nfunction copyStackTrace$1(target, source) {\n\tif (source.stack !== void 0) target.stack = source.stack.replace(source.message, target.message);\n\treturn target;\n}\n\nfunction createAssertionMessage(util, assertion, hasArgs) {\n\tconst not = util.flag(assertion, \"negate\") ? \"not.\" : \"\";\n\tconst name = `${util.flag(assertion, \"_name\")}(${\"expected\" })`;\n\tconst promiseName = util.flag(assertion, \"promise\");\n\treturn `expect(actual)${promiseName ? `.${promiseName}` : \"\"}.${not}${name}`;\n}\nfunction recordAsyncExpect(_test, promise, assertion, error) {\n\tconst test = _test;\n\t// record promise for test, that resolves before test ends\n\tif (test && promise instanceof Promise) {\n\t\t// if promise is explicitly awaited, remove it from the list\n\t\tpromise = promise.finally(() => {\n\t\t\tif (!test.promises) return;\n\t\t\tconst index = test.promises.indexOf(promise);\n\t\t\tif (index !== -1) test.promises.splice(index, 1);\n\t\t});\n\t\t// record promise\n\t\tif (!test.promises) test.promises = [];\n\t\ttest.promises.push(promise);\n\t\tlet resolved = false;\n\t\ttest.onFinished ??= [];\n\t\ttest.onFinished.push(() => {\n\t\t\tif (!resolved) {\n\t\t\t\tconst stack = (globalThis.__vitest_worker__?.onFilterStackTrace || ((s) => s || \"\"))(error.stack);\n\t\t\t\tconsole.warn([\n\t\t\t\t\t`Promise returned by \\`${assertion}\\` was not awaited. `,\n\t\t\t\t\t\"Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. \",\n\t\t\t\t\t\"Please remember to await the assertion.\\n\",\n\t\t\t\t\tstack\n\t\t\t\t].join(\"\"));\n\t\t\t}\n\t\t});\n\t\treturn {\n\t\t\tthen(onFulfilled, onRejected) {\n\t\t\t\tresolved = true;\n\t\t\t\treturn promise.then(onFulfilled, onRejected);\n\t\t\t},\n\t\t\tcatch(onRejected) {\n\t\t\t\treturn promise.catch(onRejected);\n\t\t\t},\n\t\t\tfinally(onFinally) {\n\t\t\t\treturn promise.finally(onFinally);\n\t\t\t},\n\t\t\t[Symbol.toStringTag]: \"Promise\"\n\t\t};\n\t}\n\treturn promise;\n}\n\nlet _client;\nfunction getSnapshotClient() {\n\tif (!_client) _client = new SnapshotClient({ isEqual: (received, expected) => {\n\t\treturn equals(received, expected, [iterableEquality, subsetEquality]);\n\t} });\n\treturn _client;\n}\nfunction getError(expected, promise) {\n\tif (typeof expected !== \"function\") {\n\t\tif (!promise) throw new Error(`expected must be a function, received ${typeof expected}`);\n\t\t// when \"promised\", it receives thrown error\n\t\treturn expected;\n\t}\n\ttry {\n\t\texpected();\n\t} catch (e) {\n\t\treturn e;\n\t}\n\tthrow new Error(\"snapshot function didn't throw\");\n}\nfunction getTestNames(test) {\n\treturn {\n\t\tfilepath: test.file.filepath,\n\t\tname: getNames(test).slice(1).join(\" > \"),\n\t\ttestId: test.id\n\t};\n}\nconst SnapshotPlugin = (chai, utils) => {\n\tfunction getTest(assertionName, obj) {\n\t\tconst test = utils.flag(obj, \"vitest-test\");\n\t\tif (!test) throw new Error(`'${assertionName}' cannot be used without test context`);\n\t\treturn test;\n\t}\n\tfor (const key of [\"matchSnapshot\", \"toMatchSnapshot\"]) utils.addMethod(chai.Assertion.prototype, key, function(properties, message) {\n\t\tutils.flag(this, \"_name\", key);\n\t\tif (utils.flag(this, \"negate\")) throw new Error(`${key} cannot be used with \"not\"`);\n\t\tconst expected = utils.flag(this, \"object\");\n\t\tconst test = getTest(key, this);\n\t\tif (typeof properties === \"string\" && typeof message === \"undefined\") {\n\t\t\tmessage = properties;\n\t\t\tproperties = void 0;\n\t\t}\n\t\tconst errorMessage = utils.flag(this, \"message\");\n\t\tgetSnapshotClient().assert({\n\t\t\treceived: expected,\n\t\t\tmessage,\n\t\t\tisInline: false,\n\t\t\tproperties,\n\t\t\terrorMessage,\n\t\t\t...getTestNames(test)\n\t\t});\n\t});\n\tutils.addMethod(chai.Assertion.prototype, \"toMatchFileSnapshot\", function(file, message) {\n\t\tutils.flag(this, \"_name\", \"toMatchFileSnapshot\");\n\t\tif (utils.flag(this, \"negate\")) throw new Error(\"toMatchFileSnapshot cannot be used with \\\"not\\\"\");\n\t\tconst error = /* @__PURE__ */ new Error(\"resolves\");\n\t\tconst expected = utils.flag(this, \"object\");\n\t\tconst test = getTest(\"toMatchFileSnapshot\", this);\n\t\tconst errorMessage = utils.flag(this, \"message\");\n\t\treturn recordAsyncExpect(test, getSnapshotClient().assertRaw({\n\t\t\treceived: expected,\n\t\t\tmessage,\n\t\t\tisInline: false,\n\t\t\trawSnapshot: { file },\n\t\t\terrorMessage,\n\t\t\t...getTestNames(test)\n\t\t}), createAssertionMessage(utils, this), error);\n\t});\n\tutils.addMethod(chai.Assertion.prototype, \"toMatchInlineSnapshot\", function __INLINE_SNAPSHOT__(properties, inlineSnapshot, message) {\n\t\tutils.flag(this, \"_name\", \"toMatchInlineSnapshot\");\n\t\tif (utils.flag(this, \"negate\")) throw new Error(\"toMatchInlineSnapshot cannot be used with \\\"not\\\"\");\n\t\tconst test = getTest(\"toMatchInlineSnapshot\", this);\n\t\tif (test.each || test.suite?.each) throw new Error(\"InlineSnapshot cannot be used inside of test.each or describe.each\");\n\t\tconst expected = utils.flag(this, \"object\");\n\t\tconst error = utils.flag(this, \"error\");\n\t\tif (typeof properties === \"string\") {\n\t\t\tmessage = inlineSnapshot;\n\t\t\tinlineSnapshot = properties;\n\t\t\tproperties = void 0;\n\t\t}\n\t\tif (inlineSnapshot) inlineSnapshot = stripSnapshotIndentation(inlineSnapshot);\n\t\tconst errorMessage = utils.flag(this, \"message\");\n\t\tgetSnapshotClient().assert({\n\t\t\treceived: expected,\n\t\t\tmessage,\n\t\t\tisInline: true,\n\t\t\tproperties,\n\t\t\tinlineSnapshot,\n\t\t\terror,\n\t\t\terrorMessage,\n\t\t\t...getTestNames(test)\n\t\t});\n\t});\n\tutils.addMethod(chai.Assertion.prototype, \"toThrowErrorMatchingSnapshot\", function(message) {\n\t\tutils.flag(this, \"_name\", \"toThrowErrorMatchingSnapshot\");\n\t\tif (utils.flag(this, \"negate\")) throw new Error(\"toThrowErrorMatchingSnapshot cannot be used with \\\"not\\\"\");\n\t\tconst expected = utils.flag(this, \"object\");\n\t\tconst test = getTest(\"toThrowErrorMatchingSnapshot\", this);\n\t\tconst promise = utils.flag(this, \"promise\");\n\t\tconst errorMessage = utils.flag(this, \"message\");\n\t\tgetSnapshotClient().assert({\n\t\t\treceived: getError(expected, promise),\n\t\t\tmessage,\n\t\t\terrorMessage,\n\t\t\t...getTestNames(test)\n\t\t});\n\t});\n\tutils.addMethod(chai.Assertion.prototype, \"toThrowErrorMatchingInlineSnapshot\", function __INLINE_SNAPSHOT__(inlineSnapshot, message) {\n\t\tif (utils.flag(this, \"negate\")) throw new Error(\"toThrowErrorMatchingInlineSnapshot cannot be used with \\\"not\\\"\");\n\t\tconst test = getTest(\"toThrowErrorMatchingInlineSnapshot\", this);\n\t\tif (test.each || test.suite?.each) throw new Error(\"InlineSnapshot cannot be used inside of test.each or describe.each\");\n\t\tconst expected = utils.flag(this, \"object\");\n\t\tconst error = utils.flag(this, \"error\");\n\t\tconst promise = utils.flag(this, \"promise\");\n\t\tconst errorMessage = utils.flag(this, \"message\");\n\t\tif (inlineSnapshot) inlineSnapshot = stripSnapshotIndentation(inlineSnapshot);\n\t\tgetSnapshotClient().assert({\n\t\t\treceived: getError(expected, promise),\n\t\t\tmessage,\n\t\t\tinlineSnapshot,\n\t\t\tisInline: true,\n\t\t\terror,\n\t\t\terrorMessage,\n\t\t\t...getTestNames(test)\n\t\t});\n\t});\n\tutils.addMethod(chai.expect, \"addSnapshotSerializer\", addSerializer);\n};\n\nchai.use(JestExtend);\nchai.use(JestChaiExpect);\nchai.use(SnapshotPlugin);\nchai.use(JestAsymmetricMatchers);\n\nfunction createExpect(test) {\n\tconst expect = ((value, message) => {\n\t\tconst { assertionCalls } = getState(expect);\n\t\tsetState({ assertionCalls: assertionCalls + 1 }, expect);\n\t\tconst assert = chai.expect(value, message);\n\t\tconst _test = test || getCurrentTest();\n\t\tif (_test)\n // @ts-expect-error internal\n\t\treturn assert.withTest(_test);\n\t\telse return assert;\n\t});\n\tObject.assign(expect, chai.expect);\n\tObject.assign(expect, globalThis[ASYMMETRIC_MATCHERS_OBJECT]);\n\texpect.getState = () => getState(expect);\n\texpect.setState = (state) => setState(state, expect);\n\t// @ts-expect-error global is not typed\n\tconst globalState = getState(globalThis[GLOBAL_EXPECT]) || {};\n\tsetState({\n\t\t...globalState,\n\t\tassertionCalls: 0,\n\t\tisExpectingAssertions: false,\n\t\tisExpectingAssertionsError: null,\n\t\texpectedAssertionsNumber: null,\n\t\texpectedAssertionsNumberErrorGen: null,\n\t\tget testPath() {\n\t\t\treturn getWorkerState().filepath;\n\t\t},\n\t\tcurrentTestName: test ? test.fullTestName ?? \"\" : globalState.currentTestName\n\t}, expect);\n\texpect.assert = chai.assert;\n\t// @ts-expect-error untyped\n\texpect.extend = (matchers) => chai.expect.extend(expect, matchers);\n\texpect.addEqualityTesters = (customTesters) => addCustomEqualityTesters(customTesters);\n\texpect.soft = (...args) => {\n\t\t// @ts-expect-error private soft access\n\t\treturn expect(...args).withContext({ soft: true });\n\t};\n\texpect.poll = createExpectPoll(expect);\n\texpect.unreachable = (message) => {\n\t\tchai.assert.fail(`expected${message ? ` \"${message}\" ` : \" \"}not to be reached`);\n\t};\n\tfunction assertions(expected) {\n\t\tconst errorGen = () => /* @__PURE__ */ new Error(`expected number of assertions to be ${expected}, but got ${expect.getState().assertionCalls}`);\n\t\tif (Error.captureStackTrace) Error.captureStackTrace(errorGen(), assertions);\n\t\texpect.setState({\n\t\t\texpectedAssertionsNumber: expected,\n\t\t\texpectedAssertionsNumberErrorGen: errorGen\n\t\t});\n\t}\n\tfunction hasAssertions() {\n\t\tconst error = /* @__PURE__ */ new Error(\"expected any number of assertion, but got none\");\n\t\tif (Error.captureStackTrace) Error.captureStackTrace(error, hasAssertions);\n\t\texpect.setState({\n\t\t\tisExpectingAssertions: true,\n\t\t\tisExpectingAssertionsError: error\n\t\t});\n\t}\n\tchai.util.addMethod(expect, \"assertions\", assertions);\n\tchai.util.addMethod(expect, \"hasAssertions\", hasAssertions);\n\texpect.extend(customMatchers);\n\treturn expect;\n}\nconst globalExpect = createExpect();\nObject.defineProperty(globalThis, GLOBAL_EXPECT, {\n\tvalue: globalExpect,\n\twritable: true,\n\tconfigurable: true\n});\nconst assert = chai.assert;\nconst should = chai.should;\n\n/**\n* Gives access to injected context provided from the main thread.\n* This usually returns a value provided by `globalSetup` or an external library.\n*/\nfunction inject(key) {\n\treturn getWorkerState().providedContext[key];\n}\n\nvar fakeTimersSrc = {};\n\nvar global;\nvar hasRequiredGlobal;\n\nfunction requireGlobal () {\n\tif (hasRequiredGlobal) return global;\n\thasRequiredGlobal = 1;\n\n\t/**\n\t * A reference to the global object\n\t * @type {object} globalObject\n\t */\n\tvar globalObject;\n\n\t/* istanbul ignore else */\n\tif (typeof commonjsGlobal !== \"undefined\") {\n\t    // Node\n\t    globalObject = commonjsGlobal;\n\t} else if (typeof window !== \"undefined\") {\n\t    // Browser\n\t    globalObject = window;\n\t} else {\n\t    // WebWorker\n\t    globalObject = self;\n\t}\n\n\tglobal = globalObject;\n\treturn global;\n}\n\nvar throwsOnProto_1;\nvar hasRequiredThrowsOnProto;\n\nfunction requireThrowsOnProto () {\n\tif (hasRequiredThrowsOnProto) return throwsOnProto_1;\n\thasRequiredThrowsOnProto = 1;\n\n\t/**\n\t * Is true when the environment causes an error to be thrown for accessing the\n\t * __proto__ property.\n\t * This is necessary in order to support `node --disable-proto=throw`.\n\t *\n\t * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto\n\t * @type {boolean}\n\t */\n\tlet throwsOnProto;\n\ttry {\n\t    const object = {};\n\t    // eslint-disable-next-line no-proto, no-unused-expressions\n\t    object.__proto__;\n\t    throwsOnProto = false;\n\t} catch (_) {\n\t    // This branch is covered when tests are run with `--disable-proto=throw`,\n\t    // however we can test both branches at the same time, so this is ignored\n\t    /* istanbul ignore next */\n\t    throwsOnProto = true;\n\t}\n\n\tthrowsOnProto_1 = throwsOnProto;\n\treturn throwsOnProto_1;\n}\n\nvar copyPrototypeMethods;\nvar hasRequiredCopyPrototypeMethods;\n\nfunction requireCopyPrototypeMethods () {\n\tif (hasRequiredCopyPrototypeMethods) return copyPrototypeMethods;\n\thasRequiredCopyPrototypeMethods = 1;\n\n\tvar call = Function.call;\n\tvar throwsOnProto = requireThrowsOnProto();\n\n\tvar disallowedProperties = [\n\t    // ignore size because it throws from Map\n\t    \"size\",\n\t    \"caller\",\n\t    \"callee\",\n\t    \"arguments\",\n\t];\n\n\t// This branch is covered when tests are run with `--disable-proto=throw`,\n\t// however we can test both branches at the same time, so this is ignored\n\t/* istanbul ignore next */\n\tif (throwsOnProto) {\n\t    disallowedProperties.push(\"__proto__\");\n\t}\n\n\tcopyPrototypeMethods = function copyPrototypeMethods(prototype) {\n\t    // eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods\n\t    return Object.getOwnPropertyNames(prototype).reduce(function (\n\t        result,\n\t        name\n\t    ) {\n\t        if (disallowedProperties.includes(name)) {\n\t            return result;\n\t        }\n\n\t        if (typeof prototype[name] !== \"function\") {\n\t            return result;\n\t        }\n\n\t        result[name] = call.bind(prototype[name]);\n\n\t        return result;\n\t    },\n\t    Object.create(null));\n\t};\n\treturn copyPrototypeMethods;\n}\n\nvar array;\nvar hasRequiredArray;\n\nfunction requireArray () {\n\tif (hasRequiredArray) return array;\n\thasRequiredArray = 1;\n\n\tvar copyPrototype = requireCopyPrototypeMethods();\n\n\tarray = copyPrototype(Array.prototype);\n\treturn array;\n}\n\nvar calledInOrder_1;\nvar hasRequiredCalledInOrder;\n\nfunction requireCalledInOrder () {\n\tif (hasRequiredCalledInOrder) return calledInOrder_1;\n\thasRequiredCalledInOrder = 1;\n\n\tvar every = requireArray().every;\n\n\t/**\n\t * @private\n\t */\n\tfunction hasCallsLeft(callMap, spy) {\n\t    if (callMap[spy.id] === undefined) {\n\t        callMap[spy.id] = 0;\n\t    }\n\n\t    return callMap[spy.id] < spy.callCount;\n\t}\n\n\t/**\n\t * @private\n\t */\n\tfunction checkAdjacentCalls(callMap, spy, index, spies) {\n\t    var calledBeforeNext = true;\n\n\t    if (index !== spies.length - 1) {\n\t        calledBeforeNext = spy.calledBefore(spies[index + 1]);\n\t    }\n\n\t    if (hasCallsLeft(callMap, spy) && calledBeforeNext) {\n\t        callMap[spy.id] += 1;\n\t        return true;\n\t    }\n\n\t    return false;\n\t}\n\n\t/**\n\t * A Sinon proxy object (fake, spy, stub)\n\t * @typedef {object} SinonProxy\n\t * @property {Function} calledBefore - A method that determines if this proxy was called before another one\n\t * @property {string} id - Some id\n\t * @property {number} callCount - Number of times this proxy has been called\n\t */\n\n\t/**\n\t * Returns true when the spies have been called in the order they were supplied in\n\t * @param  {SinonProxy[] | SinonProxy} spies An array of proxies, or several proxies as arguments\n\t * @returns {boolean} true when spies are called in order, false otherwise\n\t */\n\tfunction calledInOrder(spies) {\n\t    var callMap = {};\n\t    // eslint-disable-next-line no-underscore-dangle\n\t    var _spies = arguments.length > 1 ? arguments : spies;\n\n\t    return every(_spies, checkAdjacentCalls.bind(null, callMap));\n\t}\n\n\tcalledInOrder_1 = calledInOrder;\n\treturn calledInOrder_1;\n}\n\nvar className_1;\nvar hasRequiredClassName;\n\nfunction requireClassName () {\n\tif (hasRequiredClassName) return className_1;\n\thasRequiredClassName = 1;\n\n\t/**\n\t * Returns a display name for a value from a constructor\n\t * @param  {object} value A value to examine\n\t * @returns {(string|null)} A string or null\n\t */\n\tfunction className(value) {\n\t    const name = value.constructor && value.constructor.name;\n\t    return name || null;\n\t}\n\n\tclassName_1 = className;\n\treturn className_1;\n}\n\nvar deprecated = {};\n\n/* eslint-disable no-console */\n\nvar hasRequiredDeprecated;\n\nfunction requireDeprecated () {\n\tif (hasRequiredDeprecated) return deprecated;\n\thasRequiredDeprecated = 1;\n\t(function (exports$1) {\n\n\t\t/**\n\t\t * Returns a function that will invoke the supplied function and print a\n\t\t * deprecation warning to the console each time it is called.\n\t\t * @param  {Function} func\n\t\t * @param  {string} msg\n\t\t * @returns {Function}\n\t\t */\n\t\texports$1.wrap = function (func, msg) {\n\t\t    var wrapped = function () {\n\t\t        exports$1.printWarning(msg);\n\t\t        return func.apply(this, arguments);\n\t\t    };\n\t\t    if (func.prototype) {\n\t\t        wrapped.prototype = func.prototype;\n\t\t    }\n\t\t    return wrapped;\n\t\t};\n\n\t\t/**\n\t\t * Returns a string which can be supplied to `wrap()` to notify the user that a\n\t\t * particular part of the sinon API has been deprecated.\n\t\t * @param  {string} packageName\n\t\t * @param  {string} funcName\n\t\t * @returns {string}\n\t\t */\n\t\texports$1.defaultMsg = function (packageName, funcName) {\n\t\t    return `${packageName}.${funcName} is deprecated and will be removed from the public API in a future version of ${packageName}.`;\n\t\t};\n\n\t\t/**\n\t\t * Prints a warning on the console, when it exists\n\t\t * @param  {string} msg\n\t\t * @returns {undefined}\n\t\t */\n\t\texports$1.printWarning = function (msg) {\n\t\t    /* istanbul ignore next */\n\t\t    if (typeof process === \"object\" && process.emitWarning) {\n\t\t        // Emit Warnings in Node\n\t\t        process.emitWarning(msg);\n\t\t    } else if (console.info) {\n\t\t        console.info(msg);\n\t\t    } else {\n\t\t        console.log(msg);\n\t\t    }\n\t\t}; \n\t} (deprecated));\n\treturn deprecated;\n}\n\nvar every;\nvar hasRequiredEvery;\n\nfunction requireEvery () {\n\tif (hasRequiredEvery) return every;\n\thasRequiredEvery = 1;\n\n\t/**\n\t * Returns true when fn returns true for all members of obj.\n\t * This is an every implementation that works for all iterables\n\t * @param  {object}   obj\n\t * @param  {Function} fn\n\t * @returns {boolean}\n\t */\n\tevery = function every(obj, fn) {\n\t    var pass = true;\n\n\t    try {\n\t        // eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods\n\t        obj.forEach(function () {\n\t            if (!fn.apply(this, arguments)) {\n\t                // Throwing an error is the only way to break `forEach`\n\t                throw new Error();\n\t            }\n\t        });\n\t    } catch (e) {\n\t        pass = false;\n\t    }\n\n\t    return pass;\n\t};\n\treturn every;\n}\n\nvar functionName;\nvar hasRequiredFunctionName;\n\nfunction requireFunctionName () {\n\tif (hasRequiredFunctionName) return functionName;\n\thasRequiredFunctionName = 1;\n\n\t/**\n\t * Returns a display name for a function\n\t * @param  {Function} func\n\t * @returns {string}\n\t */\n\tfunctionName = function functionName(func) {\n\t    if (!func) {\n\t        return \"\";\n\t    }\n\n\t    try {\n\t        return (\n\t            func.displayName ||\n\t            func.name ||\n\t            // Use function decomposition as a last resort to get function\n\t            // name. Does not rely on function decomposition to work - if it\n\t            // doesn't debugging will be slightly less informative\n\t            // (i.e. toString will say 'spy' rather than 'myFunc').\n\t            (String(func).match(/function ([^\\s(]+)/) || [])[1]\n\t        );\n\t    } catch (e) {\n\t        // Stringify may fail and we might get an exception, as a last-last\n\t        // resort fall back to empty string.\n\t        return \"\";\n\t    }\n\t};\n\treturn functionName;\n}\n\nvar orderByFirstCall_1;\nvar hasRequiredOrderByFirstCall;\n\nfunction requireOrderByFirstCall () {\n\tif (hasRequiredOrderByFirstCall) return orderByFirstCall_1;\n\thasRequiredOrderByFirstCall = 1;\n\n\tvar sort = requireArray().sort;\n\tvar slice = requireArray().slice;\n\n\t/**\n\t * @private\n\t */\n\tfunction comparator(a, b) {\n\t    // uuid, won't ever be equal\n\t    var aCall = a.getCall(0);\n\t    var bCall = b.getCall(0);\n\t    var aId = (aCall && aCall.callId) || -1;\n\t    var bId = (bCall && bCall.callId) || -1;\n\n\t    return aId < bId ? -1 : 1;\n\t}\n\n\t/**\n\t * A Sinon proxy object (fake, spy, stub)\n\t * @typedef {object} SinonProxy\n\t * @property {Function} getCall - A method that can return the first call\n\t */\n\n\t/**\n\t * Sorts an array of SinonProxy instances (fake, spy, stub) by their first call\n\t * @param  {SinonProxy[] | SinonProxy} spies\n\t * @returns {SinonProxy[]}\n\t */\n\tfunction orderByFirstCall(spies) {\n\t    return sort(slice(spies), comparator);\n\t}\n\n\torderByFirstCall_1 = orderByFirstCall;\n\treturn orderByFirstCall_1;\n}\n\nvar _function;\nvar hasRequired_function;\n\nfunction require_function () {\n\tif (hasRequired_function) return _function;\n\thasRequired_function = 1;\n\n\tvar copyPrototype = requireCopyPrototypeMethods();\n\n\t_function = copyPrototype(Function.prototype);\n\treturn _function;\n}\n\nvar map;\nvar hasRequiredMap;\n\nfunction requireMap () {\n\tif (hasRequiredMap) return map;\n\thasRequiredMap = 1;\n\n\tvar copyPrototype = requireCopyPrototypeMethods();\n\n\tmap = copyPrototype(Map.prototype);\n\treturn map;\n}\n\nvar object;\nvar hasRequiredObject;\n\nfunction requireObject () {\n\tif (hasRequiredObject) return object;\n\thasRequiredObject = 1;\n\n\tvar copyPrototype = requireCopyPrototypeMethods();\n\n\tobject = copyPrototype(Object.prototype);\n\treturn object;\n}\n\nvar set;\nvar hasRequiredSet;\n\nfunction requireSet () {\n\tif (hasRequiredSet) return set;\n\thasRequiredSet = 1;\n\n\tvar copyPrototype = requireCopyPrototypeMethods();\n\n\tset = copyPrototype(Set.prototype);\n\treturn set;\n}\n\nvar string;\nvar hasRequiredString;\n\nfunction requireString () {\n\tif (hasRequiredString) return string;\n\thasRequiredString = 1;\n\n\tvar copyPrototype = requireCopyPrototypeMethods();\n\n\tstring = copyPrototype(String.prototype);\n\treturn string;\n}\n\nvar prototypes;\nvar hasRequiredPrototypes;\n\nfunction requirePrototypes () {\n\tif (hasRequiredPrototypes) return prototypes;\n\thasRequiredPrototypes = 1;\n\n\tprototypes = {\n\t    array: requireArray(),\n\t    function: require_function(),\n\t    map: requireMap(),\n\t    object: requireObject(),\n\t    set: requireSet(),\n\t    string: requireString(),\n\t};\n\treturn prototypes;\n}\n\nvar typeDetect$1 = {exports: {}};\n\nvar typeDetect = typeDetect$1.exports;\n\nvar hasRequiredTypeDetect;\n\nfunction requireTypeDetect () {\n\tif (hasRequiredTypeDetect) return typeDetect$1.exports;\n\thasRequiredTypeDetect = 1;\n\t(function (module, exports$1) {\n\t\t(function (global, factory) {\n\t\t\tmodule.exports = factory() ;\n\t\t}(typeDetect, (function () {\n\t\t/* !\n\t\t * type-detect\n\t\t * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>\n\t\t * MIT Licensed\n\t\t */\n\t\tvar promiseExists = typeof Promise === 'function';\n\n\t\t/* eslint-disable no-undef */\n\t\tvar globalObject = typeof self === 'object' ? self : commonjsGlobal; // eslint-disable-line id-blacklist\n\n\t\tvar symbolExists = typeof Symbol !== 'undefined';\n\t\tvar mapExists = typeof Map !== 'undefined';\n\t\tvar setExists = typeof Set !== 'undefined';\n\t\tvar weakMapExists = typeof WeakMap !== 'undefined';\n\t\tvar weakSetExists = typeof WeakSet !== 'undefined';\n\t\tvar dataViewExists = typeof DataView !== 'undefined';\n\t\tvar symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';\n\t\tvar symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';\n\t\tvar setEntriesExists = setExists && typeof Set.prototype.entries === 'function';\n\t\tvar mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';\n\t\tvar setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());\n\t\tvar mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());\n\t\tvar arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';\n\t\tvar arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());\n\t\tvar stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';\n\t\tvar stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());\n\t\tvar toStringLeftSliceLength = 8;\n\t\tvar toStringRightSliceLength = -1;\n\t\t/**\n\t\t * ### typeOf (obj)\n\t\t *\n\t\t * Uses `Object.prototype.toString` to determine the type of an object,\n\t\t * normalising behaviour across engine versions & well optimised.\n\t\t *\n\t\t * @param {Mixed} object\n\t\t * @return {String} object type\n\t\t * @api public\n\t\t */\n\t\tfunction typeDetect(obj) {\n\t\t  /* ! Speed optimisation\n\t\t   * Pre:\n\t\t   *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)\n\t\t   *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)\n\t\t   *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)\n\t\t   *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)\n\t\t   *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)\n\t\t   * Post:\n\t\t   *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)\n\t\t   *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)\n\t\t   *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)\n\t\t   *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)\n\t\t   *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)\n\t\t   */\n\t\t  var typeofObj = typeof obj;\n\t\t  if (typeofObj !== 'object') {\n\t\t    return typeofObj;\n\t\t  }\n\n\t\t  /* ! Speed optimisation\n\t\t   * Pre:\n\t\t   *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)\n\t\t   * Post:\n\t\t   *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)\n\t\t   */\n\t\t  if (obj === null) {\n\t\t    return 'null';\n\t\t  }\n\n\t\t  /* ! Spec Conformance\n\t\t   * Test: `Object.prototype.toString.call(window)``\n\t\t   *  - Node === \"[object global]\"\n\t\t   *  - Chrome === \"[object global]\"\n\t\t   *  - Firefox === \"[object Window]\"\n\t\t   *  - PhantomJS === \"[object Window]\"\n\t\t   *  - Safari === \"[object Window]\"\n\t\t   *  - IE 11 === \"[object Window]\"\n\t\t   *  - IE Edge === \"[object Window]\"\n\t\t   * Test: `Object.prototype.toString.call(this)``\n\t\t   *  - Chrome Worker === \"[object global]\"\n\t\t   *  - Firefox Worker === \"[object DedicatedWorkerGlobalScope]\"\n\t\t   *  - Safari Worker === \"[object DedicatedWorkerGlobalScope]\"\n\t\t   *  - IE 11 Worker === \"[object WorkerGlobalScope]\"\n\t\t   *  - IE Edge Worker === \"[object WorkerGlobalScope]\"\n\t\t   */\n\t\t  if (obj === globalObject) {\n\t\t    return 'global';\n\t\t  }\n\n\t\t  /* ! Speed optimisation\n\t\t   * Pre:\n\t\t   *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)\n\t\t   * Post:\n\t\t   *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)\n\t\t   */\n\t\t  if (\n\t\t    Array.isArray(obj) &&\n\t\t    (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))\n\t\t  ) {\n\t\t    return 'Array';\n\t\t  }\n\n\t\t  // Not caching existence of `window` and related properties due to potential\n\t\t  // for `window` to be unset before tests in quasi-browser environments.\n\t\t  if (typeof window === 'object' && window !== null) {\n\t\t    /* ! Spec Conformance\n\t\t     * (https://html.spec.whatwg.org/multipage/browsers.html#location)\n\t\t     * WhatWG HTML$7.7.3 - The `Location` interface\n\t\t     * Test: `Object.prototype.toString.call(window.location)``\n\t\t     *  - IE <=11 === \"[object Object]\"\n\t\t     *  - IE Edge <=13 === \"[object Object]\"\n\t\t     */\n\t\t    if (typeof window.location === 'object' && obj === window.location) {\n\t\t      return 'Location';\n\t\t    }\n\n\t\t    /* ! Spec Conformance\n\t\t     * (https://html.spec.whatwg.org/#document)\n\t\t     * WhatWG HTML$3.1.1 - The `Document` object\n\t\t     * Note: Most browsers currently adher to the W3C DOM Level 2 spec\n\t\t     *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)\n\t\t     *       which suggests that browsers should use HTMLTableCellElement for\n\t\t     *       both TD and TH elements. WhatWG separates these.\n\t\t     *       WhatWG HTML states:\n\t\t     *         > For historical reasons, Window objects must also have a\n\t\t     *         > writable, configurable, non-enumerable property named\n\t\t     *         > HTMLDocument whose value is the Document interface object.\n\t\t     * Test: `Object.prototype.toString.call(document)``\n\t\t     *  - Chrome === \"[object HTMLDocument]\"\n\t\t     *  - Firefox === \"[object HTMLDocument]\"\n\t\t     *  - Safari === \"[object HTMLDocument]\"\n\t\t     *  - IE <=10 === \"[object Document]\"\n\t\t     *  - IE 11 === \"[object HTMLDocument]\"\n\t\t     *  - IE Edge <=13 === \"[object HTMLDocument]\"\n\t\t     */\n\t\t    if (typeof window.document === 'object' && obj === window.document) {\n\t\t      return 'Document';\n\t\t    }\n\n\t\t    if (typeof window.navigator === 'object') {\n\t\t      /* ! Spec Conformance\n\t\t       * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)\n\t\t       * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray\n\t\t       * Test: `Object.prototype.toString.call(navigator.mimeTypes)``\n\t\t       *  - IE <=10 === \"[object MSMimeTypesCollection]\"\n\t\t       */\n\t\t      if (typeof window.navigator.mimeTypes === 'object' &&\n\t\t          obj === window.navigator.mimeTypes) {\n\t\t        return 'MimeTypeArray';\n\t\t      }\n\n\t\t      /* ! Spec Conformance\n\t\t       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)\n\t\t       * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray\n\t\t       * Test: `Object.prototype.toString.call(navigator.plugins)``\n\t\t       *  - IE <=10 === \"[object MSPluginsCollection]\"\n\t\t       */\n\t\t      if (typeof window.navigator.plugins === 'object' &&\n\t\t          obj === window.navigator.plugins) {\n\t\t        return 'PluginArray';\n\t\t      }\n\t\t    }\n\n\t\t    if ((typeof window.HTMLElement === 'function' ||\n\t\t        typeof window.HTMLElement === 'object') &&\n\t\t        obj instanceof window.HTMLElement) {\n\t\t      /* ! Spec Conformance\n\t\t      * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)\n\t\t      * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`\n\t\t      * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``\n\t\t      *  - IE <=10 === \"[object HTMLBlockElement]\"\n\t\t      */\n\t\t      if (obj.tagName === 'BLOCKQUOTE') {\n\t\t        return 'HTMLQuoteElement';\n\t\t      }\n\n\t\t      /* ! Spec Conformance\n\t\t       * (https://html.spec.whatwg.org/#htmltabledatacellelement)\n\t\t       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`\n\t\t       * Note: Most browsers currently adher to the W3C DOM Level 2 spec\n\t\t       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)\n\t\t       *       which suggests that browsers should use HTMLTableCellElement for\n\t\t       *       both TD and TH elements. WhatWG separates these.\n\t\t       * Test: Object.prototype.toString.call(document.createElement('td'))\n\t\t       *  - Chrome === \"[object HTMLTableCellElement]\"\n\t\t       *  - Firefox === \"[object HTMLTableCellElement]\"\n\t\t       *  - Safari === \"[object HTMLTableCellElement]\"\n\t\t       */\n\t\t      if (obj.tagName === 'TD') {\n\t\t        return 'HTMLTableDataCellElement';\n\t\t      }\n\n\t\t      /* ! Spec Conformance\n\t\t       * (https://html.spec.whatwg.org/#htmltableheadercellelement)\n\t\t       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`\n\t\t       * Note: Most browsers currently adher to the W3C DOM Level 2 spec\n\t\t       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)\n\t\t       *       which suggests that browsers should use HTMLTableCellElement for\n\t\t       *       both TD and TH elements. WhatWG separates these.\n\t\t       * Test: Object.prototype.toString.call(document.createElement('th'))\n\t\t       *  - Chrome === \"[object HTMLTableCellElement]\"\n\t\t       *  - Firefox === \"[object HTMLTableCellElement]\"\n\t\t       *  - Safari === \"[object HTMLTableCellElement]\"\n\t\t       */\n\t\t      if (obj.tagName === 'TH') {\n\t\t        return 'HTMLTableHeaderCellElement';\n\t\t      }\n\t\t    }\n\t\t  }\n\n\t\t  /* ! Speed optimisation\n\t\t  * Pre:\n\t\t  *   Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)\n\t\t  *   Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)\n\t\t  *   Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)\n\t\t  *   Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)\n\t\t  *   Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)\n\t\t  *   Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)\n\t\t  *   Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)\n\t\t  *   Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)\n\t\t  *   Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)\n\t\t  * Post:\n\t\t  *   Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)\n\t\t  *   Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)\n\t\t  *   Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)\n\t\t  *   Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)\n\t\t  *   Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)\n\t\t  *   Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)\n\t\t  *   Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)\n\t\t  *   Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)\n\t\t  *   Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)\n\t\t  */\n\t\t  var stringTag = (symbolToStringTagExists && obj[Symbol.toStringTag]);\n\t\t  if (typeof stringTag === 'string') {\n\t\t    return stringTag;\n\t\t  }\n\n\t\t  var objPrototype = Object.getPrototypeOf(obj);\n\t\t  /* ! Speed optimisation\n\t\t  * Pre:\n\t\t  *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)\n\t\t  *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)\n\t\t  * Post:\n\t\t  *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)\n\t\t  *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)\n\t\t  */\n\t\t  if (objPrototype === RegExp.prototype) {\n\t\t    return 'RegExp';\n\t\t  }\n\n\t\t  /* ! Speed optimisation\n\t\t  * Pre:\n\t\t  *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)\n\t\t  * Post:\n\t\t  *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)\n\t\t  */\n\t\t  if (objPrototype === Date.prototype) {\n\t\t    return 'Date';\n\t\t  }\n\n\t\t  /* ! Spec Conformance\n\t\t   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)\n\t\t   * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be \"Promise\":\n\t\t   * Test: `Object.prototype.toString.call(Promise.resolve())``\n\t\t   *  - Chrome <=47 === \"[object Object]\"\n\t\t   *  - Edge <=20 === \"[object Object]\"\n\t\t   *  - Firefox 29-Latest === \"[object Promise]\"\n\t\t   *  - Safari 7.1-Latest === \"[object Promise]\"\n\t\t   */\n\t\t  if (promiseExists && objPrototype === Promise.prototype) {\n\t\t    return 'Promise';\n\t\t  }\n\n\t\t  /* ! Speed optimisation\n\t\t  * Pre:\n\t\t  *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)\n\t\t  * Post:\n\t\t  *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)\n\t\t  */\n\t\t  if (setExists && objPrototype === Set.prototype) {\n\t\t    return 'Set';\n\t\t  }\n\n\t\t  /* ! Speed optimisation\n\t\t  * Pre:\n\t\t  *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)\n\t\t  * Post:\n\t\t  *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)\n\t\t  */\n\t\t  if (mapExists && objPrototype === Map.prototype) {\n\t\t    return 'Map';\n\t\t  }\n\n\t\t  /* ! Speed optimisation\n\t\t  * Pre:\n\t\t  *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)\n\t\t  * Post:\n\t\t  *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)\n\t\t  */\n\t\t  if (weakSetExists && objPrototype === WeakSet.prototype) {\n\t\t    return 'WeakSet';\n\t\t  }\n\n\t\t  /* ! Speed optimisation\n\t\t  * Pre:\n\t\t  *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)\n\t\t  * Post:\n\t\t  *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)\n\t\t  */\n\t\t  if (weakMapExists && objPrototype === WeakMap.prototype) {\n\t\t    return 'WeakMap';\n\t\t  }\n\n\t\t  /* ! Spec Conformance\n\t\t   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)\n\t\t   * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be \"DataView\":\n\t\t   * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``\n\t\t   *  - Edge <=13 === \"[object Object]\"\n\t\t   */\n\t\t  if (dataViewExists && objPrototype === DataView.prototype) {\n\t\t    return 'DataView';\n\t\t  }\n\n\t\t  /* ! Spec Conformance\n\t\t   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)\n\t\t   * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be \"Map Iterator\":\n\t\t   * Test: `Object.prototype.toString.call(new Map().entries())``\n\t\t   *  - Edge <=13 === \"[object Object]\"\n\t\t   */\n\t\t  if (mapExists && objPrototype === mapIteratorPrototype) {\n\t\t    return 'Map Iterator';\n\t\t  }\n\n\t\t  /* ! Spec Conformance\n\t\t   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)\n\t\t   * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be \"Set Iterator\":\n\t\t   * Test: `Object.prototype.toString.call(new Set().entries())``\n\t\t   *  - Edge <=13 === \"[object Object]\"\n\t\t   */\n\t\t  if (setExists && objPrototype === setIteratorPrototype) {\n\t\t    return 'Set Iterator';\n\t\t  }\n\n\t\t  /* ! Spec Conformance\n\t\t   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)\n\t\t   * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be \"Array Iterator\":\n\t\t   * Test: `Object.prototype.toString.call([][Symbol.iterator]())``\n\t\t   *  - Edge <=13 === \"[object Object]\"\n\t\t   */\n\t\t  if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {\n\t\t    return 'Array Iterator';\n\t\t  }\n\n\t\t  /* ! Spec Conformance\n\t\t   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)\n\t\t   * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be \"String Iterator\":\n\t\t   * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``\n\t\t   *  - Edge <=13 === \"[object Object]\"\n\t\t   */\n\t\t  if (stringIteratorExists && objPrototype === stringIteratorPrototype) {\n\t\t    return 'String Iterator';\n\t\t  }\n\n\t\t  /* ! Speed optimisation\n\t\t  * Pre:\n\t\t  *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)\n\t\t  * Post:\n\t\t  *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)\n\t\t  */\n\t\t  if (objPrototype === null) {\n\t\t    return 'Object';\n\t\t  }\n\n\t\t  return Object\n\t\t    .prototype\n\t\t    .toString\n\t\t    .call(obj)\n\t\t    .slice(toStringLeftSliceLength, toStringRightSliceLength);\n\t\t}\n\n\t\treturn typeDetect;\n\n\t\t}))); \n\t} (typeDetect$1));\n\treturn typeDetect$1.exports;\n}\n\nvar typeOf;\nvar hasRequiredTypeOf;\n\nfunction requireTypeOf () {\n\tif (hasRequiredTypeOf) return typeOf;\n\thasRequiredTypeOf = 1;\n\n\tvar type = requireTypeDetect();\n\n\t/**\n\t * Returns the lower-case result of running type from type-detect on the value\n\t * @param  {*} value\n\t * @returns {string}\n\t */\n\ttypeOf = function typeOf(value) {\n\t    return type(value).toLowerCase();\n\t};\n\treturn typeOf;\n}\n\nvar valueToString_1;\nvar hasRequiredValueToString;\n\nfunction requireValueToString () {\n\tif (hasRequiredValueToString) return valueToString_1;\n\thasRequiredValueToString = 1;\n\n\t/**\n\t * Returns a string representation of the value\n\t * @param  {*} value\n\t * @returns {string}\n\t */\n\tfunction valueToString(value) {\n\t    if (value && value.toString) {\n\t        // eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods\n\t        return value.toString();\n\t    }\n\t    return String(value);\n\t}\n\n\tvalueToString_1 = valueToString;\n\treturn valueToString_1;\n}\n\nvar lib;\nvar hasRequiredLib;\n\nfunction requireLib () {\n\tif (hasRequiredLib) return lib;\n\thasRequiredLib = 1;\n\n\tlib = {\n\t    global: requireGlobal(),\n\t    calledInOrder: requireCalledInOrder(),\n\t    className: requireClassName(),\n\t    deprecated: requireDeprecated(),\n\t    every: requireEvery(),\n\t    functionName: requireFunctionName(),\n\t    orderByFirstCall: requireOrderByFirstCall(),\n\t    prototypes: requirePrototypes(),\n\t    typeOf: requireTypeOf(),\n\t    valueToString: requireValueToString(),\n\t};\n\treturn lib;\n}\n\nvar hasRequiredFakeTimersSrc;\n\nfunction requireFakeTimersSrc () {\n\tif (hasRequiredFakeTimersSrc) return fakeTimersSrc;\n\thasRequiredFakeTimersSrc = 1;\n\n\tconst globalObject = requireLib().global;\n\tlet timersModule, timersPromisesModule;\n\tif (typeof __vitest_required__ !== 'undefined') {\n\t    try {\n\t        timersModule = __vitest_required__.timers;\n\t    } catch (e) {\n\t        // ignored\n\t    }\n\t    try {\n\t        timersPromisesModule = __vitest_required__.timersPromises;\n\t    } catch (e) {\n\t        // ignored\n\t    }\n\t}\n\n\t/**\n\t * @typedef {object} IdleDeadline\n\t * @property {boolean} didTimeout - whether or not the callback was called before reaching the optional timeout\n\t * @property {function():number} timeRemaining - a floating-point value providing an estimate of the number of milliseconds remaining in the current idle period\n\t */\n\n\t/**\n\t * Queues a function to be called during a browser's idle periods\n\t * @callback RequestIdleCallback\n\t * @param {function(IdleDeadline)} callback\n\t * @param {{timeout: number}} options - an options object\n\t * @returns {number} the id\n\t */\n\n\t/**\n\t * @callback NextTick\n\t * @param {VoidVarArgsFunc} callback - the callback to run\n\t * @param {...*} args - optional arguments to call the callback with\n\t * @returns {void}\n\t */\n\n\t/**\n\t * @callback SetImmediate\n\t * @param {VoidVarArgsFunc} callback - the callback to run\n\t * @param {...*} args - optional arguments to call the callback with\n\t * @returns {NodeImmediate}\n\t */\n\n\t/**\n\t * @callback VoidVarArgsFunc\n\t * @param {...*} callback - the callback to run\n\t * @returns {void}\n\t */\n\n\t/**\n\t * @typedef RequestAnimationFrame\n\t * @property {function(number):void} requestAnimationFrame\n\t * @returns {number} - the id\n\t */\n\n\t/**\n\t * @typedef Performance\n\t * @property {function(): number} now\n\t */\n\n\t/* eslint-disable jsdoc/require-property-description */\n\t/**\n\t * @typedef {object} Clock\n\t * @property {number} now - the current time\n\t * @property {Date} Date - the Date constructor\n\t * @property {number} loopLimit - the maximum number of timers before assuming an infinite loop\n\t * @property {RequestIdleCallback} requestIdleCallback\n\t * @property {function(number):void} cancelIdleCallback\n\t * @property {setTimeout} setTimeout\n\t * @property {clearTimeout} clearTimeout\n\t * @property {NextTick} nextTick\n\t * @property {queueMicrotask} queueMicrotask\n\t * @property {setInterval} setInterval\n\t * @property {clearInterval} clearInterval\n\t * @property {SetImmediate} setImmediate\n\t * @property {function(NodeImmediate):void} clearImmediate\n\t * @property {function():number} countTimers\n\t * @property {RequestAnimationFrame} requestAnimationFrame\n\t * @property {function(number):void} cancelAnimationFrame\n\t * @property {function():void} runMicrotasks\n\t * @property {function(string | number): number} tick\n\t * @property {function(string | number): Promise<number>} tickAsync\n\t * @property {function(): number} next\n\t * @property {function(): Promise<number>} nextAsync\n\t * @property {function(): number} runAll\n\t * @property {function(): number} runToFrame\n\t * @property {function(): Promise<number>} runAllAsync\n\t * @property {function(): number} runToLast\n\t * @property {function(): Promise<number>} runToLastAsync\n\t * @property {function(): void} reset\n\t * @property {function(number | Date): void} setSystemTime\n\t * @property {function(number): void} jump\n\t * @property {Performance} performance\n\t * @property {function(number[]): number[]} hrtime - process.hrtime (legacy)\n\t * @property {function(): void} uninstall Uninstall the clock.\n\t * @property {Function[]} methods - the methods that are faked\n\t * @property {boolean} [shouldClearNativeTimers] inherited from config\n\t * @property {{methodName:string, original:any}[] | undefined} timersModuleMethods\n\t * @property {{methodName:string, original:any}[] | undefined} timersPromisesModuleMethods\n\t * @property {Map<function(): void, AbortSignal>} abortListenerMap\n\t */\n\t/* eslint-enable jsdoc/require-property-description */\n\n\t/**\n\t * Configuration object for the `install` method.\n\t * @typedef {object} Config\n\t * @property {number|Date} [now] a number (in milliseconds) or a Date object (default epoch)\n\t * @property {string[]} [toFake] names of the methods that should be faked.\n\t * @property {number} [loopLimit] the maximum number of timers that will be run when calling runAll()\n\t * @property {boolean} [shouldAdvanceTime] tells FakeTimers to increment mocked time automatically (default false)\n\t * @property {number} [advanceTimeDelta] increment mocked time every <<advanceTimeDelta>> ms (default: 20ms)\n\t * @property {boolean} [shouldClearNativeTimers] forwards clear timer calls to native functions if they are not fakes (default: false)\n\t * @property {boolean} [ignoreMissingTimers] default is false, meaning asking to fake timers that are not present will throw an error\n\t */\n\n\t/* eslint-disable jsdoc/require-property-description */\n\t/**\n\t * The internal structure to describe a scheduled fake timer\n\t * @typedef {object} Timer\n\t * @property {Function} func\n\t * @property {*[]} args\n\t * @property {number} delay\n\t * @property {number} callAt\n\t * @property {number} createdAt\n\t * @property {boolean} immediate\n\t * @property {number} id\n\t * @property {Error} [error]\n\t */\n\n\t/**\n\t * A Node timer\n\t * @typedef {object} NodeImmediate\n\t * @property {function(): boolean} hasRef\n\t * @property {function(): NodeImmediate} ref\n\t * @property {function(): NodeImmediate} unref\n\t */\n\t/* eslint-enable jsdoc/require-property-description */\n\n\t/* eslint-disable complexity */\n\n\t/**\n\t * Mocks available features in the specified global namespace.\n\t * @param {*} _global Namespace to mock (e.g. `window`)\n\t * @returns {FakeTimers}\n\t */\n\tfunction withGlobal(_global) {\n\t    const maxTimeout = Math.pow(2, 31) - 1; //see https://heycam.github.io/webidl/#abstract-opdef-converttoint\n\t    const idCounterStart = 1e12; // arbitrarily large number to avoid collisions with native timer IDs\n\t    const NOOP = function () {\n\t        return undefined;\n\t    };\n\t    const NOOP_ARRAY = function () {\n\t        return [];\n\t    };\n\t    const isPresent = {};\n\t    let timeoutResult,\n\t        addTimerReturnsObject = false;\n\n\t    if (_global.setTimeout) {\n\t        isPresent.setTimeout = true;\n\t        timeoutResult = _global.setTimeout(NOOP, 0);\n\t        addTimerReturnsObject = typeof timeoutResult === \"object\";\n\t    }\n\t    isPresent.clearTimeout = Boolean(_global.clearTimeout);\n\t    isPresent.setInterval = Boolean(_global.setInterval);\n\t    isPresent.clearInterval = Boolean(_global.clearInterval);\n\t    isPresent.hrtime =\n\t        _global.process && typeof _global.process.hrtime === \"function\";\n\t    isPresent.hrtimeBigint =\n\t        isPresent.hrtime && typeof _global.process.hrtime.bigint === \"function\";\n\t    isPresent.nextTick =\n\t        _global.process && typeof _global.process.nextTick === \"function\";\n\t    const utilPromisify = _global.process && _global.__vitest_required__ && _global.__vitest_required__.util.promisify;\n\t    isPresent.performance =\n\t        _global.performance && typeof _global.performance.now === \"function\";\n\t    const hasPerformancePrototype =\n\t        _global.Performance &&\n\t        (typeof _global.Performance).match(/^(function|object)$/);\n\t    const hasPerformanceConstructorPrototype =\n\t        _global.performance &&\n\t        _global.performance.constructor &&\n\t        _global.performance.constructor.prototype;\n\t    isPresent.queueMicrotask = _global.hasOwnProperty(\"queueMicrotask\");\n\t    isPresent.requestAnimationFrame =\n\t        _global.requestAnimationFrame &&\n\t        typeof _global.requestAnimationFrame === \"function\";\n\t    isPresent.cancelAnimationFrame =\n\t        _global.cancelAnimationFrame &&\n\t        typeof _global.cancelAnimationFrame === \"function\";\n\t    isPresent.requestIdleCallback =\n\t        _global.requestIdleCallback &&\n\t        typeof _global.requestIdleCallback === \"function\";\n\t    isPresent.cancelIdleCallbackPresent =\n\t        _global.cancelIdleCallback &&\n\t        typeof _global.cancelIdleCallback === \"function\";\n\t    isPresent.setImmediate =\n\t        _global.setImmediate && typeof _global.setImmediate === \"function\";\n\t    isPresent.clearImmediate =\n\t        _global.clearImmediate && typeof _global.clearImmediate === \"function\";\n\t    isPresent.Intl = _global.Intl && typeof _global.Intl === \"object\";\n\n\t    if (_global.clearTimeout) {\n\t        _global.clearTimeout(timeoutResult);\n\t    }\n\n\t    const NativeDate = _global.Date;\n\t    const NativeIntl = isPresent.Intl\n\t        ? Object.defineProperties(\n\t              Object.create(null),\n\t              Object.getOwnPropertyDescriptors(_global.Intl),\n\t          )\n\t        : undefined;\n\t    let uniqueTimerId = idCounterStart;\n\n\t    if (NativeDate === undefined) {\n\t        throw new Error(\n\t            \"The global scope doesn't have a `Date` object\" +\n\t                \" (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)\",\n\t        );\n\t    }\n\t    isPresent.Date = true;\n\n\t    /**\n\t     * The PerformanceEntry object encapsulates a single performance metric\n\t     * that is part of the browser's performance timeline.\n\t     *\n\t     * This is an object returned by the `mark` and `measure` methods on the Performance prototype\n\t     */\n\t    class FakePerformanceEntry {\n\t        constructor(name, entryType, startTime, duration) {\n\t            this.name = name;\n\t            this.entryType = entryType;\n\t            this.startTime = startTime;\n\t            this.duration = duration;\n\t        }\n\n\t        toJSON() {\n\t            return JSON.stringify({ ...this });\n\t        }\n\t    }\n\n\t    /**\n\t     * @param {number} num\n\t     * @returns {boolean}\n\t     */\n\t    function isNumberFinite(num) {\n\t        if (Number.isFinite) {\n\t            return Number.isFinite(num);\n\t        }\n\n\t        return isFinite(num);\n\t    }\n\n\t    let isNearInfiniteLimit = false;\n\n\t    /**\n\t     * @param {Clock} clock\n\t     * @param {number} i\n\t     */\n\t    function checkIsNearInfiniteLimit(clock, i) {\n\t        if (clock.loopLimit && i === clock.loopLimit - 1) {\n\t            isNearInfiniteLimit = true;\n\t        }\n\t    }\n\n\t    /**\n\t     *\n\t     */\n\t    function resetIsNearInfiniteLimit() {\n\t        isNearInfiniteLimit = false;\n\t    }\n\n\t    /**\n\t     * Parse strings like \"01:10:00\" (meaning 1 hour, 10 minutes, 0 seconds) into\n\t     * number of milliseconds. This is used to support human-readable strings passed\n\t     * to clock.tick()\n\t     * @param {string} str\n\t     * @returns {number}\n\t     */\n\t    function parseTime(str) {\n\t        if (!str) {\n\t            return 0;\n\t        }\n\n\t        const strings = str.split(\":\");\n\t        const l = strings.length;\n\t        let i = l;\n\t        let ms = 0;\n\t        let parsed;\n\n\t        if (l > 3 || !/^(\\d\\d:){0,2}\\d\\d?$/.test(str)) {\n\t            throw new Error(\n\t                \"tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits\",\n\t            );\n\t        }\n\n\t        while (i--) {\n\t            parsed = parseInt(strings[i], 10);\n\n\t            if (parsed >= 60) {\n\t                throw new Error(`Invalid time ${str}`);\n\t            }\n\n\t            ms += parsed * Math.pow(60, l - i - 1);\n\t        }\n\n\t        return ms * 1000;\n\t    }\n\n\t    /**\n\t     * Get the decimal part of the millisecond value as nanoseconds\n\t     * @param {number} msFloat the number of milliseconds\n\t     * @returns {number} an integer number of nanoseconds in the range [0,1e6)\n\t     *\n\t     * Example: nanoRemainer(123.456789) -> 456789\n\t     */\n\t    function nanoRemainder(msFloat) {\n\t        const modulo = 1e6;\n\t        const remainder = (msFloat * 1e6) % modulo;\n\t        const positiveRemainder =\n\t            remainder < 0 ? remainder + modulo : remainder;\n\n\t        return Math.floor(positiveRemainder);\n\t    }\n\n\t    /**\n\t     * Used to grok the `now` parameter to createClock.\n\t     * @param {Date|number} epoch the system time\n\t     * @returns {number}\n\t     */\n\t    function getEpoch(epoch) {\n\t        if (!epoch) {\n\t            return 0;\n\t        }\n\t        if (typeof epoch.getTime === \"function\") {\n\t            return epoch.getTime();\n\t        }\n\t        if (typeof epoch === \"number\") {\n\t            return epoch;\n\t        }\n\t        throw new TypeError(\"now should be milliseconds since UNIX epoch\");\n\t    }\n\n\t    /**\n\t     * @param {number} from\n\t     * @param {number} to\n\t     * @param {Timer} timer\n\t     * @returns {boolean}\n\t     */\n\t    function inRange(from, to, timer) {\n\t        return timer && timer.callAt >= from && timer.callAt <= to;\n\t    }\n\n\t    /**\n\t     * @param {Clock} clock\n\t     * @param {Timer} job\n\t     */\n\t    function getInfiniteLoopError(clock, job) {\n\t        const infiniteLoopError = new Error(\n\t            `Aborting after running ${clock.loopLimit} timers, assuming an infinite loop!`,\n\t        );\n\n\t        if (!job.error) {\n\t            return infiniteLoopError;\n\t        }\n\n\t        // pattern never matched in Node\n\t        const computedTargetPattern = /target\\.*[<|(|[].*?[>|\\]|)]\\s*/;\n\t        let clockMethodPattern = new RegExp(\n\t            String(Object.keys(clock).join(\"|\")),\n\t        );\n\n\t        if (addTimerReturnsObject) {\n\t            // node.js environment\n\t            clockMethodPattern = new RegExp(\n\t                `\\\\s+at (Object\\\\.)?(?:${Object.keys(clock).join(\"|\")})\\\\s+`,\n\t            );\n\t        }\n\n\t        let matchedLineIndex = -1;\n\t        job.error.stack.split(\"\\n\").some(function (line, i) {\n\t            // If we've matched a computed target line (e.g. setTimeout) then we\n\t            // don't need to look any further. Return true to stop iterating.\n\t            const matchedComputedTarget = line.match(computedTargetPattern);\n\t            /* istanbul ignore if */\n\t            if (matchedComputedTarget) {\n\t                matchedLineIndex = i;\n\t                return true;\n\t            }\n\n\t            // If we've matched a clock method line, then there may still be\n\t            // others further down the trace. Return false to keep iterating.\n\t            const matchedClockMethod = line.match(clockMethodPattern);\n\t            if (matchedClockMethod) {\n\t                matchedLineIndex = i;\n\t                return false;\n\t            }\n\n\t            // If we haven't matched anything on this line, but we matched\n\t            // previously and set the matched line index, then we can stop.\n\t            // If we haven't matched previously, then we should keep iterating.\n\t            return matchedLineIndex >= 0;\n\t        });\n\n\t        const stack = `${infiniteLoopError}\\n${job.type || \"Microtask\"} - ${\n\t            job.func.name || \"anonymous\"\n\t        }\\n${job.error.stack\n\t            .split(\"\\n\")\n\t            .slice(matchedLineIndex + 1)\n\t            .join(\"\\n\")}`;\n\n\t        try {\n\t            Object.defineProperty(infiniteLoopError, \"stack\", {\n\t                value: stack,\n\t            });\n\t        } catch (e) {\n\t            // noop\n\t        }\n\n\t        return infiniteLoopError;\n\t    }\n\n\t    //eslint-disable-next-line jsdoc/require-jsdoc\n\t    function createDate() {\n\t        class ClockDate extends NativeDate {\n\t            /**\n\t             * @param {number} year\n\t             * @param {number} month\n\t             * @param {number} date\n\t             * @param {number} hour\n\t             * @param {number} minute\n\t             * @param {number} second\n\t             * @param {number} ms\n\t             * @returns void\n\t             */\n\t            // eslint-disable-next-line no-unused-vars\n\t            constructor(year, month, date, hour, minute, second, ms) {\n\t                // Defensive and verbose to avoid potential harm in passing\n\t                // explicit undefined when user does not pass argument\n\t                if (arguments.length === 0) {\n\t                    super(ClockDate.clock.now);\n\t                } else {\n\t                    super(...arguments);\n\t                }\n\n\t                // ensures identity checks using the constructor prop still works\n\t                // this should have no other functional effect\n\t                Object.defineProperty(this, \"constructor\", {\n\t                    value: NativeDate,\n\t                    enumerable: false,\n\t                });\n\t            }\n\n\t            static [Symbol.hasInstance](instance) {\n\t                return instance instanceof NativeDate;\n\t            }\n\t        }\n\n\t        ClockDate.isFake = true;\n\n\t        if (NativeDate.now) {\n\t            ClockDate.now = function now() {\n\t                return ClockDate.clock.now;\n\t            };\n\t        }\n\n\t        if (NativeDate.toSource) {\n\t            ClockDate.toSource = function toSource() {\n\t                return NativeDate.toSource();\n\t            };\n\t        }\n\n\t        ClockDate.toString = function toString() {\n\t            return NativeDate.toString();\n\t        };\n\n\t        // noinspection UnnecessaryLocalVariableJS\n\t        /**\n\t         * A normal Class constructor cannot be called without `new`, but Date can, so we need\n\t         * to wrap it in a Proxy in order to ensure this functionality of Date is kept intact\n\t         * @type {ClockDate}\n\t         */\n\t        const ClockDateProxy = new Proxy(ClockDate, {\n\t            // handler for [[Call]] invocations (i.e. not using `new`)\n\t            apply() {\n\t                // the Date constructor called as a function, ref Ecma-262 Edition 5.1, section 15.9.2.\n\t                // This remains so in the 10th edition of 2019 as well.\n\t                if (this instanceof ClockDate) {\n\t                    throw new TypeError(\n\t                        \"A Proxy should only capture `new` calls with the `construct` handler. This is not supposed to be possible, so check the logic.\",\n\t                    );\n\t                }\n\n\t                return new NativeDate(ClockDate.clock.now).toString();\n\t            },\n\t        });\n\n\t        return ClockDateProxy;\n\t    }\n\n\t    /**\n\t     * Mirror Intl by default on our fake implementation\n\t     *\n\t     * Most of the properties are the original native ones,\n\t     * but we need to take control of those that have a\n\t     * dependency on the current clock.\n\t     * @returns {object} the partly fake Intl implementation\n\t     */\n\t    function createIntl() {\n\t        const ClockIntl = {};\n\t        /*\n\t         * All properties of Intl are non-enumerable, so we need\n\t         * to do a bit of work to get them out.\n\t         */\n\t        Object.getOwnPropertyNames(NativeIntl).forEach(\n\t            (property) => (ClockIntl[property] = NativeIntl[property]),\n\t        );\n\n\t        ClockIntl.DateTimeFormat = function (...args) {\n\t            const realFormatter = new NativeIntl.DateTimeFormat(...args);\n\t            const formatter = {};\n\n\t            [\"formatRange\", \"formatRangeToParts\", \"resolvedOptions\"].forEach(\n\t                (method) => {\n\t                    formatter[method] =\n\t                        realFormatter[method].bind(realFormatter);\n\t                },\n\t            );\n\n\t            [\"format\", \"formatToParts\"].forEach((method) => {\n\t                formatter[method] = function (date) {\n\t                    return realFormatter[method](date || ClockIntl.clock.now);\n\t                };\n\t            });\n\n\t            return formatter;\n\t        };\n\n\t        ClockIntl.DateTimeFormat.prototype = Object.create(\n\t            NativeIntl.DateTimeFormat.prototype,\n\t        );\n\n\t        ClockIntl.DateTimeFormat.supportedLocalesOf =\n\t            NativeIntl.DateTimeFormat.supportedLocalesOf;\n\n\t        return ClockIntl;\n\t    }\n\n\t    //eslint-disable-next-line jsdoc/require-jsdoc\n\t    function enqueueJob(clock, job) {\n\t        // enqueues a microtick-deferred task - ecma262/#sec-enqueuejob\n\t        if (!clock.jobs) {\n\t            clock.jobs = [];\n\t        }\n\t        clock.jobs.push(job);\n\t    }\n\n\t    //eslint-disable-next-line jsdoc/require-jsdoc\n\t    function runJobs(clock) {\n\t        // runs all microtick-deferred tasks - ecma262/#sec-runjobs\n\t        if (!clock.jobs) {\n\t            return;\n\t        }\n\t        for (let i = 0; i < clock.jobs.length; i++) {\n\t            const job = clock.jobs[i];\n\t            job.func.apply(null, job.args);\n\n\t            checkIsNearInfiniteLimit(clock, i);\n\t            if (clock.loopLimit && i > clock.loopLimit) {\n\t                throw getInfiniteLoopError(clock, job);\n\t            }\n\t        }\n\t        resetIsNearInfiniteLimit();\n\t        clock.jobs = [];\n\t    }\n\n\t    /**\n\t     * @param {Clock} clock\n\t     * @param {Timer} timer\n\t     * @returns {number} id of the created timer\n\t     */\n\t    function addTimer(clock, timer) {\n\t        if (timer.func === undefined) {\n\t            throw new Error(\"Callback must be provided to timer calls\");\n\t        }\n\n\t        if (addTimerReturnsObject) {\n\t            // Node.js environment\n\t            if (typeof timer.func !== \"function\") {\n\t                throw new TypeError(\n\t                    `[ERR_INVALID_CALLBACK]: Callback must be a function. Received ${\n\t                        timer.func\n\t                    } of type ${typeof timer.func}`,\n\t                );\n\t            }\n\t        }\n\n\t        if (isNearInfiniteLimit) {\n\t            timer.error = new Error();\n\t        }\n\n\t        timer.type = timer.immediate ? \"Immediate\" : \"Timeout\";\n\n\t        if (timer.hasOwnProperty(\"delay\")) {\n\t            if (typeof timer.delay !== \"number\") {\n\t                timer.delay = parseInt(timer.delay, 10);\n\t            }\n\n\t            if (!isNumberFinite(timer.delay)) {\n\t                timer.delay = 0;\n\t            }\n\t            timer.delay = timer.delay > maxTimeout ? 1 : timer.delay;\n\t            timer.delay = Math.max(0, timer.delay);\n\t        }\n\n\t        if (timer.hasOwnProperty(\"interval\")) {\n\t            timer.type = \"Interval\";\n\t            timer.interval = timer.interval > maxTimeout ? 1 : timer.interval;\n\t        }\n\n\t        if (timer.hasOwnProperty(\"animation\")) {\n\t            timer.type = \"AnimationFrame\";\n\t            timer.animation = true;\n\t        }\n\n\t        if (timer.hasOwnProperty(\"idleCallback\")) {\n\t            timer.type = \"IdleCallback\";\n\t            timer.idleCallback = true;\n\t        }\n\n\t        if (!clock.timers) {\n\t            clock.timers = {};\n\t        }\n\n\t        timer.id = uniqueTimerId++;\n\t        timer.createdAt = clock.now;\n\t        timer.callAt =\n\t            clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));\n\n\t        clock.timers[timer.id] = timer;\n\n\t        if (addTimerReturnsObject) {\n\t            const res = {\n\t                refed: true,\n\t                ref: function () {\n\t                    this.refed = true;\n\t                    return res;\n\t                },\n\t                unref: function () {\n\t                    this.refed = false;\n\t                    return res;\n\t                },\n\t                hasRef: function () {\n\t                    return this.refed;\n\t                },\n\t                refresh: function () {\n\t                    timer.callAt =\n\t                        clock.now +\n\t                        (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));\n\n\t                    // it _might_ have been removed, but if not the assignment is perfectly fine\n\t                    clock.timers[timer.id] = timer;\n\n\t                    return res;\n\t                },\n\t                [Symbol.toPrimitive]: function () {\n\t                    return timer.id;\n\t                },\n\t            };\n\t            return res;\n\t        }\n\n\t        return timer.id;\n\t    }\n\n\t    /* eslint consistent-return: \"off\" */\n\t    /**\n\t     * Timer comparitor\n\t     * @param {Timer} a\n\t     * @param {Timer} b\n\t     * @returns {number}\n\t     */\n\t    function compareTimers(a, b) {\n\t        // Sort first by absolute timing\n\t        if (a.callAt < b.callAt) {\n\t            return -1;\n\t        }\n\t        if (a.callAt > b.callAt) {\n\t            return 1;\n\t        }\n\n\t        // Sort next by immediate, immediate timers take precedence\n\t        if (a.immediate && !b.immediate) {\n\t            return -1;\n\t        }\n\t        if (!a.immediate && b.immediate) {\n\t            return 1;\n\t        }\n\n\t        // Sort next by creation time, earlier-created timers take precedence\n\t        if (a.createdAt < b.createdAt) {\n\t            return -1;\n\t        }\n\t        if (a.createdAt > b.createdAt) {\n\t            return 1;\n\t        }\n\n\t        // Sort next by id, lower-id timers take precedence\n\t        if (a.id < b.id) {\n\t            return -1;\n\t        }\n\t        if (a.id > b.id) {\n\t            return 1;\n\t        }\n\n\t        // As timer ids are unique, no fallback `0` is necessary\n\t    }\n\n\t    /**\n\t     * @param {Clock} clock\n\t     * @param {number} from\n\t     * @param {number} to\n\t     * @returns {Timer}\n\t     */\n\t    function firstTimerInRange(clock, from, to) {\n\t        const timers = clock.timers;\n\t        let timer = null;\n\t        let id, isInRange;\n\n\t        for (id in timers) {\n\t            if (timers.hasOwnProperty(id)) {\n\t                isInRange = inRange(from, to, timers[id]);\n\n\t                if (\n\t                    isInRange &&\n\t                    (!timer || compareTimers(timer, timers[id]) === 1)\n\t                ) {\n\t                    timer = timers[id];\n\t                }\n\t            }\n\t        }\n\n\t        return timer;\n\t    }\n\n\t    /**\n\t     * @param {Clock} clock\n\t     * @returns {Timer}\n\t     */\n\t    function firstTimer(clock) {\n\t        const timers = clock.timers;\n\t        let timer = null;\n\t        let id;\n\n\t        for (id in timers) {\n\t            if (timers.hasOwnProperty(id)) {\n\t                if (!timer || compareTimers(timer, timers[id]) === 1) {\n\t                    timer = timers[id];\n\t                }\n\t            }\n\t        }\n\n\t        return timer;\n\t    }\n\n\t    /**\n\t     * @param {Clock} clock\n\t     * @returns {Timer}\n\t     */\n\t    function lastTimer(clock) {\n\t        const timers = clock.timers;\n\t        let timer = null;\n\t        let id;\n\n\t        for (id in timers) {\n\t            if (timers.hasOwnProperty(id)) {\n\t                if (!timer || compareTimers(timer, timers[id]) === -1) {\n\t                    timer = timers[id];\n\t                }\n\t            }\n\t        }\n\n\t        return timer;\n\t    }\n\n\t    /**\n\t     * @param {Clock} clock\n\t     * @param {Timer} timer\n\t     */\n\t    function callTimer(clock, timer) {\n\t        if (typeof timer.interval === \"number\") {\n\t            clock.timers[timer.id].callAt += timer.interval;\n\t        } else {\n\t            delete clock.timers[timer.id];\n\t        }\n\n\t        if (typeof timer.func === \"function\") {\n\t            timer.func.apply(null, timer.args);\n\t        } else {\n\t            /* eslint no-eval: \"off\" */\n\t            const eval2 = eval;\n\t            (function () {\n\t                eval2(timer.func);\n\t            })();\n\t        }\n\t    }\n\n\t    /**\n\t     * Gets clear handler name for a given timer type\n\t     * @param {string} ttype\n\t     */\n\t    function getClearHandler(ttype) {\n\t        if (ttype === \"IdleCallback\" || ttype === \"AnimationFrame\") {\n\t            return `cancel${ttype}`;\n\t        }\n\t        return `clear${ttype}`;\n\t    }\n\n\t    /**\n\t     * Gets schedule handler name for a given timer type\n\t     * @param {string} ttype\n\t     */\n\t    function getScheduleHandler(ttype) {\n\t        if (ttype === \"IdleCallback\" || ttype === \"AnimationFrame\") {\n\t            return `request${ttype}`;\n\t        }\n\t        return `set${ttype}`;\n\t    }\n\n\t    /**\n\t     * Creates an anonymous function to warn only once\n\t     */\n\t    function createWarnOnce() {\n\t        let calls = 0;\n\t        return function (msg) {\n\t            // eslint-disable-next-line\n\t            !calls++ && console.warn(msg);\n\t        };\n\t    }\n\t    const warnOnce = createWarnOnce();\n\n\t    /**\n\t     * @param {Clock} clock\n\t     * @param {number} timerId\n\t     * @param {string} ttype\n\t     */\n\t    function clearTimer(clock, timerId, ttype) {\n\t        if (!timerId) {\n\t            // null appears to be allowed in most browsers, and appears to be\n\t            // relied upon by some libraries, like Bootstrap carousel\n\t            return;\n\t        }\n\n\t        if (!clock.timers) {\n\t            clock.timers = {};\n\t        }\n\n\t        // in Node, the ID is stored as the primitive value for `Timeout` objects\n\t        // for `Immediate` objects, no ID exists, so it gets coerced to NaN\n\t        const id = Number(timerId);\n\n\t        if (Number.isNaN(id) || id < idCounterStart) {\n\t            const handlerName = getClearHandler(ttype);\n\n\t            if (clock.shouldClearNativeTimers === true) {\n\t                const nativeHandler = clock[`_${handlerName}`];\n\t                return typeof nativeHandler === \"function\"\n\t                    ? nativeHandler(timerId)\n\t                    : undefined;\n\t            }\n\t            warnOnce(\n\t                `FakeTimers: ${handlerName} was invoked to clear a native timer instead of one created by this library.` +\n\t                    \"\\nTo automatically clean-up native timers, use `shouldClearNativeTimers`.\",\n\t            );\n\t        }\n\n\t        if (clock.timers.hasOwnProperty(id)) {\n\t            // check that the ID matches a timer of the correct type\n\t            const timer = clock.timers[id];\n\t            if (\n\t                timer.type === ttype ||\n\t                (timer.type === \"Timeout\" && ttype === \"Interval\") ||\n\t                (timer.type === \"Interval\" && ttype === \"Timeout\")\n\t            ) {\n\t                delete clock.timers[id];\n\t            } else {\n\t                const clear = getClearHandler(ttype);\n\t                const schedule = getScheduleHandler(timer.type);\n\t                throw new Error(\n\t                    `Cannot clear timer: timer created with ${schedule}() but cleared with ${clear}()`,\n\t                );\n\t            }\n\t        }\n\t    }\n\n\t    /**\n\t     * @param {Clock} clock\n\t     * @param {Config} config\n\t     * @returns {Timer[]}\n\t     */\n\t    function uninstall(clock, config) {\n\t        let method, i, l;\n\t        const installedHrTime = \"_hrtime\";\n\t        const installedNextTick = \"_nextTick\";\n\n\t        for (i = 0, l = clock.methods.length; i < l; i++) {\n\t            method = clock.methods[i];\n\t            if (method === \"hrtime\" && _global.process) {\n\t                _global.process.hrtime = clock[installedHrTime];\n\t            } else if (method === \"nextTick\" && _global.process) {\n\t                _global.process.nextTick = clock[installedNextTick];\n\t            } else if (method === \"performance\") {\n\t                const originalPerfDescriptor = Object.getOwnPropertyDescriptor(\n\t                    clock,\n\t                    `_${method}`,\n\t                );\n\t                if (\n\t                    originalPerfDescriptor &&\n\t                    originalPerfDescriptor.get &&\n\t                    !originalPerfDescriptor.set\n\t                ) {\n\t                    Object.defineProperty(\n\t                        _global,\n\t                        method,\n\t                        originalPerfDescriptor,\n\t                    );\n\t                } else if (originalPerfDescriptor.configurable) {\n\t                    _global[method] = clock[`_${method}`];\n\t                }\n\t            } else {\n\t                if (_global[method] && _global[method].hadOwnProperty) {\n\t                    _global[method] = clock[`_${method}`];\n\t                } else {\n\t                    try {\n\t                        delete _global[method];\n\t                    } catch (ignore) {\n\t                        /* eslint no-empty: \"off\" */\n\t                    }\n\t                }\n\t            }\n\t            if (clock.timersModuleMethods !== undefined) {\n\t                for (let j = 0; j < clock.timersModuleMethods.length; j++) {\n\t                    const entry = clock.timersModuleMethods[j];\n\t                    timersModule[entry.methodName] = entry.original;\n\t                }\n\t            }\n\t            if (clock.timersPromisesModuleMethods !== undefined) {\n\t                for (\n\t                    let j = 0;\n\t                    j < clock.timersPromisesModuleMethods.length;\n\t                    j++\n\t                ) {\n\t                    const entry = clock.timersPromisesModuleMethods[j];\n\t                    timersPromisesModule[entry.methodName] = entry.original;\n\t                }\n\t            }\n\t        }\n\n\t        if (config.shouldAdvanceTime === true) {\n\t            _global.clearInterval(clock.attachedInterval);\n\t        }\n\n\t        // Prevent multiple executions which will completely remove these props\n\t        clock.methods = [];\n\n\t        for (const [listener, signal] of clock.abortListenerMap.entries()) {\n\t            signal.removeEventListener(\"abort\", listener);\n\t            clock.abortListenerMap.delete(listener);\n\t        }\n\n\t        // return pending timers, to enable checking what timers remained on uninstall\n\t        if (!clock.timers) {\n\t            return [];\n\t        }\n\t        return Object.keys(clock.timers).map(function mapper(key) {\n\t            return clock.timers[key];\n\t        });\n\t    }\n\n\t    /**\n\t     * @param {object} target the target containing the method to replace\n\t     * @param {string} method the keyname of the method on the target\n\t     * @param {Clock} clock\n\t     */\n\t    function hijackMethod(target, method, clock) {\n\t        clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(\n\t            target,\n\t            method,\n\t        );\n\t        clock[`_${method}`] = target[method];\n\n\t        if (method === \"Date\") {\n\t            target[method] = clock[method];\n\t        } else if (method === \"Intl\") {\n\t            target[method] = clock[method];\n\t        } else if (method === \"performance\") {\n\t            const originalPerfDescriptor = Object.getOwnPropertyDescriptor(\n\t                target,\n\t                method,\n\t            );\n\t            // JSDOM has a read only performance field so we have to save/copy it differently\n\t            if (\n\t                originalPerfDescriptor &&\n\t                originalPerfDescriptor.get &&\n\t                !originalPerfDescriptor.set\n\t            ) {\n\t                Object.defineProperty(\n\t                    clock,\n\t                    `_${method}`,\n\t                    originalPerfDescriptor,\n\t                );\n\n\t                const perfDescriptor = Object.getOwnPropertyDescriptor(\n\t                    clock,\n\t                    method,\n\t                );\n\t                Object.defineProperty(target, method, perfDescriptor);\n\t            } else {\n\t                target[method] = clock[method];\n\t            }\n\t        } else {\n\t            target[method] = function () {\n\t                return clock[method].apply(clock, arguments);\n\t            };\n\n\t            Object.defineProperties(\n\t                target[method],\n\t                Object.getOwnPropertyDescriptors(clock[method]),\n\t            );\n\t        }\n\n\t        target[method].clock = clock;\n\t    }\n\n\t    /**\n\t     * @param {Clock} clock\n\t     * @param {number} advanceTimeDelta\n\t     */\n\t    function doIntervalTick(clock, advanceTimeDelta) {\n\t        clock.tick(advanceTimeDelta);\n\t    }\n\n\t    /**\n\t     * @typedef {object} Timers\n\t     * @property {setTimeout} setTimeout\n\t     * @property {clearTimeout} clearTimeout\n\t     * @property {setInterval} setInterval\n\t     * @property {clearInterval} clearInterval\n\t     * @property {Date} Date\n\t     * @property {Intl} Intl\n\t     * @property {SetImmediate=} setImmediate\n\t     * @property {function(NodeImmediate): void=} clearImmediate\n\t     * @property {function(number[]):number[]=} hrtime\n\t     * @property {NextTick=} nextTick\n\t     * @property {Performance=} performance\n\t     * @property {RequestAnimationFrame=} requestAnimationFrame\n\t     * @property {boolean=} queueMicrotask\n\t     * @property {function(number): void=} cancelAnimationFrame\n\t     * @property {RequestIdleCallback=} requestIdleCallback\n\t     * @property {function(number): void=} cancelIdleCallback\n\t     */\n\n\t    /** @type {Timers} */\n\t    const timers = {\n\t        setTimeout: _global.setTimeout,\n\t        clearTimeout: _global.clearTimeout,\n\t        setInterval: _global.setInterval,\n\t        clearInterval: _global.clearInterval,\n\t        Date: _global.Date,\n\t    };\n\n\t    if (isPresent.setImmediate) {\n\t        timers.setImmediate = _global.setImmediate;\n\t    }\n\n\t    if (isPresent.clearImmediate) {\n\t        timers.clearImmediate = _global.clearImmediate;\n\t    }\n\n\t    if (isPresent.hrtime) {\n\t        timers.hrtime = _global.process.hrtime;\n\t    }\n\n\t    if (isPresent.nextTick) {\n\t        timers.nextTick = _global.process.nextTick;\n\t    }\n\n\t    if (isPresent.performance) {\n\t        timers.performance = _global.performance;\n\t    }\n\n\t    if (isPresent.requestAnimationFrame) {\n\t        timers.requestAnimationFrame = _global.requestAnimationFrame;\n\t    }\n\n\t    if (isPresent.queueMicrotask) {\n\t        timers.queueMicrotask = _global.queueMicrotask;\n\t    }\n\n\t    if (isPresent.cancelAnimationFrame) {\n\t        timers.cancelAnimationFrame = _global.cancelAnimationFrame;\n\t    }\n\n\t    if (isPresent.requestIdleCallback) {\n\t        timers.requestIdleCallback = _global.requestIdleCallback;\n\t    }\n\n\t    if (isPresent.cancelIdleCallback) {\n\t        timers.cancelIdleCallback = _global.cancelIdleCallback;\n\t    }\n\n\t    if (isPresent.Intl) {\n\t        timers.Intl = NativeIntl;\n\t    }\n\n\t    const originalSetTimeout = _global.setImmediate || _global.setTimeout;\n\n\t    /**\n\t     * @param {Date|number} [start] the system time - non-integer values are floored\n\t     * @param {number} [loopLimit] maximum number of timers that will be run when calling runAll()\n\t     * @returns {Clock}\n\t     */\n\t    function createClock(start, loopLimit) {\n\t        // eslint-disable-next-line no-param-reassign\n\t        start = Math.floor(getEpoch(start));\n\t        // eslint-disable-next-line no-param-reassign\n\t        loopLimit = loopLimit || 1000;\n\t        let nanos = 0;\n\t        const adjustedSystemTime = [0, 0]; // [millis, nanoremainder]\n\n\t        const clock = {\n\t            now: start,\n\t            Date: createDate(),\n\t            loopLimit: loopLimit,\n\t        };\n\n\t        clock.Date.clock = clock;\n\n\t        //eslint-disable-next-line jsdoc/require-jsdoc\n\t        function getTimeToNextFrame() {\n\t            return 16 - ((clock.now - start) % 16);\n\t        }\n\n\t        //eslint-disable-next-line jsdoc/require-jsdoc\n\t        function hrtime(prev) {\n\t            const millisSinceStart = clock.now - adjustedSystemTime[0] - start;\n\t            const secsSinceStart = Math.floor(millisSinceStart / 1000);\n\t            const remainderInNanos =\n\t                (millisSinceStart - secsSinceStart * 1e3) * 1e6 +\n\t                nanos -\n\t                adjustedSystemTime[1];\n\n\t            if (Array.isArray(prev)) {\n\t                if (prev[1] > 1e9) {\n\t                    throw new TypeError(\n\t                        \"Number of nanoseconds can't exceed a billion\",\n\t                    );\n\t                }\n\n\t                const oldSecs = prev[0];\n\t                let nanoDiff = remainderInNanos - prev[1];\n\t                let secDiff = secsSinceStart - oldSecs;\n\n\t                if (nanoDiff < 0) {\n\t                    nanoDiff += 1e9;\n\t                    secDiff -= 1;\n\t                }\n\n\t                return [secDiff, nanoDiff];\n\t            }\n\t            return [secsSinceStart, remainderInNanos];\n\t        }\n\n\t        /**\n\t         * A high resolution timestamp in milliseconds.\n\t         * @typedef {number} DOMHighResTimeStamp\n\t         */\n\n\t        /**\n\t         * performance.now()\n\t         * @returns {DOMHighResTimeStamp}\n\t         */\n\t        function fakePerformanceNow() {\n\t            const hrt = hrtime();\n\t            const millis = hrt[0] * 1000 + hrt[1] / 1e6;\n\t            return millis;\n\t        }\n\n\t        if (isPresent.hrtimeBigint) {\n\t            hrtime.bigint = function () {\n\t                const parts = hrtime();\n\t                return BigInt(parts[0]) * BigInt(1e9) + BigInt(parts[1]); // eslint-disable-line\n\t            };\n\t        }\n\n\t        if (isPresent.Intl) {\n\t            clock.Intl = createIntl();\n\t            clock.Intl.clock = clock;\n\t        }\n\n\t        clock.requestIdleCallback = function requestIdleCallback(\n\t            func,\n\t            timeout,\n\t        ) {\n\t            let timeToNextIdlePeriod = 0;\n\n\t            if (clock.countTimers() > 0) {\n\t                timeToNextIdlePeriod = 50; // const for now\n\t            }\n\n\t            const result = addTimer(clock, {\n\t                func: func,\n\t                args: Array.prototype.slice.call(arguments, 2),\n\t                delay:\n\t                    typeof timeout === \"undefined\"\n\t                        ? timeToNextIdlePeriod\n\t                        : Math.min(timeout, timeToNextIdlePeriod),\n\t                idleCallback: true,\n\t            });\n\n\t            return Number(result);\n\t        };\n\n\t        clock.cancelIdleCallback = function cancelIdleCallback(timerId) {\n\t            return clearTimer(clock, timerId, \"IdleCallback\");\n\t        };\n\n\t        clock.setTimeout = function setTimeout(func, timeout) {\n\t            return addTimer(clock, {\n\t                func: func,\n\t                args: Array.prototype.slice.call(arguments, 2),\n\t                delay: timeout,\n\t            });\n\t        };\n\t        if (typeof _global.Promise !== \"undefined\" && utilPromisify) {\n\t            clock.setTimeout[utilPromisify.custom] =\n\t                function promisifiedSetTimeout(timeout, arg) {\n\t                    return new _global.Promise(function setTimeoutExecutor(\n\t                        resolve,\n\t                    ) {\n\t                        addTimer(clock, {\n\t                            func: resolve,\n\t                            args: [arg],\n\t                            delay: timeout,\n\t                        });\n\t                    });\n\t                };\n\t        }\n\n\t        clock.clearTimeout = function clearTimeout(timerId) {\n\t            return clearTimer(clock, timerId, \"Timeout\");\n\t        };\n\n\t        clock.nextTick = function nextTick(func) {\n\t            return enqueueJob(clock, {\n\t                func: func,\n\t                args: Array.prototype.slice.call(arguments, 1),\n\t                error: isNearInfiniteLimit ? new Error() : null,\n\t            });\n\t        };\n\n\t        clock.queueMicrotask = function queueMicrotask(func) {\n\t            return clock.nextTick(func); // explicitly drop additional arguments\n\t        };\n\n\t        clock.setInterval = function setInterval(func, timeout) {\n\t            // eslint-disable-next-line no-param-reassign\n\t            timeout = parseInt(timeout, 10);\n\t            return addTimer(clock, {\n\t                func: func,\n\t                args: Array.prototype.slice.call(arguments, 2),\n\t                delay: timeout,\n\t                interval: timeout,\n\t            });\n\t        };\n\n\t        clock.clearInterval = function clearInterval(timerId) {\n\t            return clearTimer(clock, timerId, \"Interval\");\n\t        };\n\n\t        if (isPresent.setImmediate) {\n\t            clock.setImmediate = function setImmediate(func) {\n\t                return addTimer(clock, {\n\t                    func: func,\n\t                    args: Array.prototype.slice.call(arguments, 1),\n\t                    immediate: true,\n\t                });\n\t            };\n\n\t            if (typeof _global.Promise !== \"undefined\" && utilPromisify) {\n\t                clock.setImmediate[utilPromisify.custom] =\n\t                    function promisifiedSetImmediate(arg) {\n\t                        return new _global.Promise(\n\t                            function setImmediateExecutor(resolve) {\n\t                                addTimer(clock, {\n\t                                    func: resolve,\n\t                                    args: [arg],\n\t                                    immediate: true,\n\t                                });\n\t                            },\n\t                        );\n\t                    };\n\t            }\n\n\t            clock.clearImmediate = function clearImmediate(timerId) {\n\t                return clearTimer(clock, timerId, \"Immediate\");\n\t            };\n\t        }\n\n\t        clock.countTimers = function countTimers() {\n\t            return (\n\t                Object.keys(clock.timers || {}).length +\n\t                (clock.jobs || []).length\n\t            );\n\t        };\n\n\t        clock.requestAnimationFrame = function requestAnimationFrame(func) {\n\t            const result = addTimer(clock, {\n\t                func: func,\n\t                delay: getTimeToNextFrame(),\n\t                get args() {\n\t                    return [fakePerformanceNow()];\n\t                },\n\t                animation: true,\n\t            });\n\n\t            return Number(result);\n\t        };\n\n\t        clock.cancelAnimationFrame = function cancelAnimationFrame(timerId) {\n\t            return clearTimer(clock, timerId, \"AnimationFrame\");\n\t        };\n\n\t        clock.runMicrotasks = function runMicrotasks() {\n\t            runJobs(clock);\n\t        };\n\n\t        /**\n\t         * @param {number|string} tickValue milliseconds or a string parseable by parseTime\n\t         * @param {boolean} isAsync\n\t         * @param {Function} resolve\n\t         * @param {Function} reject\n\t         * @returns {number|undefined} will return the new `now` value or nothing for async\n\t         */\n\t        function doTick(tickValue, isAsync, resolve, reject) {\n\t            const msFloat =\n\t                typeof tickValue === \"number\"\n\t                    ? tickValue\n\t                    : parseTime(tickValue);\n\t            const ms = Math.floor(msFloat);\n\t            const remainder = nanoRemainder(msFloat);\n\t            let nanosTotal = nanos + remainder;\n\t            let tickTo = clock.now + ms;\n\n\t            if (msFloat < 0) {\n\t                throw new TypeError(\"Negative ticks are not supported\");\n\t            }\n\n\t            // adjust for positive overflow\n\t            if (nanosTotal >= 1e6) {\n\t                tickTo += 1;\n\t                nanosTotal -= 1e6;\n\t            }\n\n\t            nanos = nanosTotal;\n\t            let tickFrom = clock.now;\n\t            let previous = clock.now;\n\t            // ESLint fails to detect this correctly\n\t            /* eslint-disable prefer-const */\n\t            let timer,\n\t                firstException,\n\t                oldNow,\n\t                nextPromiseTick,\n\t                compensationCheck,\n\t                postTimerCall;\n\t            /* eslint-enable prefer-const */\n\n\t            clock.duringTick = true;\n\n\t            // perform microtasks\n\t            oldNow = clock.now;\n\t            runJobs(clock);\n\t            if (oldNow !== clock.now) {\n\t                // compensate for any setSystemTime() call during microtask callback\n\t                tickFrom += clock.now - oldNow;\n\t                tickTo += clock.now - oldNow;\n\t            }\n\n\t            //eslint-disable-next-line jsdoc/require-jsdoc\n\t            function doTickInner() {\n\t                // perform each timer in the requested range\n\t                timer = firstTimerInRange(clock, tickFrom, tickTo);\n\t                // eslint-disable-next-line no-unmodified-loop-condition\n\t                while (timer && tickFrom <= tickTo) {\n\t                    if (clock.timers[timer.id]) {\n\t                        tickFrom = timer.callAt;\n\t                        clock.now = timer.callAt;\n\t                        oldNow = clock.now;\n\t                        try {\n\t                            runJobs(clock);\n\t                            callTimer(clock, timer);\n\t                        } catch (e) {\n\t                            firstException = firstException || e;\n\t                        }\n\n\t                        if (isAsync) {\n\t                            // finish up after native setImmediate callback to allow\n\t                            // all native es6 promises to process their callbacks after\n\t                            // each timer fires.\n\t                            originalSetTimeout(nextPromiseTick);\n\t                            return;\n\t                        }\n\n\t                        compensationCheck();\n\t                    }\n\n\t                    postTimerCall();\n\t                }\n\n\t                // perform process.nextTick()s again\n\t                oldNow = clock.now;\n\t                runJobs(clock);\n\t                if (oldNow !== clock.now) {\n\t                    // compensate for any setSystemTime() call during process.nextTick() callback\n\t                    tickFrom += clock.now - oldNow;\n\t                    tickTo += clock.now - oldNow;\n\t                }\n\t                clock.duringTick = false;\n\n\t                // corner case: during runJobs new timers were scheduled which could be in the range [clock.now, tickTo]\n\t                timer = firstTimerInRange(clock, tickFrom, tickTo);\n\t                if (timer) {\n\t                    try {\n\t                        clock.tick(tickTo - clock.now); // do it all again - for the remainder of the requested range\n\t                    } catch (e) {\n\t                        firstException = firstException || e;\n\t                    }\n\t                } else {\n\t                    // no timers remaining in the requested range: move the clock all the way to the end\n\t                    clock.now = tickTo;\n\n\t                    // update nanos\n\t                    nanos = nanosTotal;\n\t                }\n\t                if (firstException) {\n\t                    throw firstException;\n\t                }\n\n\t                if (isAsync) {\n\t                    resolve(clock.now);\n\t                } else {\n\t                    return clock.now;\n\t                }\n\t            }\n\n\t            nextPromiseTick =\n\t                isAsync &&\n\t                function () {\n\t                    try {\n\t                        compensationCheck();\n\t                        postTimerCall();\n\t                        doTickInner();\n\t                    } catch (e) {\n\t                        reject(e);\n\t                    }\n\t                };\n\n\t            compensationCheck = function () {\n\t                // compensate for any setSystemTime() call during timer callback\n\t                if (oldNow !== clock.now) {\n\t                    tickFrom += clock.now - oldNow;\n\t                    tickTo += clock.now - oldNow;\n\t                    previous += clock.now - oldNow;\n\t                }\n\t            };\n\n\t            postTimerCall = function () {\n\t                timer = firstTimerInRange(clock, previous, tickTo);\n\t                previous = tickFrom;\n\t            };\n\n\t            return doTickInner();\n\t        }\n\n\t        /**\n\t         * @param {string|number} tickValue number of milliseconds or a human-readable value like \"01:11:15\"\n\t         * @returns {number} will return the new `now` value\n\t         */\n\t        clock.tick = function tick(tickValue) {\n\t            return doTick(tickValue, false);\n\t        };\n\n\t        if (typeof _global.Promise !== \"undefined\") {\n\t            /**\n\t             * @param {string|number} tickValue number of milliseconds or a human-readable value like \"01:11:15\"\n\t             * @returns {Promise}\n\t             */\n\t            clock.tickAsync = function tickAsync(tickValue) {\n\t                return new _global.Promise(function (resolve, reject) {\n\t                    originalSetTimeout(function () {\n\t                        try {\n\t                            doTick(tickValue, true, resolve, reject);\n\t                        } catch (e) {\n\t                            reject(e);\n\t                        }\n\t                    });\n\t                });\n\t            };\n\t        }\n\n\t        clock.next = function next() {\n\t            runJobs(clock);\n\t            const timer = firstTimer(clock);\n\t            if (!timer) {\n\t                return clock.now;\n\t            }\n\n\t            clock.duringTick = true;\n\t            try {\n\t                clock.now = timer.callAt;\n\t                callTimer(clock, timer);\n\t                runJobs(clock);\n\t                return clock.now;\n\t            } finally {\n\t                clock.duringTick = false;\n\t            }\n\t        };\n\n\t        if (typeof _global.Promise !== \"undefined\") {\n\t            clock.nextAsync = function nextAsync() {\n\t                return new _global.Promise(function (resolve, reject) {\n\t                    originalSetTimeout(function () {\n\t                        try {\n\t                            const timer = firstTimer(clock);\n\t                            if (!timer) {\n\t                                resolve(clock.now);\n\t                                return;\n\t                            }\n\n\t                            let err;\n\t                            clock.duringTick = true;\n\t                            clock.now = timer.callAt;\n\t                            try {\n\t                                callTimer(clock, timer);\n\t                            } catch (e) {\n\t                                err = e;\n\t                            }\n\t                            clock.duringTick = false;\n\n\t                            originalSetTimeout(function () {\n\t                                if (err) {\n\t                                    reject(err);\n\t                                } else {\n\t                                    resolve(clock.now);\n\t                                }\n\t                            });\n\t                        } catch (e) {\n\t                            reject(e);\n\t                        }\n\t                    });\n\t                });\n\t            };\n\t        }\n\n\t        clock.runAll = function runAll() {\n\t            let numTimers, i;\n\t            runJobs(clock);\n\t            for (i = 0; i < clock.loopLimit; i++) {\n\t                if (!clock.timers) {\n\t                    resetIsNearInfiniteLimit();\n\t                    return clock.now;\n\t                }\n\n\t                numTimers = Object.keys(clock.timers).length;\n\t                if (numTimers === 0) {\n\t                    resetIsNearInfiniteLimit();\n\t                    return clock.now;\n\t                }\n\n\t                clock.next();\n\t                checkIsNearInfiniteLimit(clock, i);\n\t            }\n\n\t            const excessJob = firstTimer(clock);\n\t            throw getInfiniteLoopError(clock, excessJob);\n\t        };\n\n\t        clock.runToFrame = function runToFrame() {\n\t            return clock.tick(getTimeToNextFrame());\n\t        };\n\n\t        if (typeof _global.Promise !== \"undefined\") {\n\t            clock.runAllAsync = function runAllAsync() {\n\t                return new _global.Promise(function (resolve, reject) {\n\t                    let i = 0;\n\t                    /**\n\t                     *\n\t                     */\n\t                    function doRun() {\n\t                        originalSetTimeout(function () {\n\t                            try {\n\t                                runJobs(clock);\n\n\t                                let numTimers;\n\t                                if (i < clock.loopLimit) {\n\t                                    if (!clock.timers) {\n\t                                        resetIsNearInfiniteLimit();\n\t                                        resolve(clock.now);\n\t                                        return;\n\t                                    }\n\n\t                                    numTimers = Object.keys(\n\t                                        clock.timers,\n\t                                    ).length;\n\t                                    if (numTimers === 0) {\n\t                                        resetIsNearInfiniteLimit();\n\t                                        resolve(clock.now);\n\t                                        return;\n\t                                    }\n\n\t                                    clock.next();\n\n\t                                    i++;\n\n\t                                    doRun();\n\t                                    checkIsNearInfiniteLimit(clock, i);\n\t                                    return;\n\t                                }\n\n\t                                const excessJob = firstTimer(clock);\n\t                                reject(getInfiniteLoopError(clock, excessJob));\n\t                            } catch (e) {\n\t                                reject(e);\n\t                            }\n\t                        });\n\t                    }\n\t                    doRun();\n\t                });\n\t            };\n\t        }\n\n\t        clock.runToLast = function runToLast() {\n\t            const timer = lastTimer(clock);\n\t            if (!timer) {\n\t                runJobs(clock);\n\t                return clock.now;\n\t            }\n\n\t            return clock.tick(timer.callAt - clock.now);\n\t        };\n\n\t        if (typeof _global.Promise !== \"undefined\") {\n\t            clock.runToLastAsync = function runToLastAsync() {\n\t                return new _global.Promise(function (resolve, reject) {\n\t                    originalSetTimeout(function () {\n\t                        try {\n\t                            const timer = lastTimer(clock);\n\t                            if (!timer) {\n\t                                runJobs(clock);\n\t                                resolve(clock.now);\n\t                            }\n\n\t                            resolve(clock.tickAsync(timer.callAt - clock.now));\n\t                        } catch (e) {\n\t                            reject(e);\n\t                        }\n\t                    });\n\t                });\n\t            };\n\t        }\n\n\t        clock.reset = function reset() {\n\t            nanos = 0;\n\t            clock.timers = {};\n\t            clock.jobs = [];\n\t            clock.now = start;\n\t        };\n\n\t        clock.setSystemTime = function setSystemTime(systemTime) {\n\t            // determine time difference\n\t            const newNow = getEpoch(systemTime);\n\t            const difference = newNow - clock.now;\n\t            let id, timer;\n\n\t            adjustedSystemTime[0] = adjustedSystemTime[0] + difference;\n\t            adjustedSystemTime[1] = adjustedSystemTime[1] + nanos;\n\t            // update 'system clock'\n\t            clock.now = newNow;\n\t            nanos = 0;\n\n\t            // update timers and intervals to keep them stable\n\t            for (id in clock.timers) {\n\t                if (clock.timers.hasOwnProperty(id)) {\n\t                    timer = clock.timers[id];\n\t                    timer.createdAt += difference;\n\t                    timer.callAt += difference;\n\t                }\n\t            }\n\t        };\n\n\t        /**\n\t         * @param {string|number} tickValue number of milliseconds or a human-readable value like \"01:11:15\"\n\t         * @returns {number} will return the new `now` value\n\t         */\n\t        clock.jump = function jump(tickValue) {\n\t            const msFloat =\n\t                typeof tickValue === \"number\"\n\t                    ? tickValue\n\t                    : parseTime(tickValue);\n\t            const ms = Math.floor(msFloat);\n\n\t            for (const timer of Object.values(clock.timers)) {\n\t                if (clock.now + ms > timer.callAt) {\n\t                    timer.callAt = clock.now + ms;\n\t                }\n\t            }\n\t            clock.tick(ms);\n\t        };\n\n\t        if (isPresent.performance) {\n\t            clock.performance = Object.create(null);\n\t            clock.performance.now = fakePerformanceNow;\n\t        }\n\n\t        if (isPresent.hrtime) {\n\t            clock.hrtime = hrtime;\n\t        }\n\n\t        return clock;\n\t    }\n\n\t    /* eslint-disable complexity */\n\n\t    /**\n\t     * @param {Config=} [config] Optional config\n\t     * @returns {Clock}\n\t     */\n\t    function install(config) {\n\t        if (\n\t            arguments.length > 1 ||\n\t            config instanceof Date ||\n\t            Array.isArray(config) ||\n\t            typeof config === \"number\"\n\t        ) {\n\t            throw new TypeError(\n\t                `FakeTimers.install called with ${String(\n\t                    config,\n\t                )} install requires an object parameter`,\n\t            );\n\t        }\n\n\t        if (_global.Date.isFake === true) {\n\t            // Timers are already faked; this is a problem.\n\t            // Make the user reset timers before continuing.\n\t            throw new TypeError(\n\t                \"Can't install fake timers twice on the same global object.\",\n\t            );\n\t        }\n\n\t        // eslint-disable-next-line no-param-reassign\n\t        config = typeof config !== \"undefined\" ? config : {};\n\t        config.shouldAdvanceTime = config.shouldAdvanceTime || false;\n\t        config.advanceTimeDelta = config.advanceTimeDelta || 20;\n\t        config.shouldClearNativeTimers =\n\t            config.shouldClearNativeTimers || false;\n\n\t        if (config.target) {\n\t            throw new TypeError(\n\t                \"config.target is no longer supported. Use `withGlobal(target)` instead.\",\n\t            );\n\t        }\n\n\t        /**\n\t         * @param {string} timer/object the name of the thing that is not present\n\t         * @param timer\n\t         */\n\t        function handleMissingTimer(timer) {\n\t            if (config.ignoreMissingTimers) {\n\t                return;\n\t            }\n\n\t            throw new ReferenceError(\n\t                `non-existent timers and/or objects cannot be faked: '${timer}'`,\n\t            );\n\t        }\n\n\t        let i, l;\n\t        const clock = createClock(config.now, config.loopLimit);\n\t        clock.shouldClearNativeTimers = config.shouldClearNativeTimers;\n\n\t        clock.uninstall = function () {\n\t            return uninstall(clock, config);\n\t        };\n\n\t        clock.abortListenerMap = new Map();\n\n\t        clock.methods = config.toFake || [];\n\n\t        if (clock.methods.length === 0) {\n\t            clock.methods = Object.keys(timers);\n\t        }\n\n\t        if (config.shouldAdvanceTime === true) {\n\t            const intervalTick = doIntervalTick.bind(\n\t                null,\n\t                clock,\n\t                config.advanceTimeDelta,\n\t            );\n\t            const intervalId = _global.setInterval(\n\t                intervalTick,\n\t                config.advanceTimeDelta,\n\t            );\n\t            clock.attachedInterval = intervalId;\n\t        }\n\n\t        if (clock.methods.includes(\"performance\")) {\n\t            const proto = (() => {\n\t                if (hasPerformanceConstructorPrototype) {\n\t                    return _global.performance.constructor.prototype;\n\t                }\n\t                if (hasPerformancePrototype) {\n\t                    return _global.Performance.prototype;\n\t                }\n\t            })();\n\t            if (proto) {\n\t                Object.getOwnPropertyNames(proto).forEach(function (name) {\n\t                    if (name !== \"now\") {\n\t                        clock.performance[name] =\n\t                            name.indexOf(\"getEntries\") === 0\n\t                                ? NOOP_ARRAY\n\t                                : NOOP;\n\t                    }\n\t                });\n\t                // ensure `mark` returns a value that is valid\n\t                clock.performance.mark = (name) =>\n\t                    new FakePerformanceEntry(name, \"mark\", 0, 0);\n\t                clock.performance.measure = (name) =>\n\t                    new FakePerformanceEntry(name, \"measure\", 0, 100);\n\t                // `timeOrigin` should return the time of when the Window session started\n\t                // (or the Worker was installed)\n\t                clock.performance.timeOrigin = getEpoch(config.now);\n\t            } else if ((config.toFake || []).includes(\"performance\")) {\n\t                return handleMissingTimer(\"performance\");\n\t            }\n\t        }\n\t        if (_global === globalObject && timersModule) {\n\t            clock.timersModuleMethods = [];\n\t        }\n\t        if (_global === globalObject && timersPromisesModule) {\n\t            clock.timersPromisesModuleMethods = [];\n\t        }\n\t        for (i = 0, l = clock.methods.length; i < l; i++) {\n\t            const nameOfMethodToReplace = clock.methods[i];\n\n\t            if (!isPresent[nameOfMethodToReplace]) {\n\t                handleMissingTimer(nameOfMethodToReplace);\n\t                // eslint-disable-next-line\n\t                continue;\n\t            }\n\n\t            if (nameOfMethodToReplace === \"hrtime\") {\n\t                if (\n\t                    _global.process &&\n\t                    typeof _global.process.hrtime === \"function\"\n\t                ) {\n\t                    hijackMethod(_global.process, nameOfMethodToReplace, clock);\n\t                }\n\t            } else if (nameOfMethodToReplace === \"nextTick\") {\n\t                if (\n\t                    _global.process &&\n\t                    typeof _global.process.nextTick === \"function\"\n\t                ) {\n\t                    hijackMethod(_global.process, nameOfMethodToReplace, clock);\n\t                }\n\t            } else {\n\t                hijackMethod(_global, nameOfMethodToReplace, clock);\n\t            }\n\t            if (\n\t                clock.timersModuleMethods !== undefined &&\n\t                timersModule[nameOfMethodToReplace]\n\t            ) {\n\t                const original = timersModule[nameOfMethodToReplace];\n\t                clock.timersModuleMethods.push({\n\t                    methodName: nameOfMethodToReplace,\n\t                    original: original,\n\t                });\n\t                timersModule[nameOfMethodToReplace] =\n\t                    _global[nameOfMethodToReplace];\n\t            }\n\t            if (clock.timersPromisesModuleMethods !== undefined) {\n\t                if (nameOfMethodToReplace === \"setTimeout\") {\n\t                    clock.timersPromisesModuleMethods.push({\n\t                        methodName: \"setTimeout\",\n\t                        original: timersPromisesModule.setTimeout,\n\t                    });\n\n\t                    timersPromisesModule.setTimeout = (\n\t                        delay,\n\t                        value,\n\t                        options = {},\n\t                    ) =>\n\t                        new Promise((resolve, reject) => {\n\t                            const abort = () => {\n\t                                options.signal.removeEventListener(\n\t                                    \"abort\",\n\t                                    abort,\n\t                                );\n\t                                clock.abortListenerMap.delete(abort);\n\n\t                                // This is safe, there is no code path that leads to this function\n\t                                // being invoked before handle has been assigned.\n\t                                // eslint-disable-next-line no-use-before-define\n\t                                clock.clearTimeout(handle);\n\t                                reject(options.signal.reason);\n\t                            };\n\n\t                            const handle = clock.setTimeout(() => {\n\t                                if (options.signal) {\n\t                                    options.signal.removeEventListener(\n\t                                        \"abort\",\n\t                                        abort,\n\t                                    );\n\t                                    clock.abortListenerMap.delete(abort);\n\t                                }\n\n\t                                resolve(value);\n\t                            }, delay);\n\n\t                            if (options.signal) {\n\t                                if (options.signal.aborted) {\n\t                                    abort();\n\t                                } else {\n\t                                    options.signal.addEventListener(\n\t                                        \"abort\",\n\t                                        abort,\n\t                                    );\n\t                                    clock.abortListenerMap.set(\n\t                                        abort,\n\t                                        options.signal,\n\t                                    );\n\t                                }\n\t                            }\n\t                        });\n\t                } else if (nameOfMethodToReplace === \"setImmediate\") {\n\t                    clock.timersPromisesModuleMethods.push({\n\t                        methodName: \"setImmediate\",\n\t                        original: timersPromisesModule.setImmediate,\n\t                    });\n\n\t                    timersPromisesModule.setImmediate = (value, options = {}) =>\n\t                        new Promise((resolve, reject) => {\n\t                            const abort = () => {\n\t                                options.signal.removeEventListener(\n\t                                    \"abort\",\n\t                                    abort,\n\t                                );\n\t                                clock.abortListenerMap.delete(abort);\n\n\t                                // This is safe, there is no code path that leads to this function\n\t                                // being invoked before handle has been assigned.\n\t                                // eslint-disable-next-line no-use-before-define\n\t                                clock.clearImmediate(handle);\n\t                                reject(options.signal.reason);\n\t                            };\n\n\t                            const handle = clock.setImmediate(() => {\n\t                                if (options.signal) {\n\t                                    options.signal.removeEventListener(\n\t                                        \"abort\",\n\t                                        abort,\n\t                                    );\n\t                                    clock.abortListenerMap.delete(abort);\n\t                                }\n\n\t                                resolve(value);\n\t                            });\n\n\t                            if (options.signal) {\n\t                                if (options.signal.aborted) {\n\t                                    abort();\n\t                                } else {\n\t                                    options.signal.addEventListener(\n\t                                        \"abort\",\n\t                                        abort,\n\t                                    );\n\t                                    clock.abortListenerMap.set(\n\t                                        abort,\n\t                                        options.signal,\n\t                                    );\n\t                                }\n\t                            }\n\t                        });\n\t                } else if (nameOfMethodToReplace === \"setInterval\") {\n\t                    clock.timersPromisesModuleMethods.push({\n\t                        methodName: \"setInterval\",\n\t                        original: timersPromisesModule.setInterval,\n\t                    });\n\n\t                    timersPromisesModule.setInterval = (\n\t                        delay,\n\t                        value,\n\t                        options = {},\n\t                    ) => ({\n\t                        [Symbol.asyncIterator]: () => {\n\t                            const createResolvable = () => {\n\t                                let resolve, reject;\n\t                                const promise = new Promise((res, rej) => {\n\t                                    resolve = res;\n\t                                    reject = rej;\n\t                                });\n\t                                promise.resolve = resolve;\n\t                                promise.reject = reject;\n\t                                return promise;\n\t                            };\n\n\t                            let done = false;\n\t                            let hasThrown = false;\n\t                            let returnCall;\n\t                            let nextAvailable = 0;\n\t                            const nextQueue = [];\n\n\t                            const handle = clock.setInterval(() => {\n\t                                if (nextQueue.length > 0) {\n\t                                    nextQueue.shift().resolve();\n\t                                } else {\n\t                                    nextAvailable++;\n\t                                }\n\t                            }, delay);\n\n\t                            const abort = () => {\n\t                                options.signal.removeEventListener(\n\t                                    \"abort\",\n\t                                    abort,\n\t                                );\n\t                                clock.abortListenerMap.delete(abort);\n\n\t                                clock.clearInterval(handle);\n\t                                done = true;\n\t                                for (const resolvable of nextQueue) {\n\t                                    resolvable.resolve();\n\t                                }\n\t                            };\n\n\t                            if (options.signal) {\n\t                                if (options.signal.aborted) {\n\t                                    done = true;\n\t                                } else {\n\t                                    options.signal.addEventListener(\n\t                                        \"abort\",\n\t                                        abort,\n\t                                    );\n\t                                    clock.abortListenerMap.set(\n\t                                        abort,\n\t                                        options.signal,\n\t                                    );\n\t                                }\n\t                            }\n\n\t                            return {\n\t                                next: async () => {\n\t                                    if (options.signal?.aborted && !hasThrown) {\n\t                                        hasThrown = true;\n\t                                        throw options.signal.reason;\n\t                                    }\n\n\t                                    if (done) {\n\t                                        return { done: true, value: undefined };\n\t                                    }\n\n\t                                    if (nextAvailable > 0) {\n\t                                        nextAvailable--;\n\t                                        return { done: false, value: value };\n\t                                    }\n\n\t                                    const resolvable = createResolvable();\n\t                                    nextQueue.push(resolvable);\n\n\t                                    await resolvable;\n\n\t                                    if (returnCall && nextQueue.length === 0) {\n\t                                        returnCall.resolve();\n\t                                    }\n\n\t                                    if (options.signal?.aborted && !hasThrown) {\n\t                                        hasThrown = true;\n\t                                        throw options.signal.reason;\n\t                                    }\n\n\t                                    if (done) {\n\t                                        return { done: true, value: undefined };\n\t                                    }\n\n\t                                    return { done: false, value: value };\n\t                                },\n\t                                return: async () => {\n\t                                    if (done) {\n\t                                        return { done: true, value: undefined };\n\t                                    }\n\n\t                                    if (nextQueue.length > 0) {\n\t                                        returnCall = createResolvable();\n\t                                        await returnCall;\n\t                                    }\n\n\t                                    clock.clearInterval(handle);\n\t                                    done = true;\n\n\t                                    if (options.signal) {\n\t                                        options.signal.removeEventListener(\n\t                                            \"abort\",\n\t                                            abort,\n\t                                        );\n\t                                        clock.abortListenerMap.delete(abort);\n\t                                    }\n\n\t                                    return { done: true, value: undefined };\n\t                                },\n\t                            };\n\t                        },\n\t                    });\n\t                }\n\t            }\n\t        }\n\n\t        return clock;\n\t    }\n\n\t    /* eslint-enable complexity */\n\n\t    return {\n\t        timers: timers,\n\t        createClock: createClock,\n\t        install: install,\n\t        withGlobal: withGlobal,\n\t    };\n\t}\n\n\t/**\n\t * @typedef {object} FakeTimers\n\t * @property {Timers} timers\n\t * @property {createClock} createClock\n\t * @property {Function} install\n\t * @property {withGlobal} withGlobal\n\t */\n\n\t/* eslint-enable complexity */\n\n\t/** @type {FakeTimers} */\n\tconst defaultImplementation = withGlobal(globalObject);\n\n\tfakeTimersSrc.timers = defaultImplementation.timers;\n\tfakeTimersSrc.createClock = defaultImplementation.createClock;\n\tfakeTimersSrc.install = defaultImplementation.install;\n\tfakeTimersSrc.withGlobal = withGlobal;\n\treturn fakeTimersSrc;\n}\n\nvar fakeTimersSrcExports = requireFakeTimersSrc();\n\nclass FakeTimers {\n\t_global;\n\t_clock;\n\t// | _fakingTime | _fakingDate |\n\t// +-------------+-------------+\n\t// | false       | falsy       | initial\n\t// | false       | truthy      | vi.setSystemTime called first (for mocking only Date without fake timers)\n\t// | true        | falsy       | vi.useFakeTimers called first\n\t// | true        | truthy      | unreachable\n\t_fakingTime;\n\t_fakingDate;\n\t_fakeTimers;\n\t_userConfig;\n\t_now = RealDate.now;\n\tconstructor({ global, config }) {\n\t\tthis._userConfig = config;\n\t\tthis._fakingDate = null;\n\t\tthis._fakingTime = false;\n\t\tthis._fakeTimers = fakeTimersSrcExports.withGlobal(global);\n\t\tthis._global = global;\n\t}\n\tclearAllTimers() {\n\t\tif (this._fakingTime) this._clock.reset();\n\t}\n\tdispose() {\n\t\tthis.useRealTimers();\n\t}\n\trunAllTimers() {\n\t\tif (this._checkFakeTimers()) this._clock.runAll();\n\t}\n\tasync runAllTimersAsync() {\n\t\tif (this._checkFakeTimers()) await this._clock.runAllAsync();\n\t}\n\trunOnlyPendingTimers() {\n\t\tif (this._checkFakeTimers()) this._clock.runToLast();\n\t}\n\tasync runOnlyPendingTimersAsync() {\n\t\tif (this._checkFakeTimers()) await this._clock.runToLastAsync();\n\t}\n\tadvanceTimersToNextTimer(steps = 1) {\n\t\tif (this._checkFakeTimers()) for (let i = steps; i > 0; i--) {\n\t\t\tthis._clock.next();\n\t\t\t// Fire all timers at this point: https://github.com/sinonjs/fake-timers/issues/250\n\t\t\tthis._clock.tick(0);\n\t\t\tif (this._clock.countTimers() === 0) break;\n\t\t}\n\t}\n\tasync advanceTimersToNextTimerAsync(steps = 1) {\n\t\tif (this._checkFakeTimers()) for (let i = steps; i > 0; i--) {\n\t\t\tawait this._clock.nextAsync();\n\t\t\t// Fire all timers at this point: https://github.com/sinonjs/fake-timers/issues/250\n\t\t\tthis._clock.tick(0);\n\t\t\tif (this._clock.countTimers() === 0) break;\n\t\t}\n\t}\n\tadvanceTimersByTime(msToRun) {\n\t\tif (this._checkFakeTimers()) this._clock.tick(msToRun);\n\t}\n\tasync advanceTimersByTimeAsync(msToRun) {\n\t\tif (this._checkFakeTimers()) await this._clock.tickAsync(msToRun);\n\t}\n\tadvanceTimersToNextFrame() {\n\t\tif (this._checkFakeTimers()) this._clock.runToFrame();\n\t}\n\trunAllTicks() {\n\t\tif (this._checkFakeTimers())\n // @ts-expect-error method not exposed\n\t\tthis._clock.runMicrotasks();\n\t}\n\tuseRealTimers() {\n\t\tif (this._fakingDate) {\n\t\t\tresetDate();\n\t\t\tthis._fakingDate = null;\n\t\t}\n\t\tif (this._fakingTime) {\n\t\t\tthis._clock.uninstall();\n\t\t\tthis._fakingTime = false;\n\t\t}\n\t}\n\tuseFakeTimers() {\n\t\tconst fakeDate = this._fakingDate || Date.now();\n\t\tif (this._fakingDate) {\n\t\t\tresetDate();\n\t\t\tthis._fakingDate = null;\n\t\t}\n\t\tif (this._fakingTime) this._clock.uninstall();\n\t\tconst toFake = Object.keys(this._fakeTimers.timers).filter((timer) => timer !== \"nextTick\" && timer !== \"queueMicrotask\");\n\t\tif (this._userConfig?.toFake?.includes(\"nextTick\") && isChildProcess()) throw new Error(\"process.nextTick cannot be mocked inside child_process\");\n\t\tthis._clock = this._fakeTimers.install({\n\t\t\tnow: fakeDate,\n\t\t\t...this._userConfig,\n\t\t\ttoFake: this._userConfig?.toFake || toFake,\n\t\t\tignoreMissingTimers: true\n\t\t});\n\t\tthis._fakingTime = true;\n\t}\n\treset() {\n\t\tif (this._checkFakeTimers()) {\n\t\t\tconst { now } = this._clock;\n\t\t\tthis._clock.reset();\n\t\t\tthis._clock.setSystemTime(now);\n\t\t}\n\t}\n\tsetSystemTime(now) {\n\t\tconst date = typeof now === \"undefined\" || now instanceof Date ? now : new Date(now);\n\t\tif (this._fakingTime) this._clock.setSystemTime(date);\n\t\telse {\n\t\t\tthis._fakingDate = date ?? new Date(this.getRealSystemTime());\n\t\t\tmockDate(this._fakingDate);\n\t\t}\n\t}\n\tgetMockedSystemTime() {\n\t\treturn this._fakingTime ? new Date(this._clock.now) : this._fakingDate;\n\t}\n\tgetRealSystemTime() {\n\t\treturn this._now();\n\t}\n\tgetTimerCount() {\n\t\tif (this._checkFakeTimers()) return this._clock.countTimers();\n\t\treturn 0;\n\t}\n\tconfigure(config) {\n\t\tthis._userConfig = config;\n\t}\n\tisFakeTimers() {\n\t\treturn this._fakingTime;\n\t}\n\t_checkFakeTimers() {\n\t\tif (!this._fakingTime) throw new Error(\"A function to advance timers was called but the timers APIs are not mocked. Call `vi.useFakeTimers()` in the test file first.\");\n\t\treturn this._fakingTime;\n\t}\n}\n\nfunction copyStackTrace(target, source) {\n\tif (source.stack !== void 0) target.stack = source.stack.replace(source.message, target.message);\n\treturn target;\n}\nfunction waitFor(callback, options = {}) {\n\tconst { setTimeout, setInterval, clearTimeout, clearInterval } = getSafeTimers();\n\tconst { interval = 50, timeout = 1e3 } = typeof options === \"number\" ? { timeout: options } : options;\n\tconst STACK_TRACE_ERROR = /* @__PURE__ */ new Error(\"STACK_TRACE_ERROR\");\n\treturn new Promise((resolve, reject) => {\n\t\tlet lastError;\n\t\tlet promiseStatus = \"idle\";\n\t\tlet timeoutId;\n\t\tlet intervalId;\n\t\tconst onResolve = (result) => {\n\t\t\tif (timeoutId) clearTimeout(timeoutId);\n\t\t\tif (intervalId) clearInterval(intervalId);\n\t\t\tresolve(result);\n\t\t};\n\t\tconst handleTimeout = () => {\n\t\t\tif (intervalId) clearInterval(intervalId);\n\t\t\tlet error = lastError;\n\t\t\tif (!error) error = copyStackTrace(/* @__PURE__ */ new Error(\"Timed out in waitFor!\"), STACK_TRACE_ERROR);\n\t\t\treject(error);\n\t\t};\n\t\tconst checkCallback = () => {\n\t\t\tif (vi.isFakeTimers()) vi.advanceTimersByTime(interval);\n\t\t\tif (promiseStatus === \"pending\") return;\n\t\t\ttry {\n\t\t\t\tconst result = callback();\n\t\t\t\tif (result !== null && typeof result === \"object\" && typeof result.then === \"function\") {\n\t\t\t\t\tconst thenable = result;\n\t\t\t\t\tpromiseStatus = \"pending\";\n\t\t\t\t\tthenable.then((resolvedValue) => {\n\t\t\t\t\t\tpromiseStatus = \"resolved\";\n\t\t\t\t\t\tonResolve(resolvedValue);\n\t\t\t\t\t}, (rejectedValue) => {\n\t\t\t\t\t\tpromiseStatus = \"rejected\";\n\t\t\t\t\t\tlastError = rejectedValue;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tonResolve(result);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlastError = error;\n\t\t\t}\n\t\t};\n\t\tif (checkCallback() === true) return;\n\t\ttimeoutId = setTimeout(handleTimeout, timeout);\n\t\tintervalId = setInterval(checkCallback, interval);\n\t});\n}\nfunction waitUntil(callback, options = {}) {\n\tconst { setTimeout, setInterval, clearTimeout, clearInterval } = getSafeTimers();\n\tconst { interval = 50, timeout = 1e3 } = typeof options === \"number\" ? { timeout: options } : options;\n\tconst STACK_TRACE_ERROR = /* @__PURE__ */ new Error(\"STACK_TRACE_ERROR\");\n\treturn new Promise((resolve, reject) => {\n\t\tlet promiseStatus = \"idle\";\n\t\tlet timeoutId;\n\t\tlet intervalId;\n\t\tconst onReject = (error) => {\n\t\t\tif (intervalId) clearInterval(intervalId);\n\t\t\tif (!error) error = copyStackTrace(/* @__PURE__ */ new Error(\"Timed out in waitUntil!\"), STACK_TRACE_ERROR);\n\t\t\treject(error);\n\t\t};\n\t\tconst onResolve = (result) => {\n\t\t\tif (!result) return;\n\t\t\tif (timeoutId) clearTimeout(timeoutId);\n\t\t\tif (intervalId) clearInterval(intervalId);\n\t\t\tresolve(result);\n\t\t\treturn true;\n\t\t};\n\t\tconst checkCallback = () => {\n\t\t\tif (vi.isFakeTimers()) vi.advanceTimersByTime(interval);\n\t\t\tif (promiseStatus === \"pending\") return;\n\t\t\ttry {\n\t\t\t\tconst result = callback();\n\t\t\t\tif (result !== null && typeof result === \"object\" && typeof result.then === \"function\") {\n\t\t\t\t\tconst thenable = result;\n\t\t\t\t\tpromiseStatus = \"pending\";\n\t\t\t\t\tthenable.then((resolvedValue) => {\n\t\t\t\t\t\tpromiseStatus = \"resolved\";\n\t\t\t\t\t\tonResolve(resolvedValue);\n\t\t\t\t\t}, (rejectedValue) => {\n\t\t\t\t\t\tpromiseStatus = \"rejected\";\n\t\t\t\t\t\tonReject(rejectedValue);\n\t\t\t\t\t});\n\t\t\t\t} else return onResolve(result);\n\t\t\t} catch (error) {\n\t\t\t\tonReject(error);\n\t\t\t}\n\t\t};\n\t\tif (checkCallback() === true) return;\n\t\ttimeoutId = setTimeout(onReject, timeout);\n\t\tintervalId = setInterval(checkCallback, interval);\n\t});\n}\n\nfunction createVitest() {\n\tlet _config = null;\n\tconst state = () => getWorkerState();\n\tlet _timers;\n\tconst timers = () => _timers ||= new FakeTimers({\n\t\tglobal: globalThis,\n\t\tconfig: state().config.fakeTimers\n\t});\n\tconst _stubsGlobal = /* @__PURE__ */ new Map();\n\tconst _stubsEnv = /* @__PURE__ */ new Map();\n\tconst _envBooleans = [\n\t\t\"PROD\",\n\t\t\"DEV\",\n\t\t\"SSR\"\n\t];\n\tconst utils = {\n\t\tuseFakeTimers(config) {\n\t\t\tif (isChildProcess()) {\n\t\t\t\tif (config?.toFake?.includes(\"nextTick\") || state().config?.fakeTimers?.toFake?.includes(\"nextTick\")) throw new Error(\"vi.useFakeTimers({ toFake: [\\\"nextTick\\\"] }) is not supported in node:child_process. Use --pool=threads if mocking nextTick is required.\");\n\t\t\t}\n\t\t\tif (config) timers().configure({\n\t\t\t\t...state().config.fakeTimers,\n\t\t\t\t...config\n\t\t\t});\n\t\t\telse timers().configure(state().config.fakeTimers);\n\t\t\ttimers().useFakeTimers();\n\t\t\treturn utils;\n\t\t},\n\t\tisFakeTimers() {\n\t\t\treturn timers().isFakeTimers();\n\t\t},\n\t\tuseRealTimers() {\n\t\t\ttimers().useRealTimers();\n\t\t\treturn utils;\n\t\t},\n\t\trunOnlyPendingTimers() {\n\t\t\ttimers().runOnlyPendingTimers();\n\t\t\treturn utils;\n\t\t},\n\t\tasync runOnlyPendingTimersAsync() {\n\t\t\tawait timers().runOnlyPendingTimersAsync();\n\t\t\treturn utils;\n\t\t},\n\t\trunAllTimers() {\n\t\t\ttimers().runAllTimers();\n\t\t\treturn utils;\n\t\t},\n\t\tasync runAllTimersAsync() {\n\t\t\tawait timers().runAllTimersAsync();\n\t\t\treturn utils;\n\t\t},\n\t\trunAllTicks() {\n\t\t\ttimers().runAllTicks();\n\t\t\treturn utils;\n\t\t},\n\t\tadvanceTimersByTime(ms) {\n\t\t\ttimers().advanceTimersByTime(ms);\n\t\t\treturn utils;\n\t\t},\n\t\tasync advanceTimersByTimeAsync(ms) {\n\t\t\tawait timers().advanceTimersByTimeAsync(ms);\n\t\t\treturn utils;\n\t\t},\n\t\tadvanceTimersToNextTimer() {\n\t\t\ttimers().advanceTimersToNextTimer();\n\t\t\treturn utils;\n\t\t},\n\t\tasync advanceTimersToNextTimerAsync() {\n\t\t\tawait timers().advanceTimersToNextTimerAsync();\n\t\t\treturn utils;\n\t\t},\n\t\tadvanceTimersToNextFrame() {\n\t\t\ttimers().advanceTimersToNextFrame();\n\t\t\treturn utils;\n\t\t},\n\t\tgetTimerCount() {\n\t\t\treturn timers().getTimerCount();\n\t\t},\n\t\tsetSystemTime(time) {\n\t\t\ttimers().setSystemTime(time);\n\t\t\treturn utils;\n\t\t},\n\t\tgetMockedSystemTime() {\n\t\t\treturn timers().getMockedSystemTime();\n\t\t},\n\t\tgetRealSystemTime() {\n\t\t\treturn timers().getRealSystemTime();\n\t\t},\n\t\tclearAllTimers() {\n\t\t\ttimers().clearAllTimers();\n\t\t\treturn utils;\n\t\t},\n\t\tspyOn,\n\t\tfn,\n\t\twaitFor,\n\t\twaitUntil,\n\t\thoisted(factory) {\n\t\t\tassertTypes(factory, \"\\\"vi.hoisted\\\" factory\", [\"function\"]);\n\t\t\treturn factory();\n\t\t},\n\t\tmock(path, factory) {\n\t\t\tif (typeof path !== \"string\") throw new TypeError(`vi.mock() expects a string path, but received a ${typeof path}`);\n\t\t\tconst importer = getImporter(\"mock\");\n\t\t\t_mocker().queueMock(path, importer, typeof factory === \"function\" ? () => factory(() => _mocker().importActual(path, importer, _mocker().getMockContext().callstack)) : factory);\n\t\t},\n\t\tunmock(path) {\n\t\t\tif (typeof path !== \"string\") throw new TypeError(`vi.unmock() expects a string path, but received a ${typeof path}`);\n\t\t\t_mocker().queueUnmock(path, getImporter(\"unmock\"));\n\t\t},\n\t\tdoMock(path, factory) {\n\t\t\tif (typeof path !== \"string\") throw new TypeError(`vi.doMock() expects a string path, but received a ${typeof path}`);\n\t\t\tconst importer = getImporter(\"doMock\");\n\t\t\t_mocker().queueMock(path, importer, typeof factory === \"function\" ? () => factory(() => _mocker().importActual(path, importer, _mocker().getMockContext().callstack)) : factory);\n\t\t},\n\t\tdoUnmock(path) {\n\t\t\tif (typeof path !== \"string\") throw new TypeError(`vi.doUnmock() expects a string path, but received a ${typeof path}`);\n\t\t\tconst importer = getImporter(\"doUnmock\");\n\t\t\t_mocker().queueUnmock(path, importer);\n\t\t},\n\t\tasync importActual(path) {\n\t\t\tconst importer = getImporter(\"importActual\");\n\t\t\treturn _mocker().importActual(path, importer, _mocker().getMockContext().callstack);\n\t\t},\n\t\tasync importMock(path) {\n\t\t\tconst importer = getImporter(\"importMock\");\n\t\t\treturn _mocker().importMock(path, importer);\n\t\t},\n\t\tmockObject(value, options) {\n\t\t\treturn _mocker().mockObject({ value }, void 0, options?.spy ? \"autospy\" : \"automock\").value;\n\t\t},\n\t\tmocked(item, _options = {}) {\n\t\t\treturn item;\n\t\t},\n\t\tisMockFunction(fn) {\n\t\t\treturn isMockFunction(fn);\n\t\t},\n\t\tclearAllMocks() {\n\t\t\tclearAllMocks();\n\t\t\treturn utils;\n\t\t},\n\t\tresetAllMocks() {\n\t\t\tresetAllMocks();\n\t\t\treturn utils;\n\t\t},\n\t\trestoreAllMocks() {\n\t\t\trestoreAllMocks();\n\t\t\treturn utils;\n\t\t},\n\t\tstubGlobal(name, value) {\n\t\t\tif (!_stubsGlobal.has(name)) _stubsGlobal.set(name, Object.getOwnPropertyDescriptor(globalThis, name));\n\t\t\tObject.defineProperty(globalThis, name, {\n\t\t\t\tvalue,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true\n\t\t\t});\n\t\t\treturn utils;\n\t\t},\n\t\tstubEnv(name, value) {\n\t\t\tconst env = state().metaEnv;\n\t\t\tif (!_stubsEnv.has(name)) _stubsEnv.set(name, env[name]);\n\t\t\tif (_envBooleans.includes(name)) env[name] = value ? \"1\" : \"\";\n\t\t\telse if (value === void 0) delete env[name];\n\t\t\telse env[name] = String(value);\n\t\t\treturn utils;\n\t\t},\n\t\tunstubAllGlobals() {\n\t\t\t_stubsGlobal.forEach((original, name) => {\n\t\t\t\tif (!original) Reflect.deleteProperty(globalThis, name);\n\t\t\t\telse Object.defineProperty(globalThis, name, original);\n\t\t\t});\n\t\t\t_stubsGlobal.clear();\n\t\t\treturn utils;\n\t\t},\n\t\tunstubAllEnvs() {\n\t\t\tconst env = state().metaEnv;\n\t\t\t_stubsEnv.forEach((original, name) => {\n\t\t\t\tif (original === void 0) delete env[name];\n\t\t\t\telse env[name] = original;\n\t\t\t});\n\t\t\t_stubsEnv.clear();\n\t\t\treturn utils;\n\t\t},\n\t\tresetModules() {\n\t\t\tresetModules(state().evaluatedModules);\n\t\t\treturn utils;\n\t\t},\n\t\tasync dynamicImportSettled() {\n\t\t\treturn waitForImportsToResolve();\n\t\t},\n\t\tsetConfig(config) {\n\t\t\tif (!_config) _config = { ...state().config };\n\t\t\tObject.assign(state().config, config);\n\t\t},\n\t\tresetConfig() {\n\t\t\tif (_config) Object.assign(state().config, _config);\n\t\t}\n\t};\n\treturn utils;\n}\nconst vitest = createVitest();\nconst vi = vitest;\nfunction _mocker() {\n\t// @ts-expect-error injected by vite-nide\n\treturn typeof __vitest_mocker__ !== \"undefined\" ? __vitest_mocker__ : new Proxy({}, { get(_, name) {\n\t\tthrow new Error(`Vitest mocker was not initialized in this environment. vi.${String(name)}() is forbidden.`);\n\t} });\n}\nfunction getImporter(name) {\n\tconst stackArray = createSimpleStackTrace({ stackTraceLimit: 5 }).split(\"\\n\");\n\treturn parseSingleStack(stackArray[stackArray.findLastIndex((stack) => {\n\t\treturn stack.includes(` at Object.${name}`) || stack.includes(`${name}@`) || stack.includes(` at ${name} (`);\n\t}) + 1])?.file || \"\";\n}\n\nexport { getSnapshotClient as a, assert as b, createExpect as c, vitest as d, globalExpect as g, inject as i, should as s, vi as v };\n"],"names":["NAME_WORKER_STATE","getWorkerState","workerState","commonjsGlobal","unsupported","throwWithCause","error","source","copyStackTrace$1","createExpectPoll","expect","fn","options","defaults","_a","interval","timeout","message","assertion","test","chai.util","proxy","target","key","receiver","assertionFunction","chai.Assertion","args","STACK_TRACE_ERROR","promise","setTimeout","clearTimeout","getSafeTimers","executionPhase","hasTimedOut","timerId","isLastAttempt","obj","err","delay","awaited","negated","assertionString","resultPromise","onFulfilled","onRejected","onFinally","createAssertionMessage","util","hasArgs","not","name","promiseName","recordAsyncExpect","_test","index","resolved","stack","s","_client","getSnapshotClient","SnapshotClient","received","expected","equals","iterableEquality","subsetEquality","getError","e","getTestNames","getNames","SnapshotPlugin","chai","utils","getTest","assertionName","properties","errorMessage","file","inlineSnapshot","stripSnapshotIndentation","addSerializer","chai.use","JestExtend","JestChaiExpect","JestAsymmetricMatchers","createExpect","value","assertionCalls","getState","setState","chai.expect","ASYMMETRIC_MATCHERS_OBJECT","state","globalState","GLOBAL_EXPECT","chai.assert","matchers","customTesters","addCustomEqualityTesters","assertions","errorGen","hasAssertions","customMatchers","globalExpect","fakeTimersSrc","global","hasRequiredGlobal","requireGlobal","globalObject","throwsOnProto_1","hasRequiredThrowsOnProto","requireThrowsOnProto","throwsOnProto","copyPrototypeMethods","hasRequiredCopyPrototypeMethods","requireCopyPrototypeMethods","call","disallowedProperties","prototype","result","array","hasRequiredArray","requireArray","copyPrototype","calledInOrder_1","hasRequiredCalledInOrder","requireCalledInOrder","every","hasCallsLeft","callMap","spy","checkAdjacentCalls","spies","calledBeforeNext","calledInOrder","_spies","className_1","hasRequiredClassName","requireClassName","className","deprecated","hasRequiredDeprecated","requireDeprecated","exports$1","func","msg","wrapped","packageName","funcName","hasRequiredEvery","requireEvery","pass","functionName","hasRequiredFunctionName","requireFunctionName","orderByFirstCall_1","hasRequiredOrderByFirstCall","requireOrderByFirstCall","sort","slice","comparator","a","b","aCall","bCall","aId","bId","orderByFirstCall","_function","hasRequired_function","require_function","map","hasRequiredMap","requireMap","object","hasRequiredObject","requireObject","set","hasRequiredSet","requireSet","string","hasRequiredString","requireString","prototypes","hasRequiredPrototypes","requirePrototypes","typeDetect$1","typeDetect","hasRequiredTypeDetect","requireTypeDetect","module","factory","promiseExists","symbolExists","mapExists","setExists","weakMapExists","weakSetExists","dataViewExists","symbolIteratorExists","symbolToStringTagExists","setEntriesExists","mapEntriesExists","setIteratorPrototype","mapIteratorPrototype","arrayIteratorExists","arrayIteratorPrototype","stringIteratorExists","stringIteratorPrototype","toStringLeftSliceLength","toStringRightSliceLength","typeofObj","stringTag","objPrototype","typeOf","hasRequiredTypeOf","requireTypeOf","type","valueToString_1","hasRequiredValueToString","requireValueToString","valueToString","lib","hasRequiredLib","requireLib","hasRequiredFakeTimersSrc","requireFakeTimersSrc","timersModule","timersPromisesModule","withGlobal","_global","maxTimeout","idCounterStart","NOOP","NOOP_ARRAY","isPresent","timeoutResult","addTimerReturnsObject","utilPromisify","hasPerformancePrototype","hasPerformanceConstructorPrototype","NativeDate","NativeIntl","uniqueTimerId","FakePerformanceEntry","entryType","startTime","duration","isNumberFinite","num","isNearInfiniteLimit","checkIsNearInfiniteLimit","clock","i","resetIsNearInfiniteLimit","parseTime","str","strings","l","ms","parsed","nanoRemainder","msFloat","remainder","positiveRemainder","getEpoch","epoch","inRange","from","to","timer","getInfiniteLoopError","job","infiniteLoopError","computedTargetPattern","clockMethodPattern","matchedLineIndex","line","createDate","ClockDate","year","month","date","hour","minute","second","instance","createIntl","ClockIntl","property","realFormatter","formatter","method","enqueueJob","runJobs","addTimer","res","compareTimers","firstTimerInRange","timers","id","isInRange","firstTimer","lastTimer","callTimer","eval2","getClearHandler","ttype","getScheduleHandler","createWarnOnce","calls","warnOnce","clearTimer","handlerName","nativeHandler","clear","schedule","uninstall","config","installedHrTime","installedNextTick","originalPerfDescriptor","j","entry","listener","signal","hijackMethod","perfDescriptor","doIntervalTick","advanceTimeDelta","originalSetTimeout","createClock","start","loopLimit","nanos","adjustedSystemTime","getTimeToNextFrame","hrtime","prev","millisSinceStart","secsSinceStart","remainderInNanos","oldSecs","nanoDiff","secDiff","fakePerformanceNow","hrt","parts","timeToNextIdlePeriod","arg","resolve","doTick","tickValue","isAsync","reject","nanosTotal","tickTo","tickFrom","previous","firstException","oldNow","nextPromiseTick","compensationCheck","postTimerCall","doTickInner","numTimers","excessJob","doRun","systemTime","newNow","difference","install","handleMissingTimer","intervalTick","intervalId","proto","nameOfMethodToReplace","original","abort","handle","createResolvable","rej","done","hasThrown","returnCall","nextAvailable","nextQueue","resolvable","_b","defaultImplementation"],"mappings":"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","x_google_ignoreList":[0,1,2]}