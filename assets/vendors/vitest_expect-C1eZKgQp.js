var Mt=Object.defineProperty;var jt=(e,t,o)=>t in e?Mt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o;var q=(e,t,o)=>jt(e,typeof t!="symbol"?t+"":t,o);import{g as ht,s as j,d as B,n as Ct,p as _t,a as St,i as D,b as N}from"./vitest_utils-CmkFzQWi.js";import{C as E}from"./tinyrainbow-Ojqivnc3.js";import{i as V}from"./vitest_spy-BZq1Pz4S.js";import{u as At,a as S}from"./chai-BbA4eoZ1.js";const k=Symbol.for("matchers-object"),P=Symbol.for("$$jest-matchers-object"),pt=Symbol.for("expect-global"),dt=Symbol.for("asymmetric-matchers-object"),he={toSatisfy(e,t,o){const{printReceived:a,printExpected:c,matcherHint:f}=this.utils,u=t(e);return{pass:u,message:()=>u?`${f(".not.toSatisfy","received","")}

Expected value to not satisfy:
${o||c(t)}
Received:
${a(e)}`:`${f(".toSatisfy","received","")}

Expected value to satisfy:
${o||c(t)}

Received:
${a(e)}`}},toBeOneOf(e,t){const{equals:o,customTesters:a}=this,{printReceived:c,printExpected:f,matcherHint:u}=this.utils;let p;if(Array.isArray(t))p=t.length===0||t.some(m=>o(m,e,a));else if(t instanceof Set)p=t.size===0||t.has(e)||[...t].some(m=>o(m,e,a));else throw new TypeError(`You must provide an array or set to ${u(".toBeOneOf")}, not '${typeof t}'.`);return{pass:p,message:()=>p?`${u(".not.toBeOneOf","received","")}

Expected value to not be one of:
${f(t)}
Received:
${c(e)}`:`${u(".toBeOneOf","received","")}

Expected value to be one of:
${f(t)}

Received:
${c(e)}`}}},L=E.green,J=E.red,It=E.inverse,Bt=E.bold,M=E.dim;function Pt(e,t="received",o="expected",a={}){const{comment:c="",isDirectExpectCall:f=!1,isNot:u=!1,promise:p="",secondArgument:m="",expectedColor:n=L,receivedColor:r=J,secondArgumentColor:s=L}=a;let i="",l="expect";return!f&&t!==""&&(i+=M(`${l}(`)+r(t),l=")"),p!==""&&(i+=M(`${l}.`)+p,l=""),u&&(i+=`${M(`${l}.`)}not`,l=""),e.includes(".")?l+=e:(i+=M(`${l}.`)+e,l=""),o===""?l+="()":(i+=M(`${l}(`)+n(o),m&&(i+=M(", ")+s(m)),l=")"),c!==""&&(l+=` // ${c}`),l!==""&&(i+=M(l)),i}const Rt="·";function mt(e){return e.replace(/\s+$/gm,t=>Rt.repeat(t.length))}function qt(e){return J(mt(j(e)))}function Dt(e){return L(mt(j(e)))}function gt(){return{EXPECTED_COLOR:L,RECEIVED_COLOR:J,INVERTED_COLOR:It,BOLD_WEIGHT:Bt,DIM_COLOR:M,diff:B,matcherHint:Pt,printReceived:qt,printExpected:Dt,printDiffOrStringify:_t,printWithType:kt}}function kt(e,t,o){const a=ht(t),c=a!=="null"&&a!=="undefined"?`${e} has type:  ${a}
`:"",f=`${e} has value: ${o(t)}`;return c+f}function pe(e){if(!Array.isArray(e))throw new TypeError(`expect.customEqualityTesters: Must be set to an array of Testers. Was given "${ht(e)}"`);globalThis[P].customEqualityTesters.push(...e)}function G(){return globalThis[P].customEqualityTesters}function g(e,t,o,a){return o=o||[],A(e,t,[],[],o,a?yt:Ht)}function K(e){return!!e&&typeof e=="object"&&"asymmetricMatch"in e&&x("Function",e.asymmetricMatch)}function Lt(e,t,o){const a=K(e),c=K(t);if(!(a&&c)){if(a)return e.asymmetricMatch(t,o);if(c)return t.asymmetricMatch(e,o)}}function A(e,t,o,a,c,f){let u=!0;const p=Lt(e,t,c);if(p!==void 0)return p;const m={equals:g};for(let h=0;h<c.length;h++){const d=c[h].call(m,e,t,c);if(d!==void 0)return d}if(typeof URL=="function"&&e instanceof URL&&t instanceof URL)return e.href===t.href;if(Object.is(e,t))return!0;if(e===null||t===null)return e===t;const n=Object.prototype.toString.call(e);if(n!==Object.prototype.toString.call(t))return!1;switch(n){case"[object Boolean]":case"[object String]":case"[object Number]":return typeof e!=typeof t?!1:typeof e!="object"&&typeof t!="object"?Object.is(e,t):Object.is(e.valueOf(),t.valueOf());case"[object Date]":{const h=+e,d=+t;return h===d||Number.isNaN(h)&&Number.isNaN(d)}case"[object RegExp]":return e.source===t.source&&e.flags===t.flags;case"[object Temporal.Instant]":case"[object Temporal.ZonedDateTime]":case"[object Temporal.PlainDateTime]":case"[object Temporal.PlainDate]":case"[object Temporal.PlainTime]":case"[object Temporal.PlainYearMonth]":case"[object Temporal.PlainMonthDay]":return e.equals(t);case"[object Temporal.Duration]":return e.toString()===t.toString()}if(typeof e!="object"||typeof t!="object")return!1;if(Z(e)&&Z(t))return e.isEqualNode(t);let r=o.length;for(;r--;){if(o[r]===e)return a[r]===t;if(a[r]===t)return!1}if(o.push(e),a.push(t),n==="[object Array]"&&e.length!==t.length)return!1;if(e instanceof Error&&t instanceof Error)try{return Wt(e,t,o,a,c,f)}finally{o.pop(),a.pop()}const s=X(e,f);let i,l=s.length;if(X(t,f).length!==l)return!1;for(;l--;)if(i=s[l],u=f(t,i)&&A(e[i],t[i],o,a,c,f),!u)return!1;return o.pop(),a.pop(),u}function Wt(e,t,o,a,c,f){let u=Object.getPrototypeOf(e)===Object.getPrototypeOf(t)&&e.name===t.name&&e.message===t.message;return typeof t.cause<"u"&&u&&(u=A(e.cause,t.cause,o,a,c,f)),e instanceof AggregateError&&t instanceof AggregateError&&u&&(u=A(e.errors,t.errors,o,a,c,f)),u&&(u=A({...e},{...t},o,a,c,f)),u}function X(e,t){const o=[];for(const a in e)t(e,a)&&o.push(a);return o.concat(Object.getOwnPropertySymbols(e).filter(a=>Object.getOwnPropertyDescriptor(e,a).enumerable))}function Ht(e,t){return yt(e,t)&&e[t]!==void 0}function yt(e,t){return Object.hasOwn(e,t)}function x(e,t){return Object.prototype.toString.apply(t)===`[object ${e}]`}function Z(e){return e!==null&&typeof e=="object"&&"nodeType"in e&&typeof e.nodeType=="number"&&"nodeName"in e&&typeof e.nodeName=="string"&&"isEqualNode"in e&&typeof e.isEqualNode=="function"}const bt="@@__IMMUTABLE_KEYED__@@",$t="@@__IMMUTABLE_SET__@@",Vt="@@__IMMUTABLE_LIST__@@",W="@@__IMMUTABLE_ORDERED__@@",Ft="@@__IMMUTABLE_RECORD__@@";function Yt(e){return!!(e&&e[bt]&&!e[W])}function Ut(e){return!!(e&&e[$t]&&!e[W])}function H(e){return e!=null&&typeof e=="object"&&!Array.isArray(e)}function Jt(e){return!!(e&&H(e)&&e[Vt])}function Gt(e){return!!(e&&H(e)&&e[bt]&&e[W])}function zt(e){return!!(e&&H(e)&&e[$t]&&e[W])}function Kt(e){return!!(e&&H(e)&&e[Ft])}const Et=Symbol.iterator;function Q(e){return!!(e!=null&&e[Et])}function v(e,t,o=[],a=[],c=[]){if(typeof e!="object"||typeof t!="object"||Array.isArray(e)||Array.isArray(t)||!Q(e)||!Q(t))return;if(e.constructor!==t.constructor)return!1;let f=a.length;for(;f--;)if(a[f]===e)return c[f]===t;a.push(e),c.push(t);const u=[...o.filter(n=>n!==v),p];function p(n,r){return v(n,r,[...o],[...a],[...c])}if(e.size!==void 0){if(e.size!==t.size)return!1;if(x("Set",e)||Ut(e)){let n=!0;for(const r of e)if(!t.has(r)){let s=!1;for(const i of t)g(r,i,u)===!0&&(s=!0);if(s===!1){n=!1;break}}return a.pop(),c.pop(),n}else if(x("Map",e)||Yt(e)){let n=!0;for(const r of e)if(!t.has(r[0])||!g(r[1],t.get(r[0]),u)){let s=!1;for(const i of t){const l=g(r[0],i[0],u);let h=!1;l===!0&&(h=g(r[1],i[1],u)),h===!0&&(s=!0)}if(s===!1){n=!1;break}}return a.pop(),c.pop(),n}}const m=t[Et]();for(const n of e){const r=m.next();if(r.done||!g(n,r.value,u))return!1}if(!m.next().done)return!1;if(!Jt(e)&&!Gt(e)&&!zt(e)&&!Kt(e)){const n=Object.entries(e),r=Object.entries(t);if(!g(n,r,u))return!1}return a.pop(),c.pop(),!0}function z(e,t){return!e||typeof e!="object"||e===Object.prototype?!1:Object.hasOwn(e,t)||z(Object.getPrototypeOf(e),t)}function Xt(e){return D(e)&&!(e instanceof Error)&&!Array.isArray(e)&&!(e instanceof Date)}function R(e,t,o=[]){const a=o.filter(f=>f!==R),c=(f=new WeakMap)=>(u,p)=>{if(Xt(p))return Object.keys(p).every(m=>{if(p[m]!=null&&typeof p[m]=="object"){if(f.has(p[m]))return g(u[m],p[m],a);f.set(p[m],!0)}const n=u!=null&&z(u,m)&&g(u[m],p[m],[...a,c(f)]);return f.delete(p[m]),n})};return c()(e,t)}function tt(e,t){if(!(e==null||t==null||e.constructor===t.constructor))return!1}function et(e,t){let o=e,a=t;if(!(e instanceof DataView&&t instanceof DataView)){if(!(e instanceof ArrayBuffer)||!(t instanceof ArrayBuffer))return;try{o=new DataView(e),a=new DataView(t)}catch{return}}if(o.byteLength!==a.byteLength)return!1;for(let c=0;c<o.byteLength;c++)if(o.getUint8(c)!==a.getUint8(c))return!1;return!0}function U(e,t,o=[]){if(!Array.isArray(e)||!Array.isArray(t))return;const a=Object.keys(e),c=Object.keys(t),f=o.filter(u=>u!==U);return g(e,t,f,!0)&&g(a,c)}function Zt(e,t="#{this}",o="#{exp}"){const a=`expected ${t} to be ${o} // Object.is equality`;return["toStrictEqual","toEqual"].includes(e)?`${a}

If it should pass with deep equality, replace "toBe" with "${e}"

Expected: ${t}
Received: serializes to the same string
`:a}function Qt(e,t){return`${t} ${e}${t===1?"":"s"}`}function F(e){return[...Object.keys(e),...Object.getOwnPropertySymbols(e).filter(t=>{var o;return(o=Object.getOwnPropertyDescriptor(e,t))===null||o===void 0?void 0:o.enumerable})]}function te(e,t,o){let a=0;const c=(f=new WeakMap)=>(u,p)=>{if(Array.isArray(u)){if(Array.isArray(p)&&p.length===u.length)return p.map((m,n)=>c(f)(u[n],m))}else{if(u instanceof Date)return u;if(D(u)&&D(p)){if(g(u,p,[...o,v,R]))return p;const m={};f.set(u,m),typeof u.constructor=="function"&&typeof u.constructor.name=="string"&&Object.defineProperty(m,"constructor",{enumerable:!1,value:u.constructor});for(const n of F(u))z(p,n)?m[n]=f.has(u[n])?f.get(u[n]):c(f)(u[n],p[n]):f.has(u[n])||(a+=1,D(u[n])&&(a+=F(u[n]).length),c(f)(u[n],p[n]));if(F(m).length>0)return m}}return u};return{subset:c()(e,t),stripped:a}}function ee(e){return!!e&&(typeof e=="object"||typeof e=="function")&&e["~standard"]&&typeof e["~standard"].validate=="function"}if(!Object.hasOwn(globalThis,k)){const e=new WeakMap,t=Object.create(null),o=[],a=Object.create(null);Object.defineProperty(globalThis,k,{get:()=>e}),Object.defineProperty(globalThis,P,{configurable:!0,get:()=>({state:e.get(globalThis[pt]),matchers:t,customEqualityTesters:o})}),Object.defineProperty(globalThis,dt,{get:()=>a})}function wt(e){return globalThis[k].get(e)}function de(e,t){const o=globalThis[k],a=o.get(t)||{},c=Object.defineProperties(a,{...Object.getOwnPropertyDescriptors(a),...Object.getOwnPropertyDescriptors(e)});o.set(t,c)}class T{constructor(t,o=!1){q(this,"$$typeof",Symbol.for("jest.asymmetricMatcher"));this.sample=t,this.inverse=o}getMatcherContext(t){return{...wt(t||globalThis[pt]),equals:g,isNot:this.inverse,customTesters:G(),utils:{...gt(),diff:B,stringify:j,iterableEquality:v,subsetEquality:R}}}}T.prototype[Symbol.for("chai/inspect")]=function(e){const t=j(this,e.depth,{min:!0});return t.length<=e.truncate?t:`${this.toString()}{…}`};class nt extends T{constructor(t,o=!1){if(!x("String",t))throw new Error("Expected is not a string");super(t,o)}asymmetricMatch(t){const o=x("String",t)&&t.includes(this.sample);return this.inverse?!o:o}toString(){return`String${this.inverse?"Not":""}Containing`}getExpectedType(){return"string"}}class ne extends T{asymmetricMatch(t){return t!=null}toString(){return"Anything"}toAsymmetricMatcher(){return"Anything"}}class rt extends T{constructor(t,o=!1){super(t,o)}getPrototype(t){return Object.getPrototypeOf?Object.getPrototypeOf(t):t.constructor.prototype===t?null:t.constructor.prototype}hasProperty(t,o){return t?Object.hasOwn(t,o)?!0:this.hasProperty(this.getPrototype(t),o):!1}getProperties(t){return[...Object.keys(t),...Object.getOwnPropertySymbols(t).filter(o=>{var a;return(a=Object.getOwnPropertyDescriptor(t,o))===null||a===void 0?void 0:a.enumerable})]}asymmetricMatch(t,o){if(typeof this.sample!="object")throw new TypeError(`You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`);let a=!0;const c=this.getProperties(this.sample);for(const p of c){var f,u;if(!this.hasProperty(t,p)){a=!1;break}const m=((f=Object.getOwnPropertyDescriptor(this.sample,p))===null||f===void 0?void 0:f.value)??this.sample[p],n=((u=Object.getOwnPropertyDescriptor(t,p))===null||u===void 0?void 0:u.value)??t[p];if(!g(m,n,o)){a=!1;break}}return this.inverse?!a:a}toString(){return`Object${this.inverse?"Not":""}Containing`}getExpectedType(){return"object"}}class ot extends T{constructor(t,o=!1){super(t,o)}asymmetricMatch(t,o){if(!Array.isArray(this.sample))throw new TypeError(`You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`);const a=this.sample.length===0||Array.isArray(t)&&this.sample.every(c=>t.some(f=>g(c,f,o)));return this.inverse?!a:a}toString(){return`Array${this.inverse?"Not":""}Containing`}getExpectedType(){return"array"}}class re extends T{constructor(t){if(typeof t>"u")throw new TypeError("any() expects to be passed a constructor function. Please pass one or use anything() to match any object.");super(t)}fnNameFor(t){if(t.name)return t.name;const a=Function.prototype.toString.call(t).match(/^(?:async)?\s*function\s*(?:\*\s*)?([\w$]+)\s*\(/);return a?a[1]:"<anonymous>"}asymmetricMatch(t){return this.sample===String?typeof t=="string"||t instanceof String:this.sample===Number?typeof t=="number"||t instanceof Number:this.sample===Function?typeof t=="function"||typeof t=="function":this.sample===Boolean?typeof t=="boolean"||t instanceof Boolean:this.sample===BigInt?typeof t=="bigint"||t instanceof BigInt:this.sample===Symbol?typeof t=="symbol"||t instanceof Symbol:this.sample===Object?typeof t=="object":t instanceof this.sample}toString(){return"Any"}getExpectedType(){return this.sample===String?"string":this.sample===Number?"number":this.sample===Function?"function":this.sample===Object?"object":this.sample===Boolean?"boolean":this.fnNameFor(this.sample)}toAsymmetricMatcher(){return`Any<${this.fnNameFor(this.sample)}>`}}class st extends T{constructor(t,o=!1){if(!x("String",t)&&!x("RegExp",t))throw new Error("Expected is not a String or a RegExp");super(new RegExp(t),o)}asymmetricMatch(t){const o=x("String",t)&&this.sample.test(t);return this.inverse?!o:o}toString(){return`String${this.inverse?"Not":""}Matching`}getExpectedType(){return"string"}}class it extends T{constructor(o,a=2,c=!1){if(!x("Number",o))throw new Error("Expected is not a Number");if(!x("Number",a))throw new Error("Precision is not a Number");super(o);q(this,"precision");this.inverse=c,this.precision=a}asymmetricMatch(o){if(!x("Number",o))return!1;let a=!1;return o===Number.POSITIVE_INFINITY&&this.sample===Number.POSITIVE_INFINITY||o===Number.NEGATIVE_INFINITY&&this.sample===Number.NEGATIVE_INFINITY?a=!0:a=Math.abs(this.sample-o)<10**-this.precision/2,this.inverse?!a:a}toString(){return`Number${this.inverse?"Not":""}CloseTo`}getExpectedType(){return"number"}toAsymmetricMatcher(){return[this.toString(),this.sample,`(${Qt("digit",this.precision)})`].join(" ")}}class at extends T{constructor(o,a=!1){if(!ee(o))throw new TypeError("SchemaMatching expected to receive a Standard Schema.");super(o,a);q(this,"result")}asymmetricMatch(o){const a=this.sample["~standard"].validate(o);if(a instanceof Promise)throw new TypeError("Async schema validation is not supported in asymmetric matchers.");this.result=a;const c=!this.result.issues||this.result.issues.length===0;return this.inverse?!c:c}toString(){return`Schema${this.inverse?"Not":""}Matching`}getExpectedType(){return"object"}toAsymmetricMatcher(){var o;const{utils:a}=this.getMatcherContext();return(((o=this.result)===null||o===void 0?void 0:o.issues)||[]).length>0?`${this.toString()} ${a.stringify(this.result,void 0,{printBasicPrototype:!1})}`:this.toString()}}const me=(e,t)=>{t.addMethod(e.expect,"anything",()=>new ne),t.addMethod(e.expect,"any",o=>new re(o)),t.addMethod(e.expect,"stringContaining",o=>new nt(o)),t.addMethod(e.expect,"objectContaining",o=>new rt(o)),t.addMethod(e.expect,"arrayContaining",o=>new ot(o)),t.addMethod(e.expect,"stringMatching",o=>new st(o)),t.addMethod(e.expect,"closeTo",(o,a)=>new it(o,a)),t.addMethod(e.expect,"schemaMatching",o=>new at(o)),e.expect.not={stringContaining:o=>new nt(o,!0),objectContaining:o=>new rt(o,!0),arrayContaining:o=>new ot(o,!0),stringMatching:o=>new st(o,!0),closeTo:(o,a)=>new it(o,a,!0),schemaMatching:o=>new at(o,!0)}};function ct(e,t,o){const a=e.flag(t,"negate")?"not.":"",c=`${e.flag(t,"_name")}(${o?"expected":""})`,f=e.flag(t,"promise");return`expect(actual)${f?`.${f}`:""}.${a}${c}`}function lt(e,t,o,a){const c=e;if(c&&t instanceof Promise){t=t.finally(()=>{if(!c.promises)return;const u=c.promises.indexOf(t);u!==-1&&c.promises.splice(u,1)}),c.promises||(c.promises=[]),c.promises.push(t);let f=!1;return c.onFinished??(c.onFinished=[]),c.onFinished.push(()=>{if(!f){var u;const m=(((u=globalThis.__vitest_worker__)===null||u===void 0?void 0:u.onFilterStackTrace)||(n=>n||""))(a.stack);console.warn([`Promise returned by \`${o}\` was not awaited. `,"Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ",`Please remember to await the assertion.
`,m].join(""))}}),{then(u,p){return f=!0,t.then(u,p)},catch(u){return t.catch(u)},finally(u){return t.finally(u)},[Symbol.toStringTag]:"Promise"}}return t}function ut(e,t){var o;e.result||(e.result={state:"fail"}),e.result.state="fail",(o=e.result).errors||(o.errors=[]),e.result.errors.push(St(t))}function vt(e,t,o){return function(...a){if(t!=="withTest"&&e.flag(this,"_name",t),!e.flag(this,"soft"))return o.apply(this,a);const c=e.flag(this,"vitest-test");if(!c)throw new Error("expect.soft() can only be used inside a test");try{const f=o.apply(this,a);return f&&typeof f=="object"&&typeof f.then=="function"?f.then(Ct,u=>{ut(c,u)}):f}catch(f){ut(c,f)}}}const ge=(e,t)=>{const{AssertionError:o}=e,a=G();function c(n,r){const s=i=>{const l=vt(t,i,r);t.addMethod(e.Assertion.prototype,i,l),t.addMethod(globalThis[P].matchers,i,l)};Array.isArray(n)?n.forEach(i=>s(i)):s(n)}["throw","throws","Throw"].forEach(n=>{t.overwriteMethod(e.Assertion.prototype,n,r=>function(...s){const i=t.flag(this,"promise"),l=t.flag(this,"object"),h=t.flag(this,"negate");if(i==="rejects")t.flag(this,"object",()=>{throw l});else if(i==="resolves"&&typeof l!="function"){if(h)return;{const d=t.flag(this,"message")||"expected promise to throw an error, but it didn't",y={showDiff:!1};throw new o(d,y,t.flag(this,"ssfi"))}}r.apply(this,s)})}),c("withTest",function(n){return t.flag(this,"vitest-test",n),this}),c("toEqual",function(n){const r=t.flag(this,"object"),s=g(r,n,[...a,v]);return this.assert(s,"expected #{this} to deeply equal #{exp}","expected #{this} to not deeply equal #{exp}",n,r)}),c("toStrictEqual",function(n){const r=t.flag(this,"object"),s=g(r,n,[...a,v,tt,U,et],!0);return this.assert(s,"expected #{this} to strictly equal #{exp}","expected #{this} to not strictly equal #{exp}",n,r)}),c("toBe",function(n){const r=this._obj,s=Object.is(r,n);let i="";return s||(g(r,n,[...a,v,tt,U,et],!0)?i="toStrictEqual":g(r,n,[...a,v])&&(i="toEqual")),this.assert(s,Zt(i),"expected #{this} not to be #{exp} // Object.is equality",n,r)}),c("toMatchObject",function(n){const r=this._obj,s=g(r,n,[...a,v,R]),i=t.flag(this,"negate"),{subset:l,stripped:h}=te(r,n,a);if(s&&i||!s&&!i){const d=t.getMessage(this,[s,"expected #{this} to match object #{exp}","expected #{this} to not match object #{exp}",n,l,!1]),y=h===0?d:`${d}
(${h} matching ${h===1?"property":"properties"} omitted from actual)`;throw new o(y,{showDiff:!0,expected:n,actual:l})}}),c("toMatch",function(n){const r=this._obj;if(typeof r!="string")throw new TypeError(`.toMatch() expects to receive a string, but got ${typeof r}`);return this.assert(typeof n=="string"?r.includes(n):r.match(n),"expected #{this} to match #{exp}","expected #{this} not to match #{exp}",n,r)}),c("toContain",function(n){const r=this._obj;if(typeof Node<"u"&&r instanceof Node){if(!(n instanceof Node))throw new TypeError(`toContain() expected a DOM node as the argument, but got ${typeof n}`);return this.assert(r.contains(n),"expected #{this} to contain element #{exp}","expected #{this} not to contain element #{exp}",n,r)}if(typeof DOMTokenList<"u"&&r instanceof DOMTokenList){N(n,"class name",["string"]);const i=t.flag(this,"negate")?r.value.replace(n,"").trim():`${r.value} ${n}`;return this.assert(r.contains(n),`expected "${r.value}" to contain "${n}"`,`expected "${r.value}" not to contain "${n}"`,i,r.value)}return typeof r=="string"&&typeof n=="string"?this.assert(r.includes(n),"expected #{this} to contain #{exp}","expected #{this} not to contain #{exp}",n,r):(r!=null&&typeof r!="string"&&t.flag(this,"object",Array.from(r)),this.contain(n))}),c("toContainEqual",function(n){const r=t.flag(this,"object"),s=Array.from(r).findIndex(i=>g(i,n,a));this.assert(s!==-1,"expected #{this} to deep equally contain #{exp}","expected #{this} to not deep equally contain #{exp}",n)}),c("toBeTruthy",function(){const n=t.flag(this,"object");this.assert(!!n,"expected #{this} to be truthy","expected #{this} to not be truthy",!0,n)}),c("toBeFalsy",function(){const n=t.flag(this,"object");this.assert(!n,"expected #{this} to be falsy","expected #{this} to not be falsy",!1,n)}),c("toBeGreaterThan",function(n){const r=this._obj;return N(r,"actual",["number","bigint"]),N(n,"expected",["number","bigint"]),this.assert(r>n,`expected ${r} to be greater than ${n}`,`expected ${r} to be not greater than ${n}`,n,r,!1)}),c("toBeGreaterThanOrEqual",function(n){const r=this._obj;return N(r,"actual",["number","bigint"]),N(n,"expected",["number","bigint"]),this.assert(r>=n,`expected ${r} to be greater than or equal to ${n}`,`expected ${r} to be not greater than or equal to ${n}`,n,r,!1)}),c("toBeLessThan",function(n){const r=this._obj;return N(r,"actual",["number","bigint"]),N(n,"expected",["number","bigint"]),this.assert(r<n,`expected ${r} to be less than ${n}`,`expected ${r} to be not less than ${n}`,n,r,!1)}),c("toBeLessThanOrEqual",function(n){const r=this._obj;return N(r,"actual",["number","bigint"]),N(n,"expected",["number","bigint"]),this.assert(r<=n,`expected ${r} to be less than or equal to ${n}`,`expected ${r} to be not less than or equal to ${n}`,n,r,!1)}),c("toBeNaN",function(){const n=t.flag(this,"object");this.assert(Number.isNaN(n),"expected #{this} to be NaN","expected #{this} not to be NaN",Number.NaN,n)}),c("toBeUndefined",function(){const n=t.flag(this,"object");this.assert(n===void 0,"expected #{this} to be undefined","expected #{this} not to be undefined",void 0,n)}),c("toBeNull",function(){const n=t.flag(this,"object");this.assert(n===null,"expected #{this} to be null","expected #{this} not to be null",null,n)}),c("toBeNullable",function(){const n=t.flag(this,"object");this.assert(n==null,"expected #{this} to be nullish","expected #{this} not to be nullish",null,n)}),c("toBeDefined",function(){const n=t.flag(this,"object");this.assert(typeof n<"u","expected #{this} to be defined","expected #{this} to be undefined",n)}),c("toBeTypeOf",function(n){const r=typeof this._obj,s=n===r;return this.assert(s,"expected #{this} to be type of #{exp}","expected #{this} not to be type of #{exp}",n,r)}),c("toBeInstanceOf",function(n){return this.instanceOf(n)}),c("toHaveLength",function(n){return this.have.length(n)}),c("toHaveProperty",function(...n){Array.isArray(n[0])&&(n[0]=n[0].map($=>String($).replace(/([.[\]])/g,"\\$1")).join("."));const r=this._obj,[s,i]=n,l=()=>Object.hasOwn(r,s)?{value:r[s],exists:!0}:t.getPathInfo(r,s),{value:h,exists:d}=l(),y=d&&(n.length===1||g(i,h,a)),b=n.length===1?"":` with value ${t.objDisplay(i)}`;return this.assert(y,`expected #{this} to have property "${s}"${b}`,`expected #{this} to not have property "${s}"${b}`,i,d?h:void 0)}),c("toBeCloseTo",function(n,r=2){const s=this._obj;let i=!1,l=0,h=0;return n===Number.POSITIVE_INFINITY&&s===Number.POSITIVE_INFINITY||n===Number.NEGATIVE_INFINITY&&s===Number.NEGATIVE_INFINITY?i=!0:(l=10**-r/2,h=Math.abs(s-n),i=h<l),this.assert(i,`expected #{this} to be close to #{exp}, received difference is ${h}, but expected ${l}`,`expected #{this} to not be close to #{exp}, received difference is ${h}, but expected ${l}`,n,s,!1)});function f(n){if(!V(n._obj))throw new TypeError(`${t.inspect(n._obj)} is not a spy or a call to a spy!`)}function u(n){return f(n),n._obj}c(["toHaveBeenCalledTimes","toBeCalledTimes"],function(n){const r=u(this),s=r.getMockName(),i=r.mock.calls.length;return this.assert(i===n,`expected "${s}" to be called #{exp} times, but got ${i} times`,`expected "${s}" to not be called #{exp} times`,n,i,!1)}),c("toHaveBeenCalledOnce",function(){const n=u(this),r=n.getMockName(),s=n.mock.calls.length;return this.assert(s===1,`expected "${r}" to be called once, but got ${s} times`,`expected "${r}" to not be called once`,1,s,!1)}),c(["toHaveBeenCalled","toBeCalled"],function(){const n=u(this),r=n.getMockName(),s=n.mock.calls.length,i=s>0,l=t.flag(this,"negate");let h=t.getMessage(this,[i,`expected "${r}" to be called at least once`,`expected "${r}" to not be called at all, but actually been called ${s} times`,!0,i]);if(i&&l&&(h=Y(n,h)),i&&l||!i&&!l)throw new o(h)});function p(n,r){return n.length===r.length&&n.every((s,i)=>g(s,r[i],[...a,v]))}c(["toHaveBeenCalledWith","toBeCalledWith"],function(...n){const r=u(this),s=r.getMockName(),i=r.mock.calls.some(d=>p(d,n)),l=t.flag(this,"negate"),h=t.getMessage(this,[i,`expected "${s}" to be called with arguments: #{exp}`,`expected "${s}" to not be called with arguments: #{exp}`,n]);if(i&&l||!i&&!l)throw new o(Y(r,h,n))}),c("toHaveBeenCalledExactlyOnceWith",function(...n){const r=u(this),s=r.getMockName(),i=r.mock.calls.length,h=r.mock.calls.some(b=>p(b,n))&&i===1,d=t.flag(this,"negate"),y=t.getMessage(this,[h,`expected "${s}" to be called once with arguments: #{exp}`,`expected "${s}" to not be called once with arguments: #{exp}`,n]);if(h&&d||!h&&!d)throw new o(Y(r,y,n))}),c(["toHaveBeenNthCalledWith","nthCalledWith"],function(n,...r){const s=u(this),i=s.getMockName(),l=s.mock.calls[n-1],h=s.mock.calls.length,d=n<=h;this.assert(l&&p(l,r),`expected ${I(n)} "${i}" call to have been called with #{exp}${d?"":`, but called only ${h} times`}`,`expected ${I(n)} "${i}" call to not have been called with #{exp}`,r,l,d)}),c(["toHaveBeenLastCalledWith","lastCalledWith"],function(...n){const r=u(this),s=r.getMockName(),i=r.mock.calls.at(-1);this.assert(i&&p(i,n),`expected last "${s}" call to have been called with #{exp}`,`expected last "${s}" call to not have been called with #{exp}`,n,i)});function m(n,r,s){const i=n.mock.invocationCallOrder,l=r.mock.invocationCallOrder;return i.length===0?!s:l.length===0?!1:i[0]<l[0]}c(["toHaveBeenCalledBefore"],function(n,r=!0){const s=u(this);if(!V(n))throw new TypeError(`${t.inspect(n)} is not a spy or a call to a spy`);this.assert(m(s,n,r),`expected "${s.getMockName()}" to have been called before "${n.getMockName()}"`,`expected "${s.getMockName()}" to not have been called before "${n.getMockName()}"`,n,s)}),c(["toHaveBeenCalledAfter"],function(n,r=!0){const s=u(this);if(!V(n))throw new TypeError(`${t.inspect(n)} is not a spy or a call to a spy`);this.assert(m(n,s,r),`expected "${s.getMockName()}" to have been called after "${n.getMockName()}"`,`expected "${s.getMockName()}" to not have been called after "${n.getMockName()}"`,n,s)}),c(["toThrow","toThrowError"],function(n){if(typeof n=="string"||typeof n>"u"||n instanceof RegExp)return this.throws(n===""?/^$/:n);const r=this._obj,s=t.flag(this,"promise"),i=t.flag(this,"negate");let l=null;if(s==="rejects")l=r;else if(s==="resolves"&&typeof r!="function"){if(i)return;{const h=t.flag(this,"message")||"expected promise to throw an error, but it didn't",d={showDiff:!1};throw new o(h,d,t.flag(this,"ssfi"))}}else{let h=!1;try{r()}catch(d){h=!0,l=d}if(!h&&!i){const d=t.flag(this,"message")||"expected function to throw an error, but it didn't",y={showDiff:!1};throw new o(d,y,t.flag(this,"ssfi"))}}if(typeof n=="function"){const h=n.name||n.prototype.constructor.name;return this.assert(l&&l instanceof n,`expected error to be instance of ${h}`,`expected error not to be instance of ${h}`,n,l)}if(n instanceof Error){const h=g(l,n,[...a,v]);return this.assert(h,"expected a thrown error to be #{exp}","expected a thrown error not to be #{exp}",n,l)}if(typeof n=="object"&&"asymmetricMatch"in n&&typeof n.asymmetricMatch=="function"){const h=n;return this.assert(l&&h.asymmetricMatch(l),"expected error to match asymmetric matcher","expected error not to match asymmetric matcher",h,l)}throw new Error(`"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "${typeof n}"`)}),[{name:"toHaveResolved",condition:n=>n.mock.settledResults.length>0&&n.mock.settledResults.some(({type:r})=>r==="fulfilled"),action:"resolved"},{name:["toHaveReturned","toReturn"],condition:n=>n.mock.calls.length>0&&n.mock.results.some(({type:r})=>r!=="throw"),action:"called"}].forEach(({name:n,condition:r,action:s})=>{c(n,function(){const i=u(this),l=i.getMockName(),h=r(i);this.assert(h,`expected "${l}" to be successfully ${s} at least once`,`expected "${l}" to not be successfully ${s}`,h,!h,!1)})}),[{name:"toHaveResolvedTimes",condition:(n,r)=>n.mock.settledResults.reduce((s,{type:i})=>i==="fulfilled"?++s:s,0)===r,action:"resolved"},{name:["toHaveReturnedTimes","toReturnTimes"],condition:(n,r)=>n.mock.results.reduce((s,{type:i})=>i==="throw"?s:++s,0)===r,action:"called"}].forEach(({name:n,condition:r,action:s})=>{c(n,function(i){const l=u(this),h=l.getMockName(),d=r(l,i);this.assert(d,`expected "${h}" to be successfully ${s} ${i} times`,`expected "${h}" to not be successfully ${s} ${i} times`,`expected resolved times: ${i}`,`received resolved times: ${d}`,!1)})}),[{name:"toHaveResolvedWith",condition:(n,r)=>n.mock.settledResults.some(({type:s,value:i})=>s==="fulfilled"&&g(r,i)),action:"resolve"},{name:["toHaveReturnedWith","toReturnWith"],condition:(n,r)=>n.mock.results.some(({type:s,value:i})=>s==="return"&&g(r,i)),action:"return"}].forEach(({name:n,condition:r,action:s})=>{c(n,function(i){const l=u(this),h=r(l,i),d=t.flag(this,"negate");if(h&&d||!h&&!d){const y=l.getMockName(),b=t.getMessage(this,[h,`expected "${y}" to ${s} with: #{exp} at least once`,`expected "${y}" to not ${s} with: #{exp}`,i]),$=s==="return"?l.mock.results:l.mock.settledResults;throw new o(oe(l,$,b,i))}})}),[{name:"toHaveLastResolvedWith",condition:(n,r)=>{const s=n.mock.settledResults.at(-1);return!!(s&&s.type==="fulfilled"&&g(s.value,r))},action:"resolve"},{name:["toHaveLastReturnedWith","lastReturnedWith"],condition:(n,r)=>{const s=n.mock.results.at(-1);return!!(s&&s.type==="return"&&g(s.value,r))},action:"return"}].forEach(({name:n,condition:r,action:s})=>{c(n,function(i){const l=u(this),d=(s==="return"?l.mock.results:l.mock.settledResults).at(-1),y=l.getMockName();this.assert(r(l,i),`expected last "${y}" call to ${s} #{exp}`,`expected last "${y}" call to not ${s} #{exp}`,i,d==null?void 0:d.value)})}),[{name:"toHaveNthResolvedWith",condition:(n,r,s)=>{const i=n.mock.settledResults[r-1];return i&&i.type==="fulfilled"&&g(i.value,s)},action:"resolve"},{name:["toHaveNthReturnedWith","nthReturnedWith"],condition:(n,r,s)=>{const i=n.mock.results[r-1];return i&&i.type==="return"&&g(i.value,s)},action:"return"}].forEach(({name:n,condition:r,action:s})=>{c(n,function(i,l){const h=u(this),d=h.getMockName(),b=(s==="return"?h.mock.results:h.mock.settledResults)[i-1],$=`${I(i)} call`;this.assert(r(h,i,l),`expected ${$} "${d}" call to ${s} #{exp}`,`expected ${$} "${d}" call to not ${s} #{exp}`,l,b==null?void 0:b.value)})}),c("withContext",function(n){for(const r in n)t.flag(this,r,n[r]);return this}),t.addProperty(e.Assertion.prototype,"resolves",function(){const r=new Error("resolves");t.flag(this,"promise","resolves"),t.flag(this,"error",r);const s=t.flag(this,"vitest-test"),i=t.flag(this,"object");if(t.flag(this,"poll"))throw new SyntaxError("expect.poll() is not supported in combination with .resolves");if(typeof(i==null?void 0:i.then)!="function")throw new TypeError(`You must provide a Promise to expect() when using .resolves, not '${typeof i}'.`);const l=new Proxy(this,{get:(h,d,y)=>{const b=Reflect.get(h,d,y);return typeof b!="function"?b instanceof e.Assertion?l:b:(...$)=>{t.flag(this,"_name",d);const C=i.then(O=>(t.flag(this,"object",O),b.call(this,...$)),O=>{const w=new o(`promise rejected "${t.inspect(O)}" instead of resolving`,{showDiff:!1});throw w.cause=O,w.stack=r.stack.replace(r.message,w.message),w});return lt(s,C,ct(t,this,!!$.length),r)}}});return l}),t.addProperty(e.Assertion.prototype,"rejects",function(){const r=new Error("rejects");t.flag(this,"promise","rejects"),t.flag(this,"error",r);const s=t.flag(this,"vitest-test"),i=t.flag(this,"object"),l=typeof i=="function"?i():i;if(t.flag(this,"poll"))throw new SyntaxError("expect.poll() is not supported in combination with .rejects");if(typeof(l==null?void 0:l.then)!="function")throw new TypeError(`You must provide a Promise to expect() when using .rejects, not '${typeof l}'.`);const h=new Proxy(this,{get:(d,y,b)=>{const $=Reflect.get(d,y,b);return typeof $!="function"?$ instanceof e.Assertion?h:$:(...C)=>{t.flag(this,"_name",y);const O=l.then(w=>{const _=new o(`promise resolved "${t.inspect(w)}" instead of rejecting`,{showDiff:!0,expected:new Error("rejected promise"),actual:w});throw _.stack=r.stack.replace(r.message,_.message),_},w=>(t.flag(this,"object",w),$.call(this,...C)));return lt(s,O,ct(t,this,!!C.length),r)}}});return h})};function I(e){const t=e%10,o=e%100;return t===1&&o!==11?`${e}st`:t===2&&o!==12?`${e}nd`:t===3&&o!==13?`${e}rd`:`${e}th`}function Y(e,t,o){return e.mock.calls.length&&(t+=E.gray(`

Received: 

${e.mock.calls.map((a,c)=>{let f=E.bold(`  ${I(c+1)} ${e.getMockName()} call:

`);return o?f+=B(o,a,{omitAnnotationLines:!0}):f+=j(a).split(`
`).map(u=>`    ${u}`).join(`
`),f+=`
`,f}).join(`
`)}`)),t+=E.gray(`

Number of calls: ${E.bold(e.mock.calls.length)}
`),t}function oe(e,t,o,a){return t.length&&(o+=E.gray(`

Received: 

${t.map((c,f)=>{let u=E.bold(`  ${I(f+1)} ${e.getMockName()} call return:

`);return a?u+=B(a,c.value,{omitAnnotationLines:!0}):u+=j(c).split(`
`).map(p=>`    ${p}`).join(`
`),u+=`
`,u}).join(`
`)}`)),o+=E.gray(`

Number of calls: ${E.bold(e.mock.calls.length)}
`),o}function se(e,t){const o=e._obj,a=S.flag(e,"negate"),c=S.flag(e,"promise")||"",f=S.flag(e,"message"),u={...gt(),diff:B,stringify:j,iterableEquality:v,subsetEquality:R};let p=S.flag(e,"vitest-test");const m=(p==null?void 0:p.fullTestName)??"";return(p==null?void 0:p.type)!=="test"&&(p=void 0),{state:{...wt(t),task:p,currentTestName:m,customTesters:G(),isNot:a,utils:u,promise:c,equals:g,suppressedErrors:[],soft:S.flag(e,"soft"),poll:S.flag(e,"poll")},isNot:a,obj:o,customMessage:f}}class ft extends Error{constructor(t,o,a){super(t),this.actual=o,this.expected=a}}function ie(e,t,o){return(a,c)=>{Object.entries(o).forEach(([f,u])=>{function p(...s){const{state:i,isNot:l,obj:h,customMessage:d}=se(this,t),y=u.call(i,h,...s);if(y&&typeof y=="object"&&typeof y.then=="function")return y.then(({pass:_,message:xt,actual:Tt,expected:Nt})=>{if(_&&l||!_&&!l){const Ot=d??xt();throw new ft(Ot,Tt,Nt)}});const{pass:b,message:$,actual:C,expected:O}=y;if(b&&l||!b&&!l){const w=d??$();throw new ft(w,C,O)}}const m=vt(c,f,p);c.addMethod(globalThis[P].matchers,f,m),c.addMethod(e.Assertion.prototype,f,m);class n extends T{constructor(i=!1,...l){super(l,i)}asymmetricMatch(i){const{pass:l}=u.call(this.getMatcherContext(t),i,...this.sample);return this.inverse?!l:l}toString(){return`${this.inverse?"not.":""}${f}`}getExpectedType(){return"any"}toAsymmetricMatcher(){return`${this.toString()}<${this.sample.map(i=>j(i)).join(", ")}>`}}const r=(...s)=>new n(!1,...s);Object.defineProperty(t,f,{configurable:!0,enumerable:!0,value:r,writable:!0}),Object.defineProperty(t.not,f,{configurable:!0,enumerable:!0,value:(...s)=>new n(!0,...s),writable:!0}),Object.defineProperty(globalThis[dt],f,{configurable:!0,enumerable:!0,value:r,writable:!0})})}}const ye=(e,t)=>{t.addMethod(e.expect,"extend",(o,a)=>{At(ie(e,o,a))})};export{dt as A,pt as G,ye as J,pe as a,ge as b,he as c,me as d,g as e,R as f,wt as g,v as i,de as s};
//# sourceMappingURL=vitest_expect-C1eZKgQp.js.map
