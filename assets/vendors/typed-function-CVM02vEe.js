function ht(){return!0}function $(){return!1}function oe(){}const mt="Argument is not a typed-function.";function yt(){function Te(n){return typeof n=="object"&&n!==null&&n.constructor===Object}const pt=[{name:"number",test:function(n){return typeof n=="number"}},{name:"string",test:function(n){return typeof n=="string"}},{name:"boolean",test:function(n){return typeof n=="boolean"}},{name:"Function",test:function(n){return typeof n=="function"}},{name:"Array",test:Array.isArray},{name:"Date",test:function(n){return n instanceof Date}},{name:"RegExp",test:function(n){return n instanceof RegExp}},{name:"Object",test:Te},{name:"null",test:function(n){return n===null}},{name:"undefined",test:function(n){return n===void 0}}],se={name:"any",test:ht,isAny:!0};let b,j,H=0,w={createCount:0};function I(n){const o=b.get(n);if(o)return o;let i='Unknown type "'+n+'"';const f=n.toLowerCase();let m;for(m of j)if(m.toLowerCase()===f){i+='. Did you mean "'+m+'" ?';break}throw new TypeError(i)}function Z(n){let o=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"any";const i=o?I(o).index:j.length,f=[];for(let u=0;u<n.length;++u){if(!n[u]||typeof n[u].name!="string"||typeof n[u].test!="function")throw new TypeError("Object with properties {name: string, test: function} expected");const y=n[u].name;if(b.has(y))throw new TypeError('Duplicate type name "'+y+'"');f.push(y),b.set(y,{name:y,test:n[u].test,isAny:n[u].isAny,index:i+u,conversionsTo:[]})}const m=j.slice(i);j=j.slice(0,i).concat(f).concat(m);for(let u=i+f.length;u<j.length;++u)b.get(j[u]).index=u}function ve(){b=new Map,j=[],H=0,Z([se],!1)}ve(),Z(pt);function De(){let n;for(n of j)b.get(n).conversionsTo=[];H=0}function q(n){const o=j.filter(i=>{const f=b.get(i);return!f.isAny&&f.test(n)});return o.length?o:["any"]}function D(n){return n&&typeof n=="function"&&"_typedFunctionData"in n}function J(n,o,i){if(!D(n))throw new TypeError(mt);const f=i&&i.exact,m=Array.isArray(o)?o.join(","):o,u=B(m),y=Y(u);if(!f||y in n.signatures){const r=n._typedFunctionData.signatureMap.get(y);if(r)return r}const g=u.length;let e;if(f){e=[];let r;for(r in n.signatures)e.push(n._typedFunctionData.signatureMap.get(r))}else e=n._typedFunctionData.signatures;for(let r=0;r<g;++r){const s=u[r],a=[];let c;for(c of e){const h=z(c.params,r);if(!(!h||s.restParam&&!h.restParam)){if(!h.hasAny){const p=ie(h);if(s.types.some(d=>!p.has(d.name)))continue}a.push(c)}}if(e=a,e.length===0)break}let t;for(t of e)if(t.params.length<=g)return t;throw new TypeError("Signature not found (signature: "+(n.name||"unnamed")+"("+Y(u,", ")+"))")}function x(n,o,i){return J(n,o,i).implementation}function M(n,o){const i=I(o);if(i.test(n))return n;const f=i.conversionsTo;if(f.length===0)throw new Error("There are no conversions to "+o+" defined.");for(let m=0;m<f.length;m++)if(I(f[m].from).test(n))return f[m].convert(n);throw new Error("Cannot convert "+n+" to "+o)}function Y(n){let o=arguments.length>1&&arguments[1]!==void 0?arguments[1]:",";return n.map(i=>i.name).join(o)}function we(n){const o=n.indexOf("...")===0,f=(o?n.length>3?n.slice(3):"any":n).split("|").map(g=>I(g.trim()));let m=!1,u=o?"...":"";return{types:f.map(function(g){return m=g.isAny||m,u+=g.name+"|",{name:g.name,typeIndex:g.index,test:g.test,isAny:g.isAny,conversion:null,conversionIndex:-1}}),name:u.slice(0,-1),hasAny:m,hasConversion:!1,restParam:o}}function Ie(n){const o=n.types.map(y=>y.name),i=ue(o);let f=n.hasAny,m=n.name;const u=i.map(function(y){const g=I(y.from);return f=g.isAny||f,m+="|"+y.from,{name:y.from,typeIndex:g.index,test:g.test,isAny:g.isAny,conversion:y,conversionIndex:y.index}});return{types:n.types.concat(u),name:m,hasAny:f,hasConversion:u.length>0,restParam:n.restParam}}function ie(n){return n.typeSet||(n.typeSet=new Set,n.types.forEach(o=>n.typeSet.add(o.name))),n.typeSet}function B(n){const o=[];if(typeof n!="string")throw new TypeError("Signatures must be strings");const i=n.trim();if(i==="")return o;const f=i.split(",");for(let m=0;m<f.length;++m){const u=we(f[m].trim());if(u.restParam&&m!==f.length-1)throw new SyntaxError('Unexpected rest parameter "'+f[m]+'": only allowed for the last parameter');if(u.types.length===0)return null;o.push(u)}return o}function k(n){const o=K(n);return o?o.restParam:!1}function S(n){if(!n||n.types.length===0)return ht;if(n.types.length===1)return I(n.types[0].name).test;if(n.types.length===2){const o=I(n.types[0].name).test,i=I(n.types[1].name).test;return function(m){return o(m)||i(m)}}else{const o=n.types.map(function(i){return I(i.name).test});return function(f){for(let m=0;m<o.length;m++)if(o[m](f))return!0;return!1}}}function Me(n){let o,i,f;if(k(n)){o=ke(n).map(S);const m=o.length,u=S(K(n)),y=function(g){for(let e=m;e<g.length;e++)if(!u(g[e]))return!1;return!0};return function(e){for(let t=0;t<o.length;t++)if(!o[t](e[t]))return!1;return y(e)&&e.length>=m+1}}else return n.length===0?function(u){return u.length===0}:n.length===1?(i=S(n[0]),function(u){return i(u[0])&&u.length===1}):n.length===2?(i=S(n[0]),f=S(n[1]),function(u){return i(u[0])&&f(u[1])&&u.length===2}):(o=n.map(S),function(u){for(let y=0;y<o.length;y++)if(!o[y](u[y]))return!1;return u.length===o.length})}function z(n,o){return o<n.length?n[o]:k(n)?K(n):null}function ce(n,o){const i=z(n,o);return i?ie(i):new Set}function xe(n){return n.conversion===null||n.conversion===void 0}function fe(n,o){const i=new Set;return n.forEach(f=>{const m=ce(f.params,o);let u;for(u of m)i.add(u)}),i.has("any")?["any"]:Array.from(i)}function ee(n,o,i){let f,m;const u=n||"unnamed";let y=i,g;for(g=0;g<o.length;g++){const s=[];if(y.forEach(a=>{const c=z(a.params,g),h=S(c);(g<a.params.length||k(a.params))&&h(o[g])&&s.push(a)}),s.length===0){if(m=fe(y,g),m.length>0){const a=q(o[g]);return f=new TypeError("Unexpected type of argument in function "+u+" (expected: "+m.join(" or ")+", actual: "+a.join(" | ")+", index: "+g+")"),f.data={category:"wrongType",fn:u,index:g,actual:a,expected:m},f}}else y=s}const e=y.map(function(s){return k(s.params)?1/0:s.params.length});if(o.length<Math.min.apply(null,e))return m=fe(y,g),f=new TypeError("Too few arguments in function "+u+" (expected: "+m.join(" or ")+", index: "+o.length+")"),f.data={category:"tooFewArgs",fn:u,index:o.length,expected:m},f;const t=Math.max.apply(null,e);if(o.length>t)return f=new TypeError("Too many arguments in function "+u+" (expected: "+t+", actual: "+o.length+")"),f.data={category:"tooManyArgs",fn:u,index:o.length,expectedLength:t},f;const r=[];for(let s=0;s<o.length;++s)r.push(q(o[s]).join("|"));return f=new TypeError('Arguments of type "'+r.join(", ")+'" do not match any of the defined signatures of function '+u+"."),f.data={category:"mismatch",actual:r},f}function O(n){let o=j.length+1;for(let i=0;i<n.types.length;i++)o=Math.min(o,n.types[i].typeIndex);return o}function P(n){let o=H+1;for(let i=0;i<n.types.length;i++)xe(n.types[i])||(o=Math.min(o,n.types[i].conversionIndex));return o}function _e(n,o){if(n.hasAny){if(!o.hasAny)return .1}else if(o.hasAny)return-.1;if(n.restParam){if(!o.restParam)return .01}else if(o.restParam)return-.01;const i=O(n)-O(o);if(i<0)return-.001;if(i>0)return .001;const f=P(n),m=P(o);if(n.hasConversion){if(!o.hasConversion)return(1+f)*1e-6}else if(o.hasConversion)return-(1+m)*1e-6;const u=f-m;return u<0?-1e-7:u>0?1e-7:0}function ae(n,o){const i=n.params,f=o.params,m=K(i),u=K(f),y=k(i),g=k(f);if(y&&m.hasAny){if(!g||!u.hasAny)return 1e7}else if(g&&u.hasAny)return-1e7;let e=0,t=0,r;for(r of i)r.hasAny&&++e,r.hasConversion&&++t;let s=0,a=0;for(r of f)r.hasAny&&++s,r.hasConversion&&++a;if(e!==s)return(e-s)*1e6;if(y&&m.hasConversion){if(!g||!u.hasConversion)return 1e5}else if(g&&u.hasConversion)return-1e5;if(t!==a)return(t-a)*1e4;if(y){if(!g)return 1e3}else if(g)return-1e3;const c=(i.length-f.length)*(y?-100:100);if(c!==0)return c;const h=[];let p=0;for(let v=0;v<i.length;++v){const E=_e(i[v],f[v]);h.push(E),p+=E}if(p!==0)return(p<0?-10:10)+p;let d,l=9;const T=l/(h.length+1);for(d of h){if(d!==0)return(d<0?-l:l)+d;l-=T}return 0}function ue(n){if(n.length===0)return[];const o=n.map(I);if(n.length===1)return o[0].conversionsTo;const i=new Set(n),f=new Set;for(let u=0;u<o.length;++u)for(const y of o[u].conversionsTo)i.has(y.from)||f.add(y.from);const m=[];for(const u of f){let y=H+1,g=null;for(let e=0;e<o.length;++e)for(const t of o[e].conversionsTo)t.from===u&&t.index<y&&(y=t.index,g=t);m.push(g)}return m}function Ae(n,o){let i=o,f="";if(n.some(u=>u.hasConversion)){const u=k(n),y=n.map(Ce);f=y.map(g=>g.name).join(";"),i=function(){const e=[],t=u?arguments.length-1:arguments.length;for(let r=0;r<t;r++)e[r]=y[r](arguments[r]);return u&&(e[t]=arguments[t].map(y[t])),o.apply(this,e)}}let m=i;if(k(n)){const u=n.length-1;m=function(){return i.apply(this,le(arguments,0,u).concat([le(arguments,u)]))}}return f&&Object.defineProperty(m,"name",{value:f}),m}function Ce(n){let o,i,f,m;const u=[],y=[];let g="";n.types.forEach(function(t){t.conversion&&(g+=t.conversion.from+"~>"+t.conversion.to+",",u.push(I(t.conversion.from).test),y.push(t.conversion.convert))}),g?g=g.slice(0,-1):g="pass";let e=t=>t;switch(y.length){case 0:break;case 1:o=u[0],f=y[0],e=function(r){return o(r)?f(r):r};break;case 2:o=u[0],i=u[1],f=y[0],m=y[1],e=function(r){return o(r)?f(r):i(r)?m(r):r};break;default:e=function(r){for(let s=0;s<y.length;s++)if(u[s](r))return y[s](r);return r}}return Object.defineProperty(e,"name",{value:g}),e}function Ee(n){function o(i,f,m){if(f<i.length){const u=i[f];let y=[];if(u.restParam){const g=u.types.filter(xe);g.length<u.types.length&&y.push({types:g,name:"..."+g.map(e=>e.name).join("|"),hasAny:g.some(e=>e.isAny),hasConversion:!1,restParam:!0}),y.push(u)}else y=u.types.map(function(g){return{types:[g],name:g.name,hasAny:g.isAny,hasConversion:g.conversion,restParam:!1}});return qe(y,function(g){return o(i,f+1,m.concat([g]))})}else return[m]}return o(n,0,[])}function be(n,o){const i=Math.max(n.length,o.length);for(let g=0;g<i;g++){const e=ce(n,g),t=ce(o,g);let r=!1,s;for(s of t)if(e.has(s)){r=!0;break}if(!r)return!1}const f=n.length,m=o.length,u=k(n),y=k(o);return u?y?f===m:m>=f:y?f>=m:f===m}function Pe(n){return n.map(o=>G(o)?pe(o.referToSelf.callback):he(o)?Oe(o.referTo.references,o.referTo.callback):o)}function Fe(n,o,i){const f=[];let m;for(m of n){let u=i[m];if(typeof u!="number")throw new TypeError('No definition for referenced signature "'+m+'"');if(u=o[u],typeof u!="function")return!1;f.push(u)}return f}function Le(n,o,i){const f=Pe(n),m=new Array(f.length).fill(!1);let u=!0;for(;u;){u=!1;let y=!0;for(let g=0;g<f.length;++g){if(m[g])continue;const e=f[g];if(G(e))f[g]=e.referToSelf.callback(i),f[g].referToSelf=e.referToSelf,m[g]=!0,y=!1;else if(he(e)){const t=Fe(e.referTo.references,f,o);t?(f[g]=e.referTo.callback.apply(this,t),f[g].referTo=e.referTo,m[g]=!0,y=!1):u=!0}}if(y&&u)throw new SyntaxError("Circular reference detected in resolving typed.referTo")}return f}function Ue(n){const o=/\bthis(\(|\.signatures\b)/;Object.keys(n).forEach(i=>{const f=n[i];if(o.test(f.toString()))throw new SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.")})}function Ne(n,o){if(w.createCount++,Object.keys(o).length===0)throw new SyntaxError("No signatures provided");w.warnAgainstDeprecatedThis&&Ue(o);const i=[],f=[],m={},u=[];let y;for(y in o){if(!Object.prototype.hasOwnProperty.call(o,y))continue;const A=B(y);if(!A)continue;i.forEach(function(X){if(be(X,A))throw new TypeError('Conflicting signatures "'+Y(X)+'" and "'+Y(A)+'".')}),i.push(A);const F=f.length;f.push(o[y]);const ut=A.map(Ie);let re;for(re of Ee(ut)){const X=Y(re);u.push({params:re,name:X,fn:F}),re.every(lt=>!lt.hasConversion)&&(m[X]=F)}}u.sort(ae);const g=Le(f,m,W);let e;for(e in m)Object.prototype.hasOwnProperty.call(m,e)&&(m[e]=g[m[e]]);const t=[],r=new Map;for(e of u)r.has(e.name)||(e.fn=g[e.fn],t.push(e),r.set(e.name,e));const s=t[0]&&t[0].params.length<=2&&!k(t[0].params),a=t[1]&&t[1].params.length<=2&&!k(t[1].params),c=t[2]&&t[2].params.length<=2&&!k(t[2].params),h=t[3]&&t[3].params.length<=2&&!k(t[3].params),p=t[4]&&t[4].params.length<=2&&!k(t[4].params),d=t[5]&&t[5].params.length<=2&&!k(t[5].params),l=s&&a&&c&&h&&p&&d;for(let A=0;A<t.length;++A)t[A].test=Me(t[A].params);const T=s?S(t[0].params[0]):$,v=a?S(t[1].params[0]):$,E=c?S(t[2].params[0]):$,_=h?S(t[3].params[0]):$,R=p?S(t[4].params[0]):$,L=d?S(t[5].params[0]):$,U=s?S(t[0].params[1]):$,Q=a?S(t[1].params[1]):$,ge=c?S(t[2].params[1]):$,V=h?S(t[3].params[1]):$,ne=p?S(t[4].params[1]):$,He=d?S(t[5].params[1]):$;for(let A=0;A<t.length;++A)t[A].implementation=Ae(t[A].params,t[A].fn);const Je=s?t[0].implementation:oe,Ke=a?t[1].implementation:oe,Qe=c?t[2].implementation:oe,Ve=h?t[3].implementation:oe,We=p?t[4].implementation:oe,Xe=d?t[5].implementation:oe,Ze=s?t[0].params.length:-1,et=a?t[1].params.length:-1,tt=c?t[2].params.length:-1,nt=h?t[3].params.length:-1,rt=p?t[4].params.length:-1,ot=d?t[5].params.length:-1,st=l?6:0,it=t.length,ct=t.map(A=>A.test),ft=t.map(A=>A.implementation),at=function(){for(let F=st;F<it;F++)if(ct[F](arguments))return ft[F].apply(this,arguments);return w.onMismatch(n,arguments,t)};function W(A,F){return arguments.length===Ze&&T(A)&&U(F)?Je.apply(this,arguments):arguments.length===et&&v(A)&&Q(F)?Ke.apply(this,arguments):arguments.length===tt&&E(A)&&ge(F)?Qe.apply(this,arguments):arguments.length===nt&&_(A)&&V(F)?Ve.apply(this,arguments):arguments.length===rt&&R(A)&&ne(F)?We.apply(this,arguments):arguments.length===ot&&L(A)&&He(F)?Xe.apply(this,arguments):at.apply(this,arguments)}try{Object.defineProperty(W,"name",{value:n})}catch{}return W.signatures=m,W._typedFunctionData={signatures:t,signatureMap:r},W}function Se(n,o,i){throw ee(n,o,i)}function ke(n){return le(n,0,n.length-1)}function K(n){return n[n.length-1]}function le(n,o,i){return Array.prototype.slice.call(n,o,i)}function $e(n,o){for(let i=0;i<n.length;i++)if(o(n[i]))return n[i]}function qe(n,o){return Array.prototype.concat.apply([],n.map(o))}function Ye(){const n=ke(arguments).map(i=>Y(B(i))),o=K(arguments);if(typeof o!="function")throw new TypeError("Callback function expected as last argument");return Oe(n,o)}function Oe(n,o){return{referTo:{references:n,callback:o}}}function pe(n){if(typeof n!="function")throw new TypeError("Callback function expected as first argument");return{referToSelf:{callback:n}}}function he(n){return n&&typeof n.referTo=="object"&&Array.isArray(n.referTo.references)&&typeof n.referTo.callback=="function"}function G(n){return n&&typeof n.referToSelf=="object"&&typeof n.referToSelf.callback=="function"}function te(n,o){if(!n)return o;if(o&&o!==n){const i=new Error("Function names do not match (expected: "+n+", actual: "+o+")");throw i.data={actual:o,expected:n},i}return n}function ze(n){let o;for(const i in n)Object.prototype.hasOwnProperty.call(n,i)&&(D(n[i])||typeof n[i].signature=="string")&&(o=te(o,n[i].name));return o}function Be(n,o){let i;for(i in o)if(Object.prototype.hasOwnProperty.call(o,i)){if(i in n&&o[i]!==n[i]){const f=new Error('Signature "'+i+'" is defined twice');throw f.data={signature:i,sourceFunction:o[i],destFunction:n[i]},f}n[i]=o[i]}}const Ge=w;w=function(n){const o=typeof n=="string",i=o?1:0;let f=o?n:"";const m={};for(let u=i;u<arguments.length;++u){const y=arguments[u];let g={},e;if(typeof y=="function"?(e=y.name,typeof y.signature=="string"?g[y.signature]=y:D(y)&&(g=y.signatures)):Te(y)&&(g=y,o||(e=ze(y))),Object.keys(g).length===0){const t=new TypeError("Argument to 'typed' at index "+u+" is not a (typed) function, nor an object with signatures as keys and functions as values.");throw t.data={index:u,argument:y},t}o||(f=te(f,e)),Be(m,g)}return Ne(f||"",m)},w.create=yt,w.createCount=Ge.createCount,w.onMismatch=Se,w.throwMismatchError=Se,w.createError=ee,w.clear=ve,w.clearConversions=De,w.addTypes=Z,w._findType=I,w.referTo=Ye,w.referToSelf=pe,w.convert=M,w.findSignature=J,w.find=x,w.isTypedFunction=D,w.warnAgainstDeprecatedThis=!0,w.addType=function(n,o){let i="any";o!==!1&&b.has("Object")&&(i="Object"),w.addTypes([n],i)};function me(n){if(!n||typeof n.from!="string"||typeof n.to!="string"||typeof n.convert!="function")throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");if(n.to===n.from)throw new SyntaxError('Illegal to define conversion from "'+n.from+'" to itself.')}return w.addConversion=function(n){let o=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{override:!1};me(n);const i=I(n.to),f=i.conversionsTo.find(m=>m.from===n.from);if(f)if(o&&o.override)w.removeConversion({from:f.from,to:n.to,convert:f.convert});else throw new Error('There is already a conversion from "'+n.from+'" to "'+i.name+'"');i.conversionsTo.push({from:n.from,to:i.name,convert:n.convert,index:H++})},w.addConversions=function(n,o){n.forEach(i=>w.addConversion(i,o))},w.removeConversion=function(n){me(n);const o=I(n.to),i=$e(o.conversionsTo,m=>m.from===n.from);if(!i)throw new Error("Attempt to remove nonexistent conversion from "+n.from+" to "+n.to);if(i.convert!==n.convert)throw new Error("Conversion to remove does not match existing conversion");const f=o.conversionsTo.indexOf(i);o.conversionsTo.splice(f,1)},w.resolve=function(n,o){if(!D(n))throw new TypeError(mt);const i=n._typedFunctionData.signatures;for(let f=0;f<i.length;++f)if(i[f].test(o))return i[f];return null},w}const xt=yt();var Re={exports:{}},wt=Re.exports,gt;function At(){return gt||(gt=1,(function(Te,pt){(function(se,b){Te.exports=b()})(wt,(function(){function se(){return!0}function b(){return!1}function j(){}const H="Argument is not a typed-function.";function w(){function Z(e){return typeof e=="object"&&e!==null&&e.constructor===Object}const ve=[{name:"number",test:function(e){return typeof e=="number"}},{name:"string",test:function(e){return typeof e=="string"}},{name:"boolean",test:function(e){return typeof e=="boolean"}},{name:"Function",test:function(e){return typeof e=="function"}},{name:"Array",test:Array.isArray},{name:"Date",test:function(e){return e instanceof Date}},{name:"RegExp",test:function(e){return e instanceof RegExp}},{name:"Object",test:Z},{name:"null",test:function(e){return e===null}},{name:"undefined",test:function(e){return e===void 0}}],De={name:"any",test:se,isAny:!0};let q,D,J=0,x={createCount:0};function M(e){const t=q.get(e);if(t)return t;let r='Unknown type "'+e+'"';const s=e.toLowerCase();let a;for(a of D)if(a.toLowerCase()===s){r+='. Did you mean "'+a+'" ?';break}throw new TypeError(r)}function Y(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"any";const r=t?M(t).index:D.length,s=[];for(let c=0;c<e.length;++c){if(!e[c]||typeof e[c].name!="string"||typeof e[c].test!="function")throw new TypeError("Object with properties {name: string, test: function} expected");const h=e[c].name;if(q.has(h))throw new TypeError('Duplicate type name "'+h+'"');s.push(h),q.set(h,{name:h,test:e[c].test,isAny:e[c].isAny,index:r+c,conversionsTo:[]})}const a=D.slice(r);D=D.slice(0,r).concat(s).concat(a);for(let c=r+s.length;c<D.length;++c)q.get(D[c]).index=c}function we(){q=new Map,D=[],J=0,Y([De],!1)}we(),Y(ve);function Ie(){let e;for(e of D)q.get(e).conversionsTo=[];J=0}function ie(e){const t=D.filter(r=>{const s=q.get(r);return!s.isAny&&s.test(e)});return t.length?t:["any"]}function B(e){return e&&typeof e=="function"&&"_typedFunctionData"in e}function k(e,t,r){if(!B(e))throw new TypeError(H);const s=r&&r.exact,a=Array.isArray(t)?t.join(","):t,c=ee(a),h=z(c);if(!s||h in e.signatures){const T=e._typedFunctionData.signatureMap.get(h);if(T)return T}const p=c.length;let d;if(s){d=[];let T;for(T in e.signatures)d.push(e._typedFunctionData.signatureMap.get(T))}else d=e._typedFunctionData.signatures;for(let T=0;T<p;++T){const v=c[T],E=[];let _;for(_ of d){const R=ae(_.params,T);if(!(!R||v.restParam&&!R.restParam)){if(!R.hasAny){const L=fe(R);if(v.types.some(U=>!L.has(U.name)))continue}E.push(_)}}if(d=E,d.length===0)break}let l;for(l of d)if(l.params.length<=p)return l;throw new TypeError("Signature not found (signature: "+(e.name||"unnamed")+"("+z(c,", ")+"))")}function S(e,t,r){return k(e,t,r).implementation}function Me(e,t){const r=M(t);if(r.test(e))return e;const s=r.conversionsTo;if(s.length===0)throw new Error("There are no conversions to "+t+" defined.");for(let a=0;a<s.length;a++)if(M(s[a].from).test(e))return s[a].convert(e);throw new Error("Cannot convert "+e+" to "+t)}function z(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:",";return e.map(r=>r.name).join(t)}function ce(e){const t=e.indexOf("...")===0,s=(t?e.length>3?e.slice(3):"any":e).split("|").map(p=>M(p.trim()));let a=!1,c=t?"...":"";return{types:s.map(function(p){return a=p.isAny||a,c+=p.name+"|",{name:p.name,typeIndex:p.index,test:p.test,isAny:p.isAny,conversion:null,conversionIndex:-1}}),name:c.slice(0,-1),hasAny:a,hasConversion:!1,restParam:t}}function xe(e){const t=e.types.map(h=>h.name),r=Ue(t);let s=e.hasAny,a=e.name;const c=r.map(function(h){const p=M(h.from);return s=p.isAny||s,a+="|"+h.from,{name:h.from,typeIndex:p.index,test:p.test,isAny:p.isAny,conversion:h,conversionIndex:h.index}});return{types:e.types.concat(c),name:a,hasAny:s,hasConversion:c.length>0,restParam:e.restParam}}function fe(e){return e.typeSet||(e.typeSet=new Set,e.types.forEach(t=>e.typeSet.add(t.name))),e.typeSet}function ee(e){const t=[];if(typeof e!="string")throw new TypeError("Signatures must be strings");const r=e.trim();if(r==="")return t;const s=r.split(",");for(let a=0;a<s.length;++a){const c=ce(s[a].trim());if(c.restParam&&a!==s.length-1)throw new SyntaxError('Unexpected rest parameter "'+s[a]+'": only allowed for the last parameter');if(c.types.length===0)return null;t.push(c)}return t}function O(e){const t=G(e);return t?t.restParam:!1}function P(e){if(!e||e.types.length===0)return se;if(e.types.length===1)return M(e.types[0].name).test;if(e.types.length===2){const t=M(e.types[0].name).test,r=M(e.types[1].name).test;return function(a){return t(a)||r(a)}}else{const t=e.types.map(function(r){return M(r.name).test});return function(s){for(let a=0;a<t.length;a++)if(t[a](s))return!0;return!1}}}function _e(e){let t,r,s;if(O(e)){t=he(e).map(P);const a=t.length,c=P(G(e)),h=function(p){for(let d=a;d<p.length;d++)if(!c(p[d]))return!1;return!0};return function(d){for(let l=0;l<t.length;l++)if(!t[l](d[l]))return!1;return h(d)&&d.length>=a+1}}else return e.length===0?function(c){return c.length===0}:e.length===1?(r=P(e[0]),function(c){return r(c[0])&&c.length===1}):e.length===2?(r=P(e[0]),s=P(e[1]),function(c){return r(c[0])&&s(c[1])&&c.length===2}):(t=e.map(P),function(c){for(let h=0;h<t.length;h++)if(!t[h](c[h]))return!1;return c.length===t.length})}function ae(e,t){return t<e.length?e[t]:O(e)?G(e):null}function ue(e,t){const r=ae(e,t);return r?fe(r):new Set}function Ae(e){return e.conversion===null||e.conversion===void 0}function Ce(e,t){const r=new Set;return e.forEach(s=>{const a=ue(s.params,t);let c;for(c of a)r.add(c)}),r.has("any")?["any"]:Array.from(r)}function Ee(e,t,r){let s,a;const c=e||"unnamed";let h=r,p;for(p=0;p<t.length;p++){const v=[];if(h.forEach(E=>{const _=ae(E.params,p),R=P(_);(p<E.params.length||O(E.params))&&R(t[p])&&v.push(E)}),v.length===0){if(a=Ce(h,p),a.length>0){const E=ie(t[p]);return s=new TypeError("Unexpected type of argument in function "+c+" (expected: "+a.join(" or ")+", actual: "+E.join(" | ")+", index: "+p+")"),s.data={category:"wrongType",fn:c,index:p,actual:E,expected:a},s}}else h=v}const d=h.map(function(v){return O(v.params)?1/0:v.params.length});if(t.length<Math.min.apply(null,d))return a=Ce(h,p),s=new TypeError("Too few arguments in function "+c+" (expected: "+a.join(" or ")+", index: "+t.length+")"),s.data={category:"tooFewArgs",fn:c,index:t.length,expected:a},s;const l=Math.max.apply(null,d);if(t.length>l)return s=new TypeError("Too many arguments in function "+c+" (expected: "+l+", actual: "+t.length+")"),s.data={category:"tooManyArgs",fn:c,index:t.length,expectedLength:l},s;const T=[];for(let v=0;v<t.length;++v)T.push(ie(t[v]).join("|"));return s=new TypeError('Arguments of type "'+T.join(", ")+'" do not match any of the defined signatures of function '+c+"."),s.data={category:"mismatch",actual:T},s}function be(e){let t=D.length+1;for(let r=0;r<e.types.length;r++)t=Math.min(t,e.types[r].typeIndex);return t}function Pe(e){let t=J+1;for(let r=0;r<e.types.length;r++)Ae(e.types[r])||(t=Math.min(t,e.types[r].conversionIndex));return t}function Fe(e,t){if(e.hasAny){if(!t.hasAny)return .1}else if(t.hasAny)return-.1;if(e.restParam){if(!t.restParam)return .01}else if(t.restParam)return-.01;const r=be(e)-be(t);if(r<0)return-.001;if(r>0)return .001;const s=Pe(e),a=Pe(t);if(e.hasConversion){if(!t.hasConversion)return(1+s)*1e-6}else if(t.hasConversion)return-(1+a)*1e-6;const c=s-a;return c<0?-1e-7:c>0?1e-7:0}function Le(e,t){const r=e.params,s=t.params,a=G(r),c=G(s),h=O(r),p=O(s);if(h&&a.hasAny){if(!p||!c.hasAny)return 1e7}else if(p&&c.hasAny)return-1e7;let d=0,l=0,T;for(T of r)T.hasAny&&++d,T.hasConversion&&++l;let v=0,E=0;for(T of s)T.hasAny&&++v,T.hasConversion&&++E;if(d!==v)return(d-v)*1e6;if(h&&a.hasConversion){if(!p||!c.hasConversion)return 1e5}else if(p&&c.hasConversion)return-1e5;if(l!==E)return(l-E)*1e4;if(h){if(!p)return 1e3}else if(p)return-1e3;const _=(r.length-s.length)*(h?-100:100);if(_!==0)return _;const R=[];let L=0;for(let V=0;V<r.length;++V){const ne=Fe(r[V],s[V]);R.push(ne),L+=ne}if(L!==0)return(L<0?-10:10)+L;let U,Q=9;const ge=Q/(R.length+1);for(U of R){if(U!==0)return(U<0?-Q:Q)+U;Q-=ge}return 0}function Ue(e){if(e.length===0)return[];const t=e.map(M);if(e.length===1)return t[0].conversionsTo;const r=new Set(e),s=new Set;for(let c=0;c<t.length;++c)for(const h of t[c].conversionsTo)r.has(h.from)||s.add(h.from);const a=[];for(const c of s){let h=J+1,p=null;for(let d=0;d<t.length;++d)for(const l of t[d].conversionsTo)l.from===c&&l.index<h&&(h=l.index,p=l);a.push(p)}return a}function Ne(e,t){let r=t,s="";if(e.some(c=>c.hasConversion)){const c=O(e),h=e.map(Se);s=h.map(p=>p.name).join(";"),r=function(){const d=[],l=c?arguments.length-1:arguments.length;for(let T=0;T<l;T++)d[T]=h[T](arguments[T]);return c&&(d[l]=arguments[l].map(h[l])),t.apply(this,d)}}let a=r;if(O(e)){const c=e.length-1;a=function(){return r.apply(this,te(arguments,0,c).concat([te(arguments,c)]))}}return s&&Object.defineProperty(a,"name",{value:s}),a}function Se(e){let t,r,s,a;const c=[],h=[];let p="";e.types.forEach(function(l){l.conversion&&(p+=l.conversion.from+"~>"+l.conversion.to+",",c.push(M(l.conversion.from).test),h.push(l.conversion.convert))}),p?p=p.slice(0,-1):p="pass";let d=l=>l;switch(h.length){case 0:break;case 1:t=c[0],s=h[0],d=function(T){return t(T)?s(T):T};break;case 2:t=c[0],r=c[1],s=h[0],a=h[1],d=function(T){return t(T)?s(T):r(T)?a(T):T};break;default:d=function(T){for(let v=0;v<h.length;v++)if(c[v](T))return h[v](T);return T}}return Object.defineProperty(d,"name",{value:p}),d}function ke(e){function t(r,s,a){if(s<r.length){const c=r[s];let h=[];if(c.restParam){const p=c.types.filter(Ae);p.length<c.types.length&&h.push({types:p,name:"..."+p.map(d=>d.name).join("|"),hasAny:p.some(d=>d.isAny),hasConversion:!1,restParam:!0}),h.push(c)}else h=c.types.map(function(p){return{types:[p],name:p.name,hasAny:p.isAny,hasConversion:p.conversion,restParam:!1}});return Be(h,function(p){return t(r,s+1,a.concat([p]))})}else return[a]}return t(e,0,[])}function K(e,t){const r=Math.max(e.length,t.length);for(let p=0;p<r;p++){const d=ue(e,p),l=ue(t,p);let T=!1,v;for(v of l)if(d.has(v)){T=!0;break}if(!T)return!1}const s=e.length,a=t.length,c=O(e),h=O(t);return c?h?s===a:a>=s:h?s>=a:s===a}function le(e){return e.map(t=>i(t)?n(t.referToSelf.callback):o(t)?me(t.referTo.references,t.referTo.callback):t)}function $e(e,t,r){const s=[];let a;for(a of e){let c=r[a];if(typeof c!="number")throw new TypeError('No definition for referenced signature "'+a+'"');if(c=t[c],typeof c!="function")return!1;s.push(c)}return s}function qe(e,t,r){const s=le(e),a=new Array(s.length).fill(!1);let c=!0;for(;c;){c=!1;let h=!0;for(let p=0;p<s.length;++p){if(a[p])continue;const d=s[p];if(i(d))s[p]=d.referToSelf.callback(r),s[p].referToSelf=d.referToSelf,a[p]=!0,h=!1;else if(o(d)){const l=$e(d.referTo.references,s,t);l?(s[p]=d.referTo.callback.apply(this,l),s[p].referTo=d.referTo,a[p]=!0,h=!1):c=!0}}if(h&&c)throw new SyntaxError("Circular reference detected in resolving typed.referTo")}return s}function Ye(e){const t=/\bthis(\(|\.signatures\b)/;Object.keys(e).forEach(r=>{const s=e[r];if(t.test(s.toString()))throw new SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.")})}function Oe(e,t){if(x.createCount++,Object.keys(t).length===0)throw new SyntaxError("No signatures provided");x.warnAgainstDeprecatedThis&&Ye(t);const r=[],s=[],a={},c=[];let h;for(h in t){if(!Object.prototype.hasOwnProperty.call(t,h))continue;const C=ee(h);if(!C)continue;r.forEach(function(de){if(K(de,C))throw new TypeError('Conflicting signatures "'+z(de)+'" and "'+z(C)+'".')}),r.push(C);const N=s.length;s.push(t[h]);const Tt=C.map(xe);let je;for(je of ke(Tt)){const de=z(je);c.push({params:je,name:de,fn:N}),je.every(vt=>!vt.hasConversion)&&(a[de]=N)}}c.sort(Le);const p=qe(s,a,ye);let d;for(d in a)Object.prototype.hasOwnProperty.call(a,d)&&(a[d]=p[a[d]]);const l=[],T=new Map;for(d of c)T.has(d.name)||(d.fn=p[d.fn],l.push(d),T.set(d.name,d));const v=l[0]&&l[0].params.length<=2&&!O(l[0].params),E=l[1]&&l[1].params.length<=2&&!O(l[1].params),_=l[2]&&l[2].params.length<=2&&!O(l[2].params),R=l[3]&&l[3].params.length<=2&&!O(l[3].params),L=l[4]&&l[4].params.length<=2&&!O(l[4].params),U=l[5]&&l[5].params.length<=2&&!O(l[5].params),Q=v&&E&&_&&R&&L&&U;for(let C=0;C<l.length;++C)l[C].test=_e(l[C].params);const ge=v?P(l[0].params[0]):b,V=E?P(l[1].params[0]):b,ne=_?P(l[2].params[0]):b,He=R?P(l[3].params[0]):b,Je=L?P(l[4].params[0]):b,Ke=U?P(l[5].params[0]):b,Qe=v?P(l[0].params[1]):b,Ve=E?P(l[1].params[1]):b,We=_?P(l[2].params[1]):b,Xe=R?P(l[3].params[1]):b,Ze=L?P(l[4].params[1]):b,et=U?P(l[5].params[1]):b;for(let C=0;C<l.length;++C)l[C].implementation=Ne(l[C].params,l[C].fn);const tt=v?l[0].implementation:j,nt=E?l[1].implementation:j,rt=_?l[2].implementation:j,ot=R?l[3].implementation:j,st=L?l[4].implementation:j,it=U?l[5].implementation:j,ct=v?l[0].params.length:-1,ft=E?l[1].params.length:-1,at=_?l[2].params.length:-1,W=R?l[3].params.length:-1,A=L?l[4].params.length:-1,F=U?l[5].params.length:-1,ut=Q?6:0,re=l.length,X=l.map(C=>C.test),lt=l.map(C=>C.implementation),dt=function(){for(let N=ut;N<re;N++)if(X[N](arguments))return lt[N].apply(this,arguments);return x.onMismatch(e,arguments,l)};function ye(C,N){return arguments.length===ct&&ge(C)&&Qe(N)?tt.apply(this,arguments):arguments.length===ft&&V(C)&&Ve(N)?nt.apply(this,arguments):arguments.length===at&&ne(C)&&We(N)?rt.apply(this,arguments):arguments.length===W&&He(C)&&Xe(N)?ot.apply(this,arguments):arguments.length===A&&Je(C)&&Ze(N)?st.apply(this,arguments):arguments.length===F&&Ke(C)&&et(N)?it.apply(this,arguments):dt.apply(this,arguments)}try{Object.defineProperty(ye,"name",{value:e})}catch{}return ye.signatures=a,ye._typedFunctionData={signatures:l,signatureMap:T},ye}function pe(e,t,r){throw Ee(e,t,r)}function he(e){return te(e,0,e.length-1)}function G(e){return e[e.length-1]}function te(e,t,r){return Array.prototype.slice.call(e,t,r)}function ze(e,t){for(let r=0;r<e.length;r++)if(t(e[r]))return e[r]}function Be(e,t){return Array.prototype.concat.apply([],e.map(t))}function Ge(){const e=he(arguments).map(r=>z(ee(r))),t=G(arguments);if(typeof t!="function")throw new TypeError("Callback function expected as last argument");return me(e,t)}function me(e,t){return{referTo:{references:e,callback:t}}}function n(e){if(typeof e!="function")throw new TypeError("Callback function expected as first argument");return{referToSelf:{callback:e}}}function o(e){return e&&typeof e.referTo=="object"&&Array.isArray(e.referTo.references)&&typeof e.referTo.callback=="function"}function i(e){return e&&typeof e.referToSelf=="object"&&typeof e.referToSelf.callback=="function"}function f(e,t){if(!e)return t;if(t&&t!==e){const r=new Error("Function names do not match (expected: "+e+", actual: "+t+")");throw r.data={actual:t,expected:e},r}return e}function m(e){let t;for(const r in e)Object.prototype.hasOwnProperty.call(e,r)&&(B(e[r])||typeof e[r].signature=="string")&&(t=f(t,e[r].name));return t}function u(e,t){let r;for(r in t)if(Object.prototype.hasOwnProperty.call(t,r)){if(r in e&&t[r]!==e[r]){const s=new Error('Signature "'+r+'" is defined twice');throw s.data={signature:r,sourceFunction:t[r],destFunction:e[r]},s}e[r]=t[r]}}const y=x;x=function(e){const t=typeof e=="string",r=t?1:0;let s=t?e:"";const a={};for(let c=r;c<arguments.length;++c){const h=arguments[c];let p={},d;if(typeof h=="function"?(d=h.name,typeof h.signature=="string"?p[h.signature]=h:B(h)&&(p=h.signatures)):Z(h)&&(p=h,t||(d=m(h))),Object.keys(p).length===0){const l=new TypeError("Argument to 'typed' at index "+c+" is not a (typed) function, nor an object with signatures as keys and functions as values.");throw l.data={index:c,argument:h},l}t||(s=f(s,d)),u(a,p)}return Oe(s||"",a)},x.create=w,x.createCount=y.createCount,x.onMismatch=pe,x.throwMismatchError=pe,x.createError=Ee,x.clear=we,x.clearConversions=Ie,x.addTypes=Y,x._findType=M,x.referTo=Ge,x.referToSelf=n,x.convert=Me,x.findSignature=k,x.find=S,x.isTypedFunction=B,x.warnAgainstDeprecatedThis=!0,x.addType=function(e,t){let r="any";t!==!1&&q.has("Object")&&(r="Object"),x.addTypes([e],r)};function g(e){if(!e||typeof e.from!="string"||typeof e.to!="string"||typeof e.convert!="function")throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");if(e.to===e.from)throw new SyntaxError('Illegal to define conversion from "'+e.from+'" to itself.')}return x.addConversion=function(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{override:!1};g(e);const r=M(e.to),s=r.conversionsTo.find(a=>a.from===e.from);if(s)if(t&&t.override)x.removeConversion({from:s.from,to:e.to,convert:s.convert});else throw new Error('There is already a conversion from "'+e.from+'" to "'+r.name+'"');r.conversionsTo.push({from:e.from,to:r.name,convert:e.convert,index:J++})},x.addConversions=function(e,t){e.forEach(r=>x.addConversion(r,t))},x.removeConversion=function(e){g(e);const t=M(e.to),r=ze(t.conversionsTo,a=>a.from===e.from);if(!r)throw new Error("Attempt to remove nonexistent conversion from "+e.from+" to "+e.to);if(r.convert!==e.convert)throw new Error("Conversion to remove does not match existing conversion");const s=t.conversionsTo.indexOf(r);t.conversionsTo.splice(s,1)},x.resolve=function(e,t){if(!B(e))throw new TypeError(H);const r=e._typedFunctionData.signatures;for(let s=0;s<r.length;++s)if(r[s].test(t))return r[s];return null},x}var I=w();return I}))})(Re)),Re.exports}export{At as r,xt as t};
//# sourceMappingURL=typed-function-CVM02vEe.js.map
