{"version":3,"file":"webgl-sdf-generator-qD_8IFx2.js","sources":["../../../node_modules/.pnpm/webgl-sdf-generator@1.1.1/node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs"],"sourcesContent":["function SDFGenerator() {\nvar exports = (function (exports) {\n\n  /**\n   * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]\n   */\n  function pointOnQuadraticBezier (x0, y0, x1, y1, x2, y2, t, pointOut) {\n    var t2 = 1 - t;\n    pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;\n    pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;\n  }\n\n  /**\n   * Find the point on a cubic bezier curve at t where t is in the range [0, 1]\n   */\n  function pointOnCubicBezier (x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {\n    var t2 = 1 - t;\n    pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;\n    pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;\n  }\n\n  /**\n   * Parse a path string into its constituent line/curve commands, invoking a callback for each.\n   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n   * @param {function(\n   *   command: 'L'|'Q'|'C',\n   *   startX: number,\n   *   startY: number,\n   *   endX: number,\n   *   endY: number,\n   *   ctrl1X?: number,\n   *   ctrl1Y?: number,\n   *   ctrl2X?: number,\n   *   ctrl2Y?: number\n   * )} commandCallback - A callback function that will be called once for each parsed path command, passing the\n   *                      command identifier (only L/Q/C commands) and its numeric arguments.\n   */\n  function forEachPathCommand(pathString, commandCallback) {\n    var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;\n    var match, firstX, firstY, prevX, prevY;\n    while ((match = segmentRE.exec(pathString))) {\n      var args = match[2]\n        .replace(/^\\s*|\\s*$/g, '')\n        .split(/[,\\s]+/)\n        .map(function (v) { return parseFloat(v); });\n      switch (match[1]) {\n        case 'M':\n          prevX = firstX = args[0];\n          prevY = firstY = args[1];\n          break\n        case 'L':\n          if (args[0] !== prevX || args[1] !== prevY) { // yup, some fonts have zero-length line commands\n            commandCallback('L', prevX, prevY, (prevX = args[0]), (prevY = args[1]));\n          }\n          break\n        case 'Q': {\n          commandCallback('Q', prevX, prevY, (prevX = args[2]), (prevY = args[3]), args[0], args[1]);\n          break\n        }\n        case 'C': {\n          commandCallback('C', prevX, prevY, (prevX = args[4]), (prevY = args[5]), args[0], args[1], args[2], args[3]);\n          break\n        }\n        case 'Z':\n          if (prevX !== firstX || prevY !== firstY) {\n            commandCallback('L', prevX, prevY, firstX, firstY);\n          }\n          break\n      }\n    }\n  }\n\n  /**\n   * Convert a path string to a series of straight line segments\n   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n   * @param {function(x1:number, y1:number, x2:number, y2:number)} segmentCallback - A callback\n   *        function that will be called once for every line segment\n   * @param {number} [curvePoints] - How many straight line segments to use when approximating a\n   *        bezier curve in the path. Defaults to 16.\n   */\n  function pathToLineSegments (pathString, segmentCallback, curvePoints) {\n    if ( curvePoints === void 0 ) curvePoints = 16;\n\n    var tempPoint = { x: 0, y: 0 };\n    forEachPathCommand(pathString, function (command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {\n      switch (command) {\n        case 'L':\n          segmentCallback(startX, startY, endX, endY);\n          break\n        case 'Q': {\n          var prevCurveX = startX;\n          var prevCurveY = startY;\n          for (var i = 1; i < curvePoints; i++) {\n            pointOnQuadraticBezier(\n              startX, startY,\n              ctrl1X, ctrl1Y,\n              endX, endY,\n              i / (curvePoints - 1),\n              tempPoint\n            );\n            segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);\n            prevCurveX = tempPoint.x;\n            prevCurveY = tempPoint.y;\n          }\n          break\n        }\n        case 'C': {\n          var prevCurveX$1 = startX;\n          var prevCurveY$1 = startY;\n          for (var i$1 = 1; i$1 < curvePoints; i$1++) {\n            pointOnCubicBezier(\n              startX, startY,\n              ctrl1X, ctrl1Y,\n              ctrl2X, ctrl2Y,\n              endX, endY,\n              i$1 / (curvePoints - 1),\n              tempPoint\n            );\n            segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);\n            prevCurveX$1 = tempPoint.x;\n            prevCurveY$1 = tempPoint.y;\n          }\n          break\n        }\n      }\n    });\n  }\n\n  var viewportQuadVertex = \"precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n  var copyTexFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}\";\n\n  var cache = new WeakMap();\n\n  var glContextParams = {\n    premultipliedAlpha: false,\n    preserveDrawingBuffer: true,\n    antialias: false,\n    depth: false,\n  };\n\n  /**\n   * This is a little helper library for WebGL. It assists with state management for a GL context.\n   * It's pretty tightly wrapped to the needs of this package, not very general-purpose.\n   *\n   * @param { WebGLRenderingContext | HTMLCanvasElement | OffscreenCanvas } glOrCanvas - the GL context to wrap\n   * @param { ({gl, getExtension, withProgram, withTexture, withTextureFramebuffer, handleContextLoss}) => void } callback\n   */\n  function withWebGLContext (glOrCanvas, callback) {\n    var gl = glOrCanvas.getContext ? glOrCanvas.getContext('webgl', glContextParams) : glOrCanvas;\n    var wrapper = cache.get(gl);\n    if (!wrapper) {\n      var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n      var extensions = {};\n      var programs = {};\n      var textures = {};\n      var textureUnit = -1;\n      var framebufferStack = [];\n\n      gl.canvas.addEventListener('webglcontextlost', function (e) {\n        handleContextLoss();\n        e.preventDefault();\n      }, false);\n\n      function getExtension (name) {\n        var ext = extensions[name];\n        if (!ext) {\n          ext = extensions[name] = gl.getExtension(name);\n          if (!ext) {\n            throw new Error((name + \" not supported\"))\n          }\n        }\n        return ext\n      }\n\n      function compileShader (src, type) {\n        var shader = gl.createShader(type);\n        gl.shaderSource(shader, src);\n        gl.compileShader(shader);\n        // const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)\n        // if (!status && !gl.isContextLost()) {\n        //   throw new Error(gl.getShaderInfoLog(shader).trim())\n        // }\n        return shader\n      }\n\n      function withProgram (name, vert, frag, func) {\n        if (!programs[name]) {\n          var attributes = {};\n          var uniforms = {};\n          var program = gl.createProgram();\n          gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));\n          gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));\n          gl.linkProgram(program);\n\n          programs[name] = {\n            program: program,\n            transaction: function transaction (func) {\n              gl.useProgram(program);\n              func({\n                setUniform: function setUniform (type, name) {\n                  var values = [], len = arguments.length - 2;\n                  while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];\n\n                  var uniformLoc = uniforms[name] || (uniforms[name] = gl.getUniformLocation(program, name));\n                  gl[(\"uniform\" + type)].apply(gl, [ uniformLoc ].concat( values ));\n                },\n\n                setAttribute: function setAttribute (name, size, usage, instancingDivisor, data) {\n                  var attr = attributes[name];\n                  if (!attr) {\n                    attr = attributes[name] = {\n                      buf: gl.createBuffer(), // TODO should we destroy our buffers?\n                      loc: gl.getAttribLocation(program, name),\n                      data: null\n                    };\n                  }\n                  gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);\n                  gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);\n                  gl.enableVertexAttribArray(attr.loc);\n                  if (isWebGL2) {\n                    gl.vertexAttribDivisor(attr.loc, instancingDivisor);\n                  } else {\n                    getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(attr.loc, instancingDivisor);\n                  }\n                  if (data !== attr.data) {\n                    gl.bufferData(gl.ARRAY_BUFFER, data, usage);\n                    attr.data = data;\n                  }\n                }\n              });\n            }\n          };\n        }\n\n        programs[name].transaction(func);\n      }\n\n      function withTexture (name, func) {\n        textureUnit++;\n        try {\n          gl.activeTexture(gl.TEXTURE0 + textureUnit);\n          var texture = textures[name];\n          if (!texture) {\n            texture = textures[name] = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n          }\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          func(texture, textureUnit);\n        } finally {\n          textureUnit--;\n        }\n      }\n\n      function withTextureFramebuffer (texture, textureUnit, func) {\n        var framebuffer = gl.createFramebuffer();\n        framebufferStack.push(framebuffer);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.activeTexture(gl.TEXTURE0 + textureUnit);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n        try {\n          func(framebuffer);\n        } finally {\n          gl.deleteFramebuffer(framebuffer);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);\n        }\n      }\n\n      function handleContextLoss () {\n        extensions = {};\n        programs = {};\n        textures = {};\n        textureUnit = -1;\n        framebufferStack.length = 0;\n      }\n\n      cache.set(gl, wrapper = {\n        gl: gl,\n        isWebGL2: isWebGL2,\n        getExtension: getExtension,\n        withProgram: withProgram,\n        withTexture: withTexture,\n        withTextureFramebuffer: withTextureFramebuffer,\n        handleContextLoss: handleContextLoss,\n      });\n    }\n    callback(wrapper);\n  }\n\n\n  function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {\n    if ( channels === void 0 ) channels = 15;\n    if ( framebuffer === void 0 ) framebuffer = null;\n\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var withProgram = ref.withProgram;\n      var withTexture = ref.withTexture;\n\n      withTexture('copy', function (tex, texUnit) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n        withProgram('copy', viewportQuadVertex, copyTexFragment, function (ref) {\n          var setUniform = ref.setUniform;\n          var setAttribute = ref.setAttribute;\n\n          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));\n          setUniform('1i', 'image', texUnit);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);\n          gl.disable(gl.BLEND);\n          gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);\n          gl.viewport(x, y, width, height);\n          gl.scissor(x, y, width, height);\n          gl.drawArrays(gl.TRIANGLES, 0, 3);\n        });\n      });\n    });\n  }\n\n  /**\n   * Resizing a canvas clears its contents; this utility copies the previous contents over.\n   * @param canvas\n   * @param newWidth\n   * @param newHeight\n   */\n  function resizeWebGLCanvasWithoutClearing(canvas, newWidth, newHeight) {\n    var width = canvas.width;\n    var height = canvas.height;\n    withWebGLContext(canvas, function (ref) {\n      var gl = ref.gl;\n\n      var data = new Uint8Array(width * height * 4);\n      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      canvas.width = newWidth;\n      canvas.height = newHeight;\n      renderImageData(gl, data, 0, 0, width, height);\n    });\n  }\n\n  var webglUtils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    withWebGLContext: withWebGLContext,\n    renderImageData: renderImageData,\n    resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing\n  });\n\n  function generate$2 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n    var textureData = new Uint8Array(sdfWidth * sdfHeight);\n\n    var viewBoxWidth = viewBox[2] - viewBox[0];\n    var viewBoxHeight = viewBox[3] - viewBox[1];\n\n    // Decompose all paths into straight line segments and add them to an index\n    var segments = [];\n    pathToLineSegments(path, function (x1, y1, x2, y2) {\n      segments.push({\n        x1: x1, y1: y1, x2: x2, y2: y2,\n        minX: Math.min(x1, x2),\n        minY: Math.min(y1, y2),\n        maxX: Math.max(x1, x2),\n        maxY: Math.max(y1, y2)\n      });\n    });\n\n    // Sort segments by maxX, this will let us short-circuit some loops below\n    segments.sort(function (a, b) { return a.maxX - b.maxX; });\n\n    // For each target SDF texel, find the distance from its center to its nearest line segment,\n    // map that distance to an alpha value, and write that alpha to the texel\n    for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {\n      for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {\n        var signedDist = findNearestSignedDistance(\n          viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,\n          viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight\n        );\n\n        // Use an exponential scale to ensure the texels very near the glyph path have adequate\n        // precision, while allowing the distance field to cover the entire texture, given that\n        // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam\n        var alpha = Math.pow((1 - Math.abs(signedDist) / maxDistance), sdfExponent) / 2;\n        if (signedDist < 0) {\n          alpha = 1 - alpha;\n        }\n\n        alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp\n        textureData[sdfY * sdfWidth + sdfX] = alpha;\n      }\n    }\n\n    return textureData\n\n    /**\n     * For a given x/y, search the index for the closest line segment and return\n     * its signed distance. Negative = inside, positive = outside, zero = on edge\n     * @param x\n     * @param y\n     * @returns {number}\n     */\n    function findNearestSignedDistance (x, y) {\n      var closestDistSq = Infinity;\n      var closestDist = Infinity;\n\n      for (var i = segments.length; i--;) {\n        var seg = segments[i];\n        if (seg.maxX + closestDist <= x) { break } //sorting by maxX means no more can be closer, so we can short-circuit\n        if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {\n          var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);\n          if (distSq < closestDistSq) {\n            closestDistSq = distSq;\n            closestDist = Math.sqrt(closestDistSq);\n          }\n        }\n      }\n\n      // Flip to negative distance if inside the poly\n      if (isPointInPoly(x, y)) {\n        closestDist = -closestDist;\n      }\n      return closestDist\n    }\n\n    /**\n     * Determine whether the given point lies inside or outside the glyph. Uses a simple\n     * winding-number ray casting algorithm using a ray pointing east from the point.\n     */\n    function isPointInPoly (x, y) {\n      var winding = 0;\n      for (var i = segments.length; i--;) {\n        var seg = segments[i];\n        if (seg.maxX <= x) { break } //sorting by maxX means no more can cross, so we can short-circuit\n        var intersects = ((seg.y1 > y) !== (seg.y2 > y)) && (x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1);\n        if (intersects) {\n          winding += seg.y1 < seg.y2 ? 1 : -1;\n        }\n      }\n      return winding !== 0\n    }\n  }\n\n  function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n  }\n\n  function generateIntoFramebuffer$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);\n    // Expand single-channel data to rbga\n    var rgbaData = new Uint8Array(data.length * 4);\n    for (var i = 0; i < data.length; i++) {\n      rgbaData[i * 4 + channel] = data[i];\n    }\n    renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << (3 - channel), framebuffer);\n  }\n\n  /**\n   * Find the absolute distance from a point to a line segment at closest approach\n   */\n  function absSquareDistanceToLineSegment (x, y, lineX0, lineY0, lineX1, lineY1) {\n    var ldx = lineX1 - lineX0;\n    var ldy = lineY1 - lineY0;\n    var lengthSq = ldx * ldx + ldy * ldy;\n    var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;\n    var dx = x - (lineX0 + t * ldx);\n    var dy = y - (lineY0 + t * ldy);\n    return dx * dx + dy * dy\n  }\n\n  var javascript = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    generate: generate$2,\n    generateIntoCanvas: generateIntoCanvas$2,\n    generateIntoFramebuffer: generateIntoFramebuffer$1\n  });\n\n  var mainVertex = \"precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n  var mainFragment = \"precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}\";\n\n  var postFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}\";\n\n  // Single triangle covering viewport\n  var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);\n\n  var implicitContext = null;\n  var isTestingSupport = false;\n  var NULL_OBJECT = {};\n  var supportByCanvas = new WeakMap(); // canvas -> bool\n\n  function validateSupport (glOrCanvas) {\n    if (!isTestingSupport && !isSupported(glOrCanvas)) {\n      throw new Error('WebGL generation not supported')\n    }\n  }\n\n  function generate$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( glOrCanvas === void 0 ) glOrCanvas = null;\n\n    if (!glOrCanvas) {\n      glOrCanvas = implicitContext;\n      if (!glOrCanvas) {\n        var canvas = typeof OffscreenCanvas === 'function'\n          ? new OffscreenCanvas(1, 1)\n          : typeof document !== 'undefined'\n            ? document.createElement('canvas')\n            : null;\n        if (!canvas) {\n          throw new Error('OffscreenCanvas or DOM canvas not supported')\n        }\n        glOrCanvas = implicitContext = canvas.getContext('webgl', { depth: false });\n      }\n    }\n\n    validateSupport(glOrCanvas);\n\n    var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4); //not Uint8ClampedArray, cuz Safari\n\n    // Render into a background texture framebuffer\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var withTexture = ref.withTexture;\n      var withTextureFramebuffer = ref.withTextureFramebuffer;\n\n      withTexture('readable', function (texture, textureUnit) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n        withTextureFramebuffer(texture, textureUnit, function (framebuffer) {\n          generateIntoFramebuffer(\n            sdfWidth,\n            sdfHeight,\n            path,\n            viewBox,\n            maxDistance,\n            sdfExponent,\n            gl,\n            framebuffer,\n            0,\n            0,\n            0 // red channel\n          );\n          gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);\n        });\n      });\n    });\n\n    // Throw away all but the red channel\n    var data = new Uint8Array(sdfWidth * sdfHeight);\n    for (var i = 0, j = 0; i < rgbaData.length; i += 4) {\n      data[j++] = rgbaData[i];\n    }\n\n    return data\n  }\n\n  function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n  }\n\n  function generateIntoFramebuffer (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    // Verify support\n    validateSupport(glOrCanvas);\n\n    // Compute path segments\n    var lineSegmentCoords = [];\n    pathToLineSegments(path, function (x1, y1, x2, y2) {\n      lineSegmentCoords.push(x1, y1, x2, y2);\n    });\n    lineSegmentCoords = new Float32Array(lineSegmentCoords);\n\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var isWebGL2 = ref.isWebGL2;\n      var getExtension = ref.getExtension;\n      var withProgram = ref.withProgram;\n      var withTexture = ref.withTexture;\n      var withTextureFramebuffer = ref.withTextureFramebuffer;\n      var handleContextLoss = ref.handleContextLoss;\n\n      withTexture('rawDistances', function (intermediateTexture, intermediateTextureUnit) {\n        if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {\n          gl.texImage2D(\n            gl.TEXTURE_2D, 0, gl.RGBA,\n            intermediateTexture._lastWidth = sdfWidth,\n            intermediateTexture._lastHeight = sdfHeight,\n            0, gl.RGBA, gl.UNSIGNED_BYTE, null\n          );\n        }\n\n        // Unsigned distance pass\n        withProgram('main', mainVertex, mainFragment, function (ref) {\n          var setAttribute = ref.setAttribute;\n          var setUniform = ref.setUniform;\n\n          // Init extensions\n          var instancingExtension = !isWebGL2 && getExtension('ANGLE_instanced_arrays');\n          var blendMinMaxExtension = !isWebGL2 && getExtension('EXT_blend_minmax');\n\n          // Init/update attributes\n          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n          setAttribute('aLineSegment', 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);\n\n          // Init/update uniforms\n          setUniform.apply(void 0, [ '4f', 'uGlyphBounds' ].concat( viewBox ));\n          setUniform('1f', 'uMaxDistance', maxDistance);\n          setUniform('1f', 'uExponent', sdfExponent);\n\n          // Render initial unsigned distance / winding number info to a texture\n          withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function (framebuffer) {\n            gl.enable(gl.BLEND);\n            gl.colorMask(true, true, true, true);\n            gl.viewport(0, 0, sdfWidth, sdfHeight);\n            gl.scissor(0, 0, sdfWidth, sdfHeight);\n            gl.blendFunc(gl.ONE, gl.ONE);\n            // Red+Green channels are incremented (FUNC_ADD) for segment-ray crossings to give a \"winding number\".\n            // Alpha holds the closest (MAX) unsigned distance.\n            gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            if (isWebGL2) {\n              gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n            } else {\n              instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n            }\n            // Debug\n            // const debug = new Uint8Array(sdfWidth * sdfHeight * 4)\n            // gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, debug)\n            // console.log('intermediate texture data: ', debug)\n          });\n        });\n\n        // Use the data stored in the texture to apply inside/outside and write to the output framebuffer rect+channel.\n        withProgram('post', viewportQuadVertex, postFragment, function (program) {\n          program.setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n          program.setUniform('1i', 'tex', intermediateTextureUnit);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n          gl.disable(gl.BLEND);\n          gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);\n          gl.viewport(x, y, sdfWidth, sdfHeight);\n          gl.scissor(x, y, sdfWidth, sdfHeight);\n          gl.drawArrays(gl.TRIANGLES, 0, 3);\n        });\n      });\n\n      // Handle context loss occurring during any of the above calls\n      if (gl.isContextLost()) {\n        handleContextLoss();\n        throw new Error('webgl context lost')\n      }\n    });\n  }\n\n  function isSupported (glOrCanvas) {\n    var key = (!glOrCanvas || glOrCanvas === implicitContext) ? NULL_OBJECT : (glOrCanvas.canvas || glOrCanvas);\n    var supported = supportByCanvas.get(key);\n    if (supported === undefined) {\n      isTestingSupport = true;\n      var failReason = null;\n      try {\n        // Since we can't detect all failure modes up front, let's just do a trial run of a\n        // simple path and compare what we get back to the correct expected result. This will\n        // also serve to prime the shader compilation.\n        var expectedResult = [\n          97, 106, 97, 61,\n          99, 137, 118, 80,\n          80, 118, 137, 99,\n          61, 97, 106, 97\n        ];\n        var testResult = generate$1(\n          4,\n          4,\n          'M8,8L16,8L24,24L16,24Z',\n          [0, 0, 32, 32],\n          24,\n          1,\n          glOrCanvas\n        );\n        supported = testResult && expectedResult.length === testResult.length &&\n          testResult.every(function (val, i) { return val === expectedResult[i]; });\n        if (!supported) {\n          failReason = 'bad trial run results';\n          console.info(expectedResult, testResult);\n        }\n      } catch (err) {\n        // TODO if it threw due to webgl context loss, should we maybe leave isSupported as null and try again later?\n        supported = false;\n        failReason = err.message;\n      }\n      if (failReason) {\n        console.warn('WebGL SDF generation not supported:', failReason);\n      }\n      isTestingSupport = false;\n      supportByCanvas.set(key, supported);\n    }\n    return supported\n  }\n\n  var webgl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    generate: generate$1,\n    generateIntoCanvas: generateIntoCanvas$1,\n    generateIntoFramebuffer: generateIntoFramebuffer,\n    isSupported: isSupported\n  });\n\n  /**\n   * Generate an SDF texture image for a 2D path.\n   *\n   * @param {number} sdfWidth - width of the SDF output image in pixels.\n   * @param {number} sdfHeight - height of the SDF output image in pixels.\n   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n   *        to half the maximum viewBox dimension.\n   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n   *        will give greater precision nearer the glyph's path.\n   * @return {Uint8Array}\n   */\n  function generate(\n    sdfWidth,\n    sdfHeight,\n    path,\n    viewBox,\n    maxDistance,\n    sdfExponent\n  ) {\n    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n    try {\n      return generate$1.apply(webgl, arguments)\n    } catch(e) {\n      console.info('WebGL SDF generation failed, falling back to JS', e);\n      return generate$2.apply(javascript, arguments)\n    }\n  }\n\n  /**\n   * Generate an SDF texture image for a 2D path, inserting the result into a WebGL `canvas` at a given x/y position\n   * and color channel. This is generally much faster than calling `generate` because it does not require reading pixels\n   * back from the GPU->CPU -- the `canvas` can be used directly as a WebGL texture image, so it all stays on the GPU.\n   *\n   * @param {number} sdfWidth - width of the SDF output image in pixels.\n   * @param {number} sdfHeight - height of the SDF output image in pixels.\n   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n   *        to half the maximum viewBox dimension.\n   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n   *        will give greater precision nearer the glyph's path.\n   * @param {HTMLCanvasElement|OffscreenCanvas} canvas - a WebGL-enabled canvas into which the SDF will be rendered.\n   *        Only the relevant rect/channel will be modified, the rest will be preserved. To avoid unpredictable results\n   *        due to shared GL context state, this canvas should be dedicated to use by this library alone.\n   * @param {number} x - the x position at which to render the SDF.\n   * @param {number} y - the y position at which to render the SDF.\n   * @param {number} channel - the color channel index (0-4) into which the SDF will be rendered.\n   * @return {Uint8Array}\n   */\n  function generateIntoCanvas(\n    sdfWidth,\n    sdfHeight,\n    path,\n    viewBox,\n    maxDistance,\n    sdfExponent,\n    canvas,\n    x,\n    y,\n    channel\n  ) {\n    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    try {\n      return generateIntoCanvas$1.apply(webgl, arguments)\n    } catch(e) {\n      console.info('WebGL SDF generation failed, falling back to JS', e);\n      return generateIntoCanvas$2.apply(javascript, arguments)\n    }\n  }\n\n  exports.forEachPathCommand = forEachPathCommand;\n  exports.generate = generate;\n  exports.generateIntoCanvas = generateIntoCanvas;\n  exports.javascript = javascript;\n  exports.pathToLineSegments = pathToLineSegments;\n  exports.webgl = webgl;\n  exports.webglUtils = webglUtils;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\nreturn exports\n}\n\nexport { SDFGenerator as default };\n"],"names":["SDFGenerator","exports","pointOnQuadraticBezier","x0","y0","x1","y1","x2","y2","pointOut","t2","pointOnCubicBezier","x3","y3","t","forEachPathCommand","pathString","commandCallback","segmentRE","match","firstX","firstY","prevX","prevY","args","v","pathToLineSegments","segmentCallback","curvePoints","tempPoint","command","startX","startY","endX","endY","ctrl1X","ctrl1Y","ctrl2X","ctrl2Y","prevCurveX","prevCurveY","i","prevCurveX$1","prevCurveY$1","i$1","viewportQuadVertex","copyTexFragment","cache","glContextParams","withWebGLContext","glOrCanvas","callback","gl","wrapper","getExtension","name","ext","extensions","compileShader","src","type","shader","withProgram","vert","frag","func","programs","attributes","uniforms","program","values","len","uniformLoc","size","usage","instancingDivisor","data","attr","isWebGL2","withTexture","textureUnit","texture","textures","withTextureFramebuffer","framebuffer","framebufferStack","handleContextLoss","e","renderImageData","imageData","x","y","width","height","channels","ref","tex","texUnit","setUniform","setAttribute","resizeWebGLCanvasWithoutClearing","canvas","newWidth","newHeight","webglUtils","generate$2","sdfWidth","sdfHeight","path","viewBox","maxDistance","sdfExponent","textureData","viewBoxWidth","viewBoxHeight","segments","a","b","sdfX","sdfY","signedDist","findNearestSignedDistance","alpha","closestDistSq","closestDist","seg","distSq","absSquareDistanceToLineSegment","isPointInPoly","winding","intersects","generateIntoCanvas$2","channel","generateIntoFramebuffer$1","rgbaData","lineX0","lineY0","lineX1","lineY1","ldx","ldy","lengthSq","dx","dy","javascript","mainVertex","mainFragment","postFragment","viewportUVs","implicitContext","isTestingSupport","NULL_OBJECT","supportByCanvas","validateSupport","isSupported","generate$1","generateIntoFramebuffer","j","generateIntoCanvas$1","lineSegmentCoords","intermediateTexture","intermediateTextureUnit","instancingExtension","blendMinMaxExtension","key","supported","failReason","expectedResult","testResult","val","err","webgl","generate","generateIntoCanvas"],"mappings":"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","x_google_ignoreList":[0]}