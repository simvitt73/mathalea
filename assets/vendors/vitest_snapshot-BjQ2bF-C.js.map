{"version":3,"mappings":"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","names":["comma","chars","intToChar","charToInt","i","c","decodeInteger","reader","relative","value","shift","integer","shouldNegate","hasMoreVlq","max","StringReader","buffer","char","pos","idx","decode","mappings","length","decoded","genColumn","sourcesIndex","sourceLine","sourceColumn","namesIndex","semi","line","sorted","lastCol","seg","sort","sortComparator","a","b","COLUMN","SOURCES_INDEX","SOURCE_LINE","SOURCE_COLUMN","NAMES_INDEX","found","binarySearch","haystack","needle","low","high","mid","cmp","upperBound","index","lowerBound","memoizedBinarySearch","state","key","lastKey","lastNeedle","lastIndex","LINE_GTR_ZERO","COL_GTR_EQ_ZERO","LEAST_UPPER_BOUND","GREATEST_LOWER_BOUND","decodedMappings","map","_a","originalPositionFor","column","bias","OMapping","segments","traceSegmentInternal","segment","names","resolvedSources","source","name","memo","notNullish","v","isPrimitive","isObject","item","getCallLastIndex","code","charIndex","inString","startedBracers","endedBracers","beforeChar","CHROME_IE_STACK_REGEXP","SAFARI_NATIVE_CODE_REGEXP","stackIgnorePatterns","extractLocation","urlLike","parts","url","urlObj","isWindows","parseSingleFFOrSafariStack","raw","atIndex","locationPart","functionName","candidateLocation","lineNumber","columnNumber","parseSingleV8Stack","sanitizedLine","location","method","file","resolve","parseStacktrace","stack","options","ignoreStackEntries","parseV8Stacktrace","parseFFOrSafariStackTrace","_options$getSourceMap","shouldFilter","traceMap","DecodedMap","position","getOriginalPosition","p","parseErrorStacktrace","stackStr","stackFrames","e_","f","from","__publicField","sources","memoizedState","s","result","lineSplitRE","positionToOffset","lines","nl","start","offsetToLineNumber","offset","counted","lineLength","saveInlineSnapshots","environment","snapshots","MagicString","__vitePreload","__vite_default__","files","snaps","snap","replaceInlineSnap","transformed","startObjectRegex","replaceObjectSnap","newSnap","_code","startMatch","callEnd","shapeStart","shapeEnd","getObjectShapeEndIndex","prepareSnapString","startBraces","endBraces","indent","indentNext","isOneline","quote","toMatchInlineName","toThrowErrorMatchingInlineName","getCodeStartingAtIndex","indexInline","indexThrowInline","startRegex","currentIndex","codeStartingAtIndex","firstKeywordMatch","startIndex","snapString","endMatch","endIndex","INDENTATION_REGEX","stripSnapshotIndentation","inlineSnapshot","_lines$at","match","indentation","saveRawSnapshots","getDefaultExportFromCjs","x","naturalCompare$1","hasRequiredNaturalCompare","requireNaturalCompare","naturalCompare","codeA","codeB","posA","posB","alphabet","getCode","str","naturalCompareExports","serialize$1","val","config","depth","refs","printer","nameString","callsString","indentationNext","test","plugin","DOMCollection","DOMElement","Immutable","ReactElement","ReactTestComponent","AsymmetricMatcher","plugins","PLUGINS","addSerializer","getSerializers","testNameToKey","testName","count","keyToTestName","getSnapshotData","content","update","data","snapshotContents","dirty","addExtraLineBreaks","string","removeExtraLineBreaks","escapeRegex","printFunctionName","serialize","formatOverrides","normalizeNewlines","format","escapeBacktickString","printBacktickString","saveSnapshotFile","snapshotData","snapshotPath","oldContent","deepMergeArray","target","mergedOutput","sourceElement","targetElement","deepMergeSnapshot","DefaultMap","defaultFn","entries","CounterMap","total","isSameStackPosition","y","SnapshotState","testFilePath","snapshotContent","uncheckedKey","testId","stacks","promiseIndex","stackIndex","receivedSerialized","hasExternalSnapshots","hasInlineSnapshots","hasRawSnapshots","isEmpty","status","received","isInline","error","rawSnapshot","expected","expectedTrimmed","pass","hasSnapshot","snapshotIsPersisted","_this$environment$pro","_this$environment","_stack","snapshotsWithSameStack","differentSnapshot","snapshot","uncheckedCount","uncheckedKeys","createMismatchError","message","expand","actual","SnapshotClient","filepath","properties","errorMessage","snapshotState","_this$options$isEqual","_this$options","err"],"ignoreList":[0],"sources":["../../../node_modules/.pnpm/@vitest+snapshot@4.0.18/node_modules/@vitest/snapshot/dist/index.js"],"sourcesContent":["import { resolve } from 'pathe';\nimport { plugins, format } from '@vitest/pretty-format';\n\n// src/vlq.ts\nvar comma = \",\".charCodeAt(0);\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar intToChar = new Uint8Array(64);\nvar charToInt = new Uint8Array(128);\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\nfunction decodeInteger(reader, relative) {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n  const shouldNegate = value & 1;\n  value >>>= 1;\n  if (shouldNegate) {\n    value = -2147483648 | -value;\n  }\n  return relative + value;\n}\nfunction hasMoreVlq(reader, max) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}\nvar StringReader = class {\n  constructor(buffer) {\n    this.pos = 0;\n    this.buffer = buffer;\n  }\n  next() {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n  peek() {\n    return this.buffer.charCodeAt(this.pos);\n  }\n  indexOf(char) {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n};\n\n// src/sourcemap-codec.ts\nfunction decode(mappings) {\n  const { length } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  do {\n    const semi = reader.indexOf(\";\");\n    const line = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n    while (reader.pos < semi) {\n      let seg;\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n      line.push(seg);\n      reader.pos++;\n    }\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n  return decoded;\n}\nfunction sort(line) {\n  line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[0] - b[0];\n}\n\n// src/trace-mapping.ts\n\n// src/sourcemap-segment.ts\nvar COLUMN = 0;\nvar SOURCES_INDEX = 1;\nvar SOURCE_LINE = 2;\nvar SOURCE_COLUMN = 3;\nvar NAMES_INDEX = 4;\n\n// src/binary-search.ts\nvar found = false;\nfunction binarySearch(haystack, needle, low, high) {\n  while (low <= high) {\n    const mid = low + (high - low >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  found = false;\n  return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction lowerBound(haystack, needle, index) {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n  const { lastKey, lastNeedle, lastIndex } = state;\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n    if (needle >= lastNeedle) {\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n  return state.lastIndex = binarySearch(haystack, needle, low, high);\n}\n\n// src/trace-mapping.ts\nvar LINE_GTR_ZERO = \"`line` must be greater than 0 (lines start at line 1)\";\nvar COL_GTR_EQ_ZERO = \"`column` must be greater than or equal to 0 (columns start at column 0)\";\nvar LEAST_UPPER_BOUND = -1;\nvar GREATEST_LOWER_BOUND = 1;\nfunction cast(map) {\n  return map;\n}\nfunction decodedMappings(map) {\n  var _a;\n  return (_a = cast(map))._decoded || (_a._decoded = decode(cast(map)._encoded));\n}\nfunction originalPositionFor(map, needle) {\n  let { line, column, bias } = needle;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n  const decoded = decodedMappings(map);\n  if (line >= decoded.length) return OMapping(null, null, null, null);\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    bias || GREATEST_LOWER_BOUND\n  );\n  if (index === -1) return OMapping(null, null, null, null);\n  const segment = segments[index];\n  if (segment.length === 1) return OMapping(null, null, null, null);\n  const { names, resolvedSources } = map;\n  return OMapping(\n    resolvedSources[segment[SOURCES_INDEX]],\n    segment[SOURCE_LINE] + 1,\n    segment[SOURCE_COLUMN],\n    segment.length === 5 ? names[segment[NAMES_INDEX]] : null\n  );\n}\nfunction OMapping(source, line, column, name) {\n  return { source, line, column, name };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (found) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\n\nfunction notNullish(v) {\n\treturn v != null;\n}\nfunction isPrimitive(value) {\n\treturn value === null || typeof value !== \"function\" && typeof value !== \"object\";\n}\nfunction isObject(item) {\n\treturn item != null && typeof item === \"object\" && !Array.isArray(item);\n}\n/**\n* If code starts with a function call, will return its last index, respecting arguments.\n* This will return 25 - last ending character of toMatch \")\"\n* Also works with callbacks\n* ```\n* toMatch({ test: '123' });\n* toBeAliased('123')\n* ```\n*/\nfunction getCallLastIndex(code) {\n\tlet charIndex = -1;\n\tlet inString = null;\n\tlet startedBracers = 0;\n\tlet endedBracers = 0;\n\tlet beforeChar = null;\n\twhile (charIndex <= code.length) {\n\t\tbeforeChar = code[charIndex];\n\t\tcharIndex++;\n\t\tconst char = code[charIndex];\n\t\tconst isCharString = char === \"\\\"\" || char === \"'\" || char === \"`\";\n\t\tif (isCharString && beforeChar !== \"\\\\\") {\n\t\t\tif (inString === char) {\n\t\t\t\tinString = null;\n\t\t\t} else if (!inString) {\n\t\t\t\tinString = char;\n\t\t\t}\n\t\t}\n\t\tif (!inString) {\n\t\t\tif (char === \"(\") {\n\t\t\t\tstartedBracers++;\n\t\t\t}\n\t\t\tif (char === \")\") {\n\t\t\t\tendedBracers++;\n\t\t\t}\n\t\t}\n\t\tif (startedBracers && endedBracers && startedBracers === endedBracers) {\n\t\t\treturn charIndex;\n\t\t}\n\t}\n\treturn null;\n}\n\nconst CHROME_IE_STACK_REGEXP = /^\\s*at .*(?:\\S:\\d+|\\(native\\))/m;\nconst SAFARI_NATIVE_CODE_REGEXP = /^(?:eval@)?(?:\\[native code\\])?$/;\nconst stackIgnorePatterns = [\n\t\"node:internal\",\n\t/\\/packages\\/\\w+\\/dist\\//,\n\t/\\/@vitest\\/\\w+\\/dist\\//,\n\t\"/vitest/dist/\",\n\t\"/vitest/src/\",\n\t\"/node_modules/chai/\",\n\t\"/node_modules/tinyspy/\",\n\t\"/vite/dist/node/module-runner\",\n\t\"/rolldown-vite/dist/node/module-runner\",\n\t\"/deps/chunk-\",\n\t\"/deps/@vitest\",\n\t\"/deps/loupe\",\n\t\"/deps/chai\",\n\t\"/browser-playwright/dist/locators.js\",\n\t\"/browser-webdriverio/dist/locators.js\",\n\t\"/browser-preview/dist/locators.js\",\n\t/node:\\w+/,\n\t/__vitest_test__/,\n\t/__vitest_browser__/,\n\t/\\/deps\\/vitest_/\n];\nfunction extractLocation(urlLike) {\n\t// Fail-fast but return locations like \"(native)\"\n\tif (!urlLike.includes(\":\")) {\n\t\treturn [urlLike];\n\t}\n\tconst regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n\tconst parts = regExp.exec(urlLike.replace(/^\\(|\\)$/g, \"\"));\n\tif (!parts) {\n\t\treturn [urlLike];\n\t}\n\tlet url = parts[1];\n\tif (url.startsWith(\"async \")) {\n\t\turl = url.slice(6);\n\t}\n\tif (url.startsWith(\"http:\") || url.startsWith(\"https:\")) {\n\t\tconst urlObj = new URL(url);\n\t\turlObj.searchParams.delete(\"import\");\n\t\turlObj.searchParams.delete(\"browserv\");\n\t\turl = urlObj.pathname + urlObj.hash + urlObj.search;\n\t}\n\tif (url.startsWith(\"/@fs/\")) {\n\t\tconst isWindows = /^\\/@fs\\/[a-zA-Z]:\\//.test(url);\n\t\turl = url.slice(isWindows ? 5 : 4);\n\t}\n\treturn [\n\t\turl,\n\t\tparts[2] || undefined,\n\t\tparts[3] || undefined\n\t];\n}\nfunction parseSingleFFOrSafariStack(raw) {\n\tlet line = raw.trim();\n\tif (SAFARI_NATIVE_CODE_REGEXP.test(line)) {\n\t\treturn null;\n\t}\n\tif (line.includes(\" > eval\")) {\n\t\tline = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, \":$1\");\n\t}\n\t// Early return for lines that don't look like Firefox/Safari stack traces\n\t// Firefox/Safari stack traces must contain '@' and should have location info after it\n\tif (!line.includes(\"@\")) {\n\t\treturn null;\n\t}\n\t// Find the correct @ that separates function name from location\n\t// For cases like '@https://@fs/path' or 'functionName@https://@fs/path'\n\t// we need to find the first @ that precedes a valid location (containing :)\n\tlet atIndex = -1;\n\tlet locationPart = \"\";\n\tlet functionName;\n\t// Try each @ from left to right to find the one that gives us a valid location\n\tfor (let i = 0; i < line.length; i++) {\n\t\tif (line[i] === \"@\") {\n\t\t\tconst candidateLocation = line.slice(i + 1);\n\t\t\t// Minimum length 3 for valid location: 1 for filename + 1 for colon + 1 for line number (e.g., \"a:1\")\n\t\t\tif (candidateLocation.includes(\":\") && candidateLocation.length >= 3) {\n\t\t\t\tatIndex = i;\n\t\t\t\tlocationPart = candidateLocation;\n\t\t\t\tfunctionName = i > 0 ? line.slice(0, i) : undefined;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t// Validate we found a valid location with minimum length (filename:line format)\n\tif (atIndex === -1 || !locationPart.includes(\":\") || locationPart.length < 3) {\n\t\treturn null;\n\t}\n\tconst [url, lineNumber, columnNumber] = extractLocation(locationPart);\n\tif (!url || !lineNumber || !columnNumber) {\n\t\treturn null;\n\t}\n\treturn {\n\t\tfile: url,\n\t\tmethod: functionName || \"\",\n\t\tline: Number.parseInt(lineNumber),\n\t\tcolumn: Number.parseInt(columnNumber)\n\t};\n}\n// Based on https://github.com/stacktracejs/error-stack-parser\n// Credit to stacktracejs\nfunction parseSingleV8Stack(raw) {\n\tlet line = raw.trim();\n\tif (!CHROME_IE_STACK_REGEXP.test(line)) {\n\t\treturn null;\n\t}\n\tif (line.includes(\"(eval \")) {\n\t\tline = line.replace(/eval code/g, \"eval\").replace(/(\\(eval at [^()]*)|(,.*$)/g, \"\");\n\t}\n\tlet sanitizedLine = line.replace(/^\\s+/, \"\").replace(/\\(eval code/g, \"(\").replace(/^.*?\\s+/, \"\");\n\t// capture and preserve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n\t// case it has spaces in it, as the string is split on \\s+ later on\n\tconst location = sanitizedLine.match(/ (\\(.+\\)$)/);\n\t// remove the parenthesized location from the line, if it was matched\n\tsanitizedLine = location ? sanitizedLine.replace(location[0], \"\") : sanitizedLine;\n\t// if a location was matched, pass it to extractLocation() otherwise pass all sanitizedLine\n\t// because this line doesn't have function name\n\tconst [url, lineNumber, columnNumber] = extractLocation(location ? location[1] : sanitizedLine);\n\tlet method = location && sanitizedLine || \"\";\n\tlet file = url && [\"eval\", \"<anonymous>\"].includes(url) ? undefined : url;\n\tif (!file || !lineNumber || !columnNumber) {\n\t\treturn null;\n\t}\n\tif (method.startsWith(\"async \")) {\n\t\tmethod = method.slice(6);\n\t}\n\tif (file.startsWith(\"file://\")) {\n\t\tfile = file.slice(7);\n\t}\n\t// normalize Windows path (\\ -> /)\n\tfile = file.startsWith(\"node:\") || file.startsWith(\"internal:\") ? file : resolve(file);\n\tif (method) {\n\t\tmethod = method.replace(/__vite_ssr_import_\\d+__\\./g, \"\").replace(/(Object\\.)?__vite_ssr_export_default__\\s?/g, \"\");\n\t}\n\treturn {\n\t\tmethod,\n\t\tfile,\n\t\tline: Number.parseInt(lineNumber),\n\t\tcolumn: Number.parseInt(columnNumber)\n\t};\n}\nfunction parseStacktrace(stack, options = {}) {\n\tconst { ignoreStackEntries = stackIgnorePatterns } = options;\n\tconst stacks = !CHROME_IE_STACK_REGEXP.test(stack) ? parseFFOrSafariStackTrace(stack) : parseV8Stacktrace(stack);\n\treturn stacks.map((stack) => {\n\t\tvar _options$getSourceMap;\n\t\tif (options.getUrlId) {\n\t\t\tstack.file = options.getUrlId(stack.file);\n\t\t}\n\t\tconst map = (_options$getSourceMap = options.getSourceMap) === null || _options$getSourceMap === void 0 ? void 0 : _options$getSourceMap.call(options, stack.file);\n\t\tif (!map || typeof map !== \"object\" || !map.version) {\n\t\t\treturn shouldFilter(ignoreStackEntries, stack.file) ? null : stack;\n\t\t}\n\t\tconst traceMap = new DecodedMap(map, stack.file);\n\t\tconst position = getOriginalPosition(traceMap, stack);\n\t\tif (!position) {\n\t\t\treturn stack;\n\t\t}\n\t\tconst { line, column, source, name } = position;\n\t\tlet file = source || stack.file;\n\t\tif (file.match(/\\/\\w:\\//)) {\n\t\t\tfile = file.slice(1);\n\t\t}\n\t\tif (shouldFilter(ignoreStackEntries, file)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (line != null && column != null) {\n\t\t\treturn {\n\t\t\t\tline,\n\t\t\t\tcolumn,\n\t\t\t\tfile,\n\t\t\t\tmethod: name || stack.method\n\t\t\t};\n\t\t}\n\t\treturn stack;\n\t}).filter((s) => s != null);\n}\nfunction shouldFilter(ignoreStackEntries, file) {\n\treturn ignoreStackEntries.some((p) => file.match(p));\n}\nfunction parseFFOrSafariStackTrace(stack) {\n\treturn stack.split(\"\\n\").map((line) => parseSingleFFOrSafariStack(line)).filter(notNullish);\n}\nfunction parseV8Stacktrace(stack) {\n\treturn stack.split(\"\\n\").map((line) => parseSingleV8Stack(line)).filter(notNullish);\n}\nfunction parseErrorStacktrace(e, options = {}) {\n\tif (!e || isPrimitive(e)) {\n\t\treturn [];\n\t}\n\tif (\"stacks\" in e && e.stacks) {\n\t\treturn e.stacks;\n\t}\n\tconst stackStr = e.stack || \"\";\n\t// if \"stack\" property was overwritten at runtime to be something else,\n\t// ignore the value because we don't know how to process it\n\tlet stackFrames = typeof stackStr === \"string\" ? parseStacktrace(stackStr, options) : [];\n\tif (!stackFrames.length) {\n\t\tconst e_ = e;\n\t\tif (e_.fileName != null && e_.lineNumber != null && e_.columnNumber != null) {\n\t\t\tstackFrames = parseStacktrace(`${e_.fileName}:${e_.lineNumber}:${e_.columnNumber}`, options);\n\t\t}\n\t\tif (e_.sourceURL != null && e_.line != null && e_._column != null) {\n\t\t\tstackFrames = parseStacktrace(`${e_.sourceURL}:${e_.line}:${e_.column}`, options);\n\t\t}\n\t}\n\tif (options.frameFilter) {\n\t\tstackFrames = stackFrames.filter((f) => options.frameFilter(e, f) !== false);\n\t}\n\te.stacks = stackFrames;\n\treturn stackFrames;\n}\nclass DecodedMap {\n\t_encoded;\n\t_decoded;\n\t_decodedMemo;\n\turl;\n\tversion;\n\tnames = [];\n\tresolvedSources;\n\tconstructor(map, from) {\n\t\tthis.map = map;\n\t\tconst { mappings, names, sources } = map;\n\t\tthis.version = map.version;\n\t\tthis.names = names || [];\n\t\tthis._encoded = mappings || \"\";\n\t\tthis._decodedMemo = memoizedState();\n\t\tthis.url = from;\n\t\tthis.resolvedSources = (sources || []).map((s) => resolve(s || \"\", from));\n\t}\n}\nfunction memoizedState() {\n\treturn {\n\t\tlastKey: -1,\n\t\tlastNeedle: -1,\n\t\tlastIndex: -1\n\t};\n}\nfunction getOriginalPosition(map, needle) {\n\tconst result = originalPositionFor(map, needle);\n\tif (result.column == null) {\n\t\treturn null;\n\t}\n\treturn result;\n}\n\nconst lineSplitRE = /\\r?\\n/;\nfunction positionToOffset(source, lineNumber, columnNumber) {\n\tconst lines = source.split(lineSplitRE);\n\tconst nl = /\\r\\n/.test(source) ? 2 : 1;\n\tlet start = 0;\n\tif (lineNumber > lines.length) {\n\t\treturn source.length;\n\t}\n\tfor (let i = 0; i < lineNumber - 1; i++) {\n\t\tstart += lines[i].length + nl;\n\t}\n\treturn start + columnNumber;\n}\nfunction offsetToLineNumber(source, offset) {\n\tif (offset > source.length) {\n\t\tthrow new Error(`offset is longer than source length! offset ${offset} > length ${source.length}`);\n\t}\n\tconst lines = source.split(lineSplitRE);\n\tconst nl = /\\r\\n/.test(source) ? 2 : 1;\n\tlet counted = 0;\n\tlet line = 0;\n\tfor (; line < lines.length; line++) {\n\t\tconst lineLength = lines[line].length + nl;\n\t\tif (counted + lineLength >= offset) {\n\t\t\tbreak;\n\t\t}\n\t\tcounted += lineLength;\n\t}\n\treturn line + 1;\n}\n\nasync function saveInlineSnapshots(environment, snapshots) {\n\tconst MagicString = (await import('magic-string')).default;\n\tconst files = new Set(snapshots.map((i) => i.file));\n\tawait Promise.all(Array.from(files).map(async (file) => {\n\t\tconst snaps = snapshots.filter((i) => i.file === file);\n\t\tconst code = await environment.readSnapshotFile(file);\n\t\tconst s = new MagicString(code);\n\t\tfor (const snap of snaps) {\n\t\t\tconst index = positionToOffset(code, snap.line, snap.column);\n\t\t\treplaceInlineSnap(code, s, index, snap.snapshot);\n\t\t}\n\t\tconst transformed = s.toString();\n\t\tif (transformed !== code) {\n\t\t\tawait environment.saveSnapshotFile(file, transformed);\n\t\t}\n\t}));\n}\nconst startObjectRegex = /(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\\s*\\(\\s*(?:\\/\\*[\\s\\S]*\\*\\/\\s*|\\/\\/.*(?:[\\n\\r\\u2028\\u2029]\\s*|[\\t\\v\\f \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF]))*\\{/;\nfunction replaceObjectSnap(code, s, index, newSnap) {\n\tlet _code = code.slice(index);\n\tconst startMatch = startObjectRegex.exec(_code);\n\tif (!startMatch) {\n\t\treturn false;\n\t}\n\t_code = _code.slice(startMatch.index);\n\tlet callEnd = getCallLastIndex(_code);\n\tif (callEnd === null) {\n\t\treturn false;\n\t}\n\tcallEnd += index + startMatch.index;\n\tconst shapeStart = index + startMatch.index + startMatch[0].length;\n\tconst shapeEnd = getObjectShapeEndIndex(code, shapeStart);\n\tconst snap = `, ${prepareSnapString(newSnap, code, index)}`;\n\tif (shapeEnd === callEnd) {\n\t\t// toMatchInlineSnapshot({ foo: expect.any(String) })\n\t\ts.appendLeft(callEnd, snap);\n\t} else {\n\t\t// toMatchInlineSnapshot({ foo: expect.any(String) }, ``)\n\t\ts.overwrite(shapeEnd, callEnd, snap);\n\t}\n\treturn true;\n}\nfunction getObjectShapeEndIndex(code, index) {\n\tlet startBraces = 1;\n\tlet endBraces = 0;\n\twhile (startBraces !== endBraces && index < code.length) {\n\t\tconst s = code[index++];\n\t\tif (s === \"{\") {\n\t\t\tstartBraces++;\n\t\t} else if (s === \"}\") {\n\t\t\tendBraces++;\n\t\t}\n\t}\n\treturn index;\n}\nfunction prepareSnapString(snap, source, index) {\n\tconst lineNumber = offsetToLineNumber(source, index);\n\tconst line = source.split(lineSplitRE)[lineNumber - 1];\n\tconst indent = line.match(/^\\s*/)[0] || \"\";\n\tconst indentNext = indent.includes(\"\t\") ? `${indent}\\t` : `${indent}  `;\n\tconst lines = snap.trim().replace(/\\\\/g, \"\\\\\\\\\").split(/\\n/g);\n\tconst isOneline = lines.length <= 1;\n\tconst quote = \"`\";\n\tif (isOneline) {\n\t\treturn `${quote}${lines.join(\"\\n\").replace(/`/g, \"\\\\`\").replace(/\\$\\{/g, \"\\\\${\")}${quote}`;\n\t}\n\treturn `${quote}\\n${lines.map((i) => i ? indentNext + i : \"\").join(\"\\n\").replace(/`/g, \"\\\\`\").replace(/\\$\\{/g, \"\\\\${\")}\\n${indent}${quote}`;\n}\nconst toMatchInlineName = \"toMatchInlineSnapshot\";\nconst toThrowErrorMatchingInlineName = \"toThrowErrorMatchingInlineSnapshot\";\n// on webkit, the line number is at the end of the method, not at the start\nfunction getCodeStartingAtIndex(code, index) {\n\tconst indexInline = index - toMatchInlineName.length;\n\tif (code.slice(indexInline, index) === toMatchInlineName) {\n\t\treturn {\n\t\t\tcode: code.slice(indexInline),\n\t\t\tindex: indexInline\n\t\t};\n\t}\n\tconst indexThrowInline = index - toThrowErrorMatchingInlineName.length;\n\tif (code.slice(index - indexThrowInline, index) === toThrowErrorMatchingInlineName) {\n\t\treturn {\n\t\t\tcode: code.slice(index - indexThrowInline),\n\t\t\tindex: index - indexThrowInline\n\t\t};\n\t}\n\treturn {\n\t\tcode: code.slice(index),\n\t\tindex\n\t};\n}\nconst startRegex = /(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\\s*\\(\\s*(?:\\/\\*[\\s\\S]*\\*\\/\\s*|\\/\\/.*(?:[\\n\\r\\u2028\\u2029]\\s*|[\\t\\v\\f \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF]))*[\\w$]*(['\"`)])/;\nfunction replaceInlineSnap(code, s, currentIndex, newSnap) {\n\tconst { code: codeStartingAtIndex, index } = getCodeStartingAtIndex(code, currentIndex);\n\tconst startMatch = startRegex.exec(codeStartingAtIndex);\n\tconst firstKeywordMatch = /toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot/.exec(codeStartingAtIndex);\n\tif (!startMatch || startMatch.index !== (firstKeywordMatch === null || firstKeywordMatch === void 0 ? void 0 : firstKeywordMatch.index)) {\n\t\treturn replaceObjectSnap(code, s, index, newSnap);\n\t}\n\tconst quote = startMatch[1];\n\tconst startIndex = index + startMatch.index + startMatch[0].length;\n\tconst snapString = prepareSnapString(newSnap, code, index);\n\tif (quote === \")\") {\n\t\ts.appendRight(startIndex - 1, snapString);\n\t\treturn true;\n\t}\n\tconst quoteEndRE = new RegExp(`(?:^|[^\\\\\\\\])${quote}`);\n\tconst endMatch = quoteEndRE.exec(code.slice(startIndex));\n\tif (!endMatch) {\n\t\treturn false;\n\t}\n\tconst endIndex = startIndex + endMatch.index + endMatch[0].length;\n\ts.overwrite(startIndex - 1, endIndex, snapString);\n\treturn true;\n}\nconst INDENTATION_REGEX = /^([^\\S\\n]*)\\S/m;\nfunction stripSnapshotIndentation(inlineSnapshot) {\n\tvar _lines$at;\n\t// Find indentation if exists.\n\tconst match = inlineSnapshot.match(INDENTATION_REGEX);\n\tif (!match || !match[1]) {\n\t\t// No indentation.\n\t\treturn inlineSnapshot;\n\t}\n\tconst indentation = match[1];\n\tconst lines = inlineSnapshot.split(/\\n/g);\n\tif (lines.length <= 2) {\n\t\t// Must be at least 3 lines.\n\t\treturn inlineSnapshot;\n\t}\n\tif (lines[0].trim() !== \"\" || ((_lines$at = lines.at(-1)) === null || _lines$at === void 0 ? void 0 : _lines$at.trim()) !== \"\") {\n\t\t// If not blank first and last lines, abort.\n\t\treturn inlineSnapshot;\n\t}\n\tfor (let i = 1; i < lines.length - 1; i++) {\n\t\tif (lines[i] !== \"\") {\n\t\t\tif (lines[i].indexOf(indentation) !== 0) {\n\t\t\t\t// All lines except first and last should either be blank or have the same\n\t\t\t\t// indent as the first line (or more). If this isn't the case we don't\n\t\t\t\t// want to touch the snapshot at all.\n\t\t\t\treturn inlineSnapshot;\n\t\t\t}\n\t\t\tlines[i] = lines[i].substring(indentation.length);\n\t\t}\n\t}\n\t// Last line is a special case because it won't have the same indent as others\n\t// but may still have been given some indent to line up.\n\tlines[lines.length - 1] = \"\";\n\t// Return inline snapshot, now at indent 0.\n\tinlineSnapshot = lines.join(\"\\n\");\n\treturn inlineSnapshot;\n}\n\nasync function saveRawSnapshots(environment, snapshots) {\n\tawait Promise.all(snapshots.map(async (snap) => {\n\t\tif (!snap.readonly) {\n\t\t\tawait environment.saveSnapshotFile(snap.file, snap.snapshot);\n\t\t}\n\t}));\n}\n\nfunction getDefaultExportFromCjs(x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\n\nvar naturalCompare$1 = {exports: {}};\n\nvar hasRequiredNaturalCompare;\n\nfunction requireNaturalCompare () {\n\tif (hasRequiredNaturalCompare) return naturalCompare$1.exports;\n\thasRequiredNaturalCompare = 1;\n\t/*\n\t * @version    1.4.0\n\t * @date       2015-10-26\n\t * @stability  3 - Stable\n\t * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)\n\t * @license    MIT License\n\t */\n\n\n\tvar naturalCompare = function(a, b) {\n\t\tvar i, codeA\n\t\t, codeB = 1\n\t\t, posA = 0\n\t\t, posB = 0\n\t\t, alphabet = String.alphabet;\n\n\t\tfunction getCode(str, pos, code) {\n\t\t\tif (code) {\n\t\t\t\tfor (i = pos; code = getCode(str, i), code < 76 && code > 65;) ++i;\n\t\t\t\treturn +str.slice(pos - 1, i)\n\t\t\t}\n\t\t\tcode = alphabet && alphabet.indexOf(str.charAt(pos));\n\t\t\treturn code > -1 ? code + 76 : ((code = str.charCodeAt(pos) || 0), code < 45 || code > 127) ? code\n\t\t\t\t: code < 46 ? 65               // -\n\t\t\t\t: code < 48 ? code - 1\n\t\t\t\t: code < 58 ? code + 18        // 0-9\n\t\t\t\t: code < 65 ? code - 11\n\t\t\t\t: code < 91 ? code + 11        // A-Z\n\t\t\t\t: code < 97 ? code - 37\n\t\t\t\t: code < 123 ? code + 5        // a-z\n\t\t\t\t: code - 63\n\t\t}\n\n\n\t\tif ((a+=\"\") != (b+=\"\")) for (;codeB;) {\n\t\t\tcodeA = getCode(a, posA++);\n\t\t\tcodeB = getCode(b, posB++);\n\n\t\t\tif (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {\n\t\t\t\tcodeA = getCode(a, posA, posA);\n\t\t\t\tcodeB = getCode(b, posB, posA = i);\n\t\t\t\tposB = i;\n\t\t\t}\n\n\t\t\tif (codeA != codeB) return (codeA < codeB) ? -1 : 1\n\t\t}\n\t\treturn 0\n\t};\n\n\ttry {\n\t\tnaturalCompare$1.exports = naturalCompare;\n\t} catch (e) {\n\t\tString.naturalCompare = naturalCompare;\n\t}\n\treturn naturalCompare$1.exports;\n}\n\nvar naturalCompareExports = requireNaturalCompare();\nvar naturalCompare = /*@__PURE__*/getDefaultExportFromCjs(naturalCompareExports);\n\nconst serialize$1 = (val, config, indentation, depth, refs, printer) => {\n\t// Serialize a non-default name, even if config.printFunctionName is false.\n\tconst name = val.getMockName();\n\tconst nameString = name === \"vi.fn()\" ? \"\" : ` ${name}`;\n\tlet callsString = \"\";\n\tif (val.mock.calls.length !== 0) {\n\t\tconst indentationNext = indentation + config.indent;\n\t\tcallsString = ` {${config.spacingOuter}${indentationNext}\"calls\": ${printer(val.mock.calls, config, indentationNext, depth, refs)}${config.min ? \", \" : \",\"}${config.spacingOuter}${indentationNext}\"results\": ${printer(val.mock.results, config, indentationNext, depth, refs)}${config.min ? \"\" : \",\"}${config.spacingOuter}${indentation}}`;\n\t}\n\treturn `[MockFunction${nameString}]${callsString}`;\n};\nconst test = (val) => val && !!val._isMockFunction;\nconst plugin = {\n\tserialize: serialize$1,\n\ttest\n};\n\nconst { DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent, AsymmetricMatcher } = plugins;\nlet PLUGINS = [\n\tReactTestComponent,\n\tReactElement,\n\tDOMElement,\n\tDOMCollection,\n\tImmutable,\n\tAsymmetricMatcher,\n\tplugin\n];\nfunction addSerializer(plugin) {\n\tPLUGINS = [plugin].concat(PLUGINS);\n}\nfunction getSerializers() {\n\treturn PLUGINS;\n}\n\n// TODO: rewrite and clean up\nfunction testNameToKey(testName, count) {\n\treturn `${testName} ${count}`;\n}\nfunction keyToTestName(key) {\n\tif (!/ \\d+$/.test(key)) {\n\t\tthrow new Error(\"Snapshot keys must end with a number.\");\n\t}\n\treturn key.replace(/ \\d+$/, \"\");\n}\nfunction getSnapshotData(content, options) {\n\tconst update = options.updateSnapshot;\n\tconst data = Object.create(null);\n\tlet snapshotContents = \"\";\n\tlet dirty = false;\n\tif (content != null) {\n\t\ttry {\n\t\t\tsnapshotContents = content;\n\t\t\t// eslint-disable-next-line no-new-func\n\t\t\tconst populate = new Function(\"exports\", snapshotContents);\n\t\t\tpopulate(data);\n\t\t} catch {}\n\t}\n\t// const validationResult = validateSnapshotVersion(snapshotContents)\n\tconst isInvalid = snapshotContents;\n\t// if (update === 'none' && isInvalid)\n\t//   throw validationResult\n\tif ((update === \"all\" || update === \"new\") && isInvalid) {\n\t\tdirty = true;\n\t}\n\treturn {\n\t\tdata,\n\t\tdirty\n\t};\n}\n// Add extra line breaks at beginning and end of multiline snapshot\n// to make the content easier to read.\nfunction addExtraLineBreaks(string) {\n\treturn string.includes(\"\\n\") ? `\\n${string}\\n` : string;\n}\n// Remove extra line breaks at beginning and end of multiline snapshot.\n// Instead of trim, which can remove additional newlines or spaces\n// at beginning or end of the content from a custom serializer.\nfunction removeExtraLineBreaks(string) {\n\treturn string.length > 2 && string[0] === \"\\n\" && string.endsWith(\"\\n\") ? string.slice(1, -1) : string;\n}\n// export const removeLinesBeforeExternalMatcherTrap = (stack: string): string => {\n//   const lines = stack.split('\\n')\n//   for (let i = 0; i < lines.length; i += 1) {\n//     // It's a function name specified in `packages/expect/src/index.ts`\n//     // for external custom matchers.\n//     if (lines[i].includes('__EXTERNAL_MATCHER_TRAP__'))\n//       return lines.slice(i + 1).join('\\n')\n//   }\n//   return stack\n// }\nconst escapeRegex = true;\nconst printFunctionName = false;\nfunction serialize(val, indent = 2, formatOverrides = {}) {\n\treturn normalizeNewlines(format(val, {\n\t\tescapeRegex,\n\t\tindent,\n\t\tplugins: getSerializers(),\n\t\tprintFunctionName,\n\t\t...formatOverrides\n\t}));\n}\nfunction escapeBacktickString(str) {\n\treturn str.replace(/`|\\\\|\\$\\{/g, \"\\\\$&\");\n}\nfunction printBacktickString(str) {\n\treturn `\\`${escapeBacktickString(str)}\\``;\n}\nfunction normalizeNewlines(string) {\n\treturn string.replace(/\\r\\n|\\r/g, \"\\n\");\n}\nasync function saveSnapshotFile(environment, snapshotData, snapshotPath) {\n\tconst snapshots = Object.keys(snapshotData).sort(naturalCompare).map((key) => `exports[${printBacktickString(key)}] = ${printBacktickString(normalizeNewlines(snapshotData[key]))};`);\n\tconst content = `${environment.getHeader()}\\n\\n${snapshots.join(\"\\n\\n\")}\\n`;\n\tconst oldContent = await environment.readSnapshotFile(snapshotPath);\n\tconst skipWriting = oldContent != null && oldContent === content;\n\tif (skipWriting) {\n\t\treturn;\n\t}\n\tawait environment.saveSnapshotFile(snapshotPath, content);\n}\nfunction deepMergeArray(target = [], source = []) {\n\tconst mergedOutput = Array.from(target);\n\tsource.forEach((sourceElement, index) => {\n\t\tconst targetElement = mergedOutput[index];\n\t\tif (Array.isArray(target[index])) {\n\t\t\tmergedOutput[index] = deepMergeArray(target[index], sourceElement);\n\t\t} else if (isObject(targetElement)) {\n\t\t\tmergedOutput[index] = deepMergeSnapshot(target[index], sourceElement);\n\t\t} else {\n\t\t\t// Source does not exist in target or target is primitive and cannot be deep merged\n\t\t\tmergedOutput[index] = sourceElement;\n\t\t}\n\t});\n\treturn mergedOutput;\n}\n/**\n* Deep merge, but considers asymmetric matchers. Unlike base util's deep merge,\n* will merge any object-like instance.\n* Compatible with Jest's snapshot matcher. Should not be used outside of snapshot.\n*\n* @example\n* ```ts\n* toMatchSnapshot({\n*   name: expect.stringContaining('text')\n* })\n* ```\n*/\nfunction deepMergeSnapshot(target, source) {\n\tif (isObject(target) && isObject(source)) {\n\t\tconst mergedOutput = { ...target };\n\t\tObject.keys(source).forEach((key) => {\n\t\t\tif (isObject(source[key]) && !source[key].$$typeof) {\n\t\t\t\tif (!(key in target)) {\n\t\t\t\t\tObject.assign(mergedOutput, { [key]: source[key] });\n\t\t\t\t} else {\n\t\t\t\t\tmergedOutput[key] = deepMergeSnapshot(target[key], source[key]);\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(source[key])) {\n\t\t\t\tmergedOutput[key] = deepMergeArray(target[key], source[key]);\n\t\t\t} else {\n\t\t\t\tObject.assign(mergedOutput, { [key]: source[key] });\n\t\t\t}\n\t\t});\n\t\treturn mergedOutput;\n\t} else if (Array.isArray(target) && Array.isArray(source)) {\n\t\treturn deepMergeArray(target, source);\n\t}\n\treturn target;\n}\nclass DefaultMap extends Map {\n\tconstructor(defaultFn, entries) {\n\t\tsuper(entries);\n\t\tthis.defaultFn = defaultFn;\n\t}\n\tget(key) {\n\t\tif (!this.has(key)) {\n\t\t\tthis.set(key, this.defaultFn(key));\n\t\t}\n\t\treturn super.get(key);\n\t}\n}\nclass CounterMap extends DefaultMap {\n\tconstructor() {\n\t\tsuper(() => 0);\n\t}\n\t// compat for jest-image-snapshot https://github.com/vitest-dev/vitest/issues/7322\n\t// `valueOf` and `Snapshot.added` setter allows\n\t//   snapshotState.added = snapshotState.added + 1\n\t// to function as\n\t//   snapshotState.added.total_ = snapshotState.added.total() + 1\n\t_total;\n\tvalueOf() {\n\t\treturn this._total = this.total();\n\t}\n\tincrement(key) {\n\t\tif (typeof this._total !== \"undefined\") {\n\t\t\tthis._total++;\n\t\t}\n\t\tthis.set(key, this.get(key) + 1);\n\t}\n\ttotal() {\n\t\tif (typeof this._total !== \"undefined\") {\n\t\t\treturn this._total;\n\t\t}\n\t\tlet total = 0;\n\t\tfor (const x of this.values()) {\n\t\t\ttotal += x;\n\t\t}\n\t\treturn total;\n\t}\n}\n\nfunction isSameStackPosition(x, y) {\n\treturn x.file === y.file && x.column === y.column && x.line === y.line;\n}\nclass SnapshotState {\n\t_counters = new CounterMap();\n\t_dirty;\n\t_updateSnapshot;\n\t_snapshotData;\n\t_initialData;\n\t_inlineSnapshots;\n\t_inlineSnapshotStacks;\n\t_testIdToKeys = new DefaultMap(() => []);\n\t_rawSnapshots;\n\t_uncheckedKeys;\n\t_snapshotFormat;\n\t_environment;\n\t_fileExists;\n\texpand;\n\t// getter/setter for jest-image-snapshot compat\n\t// https://github.com/vitest-dev/vitest/issues/7322\n\t_added = new CounterMap();\n\t_matched = new CounterMap();\n\t_unmatched = new CounterMap();\n\t_updated = new CounterMap();\n\tget added() {\n\t\treturn this._added;\n\t}\n\tset added(value) {\n\t\tthis._added._total = value;\n\t}\n\tget matched() {\n\t\treturn this._matched;\n\t}\n\tset matched(value) {\n\t\tthis._matched._total = value;\n\t}\n\tget unmatched() {\n\t\treturn this._unmatched;\n\t}\n\tset unmatched(value) {\n\t\tthis._unmatched._total = value;\n\t}\n\tget updated() {\n\t\treturn this._updated;\n\t}\n\tset updated(value) {\n\t\tthis._updated._total = value;\n\t}\n\tconstructor(testFilePath, snapshotPath, snapshotContent, options) {\n\t\tthis.testFilePath = testFilePath;\n\t\tthis.snapshotPath = snapshotPath;\n\t\tconst { data, dirty } = getSnapshotData(snapshotContent, options);\n\t\tthis._fileExists = snapshotContent != null;\n\t\tthis._initialData = { ...data };\n\t\tthis._snapshotData = { ...data };\n\t\tthis._dirty = dirty;\n\t\tthis._inlineSnapshots = [];\n\t\tthis._inlineSnapshotStacks = [];\n\t\tthis._rawSnapshots = [];\n\t\tthis._uncheckedKeys = new Set(Object.keys(this._snapshotData));\n\t\tthis.expand = options.expand || false;\n\t\tthis._updateSnapshot = options.updateSnapshot;\n\t\tthis._snapshotFormat = {\n\t\t\tprintBasicPrototype: false,\n\t\t\tescapeString: false,\n\t\t\t...options.snapshotFormat\n\t\t};\n\t\tthis._environment = options.snapshotEnvironment;\n\t}\n\tstatic async create(testFilePath, options) {\n\t\tconst snapshotPath = await options.snapshotEnvironment.resolvePath(testFilePath);\n\t\tconst content = await options.snapshotEnvironment.readSnapshotFile(snapshotPath);\n\t\treturn new SnapshotState(testFilePath, snapshotPath, content, options);\n\t}\n\tget environment() {\n\t\treturn this._environment;\n\t}\n\tmarkSnapshotsAsCheckedForTest(testName) {\n\t\tthis._uncheckedKeys.forEach((uncheckedKey) => {\n\t\t\t// skip snapshots with following keys\n\t\t\t//   testName n\n\t\t\t//   testName > xxx n (this is for toMatchSnapshot(\"xxx\") API)\n\t\t\tif (/ \\d+$| > /.test(uncheckedKey.slice(testName.length))) {\n\t\t\t\tthis._uncheckedKeys.delete(uncheckedKey);\n\t\t\t}\n\t\t});\n\t}\n\tclearTest(testId) {\n\t\t// clear inline\n\t\tthis._inlineSnapshots = this._inlineSnapshots.filter((s) => s.testId !== testId);\n\t\tthis._inlineSnapshotStacks = this._inlineSnapshotStacks.filter((s) => s.testId !== testId);\n\t\t// clear file\n\t\tfor (const key of this._testIdToKeys.get(testId)) {\n\t\t\tconst name = keyToTestName(key);\n\t\t\tconst count = this._counters.get(name);\n\t\t\tif (count > 0) {\n\t\t\t\tif (key in this._snapshotData || key in this._initialData) {\n\t\t\t\t\tthis._snapshotData[key] = this._initialData[key];\n\t\t\t\t}\n\t\t\t\tthis._counters.set(name, count - 1);\n\t\t\t}\n\t\t}\n\t\tthis._testIdToKeys.delete(testId);\n\t\t// clear stats\n\t\tthis.added.delete(testId);\n\t\tthis.updated.delete(testId);\n\t\tthis.matched.delete(testId);\n\t\tthis.unmatched.delete(testId);\n\t}\n\t_inferInlineSnapshotStack(stacks) {\n\t\t// if called inside resolves/rejects, stacktrace is different\n\t\tconst promiseIndex = stacks.findIndex((i) => i.method.match(/__VITEST_(RESOLVES|REJECTS)__/));\n\t\tif (promiseIndex !== -1) {\n\t\t\treturn stacks[promiseIndex + 3];\n\t\t}\n\t\t// inline snapshot function is called __INLINE_SNAPSHOT__\n\t\t// in integrations/snapshot/chai.ts\n\t\tconst stackIndex = stacks.findIndex((i) => i.method.includes(\"__INLINE_SNAPSHOT__\"));\n\t\treturn stackIndex !== -1 ? stacks[stackIndex + 2] : null;\n\t}\n\t_addSnapshot(key, receivedSerialized, options) {\n\t\tthis._dirty = true;\n\t\tif (options.stack) {\n\t\t\tthis._inlineSnapshots.push({\n\t\t\t\tsnapshot: receivedSerialized,\n\t\t\t\ttestId: options.testId,\n\t\t\t\t...options.stack\n\t\t\t});\n\t\t} else if (options.rawSnapshot) {\n\t\t\tthis._rawSnapshots.push({\n\t\t\t\t...options.rawSnapshot,\n\t\t\t\tsnapshot: receivedSerialized\n\t\t\t});\n\t\t} else {\n\t\t\tthis._snapshotData[key] = receivedSerialized;\n\t\t}\n\t}\n\tasync save() {\n\t\tconst hasExternalSnapshots = Object.keys(this._snapshotData).length;\n\t\tconst hasInlineSnapshots = this._inlineSnapshots.length;\n\t\tconst hasRawSnapshots = this._rawSnapshots.length;\n\t\tconst isEmpty = !hasExternalSnapshots && !hasInlineSnapshots && !hasRawSnapshots;\n\t\tconst status = {\n\t\t\tdeleted: false,\n\t\t\tsaved: false\n\t\t};\n\t\tif ((this._dirty || this._uncheckedKeys.size) && !isEmpty) {\n\t\t\tif (hasExternalSnapshots) {\n\t\t\t\tawait saveSnapshotFile(this._environment, this._snapshotData, this.snapshotPath);\n\t\t\t\tthis._fileExists = true;\n\t\t\t}\n\t\t\tif (hasInlineSnapshots) {\n\t\t\t\tawait saveInlineSnapshots(this._environment, this._inlineSnapshots);\n\t\t\t}\n\t\t\tif (hasRawSnapshots) {\n\t\t\t\tawait saveRawSnapshots(this._environment, this._rawSnapshots);\n\t\t\t}\n\t\t\tstatus.saved = true;\n\t\t} else if (!hasExternalSnapshots && this._fileExists) {\n\t\t\tif (this._updateSnapshot === \"all\") {\n\t\t\t\tawait this._environment.removeSnapshotFile(this.snapshotPath);\n\t\t\t\tthis._fileExists = false;\n\t\t\t}\n\t\t\tstatus.deleted = true;\n\t\t}\n\t\treturn status;\n\t}\n\tgetUncheckedCount() {\n\t\treturn this._uncheckedKeys.size || 0;\n\t}\n\tgetUncheckedKeys() {\n\t\treturn Array.from(this._uncheckedKeys);\n\t}\n\tremoveUncheckedKeys() {\n\t\tif (this._updateSnapshot === \"all\" && this._uncheckedKeys.size) {\n\t\t\tthis._dirty = true;\n\t\t\tthis._uncheckedKeys.forEach((key) => delete this._snapshotData[key]);\n\t\t\tthis._uncheckedKeys.clear();\n\t\t}\n\t}\n\tmatch({ testId, testName, received, key, inlineSnapshot, isInline, error, rawSnapshot }) {\n\t\t// this also increments counter for inline snapshots. maybe we shouldn't?\n\t\tthis._counters.increment(testName);\n\t\tconst count = this._counters.get(testName);\n\t\tif (!key) {\n\t\t\tkey = testNameToKey(testName, count);\n\t\t}\n\t\tthis._testIdToKeys.get(testId).push(key);\n\t\t// Do not mark the snapshot as \"checked\" if the snapshot is inline and\n\t\t// there's an external snapshot. This way the external snapshot can be\n\t\t// removed with `--updateSnapshot`.\n\t\tif (!(isInline && this._snapshotData[key] !== undefined)) {\n\t\t\tthis._uncheckedKeys.delete(key);\n\t\t}\n\t\tlet receivedSerialized = rawSnapshot && typeof received === \"string\" ? received : serialize(received, undefined, this._snapshotFormat);\n\t\tif (!rawSnapshot) {\n\t\t\treceivedSerialized = addExtraLineBreaks(receivedSerialized);\n\t\t}\n\t\tif (rawSnapshot) {\n\t\t\t// normalize EOL when snapshot contains CRLF but received is LF\n\t\t\tif (rawSnapshot.content && rawSnapshot.content.match(/\\r\\n/) && !receivedSerialized.match(/\\r\\n/)) {\n\t\t\t\trawSnapshot.content = normalizeNewlines(rawSnapshot.content);\n\t\t\t}\n\t\t}\n\t\tconst expected = isInline ? inlineSnapshot : rawSnapshot ? rawSnapshot.content : this._snapshotData[key];\n\t\tconst expectedTrimmed = rawSnapshot ? expected : expected === null || expected === void 0 ? void 0 : expected.trim();\n\t\tconst pass = expectedTrimmed === (rawSnapshot ? receivedSerialized : receivedSerialized.trim());\n\t\tconst hasSnapshot = expected !== undefined;\n\t\tconst snapshotIsPersisted = isInline || this._fileExists || rawSnapshot && rawSnapshot.content != null;\n\t\tif (pass && !isInline && !rawSnapshot) {\n\t\t\t// Executing a snapshot file as JavaScript and writing the strings back\n\t\t\t// when other snapshots have changed loses the proper escaping for some\n\t\t\t// characters. Since we check every snapshot in every test, use the newly\n\t\t\t// generated formatted string.\n\t\t\t// Note that this is only relevant when a snapshot is added and the dirty\n\t\t\t// flag is set.\n\t\t\tthis._snapshotData[key] = receivedSerialized;\n\t\t}\n\t\t// find call site of toMatchInlineSnapshot\n\t\tlet stack;\n\t\tif (isInline) {\n\t\t\tvar _this$environment$pro, _this$environment;\n\t\t\tconst stacks = parseErrorStacktrace(error || new Error(\"snapshot\"), { ignoreStackEntries: [] });\n\t\t\tconst _stack = this._inferInlineSnapshotStack(stacks);\n\t\t\tif (!_stack) {\n\t\t\t\tthrow new Error(`@vitest/snapshot: Couldn't infer stack frame for inline snapshot.\\n${JSON.stringify(stacks)}`);\n\t\t\t}\n\t\t\tstack = ((_this$environment$pro = (_this$environment = this.environment).processStackTrace) === null || _this$environment$pro === void 0 ? void 0 : _this$environment$pro.call(_this$environment, _stack)) || _stack;\n\t\t\t// removing 1 column, because source map points to the wrong\n\t\t\t// location for js files, but `column-1` points to the same in both js/ts\n\t\t\t// https://github.com/vitejs/vite/issues/8657\n\t\t\tstack.column--;\n\t\t\t// reject multiple inline snapshots at the same location if snapshot is different\n\t\t\tconst snapshotsWithSameStack = this._inlineSnapshotStacks.filter((s) => isSameStackPosition(s, stack));\n\t\t\tif (snapshotsWithSameStack.length > 0) {\n\t\t\t\t// ensure only one snapshot will be written at the same location\n\t\t\t\tthis._inlineSnapshots = this._inlineSnapshots.filter((s) => !isSameStackPosition(s, stack));\n\t\t\t\tconst differentSnapshot = snapshotsWithSameStack.find((s) => s.snapshot !== receivedSerialized);\n\t\t\t\tif (differentSnapshot) {\n\t\t\t\t\tthrow Object.assign(new Error(\"toMatchInlineSnapshot with different snapshots cannot be called at the same location\"), {\n\t\t\t\t\t\tactual: receivedSerialized,\n\t\t\t\t\t\texpected: differentSnapshot.snapshot\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._inlineSnapshotStacks.push({\n\t\t\t\t...stack,\n\t\t\t\ttestId,\n\t\t\t\tsnapshot: receivedSerialized\n\t\t\t});\n\t\t}\n\t\t// These are the conditions on when to write snapshots:\n\t\t//  * There's no snapshot file in a non-CI environment.\n\t\t//  * There is a snapshot file and we decided to update the snapshot.\n\t\t//  * There is a snapshot file, but it doesn't have this snapshot.\n\t\t// These are the conditions on when not to write snapshots:\n\t\t//  * The update flag is set to 'none'.\n\t\t//  * There's no snapshot file or a file without this snapshot on a CI environment.\n\t\tif (hasSnapshot && this._updateSnapshot === \"all\" || (!hasSnapshot || !snapshotIsPersisted) && (this._updateSnapshot === \"new\" || this._updateSnapshot === \"all\")) {\n\t\t\tif (this._updateSnapshot === \"all\") {\n\t\t\t\tif (!pass) {\n\t\t\t\t\tif (hasSnapshot) {\n\t\t\t\t\t\tthis.updated.increment(testId);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.added.increment(testId);\n\t\t\t\t\t}\n\t\t\t\t\tthis._addSnapshot(key, receivedSerialized, {\n\t\t\t\t\t\tstack,\n\t\t\t\t\t\ttestId,\n\t\t\t\t\t\trawSnapshot\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthis.matched.increment(testId);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._addSnapshot(key, receivedSerialized, {\n\t\t\t\t\tstack,\n\t\t\t\t\ttestId,\n\t\t\t\t\trawSnapshot\n\t\t\t\t});\n\t\t\t\tthis.added.increment(testId);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tactual: \"\",\n\t\t\t\tcount,\n\t\t\t\texpected: \"\",\n\t\t\t\tkey,\n\t\t\t\tpass: true\n\t\t\t};\n\t\t} else {\n\t\t\tif (!pass) {\n\t\t\t\tthis.unmatched.increment(testId);\n\t\t\t\treturn {\n\t\t\t\t\tactual: rawSnapshot ? receivedSerialized : removeExtraLineBreaks(receivedSerialized),\n\t\t\t\t\tcount,\n\t\t\t\t\texpected: expectedTrimmed !== undefined ? rawSnapshot ? expectedTrimmed : removeExtraLineBreaks(expectedTrimmed) : undefined,\n\t\t\t\t\tkey,\n\t\t\t\t\tpass: false\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tthis.matched.increment(testId);\n\t\t\t\treturn {\n\t\t\t\t\tactual: \"\",\n\t\t\t\t\tcount,\n\t\t\t\t\texpected: \"\",\n\t\t\t\t\tkey,\n\t\t\t\t\tpass: true\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\tasync pack() {\n\t\tconst snapshot = {\n\t\t\tfilepath: this.testFilePath,\n\t\t\tadded: 0,\n\t\t\tfileDeleted: false,\n\t\t\tmatched: 0,\n\t\t\tunchecked: 0,\n\t\t\tuncheckedKeys: [],\n\t\t\tunmatched: 0,\n\t\t\tupdated: 0\n\t\t};\n\t\tconst uncheckedCount = this.getUncheckedCount();\n\t\tconst uncheckedKeys = this.getUncheckedKeys();\n\t\tif (uncheckedCount) {\n\t\t\tthis.removeUncheckedKeys();\n\t\t}\n\t\tconst status = await this.save();\n\t\tsnapshot.fileDeleted = status.deleted;\n\t\tsnapshot.added = this.added.total();\n\t\tsnapshot.matched = this.matched.total();\n\t\tsnapshot.unmatched = this.unmatched.total();\n\t\tsnapshot.updated = this.updated.total();\n\t\tsnapshot.unchecked = !status.deleted ? uncheckedCount : 0;\n\t\tsnapshot.uncheckedKeys = Array.from(uncheckedKeys);\n\t\treturn snapshot;\n\t}\n}\n\nfunction createMismatchError(message, expand, actual, expected) {\n\tconst error = new Error(message);\n\tObject.defineProperty(error, \"actual\", {\n\t\tvalue: actual,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t\twritable: true\n\t});\n\tObject.defineProperty(error, \"expected\", {\n\t\tvalue: expected,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t\twritable: true\n\t});\n\tObject.defineProperty(error, \"diffOptions\", { value: { expand } });\n\treturn error;\n}\nclass SnapshotClient {\n\tsnapshotStateMap = new Map();\n\tconstructor(options = {}) {\n\t\tthis.options = options;\n\t}\n\tasync setup(filepath, options) {\n\t\tif (this.snapshotStateMap.has(filepath)) {\n\t\t\treturn;\n\t\t}\n\t\tthis.snapshotStateMap.set(filepath, await SnapshotState.create(filepath, options));\n\t}\n\tasync finish(filepath) {\n\t\tconst state = this.getSnapshotState(filepath);\n\t\tconst result = await state.pack();\n\t\tthis.snapshotStateMap.delete(filepath);\n\t\treturn result;\n\t}\n\tskipTest(filepath, testName) {\n\t\tconst state = this.getSnapshotState(filepath);\n\t\tstate.markSnapshotsAsCheckedForTest(testName);\n\t}\n\tclearTest(filepath, testId) {\n\t\tconst state = this.getSnapshotState(filepath);\n\t\tstate.clearTest(testId);\n\t}\n\tgetSnapshotState(filepath) {\n\t\tconst state = this.snapshotStateMap.get(filepath);\n\t\tif (!state) {\n\t\t\tthrow new Error(`The snapshot state for '${filepath}' is not found. Did you call 'SnapshotClient.setup()'?`);\n\t\t}\n\t\treturn state;\n\t}\n\tassert(options) {\n\t\tconst { filepath, name, testId = name, message, isInline = false, properties, inlineSnapshot, error, errorMessage, rawSnapshot } = options;\n\t\tlet { received } = options;\n\t\tif (!filepath) {\n\t\t\tthrow new Error(\"Snapshot cannot be used outside of test\");\n\t\t}\n\t\tconst snapshotState = this.getSnapshotState(filepath);\n\t\tif (typeof properties === \"object\") {\n\t\t\tif (typeof received !== \"object\" || !received) {\n\t\t\t\tthrow new Error(\"Received value must be an object when the matcher has properties\");\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tvar _this$options$isEqual, _this$options;\n\t\t\t\tconst pass = ((_this$options$isEqual = (_this$options = this.options).isEqual) === null || _this$options$isEqual === void 0 ? void 0 : _this$options$isEqual.call(_this$options, received, properties)) ?? false;\n\t\t\t\t// const pass = equals(received, properties, [iterableEquality, subsetEquality])\n\t\t\t\tif (!pass) {\n\t\t\t\t\tthrow createMismatchError(\"Snapshot properties mismatched\", snapshotState.expand, received, properties);\n\t\t\t\t} else {\n\t\t\t\t\treceived = deepMergeSnapshot(received, properties);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\terr.message = errorMessage || \"Snapshot mismatched\";\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t\tconst testName = [name, ...message ? [message] : []].join(\" > \");\n\t\tconst { actual, expected, key, pass } = snapshotState.match({\n\t\t\ttestId,\n\t\t\ttestName,\n\t\t\treceived,\n\t\t\tisInline,\n\t\t\terror,\n\t\t\tinlineSnapshot,\n\t\t\trawSnapshot\n\t\t});\n\t\tif (!pass) {\n\t\t\tthrow createMismatchError(`Snapshot \\`${key || \"unknown\"}\\` mismatched`, snapshotState.expand, rawSnapshot ? actual : actual === null || actual === void 0 ? void 0 : actual.trim(), rawSnapshot ? expected : expected === null || expected === void 0 ? void 0 : expected.trim());\n\t\t}\n\t}\n\tasync assertRaw(options) {\n\t\tif (!options.rawSnapshot) {\n\t\t\tthrow new Error(\"Raw snapshot is required\");\n\t\t}\n\t\tconst { filepath, rawSnapshot } = options;\n\t\tif (rawSnapshot.content == null) {\n\t\t\tif (!filepath) {\n\t\t\t\tthrow new Error(\"Snapshot cannot be used outside of test\");\n\t\t\t}\n\t\t\tconst snapshotState = this.getSnapshotState(filepath);\n\t\t\t// save the filepath, so it don't lose even if the await make it out-of-context\n\t\t\toptions.filepath || (options.filepath = filepath);\n\t\t\t// resolve and read the raw snapshot file\n\t\t\trawSnapshot.file = await snapshotState.environment.resolveRawPath(filepath, rawSnapshot.file);\n\t\t\trawSnapshot.content = await snapshotState.environment.readSnapshotFile(rawSnapshot.file) ?? undefined;\n\t\t}\n\t\treturn this.assert(options);\n\t}\n\tclear() {\n\t\tthis.snapshotStateMap.clear();\n\t}\n}\n\nexport { SnapshotClient, SnapshotState, addSerializer, getSerializers, stripSnapshotIndentation };\n"],"file":"vitest_snapshot-BjQ2bF-C.js"}