{"version":3,"file":"labyrinthe-K4T69MwU.js","sources":["../../../node_modules/.pnpm/labyrinthe@git+https+++forge.apps.education.fr+coopmaths+apps+labyrinthe.git+990940970c_04767834aad3a77d3e6f8bc50f82ead8/node_modules/labyrinthe/src/labyrinthe/model.ts","../../../node_modules/.pnpm/labyrinthe@git+https+++forge.apps.education.fr+coopmaths+apps+labyrinthe.git+990940970c_04767834aad3a77d3e6f8bc50f82ead8/node_modules/labyrinthe/src/labyrinthe/renderer.ts","../../../node_modules/.pnpm/labyrinthe@git+https+++forge.apps.education.fr+coopmaths+apps+labyrinthe.git+990940970c_04767834aad3a77d3e6f8bc50f82ead8/node_modules/labyrinthe/src/LabyrintheElement.ts"],"sourcesContent":["import seedrandom from 'seedrandom'\nimport type {\n  CellGrid,\n  CellState,\n  Coords,\n  GameSnapshot,\n  LabyrintheModel as ILabyrintheModel,\n  LatexOptions,\n  ModelConfig,\n  Orientation,\n  SerializedState,\n} from './types'\n\n/**\n * Implémentation pure (sans DOM) du modèle de labyrinthe.\n * - Génère un chemin unique (8-voisins) entre deux bords selon l'orientation.\n * - Gère l'état de jeu: clics, victoire/défaite.\n * - Sérialise/Restaure l'état utilisateur indépendamment du DOM.\n * - Distribue les valeurs (bonnes/mauvaises) dans la grille.\n */\nexport class Labyrinthe implements ILabyrintheModel {\n  private rows: number = 8\n  private cols: number = 8\n\n  private seed: string | null = null\n  private rnd: () => number = Math.random\n\n  // Expose a seeded random generator for deterministic value generation\n  private valuesRnd: (() => number) | null = null\n\n  // 'random' permet de tirer l'orientation à chaque génération\n  private orientationMode: Orientation | 'random' = 'random'\n  private lastOrientation: Orientation = 'vertical'\n\n  private start: Coords = { row: 0, col: 0 }\n  private end: Coords = { row: 0, col: 0 }\n\n  private grid: CellGrid = []\n  private correctClicks: number = 0\n  private badClicks: number = 0\n  private win: boolean = false\n  private gameOver: boolean = false\n\n  private goodAnswers: string[] = []\n  private badAnswers: string[] = []\n\n  // Dimensions des cellules en em\n  private width: number | null = null\n  private height: number | null = null\n\n  constructor(opts?: ModelConfig) {\n    if (opts) this.configure(opts)\n    // Ne pas régénérer automatiquement - laissez l'appelant le faire explicitement\n    // Cela évite les régénérations multiples non-déterministes\n  }\n\n  get cellWidth(): number | null {\n    return this.width\n  }\n\n  get cellHeight(): number | null {\n    return this.height\n  }\n\n  configure(opts: ModelConfig): void {\n    if (opts.seed !== undefined) {\n      this.seed = opts.seed ?? null\n      this.rnd = this.seed != null ? seedrandom(this.seed) : Math.random\n      // Create a separate RNG for values generation with a derived seed\n      this.valuesRnd = this.seed != null ? seedrandom(this.seed + '-values') : null\n    }\n    if (opts.orientation !== undefined) {\n      this.orientationMode = opts.orientation\n    }\n    if (opts.rows !== undefined) {\n      const n = Math.floor(Number(opts.rows))\n      if (Number.isFinite(n) && n > 0) this.rows = n\n    }\n    if (opts.cols !== undefined) {\n      const n = Math.floor(Number(opts.cols))\n      if (Number.isFinite(n) && n > 0) this.cols = n\n    }\n    if (opts.width !== undefined) {\n      this.width = opts.width\n    }\n    if (opts.height !== undefined) {\n      this.height = opts.height\n    }\n  }\n\n  regenerate(): void {\n    // Réinitialise l'état de jeu\n    this.correctClicks = 0\n    this.badClicks = 0\n    this.win = false\n    this.gameOver = false\n\n    // IMPORTANT: Réinitialiser le RNG pour garantir le déterminisme\n    // Chaque appel à regenerate() avec le même seed doit produire le même labyrinthe\n    if (this.seed != null) {\n      this.rnd = seedrandom(this.seed)\n      // Reset the values RNG as well for deterministic value generation\n      this.valuesRnd = seedrandom(this.seed + '-values')\n    }\n\n    // Génère un masque de chemin (0/1) puis convertit en grille de CellState\n    const { mask, start, end, orientation } = this.generateNewPathMask()\n    this.start = start\n    this.end = end\n    this.lastOrientation = orientation\n\n    this.grid = Array(this.rows)\n      .fill(0)\n      .map((_, r) =>\n        Array(this.cols)\n          .fill(0)\n          .map(\n            (__, c): CellState => ({\n              isGood: mask[r][c] === 1,\n              clicked: false,\n              text: '',\n            }),\n          ),\n      )\n\n    // Redistribue les valeurs si elles ont été fournies auparavant\n    // (mais seulement si on a effectivement des valeurs à distribuer)\n    if (this.goodAnswers.length > 0 || this.badAnswers.length > 0) {\n      this.assignValuesToGrid()\n    }\n  }\n\n  setValues(good: string[], bad: string[]): void {\n    this.goodAnswers = Array.isArray(good) ? good.map(String) : []\n    this.badAnswers = Array.isArray(bad) ? bad.map(String) : []\n    this.assignValuesToGrid()\n  }\n\n  clickCell(row: number, col: number): void {\n    if (this.gameOver) return\n    if (!this.inBounds(row, col)) return\n\n    const cell = this.grid[row][col]\n    if (cell.clicked) return\n\n    cell.clicked = true\n    if (cell.isGood) {\n      this.correctClicks++\n      // On considère que le joueur n'a pas besoin de cliquer Départ/Arrivée pour gagner.\n      // Donc win si toutes les bonnes cases sauf 2 (Départ/Arrivée) ont été trouvées.\n      if (this.correctClicks >= this.numberOfGoodAnswers() - 2) {\n        this.win = true\n        this.gameOver = true\n      }\n    } else {\n      this.badClicks++\n      this.win = false\n      this.gameOver = true\n    }\n  }\n\n  snapshot(): GameSnapshot {\n    return {\n      seed: this.seed,\n      orientation: this.lastOrientation,\n      rows: this.rows,\n      cols: this.cols,\n      start: { ...this.start },\n      end: { ...this.end },\n      grid: this.cloneGrid(this.grid),\n\n      win: this.win,\n      gameOver: this.gameOver,\n      correctClicks: this.correctClicks,\n      badAnswers: this.badClicks,\n    }\n  }\n\n  serializeState(): SerializedState {\n    // Format JSON compact :\n    //  - c: correct clicks\n    //  - b: bad clicks\n    //  - g: matrice 0/1 des clics utilisateur\n    const clicked = this.grid.map((row) => row.map((c) => (c.clicked ? 1 : 0)))\n    return JSON.stringify({\n      c: this.correctClicks,\n      b: this.badClicks,\n      g: clicked,\n    })\n  }\n\n  restoreState(state: SerializedState): void {\n    try {\n      const parsed = JSON.parse(state)\n      const g = parsed?.g\n      if (Array.isArray(g)) {\n        for (let r = 0; r < this.rows; r++) {\n          for (let c = 0; c < this.cols; c++) {\n            const v = g?.[r]?.[c]\n            this.grid[r][c].clicked = v === 1\n          }\n        }\n      }\n\n      // Recalcule les compteurs à partir de la grille (source de vérité)\n      let correct = 0\n      let wrong = 0\n      for (let r = 0; r < this.rows; r++) {\n        for (let c = 0; c < this.cols; c++) {\n          const cell = this.grid[r][c]\n          if (cell.clicked) {\n            if (cell.isGood) correct++\n            else wrong++\n          }\n        }\n      }\n      this.correctClicks = correct\n      this.badClicks = wrong\n\n      // Déduit la fin de partie: si mauvaise case cliquée -> perdu\n      if (wrong > 0) {\n        this.win = false\n        this.gameOver = true\n      } else if (correct >= this.numberOfGoodAnswers() - 2 && correct > 0) {\n        // Si toutes les bonnes (sauf départ/arrivée) sont cliquées -> gagné\n        this.win = true\n        this.gameOver = true\n      } else {\n        this.win = false\n        this.gameOver = false\n      }\n    } catch {\n      // État invalide: ignorer (pas d'exception)\n    }\n  }\n\n  numberOfGoodAnswers(): number {\n    let count = 0\n    for (let r = 0; r < this.rows; r++) {\n      for (let c = 0; c < this.cols; c++) {\n        if (this.grid?.[r]?.[c]?.isGood) count++\n      }\n    }\n    return count\n  }\n\n  numberOfIncorrectAnswers(): number {\n    return this.rows * this.cols - this.numberOfGoodAnswers()\n  }\n\n  // ========================\n  // Logique de génération\n  // ========================\n\n  private generateNewPathMask(): {\n    mask: number[][]\n    start: Coords\n    end: Coords\n    orientation: Orientation\n  } {\n    const MAX_ATTEMPTS = 200\n    const orientation = this.chooseOrientation()\n\n    // Stratégie déterministe: on génère tous les chemins possibles avec le même RNG\n    // et on retourne le premier succès. Avec le même seed, on aura toujours le même résultat.\n    // Note: le RNG a été réinitialisé dans regenerate() pour garantir la reproductibilité.\n    for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {\n      const result = this.tryGeneratePathOnce(orientation)\n      if (result) return result\n    }\n    // Fallback: chemin en ligne droite\n    return this.generateFallbackStraightPath(orientation)\n  }\n\n  private tryGeneratePathOnce(\n    orientation: Orientation,\n  ): { mask: number[][]; start: Coords; end: Coords; orientation: Orientation } | null {\n    const mask = this.zeroMask()\n\n    // Point de départ\n    let currentRow: number\n    let currentCol: number\n    if (orientation === 'vertical') {\n      currentRow = 0\n      currentCol = Math.floor(this.rnd() * this.cols)\n    } else {\n      currentRow = Math.floor(this.rnd() * this.rows)\n      currentCol = 0\n    }\n\n    mask[currentRow][currentCol] = 1\n    const path: Array<[number, number]> = [[currentRow, currentCol]]\n\n    const touchesOnlyCurrent = (r: number, c: number, curR: number, curC: number) => {\n      for (let dr = -1; dr <= 1; dr++) {\n        for (let dc = -1; dc <= 1; dc++) {\n          if (dr === 0 && dc === 0) continue\n          const nr = r + dr\n          const nc = c + dc\n          if (nr === curR && nc === curC) continue\n          if (this.inBounds(nr, nc) && mask[nr][nc] === 1) {\n            return false\n          }\n        }\n      }\n      return true\n    }\n\n    const maxSteps = this.rows * this.cols * 4\n    let steps = 0\n\n    while (true) {\n      if (++steps > maxSteps) return null\n\n      const neighbors: Array<[number, number]> = []\n      for (let dr = -1; dr <= 1; dr++) {\n        for (let dc = -1; dc <= 1; dc++) {\n          if (dr === 0 && dc === 0) continue\n          const newRow = currentRow + dr\n          const newCol = currentCol + dc\n          if (\n            this.inBounds(newRow, newCol) &&\n            mask[newRow][newCol] === 0 &&\n            touchesOnlyCurrent(newRow, newCol, currentRow, currentCol)\n          ) {\n            neighbors.push([newRow, newCol])\n          }\n        }\n      }\n\n      if (neighbors.length === 0) {\n        // retour en arrière : on démarque la case courante\n        mask[currentRow][currentCol] = 0\n        path.pop()\n        if (path.length === 0) return null\n        ;[currentRow, currentCol] = path[path.length - 1]\n        continue\n      }\n\n      // avance vers un voisin aléatoire\n      const [nextRow, nextCol] = neighbors[Math.floor(this.rnd() * neighbors.length)]\n      mask[nextRow][nextCol] = 1\n      path.push([nextRow, nextCol])\n      ;[currentRow, currentCol] = [nextRow, nextCol]\n\n      // sortie atteinte ?\n      if (orientation === 'vertical' && currentRow === this.rows - 1) break\n      if (orientation === 'horizontal' && currentCol === this.cols - 1) break\n    }\n\n    if (!this.isUniquePath(mask)) return null\n\n    const start: Coords = { row: path[0][0], col: path[0][1] }\n    const end: Coords = { row: path[path.length - 1][0], col: path[path.length - 1][1] }\n\n    return { mask, start, end, orientation }\n  }\n\n  private generateFallbackStraightPath(orientation: Orientation): {\n    mask: number[][]\n    start: Coords\n    end: Coords\n    orientation: Orientation\n  } {\n    const mask = this.zeroMask()\n    if (orientation === 'vertical') {\n      const col = Math.floor(this.rnd() * this.cols)\n      for (let r = 0; r < this.rows; r++) mask[r][col] = 1\n      return {\n        mask,\n        start: { row: 0, col },\n        end: { row: this.rows - 1, col },\n        orientation,\n      }\n    } else {\n      const row = Math.floor(this.rnd() * this.rows)\n      for (let c = 0; c < this.cols; c++) mask[row][c] = 1\n      return {\n        mask,\n        start: { row, col: 0 },\n        end: { row, col: this.cols - 1 },\n        orientation,\n      }\n    }\n  }\n\n  // Unicité du chemin:\n  // - exactement 2 noeuds de degré 1\n  // - tous les autres noeuds de degré 2\n  // - composante connexe\n  // Les voisins considérés sont les 8-voisins (diagonales incluses),\n  // cohérent avec la génération.\n  private isUniquePath(mask: number[][]): boolean {\n    const key = (r: number, c: number) => `${r},${c}`\n    const open = new Set<string>()\n    for (let r = 0; r < this.rows; r++) {\n      for (let c = 0; c < this.cols; c++) {\n        if (mask[r][c] === 1) open.add(key(r, c))\n      }\n    }\n    if (open.size < 2) return false\n\n    const inOpen = (r: number, c: number) => this.inBounds(r, c) && open.has(key(r, c))\n\n    const neighbors8 = (r: number, c: number) => {\n      const out: Array<[number, number]> = []\n      for (let dr = -1; dr <= 1; dr++) {\n        for (let dc = -1; dc <= 1; dc++) {\n          if (dr === 0 && dc === 0) continue\n          const nr = r + dr\n          const nc = c + dc\n          if (inOpen(nr, nc)) out.push([nr, nc])\n        }\n      }\n      return out\n    }\n\n    const deg1: Array<[number, number]> = []\n    for (const id of open) {\n      const [r, c] = id.split(',').map(Number)\n      const d = neighbors8(r, c).length\n      if (d === 1) deg1.push([r, c])\n      else if (d !== 2) return false\n    }\n    if (deg1.length !== 2) return false\n\n    // vérifie la connexité\n    const start = deg1[0]\n    const stack = [start]\n    const visited = new Set<string>([key(start[0], start[1])])\n    while (stack.length) {\n      const popped = stack.pop()\n      if (!popped) break\n      const [r, c] = popped\n      for (const [nr, nc] of neighbors8(r, c)) {\n        const k = key(nr, nc)\n        if (!visited.has(k)) {\n          visited.add(k)\n          stack.push([nr, nc])\n        }\n      }\n    }\n    return visited.size === open.size\n  }\n\n  // ========================\n  // Helpers internes\n  // ========================\n\n  private inBounds(r: number, c: number): boolean {\n    return r >= 0 && r < this.rows && c >= 0 && c < this.cols\n  }\n\n  private zeroMask(): number[][] {\n    return Array(this.rows)\n      .fill(0)\n      .map(() => Array(this.cols).fill(0))\n  }\n\n  private chooseOrientation(): Orientation {\n    if (this.orientationMode === 'random') {\n      return this.rnd() > 0.5 ? 'vertical' : 'horizontal'\n    }\n    return this.orientationMode\n  }\n\n  private assignValuesToGrid(): void {\n    if (!this.grid || this.grid.length === 0) return\n\n    let gi = 0\n    let bi = 0\n    let emptyCells = 0\n    for (let r = 0; r < this.rows; r++) {\n      for (let c = 0; c < this.cols; c++) {\n        const cell = this.grid[r][c]\n        if (cell.isGood) {\n          cell.text = this.goodAnswers?.[gi++] ?? ''\n          if (cell.text === '') emptyCells++\n        } else {\n          cell.text = this.badAnswers?.[bi++] ?? ''\n          if (cell.text === '') emptyCells++\n        }\n      }\n    }\n\n    if (emptyCells > 0) {\n      console.warn(`assignValuesToGrid: ${emptyCells} cellules vides détectées`, {\n        goodUsed: gi,\n        goodAvailable: this.goodAnswers.length,\n        badUsed: bi,\n        badAvailable: this.badAnswers.length,\n      })\n    }\n  }\n\n  private cloneGrid(grid: CellGrid): CellGrid {\n    return grid.map((row) => row.map((c) => ({ isGood: c.isGood, clicked: c.clicked, text: c.text })))\n  }\n\n  /**\n   * Generate a deterministic random integer between min and max (inclusive).\n   * Uses the seeded RNG if available, otherwise falls back to Math.random.\n   */\n  randomInt(min: number, max: number): number {\n    const rng = this.valuesRnd ?? Math.random\n    return Math.floor(rng() * (max - min + 1)) + min\n  }\n\n  /**\n   * Generate a deterministic random number between 0 and 1.\n   * Uses the seeded RNG if available, otherwise falls back to Math.random.\n   */\n  random(): number {\n    return this.valuesRnd ? this.valuesRnd() : Math.random()\n  }\n  private escapeForTabular(s: string): string {\n    if (s == null) return ''\n    return String(s).replace(/&/g, '\\\\&').replace(/\\r?\\n/g, ' ')\n  }\n\n  generateLatex(options: LatexOptions = {}): string {\n    const { correction = false, align = 'c', borders = true, rowSeparators = true } = options\n    const snap = this.snapshot()\n    const rows = snap.rows\n    const cols = snap.cols\n\n    const colSpec = borders ? '|' + `${align}|`.repeat(cols) : `${align}`.repeat(cols)\n    const out: string[] = []\n    out.push(`\\\\begin{tabular}{${colSpec}}`)\n    if (rowSeparators) out.push(`\\\\hline`)\n\n    for (let i = 0; i < rows; i++) {\n      const cells: string[] = []\n      for (let j = 0; j < cols; j++) {\n        const cell = snap.grid?.[i]?.[j]\n        const isGood = !!cell?.isGood\n        let text = cell?.text ?? ''\n        if (correction && isGood) {\n          text = `\\\\textbf{${text}}`\n        }\n\n        // Griser le départ/arrivée, et en mode correction griser aussi les bonnes cases\n        const isStart = snap.start.row === i && snap.start.col === j\n        const isEnd = snap.end.row === i && snap.end.col === j\n        const shouldShade = isStart || isEnd || (correction && isGood)\n\n        let cellLatex = this.escapeForTabular(text)\n        if (shouldShade) {\n          if (cellLatex.trim() === '') {\n            cellLatex = `\\\\cellcolor{gray!20}~`\n          } else {\n            cellLatex = `\\\\cellcolor{gray!20}${cellLatex}`\n          }\n        }\n\n        cells.push(cellLatex)\n      }\n      if (rowSeparators) {\n        out.push(`${cells.join(' & ')} \\\\\\\\ \\\\hline`)\n      } else {\n        out.push(`${cells.join(' & ')} \\\\\\\\`)\n      }\n    }\n\n    out.push(`\\\\end{tabular}`)\n    return out.join('\\n')\n  }\n\n  generateLatexCorrection(options: Omit<LatexOptions, 'correction'> = {}): string {\n    return this.generateLatex({ ...options, correction: true })\n  }\n}\n\nexport default Labyrinthe\n","import type { GameSnapshot, LabyrintheRenderer as ILabyrintheRenderer, MathRenderer } from './types'\n\n/**\n * Renderer DOM pour Labyrinthe qui consomme un snapshot pur et le projette dans un ShadowRoot.\n * - Aucune logique métier ici.\n * - Aucun binding d’événements (le contrôleur s’en charge via data-row/data-col).\n * - La composition mathématique est déléguée au MathRenderer fourni (optionnel).\n */\nexport class DomLabyrintheRenderer implements ILabyrintheRenderer {\n  private math?: MathRenderer\n\n  constructor(math?: MathRenderer) {\n    this.math = math\n  }\n\n  render(root: ShadowRoot, snapshot: GameSnapshot, width?: number | null, height?: number | null): void {\n    this.ensureStyle(root)\n    const container = this.ensureContainer(root)\n\n    // Apply custom width if provided\n    if (width != null && width > 0) {\n      container.style.setProperty('--cell-width', `${width}em`)\n    } else {\n      container.style.removeProperty('--cell-width')\n    }\n\n    // Apply custom height if provided\n    if (height != null && height > 0) {\n      container.style.setProperty('--cell-height', `${height}em`)\n    } else {\n      container.style.removeProperty('--cell-height')\n    }\n\n    // Update dynamic grid template via inline styles (repeat() can't use CSS variables reliably)\n    container.style.gridTemplateColumns = `repeat(${snapshot.cols}, var(--cell-width))`\n    container.style.gridTemplateRows = `repeat(${snapshot.rows}, var(--cell-height))`\n\n    // Clear existing cells\n    this.removeGridCells(container)\n\n    // Rebuild cells\n    for (let r = 0; r < snapshot.rows; r++) {\n      for (let c = 0; c < snapshot.cols; c++) {\n        const cellState = snapshot.grid[r]?.[c]\n        const cell = document.createElement('div')\n        cell.className = 'grid-cell'\n        cell.dataset.row = String(r)\n        cell.dataset.col = String(c)\n\n        // Start/End markers\n        if (snapshot.start.row === r && snapshot.start.col === c) {\n          cell.classList.add('start')\n        }\n        if (snapshot.end.row === r && snapshot.end.col === c) {\n          cell.classList.add('end')\n        }\n\n        // Clicked state visualization\n        if (cellState?.clicked) {\n          if (cellState.isGood) cell.classList.add('correct')\n          else cell.classList.add('incorrect')\n        }\n\n        // Content\n        cell.textContent = cellState?.text ?? ''\n\n        container.appendChild(cell)\n      }\n    }\n\n    // No overlay: game over handled by disabling at component level\n\n    // Delegate math typesetting to the provided renderer (if any)\n    this.math?.typeset(container)\n  }\n\n  showCorrection(root: ShadowRoot, snapshot: GameSnapshot): void {\n    const container = root.querySelector('.grid-container') as HTMLDivElement | null\n    if (!container) return\n    for (let r = 0; r < snapshot.rows; r++) {\n      for (let c = 0; c < snapshot.cols; c++) {\n        const cell = container.querySelector(`.grid-cell[data-row=\"${r}\"][data-col=\"${c}\"]`) as HTMLDivElement | null\n        if (!cell) continue\n        const isGood = snapshot.grid[r]?.[c]?.isGood\n        if (isGood) {\n          cell.classList.add('correct')\n          cell.classList.remove('incorrect')\n        }\n      }\n    }\n  }\n\n  setDisabled(root: ShadowRoot, disabled: boolean): void {\n    const container = root.querySelector('.grid-container') as HTMLDivElement | null\n    if (!container) return\n    if (disabled) {\n      container.classList.add('disabled')\n      container.setAttribute('aria-disabled', 'true')\n      container.style.opacity = '0.6'\n      container.style.pointerEvents = 'none'\n    } else {\n      container.classList.remove('disabled')\n      container.removeAttribute('aria-disabled')\n      container.style.opacity = ''\n      container.style.pointerEvents = ''\n    }\n  }\n\n  // Internals\n\n  private ensureStyle(root: ShadowRoot): HTMLStyleElement {\n    let style = root.querySelector('style[data-labyrinthe-style=\"1\"]') as HTMLStyleElement | null\n    if (style) return style\n\n    style = document.createElement('style')\n    style.setAttribute('data-labyrinthe-style', '1')\n    style.textContent = `\n      :host {\n        --cell-width: clamp(44px, 9vw, 72px);\n        --cell-height: clamp(44px, 9vw, 72px);\n        --gap: 6px;\n        --radius: 14px;\n        --cell-radius: 12px;\n\n        --bg-start: #f8fafc; /* slate-50 */\n        --bg-end: #eef2f7;   /* subtle */\n        --border: 1px solid rgba(2, 6, 23, 0.08);\n\n        --cell-bg-start: #ffffff;\n        --cell-bg-end: #f3f6fb;\n\n        --accent: #3b82f6;       /* blue-500 */\n        --correct-1: #34d399;    /* emerald-400 */\n        --correct-2: #10b981;    /* emerald-500 */\n        --incorrect-1: #f87171;  /* red-400 */\n        --incorrect-2: #ef4444;  /* red-500 */\n        --start-1: #60a5fa;      /* blue-400 */\n        --start-2: #3b82f6;      /* blue-500 */\n        --end-1: #a78bfa;        /* violet-400 */\n        --end-2: #8b5cf6;        /* violet-500 */\n\n        --shadow: 0 6px 16px rgba(2, 6, 23, 0.09), 0 2px 6px rgba(2, 6, 23, 0.05);\n        --shadow-hover: 0 10px 24px rgba(2, 6, 23, 0.12), 0 3px 8px rgba(2, 6, 23, 0.06);\n\n        display: inline-block;\n      }\n\n      .grid-container {\n        display: grid;\n        gap: var(--gap);\n        margin: 8px auto;\n        padding: calc(var(--gap) + 6px);\n        background: linear-gradient(180deg, var(--bg-start) 0%, var(--bg-end) 100%);\n        border-radius: var(--radius);\n        border: var(--border);\n        box-shadow: var(--shadow);\n        position: relative;\n      }\n\n\n\n      .grid-cell {\n        width: var(--cell-width);\n        height: var(--cell-height);\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        font: 600 14px/1 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, \"Helvetica Neue\", Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n        color: #0f172a; /* slate-900 */\n        letter-spacing: 0.2px;\n\n        background: linear-gradient(180deg, var(--cell-bg-start) 0%, var(--cell-bg-end) 100%);\n        border-radius: var(--cell-radius);\n        border: 1px solid rgba(2, 6, 23, 0.08);\n        box-shadow:\n          0 1px 0 rgba(255, 255, 255, 0.65) inset,\n          0 1.5px 3px rgba(2, 6, 23, 0.06);\n\n        cursor: pointer;\n        user-select: none;\n        -webkit-tap-highlight-color: transparent;\n        touch-action: manipulation;\n\n        transition:\n          transform 0.18s ease,\n          background 0.25s ease,\n          box-shadow 0.25s ease,\n          color 0.25s ease,\n          border-color 0.25s ease;\n      }\n\n      .grid-cell * {\n        user-select: none;\n        pointer-events: none;\n      }\n\n      .grid-cell:hover {\n        background: linear-gradient(180deg, #eef2ff 0%, #e5e9f2 100%);\n        transform: translateY(-1px);\n        box-shadow: var(--shadow-hover);\n        border-color: rgba(2, 6, 23, 0.12);\n      }\n\n      .grid-cell:active {\n        transform: translateY(0);\n        box-shadow: 0 2px 6px rgba(2, 6, 23, 0.10);\n      }\n\n      .grid-cell.start,\n      .grid-cell.start.correct {\n        background: linear-gradient(180deg, var(--start-1) 0%, var(--start-2) 100%);\n        color: #fff;\n        border-color: transparent;\n        position: relative;\n      }\n\n      .grid-cell.end,\n      .grid-cell.end.correct {\n        background: linear-gradient(180deg, var(--end-1) 0%, var(--end-2) 100%);\n        color: #fff;\n        border-color: transparent;\n        position: relative;\n      }\n\n      .grid-cell.start::after,\n      .grid-cell.end::after {\n        position: absolute;\n        top: 6px;\n        left: 6px;\n        padding: 2px 6px;\n        border-radius: 999px;\n        font-size: 10px;\n        line-height: 1;\n        letter-spacing: .2px;\n        background: rgba(255,255,255,.85);\n        color: #0f172a;\n        border: 1px solid rgba(2,6,23,.08);\n        box-shadow: 0 1px 0 rgba(255,255,255,.6) inset, 0 1px 2px rgba(2,6,23,.08);\n        pointer-events: none;\n        content: '';\n      }\n      .grid-cell.start::after { content: \"Départ\"; }\n      .grid-cell.end::after { content: \"Arrivée\"; }\n\n      @keyframes pop {\n        0% { transform: scale(0.96); }\n        60% { transform: scale(1.03); }\n        100% { transform: scale(1); }\n      }\n\n      .grid-cell.correct,\n      .grid-cell.incorrect {\n        color: #fff;\n        border-color: transparent;\n        animation: pop 180ms ease-out;\n      }\n\n      .grid-cell.correct {\n        background: linear-gradient(180deg, var(--correct-1) 0%, var(--correct-2) 100%);\n        box-shadow:\n          0 2px 10px rgba(16, 185, 129, 0.25),\n          0 1px 0 rgba(255, 255, 255, 0.35) inset;\n      }\n\n      .grid-cell.incorrect {\n        background: linear-gradient(180deg, var(--incorrect-1) 0%, var(--incorrect-2) 100%);\n        box-shadow:\n          0 2px 10px rgba(239, 68, 68, 0.25),\n          0 1px 0 rgba(255, 255, 255, 0.35) inset;\n      }\n\n\n\n\n\n\n\n      @media (max-width: 720px) {\n        :host {\n          --gap: 5px;\n          --cell-radius: 10px;\n        }\n        .grid-container {\n          padding: calc(var(--gap) + 4px);\n        }\n        .grid-cell {\n          font-weight: 600;\n          font-size: 13px;\n        }\n        .grid-cell.start::after,\n        .grid-cell.end::after {\n          display: none;\n        }\n      }\n    `\n    root.appendChild(style)\n    return style\n  }\n\n  private ensureContainer(root: ShadowRoot): HTMLDivElement {\n    let container = root.querySelector('.grid-container') as HTMLDivElement | null\n    if (!container) {\n      container = document.createElement('div')\n      container.className = 'grid-container mx-auto'\n      root.appendChild(container)\n    }\n    return container\n  }\n\n  private removeGridCells(container: HTMLDivElement) {\n    const cells = container.querySelectorAll('.grid-cell')\n    cells.forEach((el) => {\n      el.remove()\n    })\n  }\n\n  // overlay removed\n}\n\nexport default DomLabyrintheRenderer\n","import { renderMathInElement } from 'mathlive'\n\nimport Labyrinthe from './labyrinthe/model'\nimport DomLabyrintheRenderer from './labyrinthe/renderer'\nimport type { GameEndDetail, MathRenderer, Orientation } from './labyrinthe/types'\n\n/**\n * Web Component “mince” qui délègue :\n * - la logique métier au modèle (génération du chemin, état de jeu, sérialisation)\n * - le rendu DOM au renderer (construction de la grille, styles, typesetting math)\n * - aucun overlay : quand la partie est finie, l’élément est simplement désactivé\n */\nexport default class LabyrintheElement extends HTMLElement {\n  // Lifecycle state\n  ready = false\n  gameOver = false\n  win = false\n\n  // Controller internals\n  #root: ShadowRoot\n  #model = new Labyrinthe()\n  #renderer = new DomLabyrintheRenderer(new MathliveRenderer())\n  #pendingSerializedState: string | null = null\n\n  constructor() {\n    super()\n    // Conserver un Shadow DOM fermé comme l’implémentation d’origine\n    this.#root = this.attachShadow({ mode: 'closed' })\n  }\n\n  static get observedAttributes() {\n    return ['state', 'disabled', 'seed', 'rows', 'cols', 'orientation', 'width', 'height']\n  }\n\n  connectedCallback() {\n    // Exiger une seed pour garantir la reproductibilité (comportement antérieur)\n    const seed = this.getAttribute('seed')\n    if (!seed) {\n      throw new Error('[LabyrintheElement] Missing required \"seed\" attribute')\n    }\n\n    // Configurer le modèle à partir des attributs\n    this.#configureModelFromAttributes()\n\n    // Générer un nouveau labyrinthe et premier rendu\n    this.#model.regenerate()\n    this.#renderAndPersist()\n\n    // Restaurer un éventuel état sérialisé\n    if (this.getAttribute('state')) {\n      this.#pendingSerializedState = this.getAttribute('state')\n      this.#applyPendingState()\n      this.#renderAndPersist()\n    }\n\n    // Appliquer l’état disabled si présent\n    this.#renderer.setDisabled(this.#root, this.disabled)\n\n    // Écoutes d’événements utilisateur\n    this.#bindEvents()\n\n    this.ready = true\n  }\n\n  attributeChangedCallback(name: string, _oldValue: string | null, newValue: string | null) {\n    switch (name) {\n      case 'state': {\n        // L’état peut arriver avant que la grille ne soit prête; on met en attente\n        this.#pendingSerializedState = newValue ?? ''\n        if (this.isConnected) {\n          this.#applyPendingState()\n          this.#renderAndPersist()\n        }\n        break\n      }\n      case 'disabled': {\n        if (this.isConnected) {\n          this.#renderer.setDisabled(this.#root, newValue !== null)\n        }\n        break\n      }\n      case 'seed':\n      case 'rows':\n      case 'cols':\n      case 'orientation': {\n        if (!this.isConnected) break\n        this.#configureModelFromAttributes()\n        this.#model.regenerate()\n        // Réappliquer l'éventuel state après régénération pour conserver les clics\n        if (this.#pendingSerializedState != null) {\n          this.#applyPendingState()\n        }\n        this.#renderAndPersist()\n        this.#renderer.setDisabled(this.#root, this.disabled)\n        break\n      }\n      case 'width':\n      case 'height': {\n        if (this.isConnected) {\n          this.#renderAndPersist()\n        }\n        break\n      }\n    }\n  }\n\n  // Public API (compat)\n\n  get disabled(): boolean {\n    return this.hasAttribute('disabled')\n  }\n  set disabled(v: boolean) {\n    if (v) this.setAttribute('disabled', '')\n    else this.removeAttribute('disabled')\n  }\n\n  get seed(): string {\n    return this.getAttribute('seed') ?? ''\n  }\n  set seed(v: string) {\n    if (v == null) this.removeAttribute('seed')\n    else this.setAttribute('seed', String(v))\n  }\n\n  get orientation(): 'vertical' | 'horizontal' | null {\n    const v = this.getAttribute('orientation')\n    if (v == null) return null\n    const val = v.toLowerCase()\n    if (val === 'vertical') return 'vertical'\n    if (val === 'horizontal') return 'horizontal'\n    return null\n  }\n  set orientation(v: 'vertical' | 'horizontal' | null) {\n    if (v == null) this.removeAttribute('orientation')\n    else this.setAttribute('orientation', v)\n  }\n\n  get rows(): number {\n    return this.#model.snapshot().rows\n  }\n  set rows(v: number) {\n    const n = Math.floor(Number(v))\n    if (!Number.isFinite(n) || n <= 0) return\n    this.setAttribute('rows', String(n))\n  }\n\n  get cols(): number {\n    return this.#model.snapshot().cols\n  }\n  set cols(v: number) {\n    const n = Math.floor(Number(v))\n    if (!Number.isFinite(n) || n <= 0) return\n    this.setAttribute('cols', String(n))\n  }\n\n  get state(): string {\n    return this.getAttribute('state') ?? ''\n  }\n  set state(v: string) {\n    const s = v == null ? '' : String(v)\n    if (this.getAttribute('state') !== s) {\n      this.setAttribute('state', s)\n    }\n  }\n\n  get width(): number | null {\n    const w = this.getAttribute('width')\n    if (w == null) return null\n    const n = parseFloat(w)\n    return Number.isFinite(n) && n > 0 ? n : null\n  }\n  set width(v: number | null) {\n    if (v == null) this.removeAttribute('width')\n    else this.setAttribute('width', String(v))\n  }\n\n  get height(): number | null {\n    const h = this.getAttribute('height')\n    if (h == null) return null\n    const n = parseFloat(h)\n    return Number.isFinite(n) && n > 0 ? n : null\n  }\n  set height(v: number | null) {\n    if (v == null) this.removeAttribute('height')\n    else this.setAttribute('height', String(v))\n  }\n\n  get numberOfGoodAnswers(): number {\n    return this.#model.numberOfGoodAnswers()\n  }\n\n  get numberOfIncorrectAnswers(): number {\n    return this.#model.numberOfIncorrectAnswers()\n  }\n\n  get correctClicks(): number {\n    return this.#model.snapshot().correctClicks\n  }\n\n  get totalGood(): number {\n    return this.#model.numberOfGoodAnswers()\n  }\n\n  regenerate() {\n    this.#model.regenerate()\n    this.#renderAndPersist()\n  }\n\n  /**\n   * Met à jour le contenu (bonnes/mauvaises valeurs) puis re-render.\n   */\n  setValues(good: string[], bad: string[]) {\n    this.#model.setValues(good, bad)\n    this.#renderAndPersist()\n  }\n\n  /**\n   * Affiche la correction visuelle.\n   * Note: n’impacte pas l’état du modèle (pas de game over forcé).\n   */\n  showCorrection() {\n    const snap = this.#model.snapshot()\n    this.#renderer.showCorrection(this.#root, snap)\n    // Persiste l’état actuel (inchangé)\n    this.#persistState()\n  }\n\n  /**\n   * Export LaTeX du tableau, avec ou sans mise en évidence des bonnes cases.\n   */\n  get latex(): string {\n    return this.#generateLatex(false)\n  }\n  set latex(_: string) {\n    this.setAttribute('latex', this.#generateLatex(false))\n  }\n  get latexCorrection(): string {\n    return this.#generateLatex(true)\n  }\n\n  // Internals\n\n  #configureModelFromAttributes() {\n    const seed = this.getAttribute('seed') ?? null\n    const rowsAttr = this.getAttribute('rows')\n    const colsAttr = this.getAttribute('cols')\n    const orientationAttr = this.getAttribute('orientation')\n\n    const rows = rowsAttr != null ? Math.floor(parseInt(rowsAttr, 10)) : undefined\n    const cols = colsAttr != null ? Math.floor(parseInt(colsAttr, 10)) : undefined\n    const orientation: Orientation | undefined =\n      orientationAttr && (orientationAttr.toLowerCase() === 'vertical' || orientationAttr.toLowerCase() === 'horizontal')\n        ? (orientationAttr.toLowerCase() as Orientation)\n        : undefined\n\n    this.#model.configure({\n      seed,\n      rows,\n      cols,\n      orientation,\n    })\n  }\n\n  #bindEvents() {\n    // Délégation de clic sur les cellules (repérées par data-row/data-col)\n    this.#root.addEventListener('click', (e: Event) => {\n      if (this.gameOver || this.disabled) return\n      const target = e.composedPath().find((n) => n instanceof HTMLElement && n.classList.contains('grid-cell')) as\n        | HTMLElement\n        | undefined\n      if (!target) return\n      const r = target.dataset.row\n      const c = target.dataset.col\n      if (r == null || c == null) return\n\n      const before = this.#model.snapshot().gameOver\n      this.#model.clickCell(parseInt(r, 10), parseInt(c, 10))\n      this.#renderAndPersist()\n\n      const afterSnap = this.#model.snapshot()\n      this.gameOver = afterSnap.gameOver\n      this.win = afterSnap.win\n\n      if (!before && afterSnap.gameOver) {\n        // Désactiver l’interaction (comportement antérieur dans endGame)\n        this.disabled = true\n        const detail: GameEndDetail = {\n          win: afterSnap.win,\n          correctClicks: afterSnap.correctClicks,\n          totalGood: this.#model.numberOfGoodAnswers(),\n          totalBad: this.#model.numberOfIncorrectAnswers(),\n          state: this.state,\n        }\n        this.dispatchEvent(\n          new CustomEvent('labyrinthe:gameend', {\n            detail,\n            bubbles: true,\n            composed: true,\n          }),\n        )\n      }\n    })\n  }\n\n  #renderAndPersist() {\n    const snap = this.#model.snapshot()\n    this.#renderer.render(this.#root, snap, this.width, this.height)\n    this.#persistState()\n    // Synchroniser les propriétés publiques avec l'état du modèle\n    this.gameOver = snap.gameOver\n    this.win = snap.win\n  }\n\n  #persistState() {\n    // Persistance via attribut `state` (format interne JSON)\n    const s = this.#model.serializeState()\n    if (this.getAttribute('state') !== s) {\n      this.setAttribute('state', s)\n    }\n  }\n\n  #applyPendingState() {\n    if (this.#pendingSerializedState == null) return\n\n    const raw = this.#pendingSerializedState\n    this.#pendingSerializedState = null\n\n    // Si la chaîne semble être du JSON -> on passe tel quel au modèle\n    const trimmed = raw.trim()\n    if (trimmed.startsWith('{') || trimmed.startsWith('[')) {\n      this.#model.restoreState(trimmed)\n      return\n    }\n\n    // Compat: ancien format \"r-c|r-c|...\"\n    const snap = this.#model.snapshot()\n    const rows = snap.rows\n    const cols = snap.cols\n\n    const clicked = Array(rows)\n      .fill(0)\n      .map(() => Array(cols).fill(0))\n\n    const tokens = trimmed\n      .split('|')\n      .map((s) => s.trim())\n      .filter((s) => s.length > 0)\n\n    for (const t of tokens) {\n      const [rs, cs] = t.split('-')\n      if (rs == null || cs == null) continue\n      const r = parseInt(rs, 10)\n      const c = parseInt(cs, 10)\n      if (Number.isFinite(r) && Number.isFinite(c) && r >= 0 && r < rows && c >= 0 && c < cols) {\n        clicked[r][c] = 1\n      }\n    }\n\n    const json = JSON.stringify({\n      c: 0,\n      b: 0,\n      g: clicked,\n    })\n    this.#model.restoreState(json)\n  }\n\n  // LaTeX generation (reprend la logique initiale, indépendante du DOM)\n  #generateLatex(correction: boolean): string {\n    return correction ? this.#model.generateLatexCorrection() : this.#model.generateLatex()\n  }\n}\n\n/**\n * Adaptateur vers MathLive respectant l’interface MathRenderer.\n * - injecte la feuille de styles MathLive dans le ShadowRoot si absent\n * - lance le typesetting sur le conteneur passé par le renderer\n */\nclass MathliveRenderer implements MathRenderer {\n  typeset(root: Element | ShadowRoot): void {\n    // Injecte le style MathLive une seule fois dans le ShadowRoot (si disponible)\n    const shadow = root instanceof ShadowRoot ? root : (root.getRootNode() as ShadowRoot | Document)\n    const hostShadow = shadow instanceof ShadowRoot ? shadow : null\n    if (hostShadow && !hostShadow.querySelector('style[data-mathlive-style=\"1\"]')) {\n      const s = document.createElement('style')\n      s.setAttribute('data-mathlive-style', '1')\n      s.textContent = `@import url(\"https://cdn.jsdelivr.net/npm/mathlive/mathlive-static.css\");`\n      hostShadow.appendChild(s)\n    }\n\n    // Typesetting\n    if (root instanceof HTMLElement) {\n      renderMathInElement(root, {\n        TeX: {\n          delimiters: {\n            inline: [\n              ['$', '$'],\n              ['\\\\(', '\\\\)'],\n            ],\n            display: [],\n          },\n        },\n      })\n    }\n  }\n}\n"],"names":["Labyrinthe","opts","seedrandom","n","mask","start","end","orientation","_","r","__","c","good","bad","row","col","cell","clicked","state","parsed","g","v","_a","correct","wrong","count","_c","_b","attempt","result","currentRow","currentCol","path","touchesOnlyCurrent","curR","curC","dr","dc","nr","nc","maxSteps","steps","neighbors","newRow","newCol","nextRow","nextCol","key","open","inOpen","neighbors8","out","deg1","id","d","stack","visited","popped","k","gi","bi","emptyCells","grid","min","max","rng","options","correction","align","borders","rowSeparators","snap","rows","cols","colSpec","i","cells","j","isGood","text","isStart","isEnd","shouldShade","cellLatex","DomLabyrintheRenderer","math","root","snapshot","width","height","container","cellState","disabled","style","el","LabyrintheElement","__privateAdd","_LabyrintheElement_instances","_root","_model","_renderer","_pendingSerializedState","__privateSet","MathliveRenderer","__privateMethod","configureModelFromAttributes_fn","__privateGet","renderAndPersist_fn","applyPendingState_fn","bindEvents_fn","name","_oldValue","newValue","val","s","w","h","persistState_fn","generateLatex_fn","seed","rowsAttr","colsAttr","orientationAttr","e","target","before","afterSnap","detail","raw","trimmed","tokens","t","rs","cs","json","shadow","hostShadow","renderMathInElement"],"mappings":"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","x_google_ignoreList":[0,1,2]}