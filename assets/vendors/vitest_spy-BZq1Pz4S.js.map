{"version":3,"file":"vitest_spy-BZq1Pz4S.js","sources":["../../../node_modules/.pnpm/@vitest+spy@4.0.18/node_modules/@vitest/spy/dist/index.js"],"sourcesContent":["function isMockFunction(fn) {\n\treturn typeof fn === \"function\" && \"_isMockFunction\" in fn && fn._isMockFunction === true;\n}\nconst MOCK_RESTORE = new Set();\n// Jest keeps the state in a separate WeakMap which is good for memory,\n// but it makes the state slower to access and return different values\n// if you stored it before calling `mockClear` where it will be recreated\nconst REGISTERED_MOCKS = new Set();\nconst MOCK_CONFIGS = new WeakMap();\nfunction createMockInstance(options = {}) {\n\tvar _ref;\n\tconst { originalImplementation, restore, mockImplementation, resetToMockImplementation, resetToMockName } = options;\n\tif (restore) {\n\t\tMOCK_RESTORE.add(restore);\n\t}\n\tconst config = getDefaultConfig(originalImplementation);\n\tconst state = getDefaultState();\n\tconst mock = createMock({\n\t\tconfig,\n\t\tstate,\n\t\t...options\n\t});\n\tconst mockLength = ((_ref = mockImplementation || originalImplementation) === null || _ref === void 0 ? void 0 : _ref.length) ?? 0;\n\tObject.defineProperty(mock, \"length\", {\n\t\twritable: true,\n\t\tenumerable: false,\n\t\tvalue: mockLength,\n\t\tconfigurable: true\n\t});\n\t// inherit the default name so it appears in snapshots and logs\n\t// this is used by `vi.spyOn()` for better debugging.\n\t// when `vi.fn()` is called, we just use the default string\n\tif (resetToMockName) {\n\t\tconfig.mockName = mock.name || \"vi.fn()\";\n\t}\n\tMOCK_CONFIGS.set(mock, config);\n\tREGISTERED_MOCKS.add(mock);\n\tmock._isMockFunction = true;\n\tmock.getMockImplementation = () => {\n\t\t// Jest only returns `config.mockImplementation` here,\n\t\t// but we think it makes sense to return what the next function will be called\n\t\treturn config.onceMockImplementations[0] || config.mockImplementation;\n\t};\n\tObject.defineProperty(mock, \"mock\", {\n\t\tconfigurable: false,\n\t\tenumerable: true,\n\t\twritable: false,\n\t\tvalue: state\n\t});\n\tmock.mockImplementation = function mockImplementation(implementation) {\n\t\tconfig.mockImplementation = implementation;\n\t\treturn mock;\n\t};\n\tmock.mockImplementationOnce = function mockImplementationOnce(implementation) {\n\t\tconfig.onceMockImplementations.push(implementation);\n\t\treturn mock;\n\t};\n\tmock.withImplementation = function withImplementation(implementation, callback) {\n\t\tconst previousImplementation = config.mockImplementation;\n\t\tconst previousOnceImplementations = config.onceMockImplementations;\n\t\tconst reset = () => {\n\t\t\tconfig.mockImplementation = previousImplementation;\n\t\t\tconfig.onceMockImplementations = previousOnceImplementations;\n\t\t};\n\t\tconfig.mockImplementation = implementation;\n\t\tconfig.onceMockImplementations = [];\n\t\tconst returnValue = callback();\n\t\tif (typeof returnValue === \"object\" && typeof (returnValue === null || returnValue === void 0 ? void 0 : returnValue.then) === \"function\") {\n\t\t\treturn returnValue.then(() => {\n\t\t\t\treset();\n\t\t\t\treturn mock;\n\t\t\t});\n\t\t} else {\n\t\t\treset();\n\t\t}\n\t\treturn mock;\n\t};\n\tmock.mockReturnThis = function mockReturnThis() {\n\t\treturn mock.mockImplementation(function() {\n\t\t\treturn this;\n\t\t});\n\t};\n\tmock.mockReturnValue = function mockReturnValue(value) {\n\t\treturn mock.mockImplementation(() => value);\n\t};\n\tmock.mockReturnValueOnce = function mockReturnValueOnce(value) {\n\t\treturn mock.mockImplementationOnce(() => value);\n\t};\n\tmock.mockResolvedValue = function mockResolvedValue(value) {\n\t\treturn mock.mockImplementation(() => Promise.resolve(value));\n\t};\n\tmock.mockResolvedValueOnce = function mockResolvedValueOnce(value) {\n\t\treturn mock.mockImplementationOnce(() => Promise.resolve(value));\n\t};\n\tmock.mockRejectedValue = function mockRejectedValue(value) {\n\t\treturn mock.mockImplementation(() => Promise.reject(value));\n\t};\n\tmock.mockRejectedValueOnce = function mockRejectedValueOnce(value) {\n\t\treturn mock.mockImplementationOnce(() => Promise.reject(value));\n\t};\n\tmock.mockClear = function mockClear() {\n\t\tstate.calls = [];\n\t\tstate.contexts = [];\n\t\tstate.instances = [];\n\t\tstate.invocationCallOrder = [];\n\t\tstate.results = [];\n\t\tstate.settledResults = [];\n\t\treturn mock;\n\t};\n\tmock.mockReset = function mockReset() {\n\t\tmock.mockClear();\n\t\tconfig.mockImplementation = resetToMockImplementation ? mockImplementation : undefined;\n\t\tconfig.mockName = resetToMockName ? mock.name || \"vi.fn()\" : \"vi.fn()\";\n\t\tconfig.onceMockImplementations = [];\n\t\treturn mock;\n\t};\n\tmock.mockRestore = function mockRestore() {\n\t\tmock.mockReset();\n\t\treturn restore === null || restore === void 0 ? void 0 : restore();\n\t};\n\tmock.mockName = function mockName(name) {\n\t\tif (typeof name === \"string\") {\n\t\t\tconfig.mockName = name;\n\t\t}\n\t\treturn mock;\n\t};\n\tmock.getMockName = function getMockName() {\n\t\treturn config.mockName || \"vi.fn()\";\n\t};\n\tif (Symbol.dispose) {\n\t\tmock[Symbol.dispose] = () => mock.mockRestore();\n\t}\n\tif (mockImplementation) {\n\t\tmock.mockImplementation(mockImplementation);\n\t}\n\treturn mock;\n}\nfunction fn(originalImplementation) {\n\t// if the function is already a mock, just return the same function,\n\t// simillarly to how vi.spyOn() works\n\tif (originalImplementation != null && isMockFunction(originalImplementation)) {\n\t\treturn originalImplementation;\n\t}\n\treturn createMockInstance({\n\t\tmockImplementation: originalImplementation,\n\t\tresetToMockImplementation: true\n\t});\n}\nfunction spyOn(object, key, accessor) {\n\tassert(object != null, \"The vi.spyOn() function could not find an object to spy upon. The first argument must be defined.\");\n\tassert(typeof object === \"object\" || typeof object === \"function\", \"Vitest cannot spy on a primitive value.\");\n\tconst [originalDescriptorObject, originalDescriptor] = getDescriptor(object, key) || [];\n\tassert(originalDescriptor || key in object, `The property \"${String(key)}\" is not defined on the ${typeof object}.`);\n\tlet accessType = accessor || \"value\";\n\tlet ssr = false;\n\t// vite ssr support - actual function is stored inside a getter\n\tif (accessType === \"value\" && originalDescriptor && originalDescriptor.value == null && originalDescriptor.get) {\n\t\taccessType = \"get\";\n\t\tssr = true;\n\t}\n\tlet original;\n\tif (originalDescriptor) {\n\t\toriginal = originalDescriptor[accessType];\n\t} else if (accessType !== \"value\") {\n\t\toriginal = () => object[key];\n\t} else {\n\t\toriginal = object[key];\n\t}\n\tconst originalImplementation = ssr && original ? original() : original;\n\tconst originalType = typeof originalImplementation;\n\tassert(\n\t\t// allow only functions\n\t\toriginalType === \"function\" || accessType !== \"value\" && original == null,\n\t\t`vi.spyOn() can only spy on a function. Received ${originalType}.`\n\t);\n\tif (isMockFunction(originalImplementation)) {\n\t\treturn originalImplementation;\n\t}\n\tconst reassign = (cb) => {\n\t\tconst { value, ...desc } = originalDescriptor || {\n\t\t\tconfigurable: true,\n\t\t\twritable: true\n\t\t};\n\t\tif (accessType !== \"value\") {\n\t\t\tdelete desc.writable;\n\t\t}\n\t\tdesc[accessType] = cb;\n\t\tObject.defineProperty(object, key, desc);\n\t};\n\tconst restore = () => {\n\t\t// if method is defined on the prototype, we can just remove it from\n\t\t// the current object instead of redefining a copy of it\n\t\tif (originalDescriptorObject !== object) {\n\t\t\tReflect.deleteProperty(object, key);\n\t\t} else if (originalDescriptor && !original) {\n\t\t\tObject.defineProperty(object, key, originalDescriptor);\n\t\t} else {\n\t\t\treassign(original);\n\t\t}\n\t};\n\tconst mock = createMockInstance({\n\t\trestore,\n\t\toriginalImplementation,\n\t\tresetToMockName: true\n\t});\n\ttry {\n\t\treassign(ssr ? () => mock : mock);\n\t} catch (error) {\n\t\tif (error instanceof TypeError && Symbol.toStringTag && object[Symbol.toStringTag] === \"Module\" && (error.message.includes(\"Cannot redefine property\") || error.message.includes(\"Cannot replace module namespace\") || error.message.includes(\"can't redefine non-configurable property\"))) {\n\t\t\tthrow new TypeError(`Cannot spy on export \"${String(key)}\". Module namespace is not configurable in ESM. See: https://vitest.dev/guide/browser/#limitations`, { cause: error });\n\t\t}\n\t\tthrow error;\n\t}\n\treturn mock;\n}\nfunction getDescriptor(obj, method) {\n\tconst objDescriptor = Object.getOwnPropertyDescriptor(obj, method);\n\tif (objDescriptor) {\n\t\treturn [obj, objDescriptor];\n\t}\n\tlet currentProto = Object.getPrototypeOf(obj);\n\twhile (currentProto !== null) {\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(currentProto, method);\n\t\tif (descriptor) {\n\t\t\treturn [currentProto, descriptor];\n\t\t}\n\t\tcurrentProto = Object.getPrototypeOf(currentProto);\n\t}\n}\nfunction assert(condition, message) {\n\tif (!condition) {\n\t\tthrow new Error(message);\n\t}\n}\nlet invocationCallCounter = 1;\nfunction createMock({ state, config, name: mockName, prototypeState, prototypeConfig, keepMembersImplementation, mockImplementation, prototypeMembers = [] }) {\n\tconst original = config.mockOriginal;\n\tconst pseudoOriginal = mockImplementation;\n\tconst name = mockName || (original === null || original === void 0 ? void 0 : original.name) || \"Mock\";\n\tconst namedObject = { [name]: (function(...args) {\n\t\tregisterCalls(args, state, prototypeState);\n\t\tregisterInvocationOrder(invocationCallCounter++, state, prototypeState);\n\t\tconst result = {\n\t\t\ttype: \"incomplete\",\n\t\t\tvalue: undefined\n\t\t};\n\t\tconst settledResult = {\n\t\t\ttype: \"incomplete\",\n\t\t\tvalue: undefined\n\t\t};\n\t\tregisterResult(result, state, prototypeState);\n\t\tregisterSettledResult(settledResult, state, prototypeState);\n\t\tconst context = new.target ? undefined : this;\n\t\tconst [instanceIndex, instancePrototypeIndex] = registerInstance(context, state, prototypeState);\n\t\tconst [contextIndex, contextPrototypeIndex] = registerContext(context, state, prototypeState);\n\t\tconst implementation = config.onceMockImplementations.shift() || config.mockImplementation || (prototypeConfig === null || prototypeConfig === void 0 ? void 0 : prototypeConfig.onceMockImplementations.shift()) || (prototypeConfig === null || prototypeConfig === void 0 ? void 0 : prototypeConfig.mockImplementation) || original || function() {};\n\t\tlet returnValue;\n\t\tlet thrownValue;\n\t\tlet didThrow = false;\n\t\ttry {\n\t\t\tif (new.target) {\n\t\t\t\treturnValue = Reflect.construct(implementation, args, new.target);\n\t\t\t\t// jest calls this before the implementation, but we have to resolve this _after_\n\t\t\t\t// because we cannot do it before the `Reflect.construct` called the custom implementation.\n\t\t\t\t// fortunetly, the constructor is always an empty functon because `prototypeMethods`\n\t\t\t\t// are only used by the automocker, so this doesn't matter\n\t\t\t\tfor (const prop of prototypeMembers) {\n\t\t\t\t\tconst prototypeMock = returnValue[prop];\n\t\t\t\t\t// the method was overidden because of inheritence, ignore it\n\t\t\t\t\t// eslint-disable-next-line ts/no-use-before-define\n\t\t\t\t\tif (prototypeMock !== mock.prototype[prop]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst isMock = isMockFunction(prototypeMock);\n\t\t\t\t\tconst prototypeState = isMock ? prototypeMock.mock : undefined;\n\t\t\t\t\tconst prototypeConfig = isMock ? MOCK_CONFIGS.get(prototypeMock) : undefined;\n\t\t\t\t\treturnValue[prop] = createMockInstance({\n\t\t\t\t\t\toriginalImplementation: keepMembersImplementation ? prototypeConfig === null || prototypeConfig === void 0 ? void 0 : prototypeConfig.mockOriginal : undefined,\n\t\t\t\t\t\tprototypeState,\n\t\t\t\t\t\tprototypeConfig,\n\t\t\t\t\t\tkeepMembersImplementation\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturnValue = implementation.apply(this, args);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrownValue = error;\n\t\t\tdidThrow = true;\n\t\t\tif (error instanceof TypeError && error.message.includes(\"is not a constructor\")) {\n\t\t\t\tconsole.warn(`[vitest] The ${namedObject[name].getMockName()} mock did not use 'function' or 'class' in its implementation, see https://vitest.dev/api/vi#vi-spyon for examples.`);\n\t\t\t}\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tif (didThrow) {\n\t\t\t\tresult.type = \"throw\";\n\t\t\t\tresult.value = thrownValue;\n\t\t\t\tsettledResult.type = \"rejected\";\n\t\t\t\tsettledResult.value = thrownValue;\n\t\t\t} else {\n\t\t\t\tresult.type = \"return\";\n\t\t\t\tresult.value = returnValue;\n\t\t\t\tif (new.target) {\n\t\t\t\t\tstate.contexts[contextIndex - 1] = returnValue;\n\t\t\t\t\tstate.instances[instanceIndex - 1] = returnValue;\n\t\t\t\t\tif (contextPrototypeIndex != null && prototypeState) {\n\t\t\t\t\t\tprototypeState.contexts[contextPrototypeIndex - 1] = returnValue;\n\t\t\t\t\t}\n\t\t\t\t\tif (instancePrototypeIndex != null && prototypeState) {\n\t\t\t\t\t\tprototypeState.instances[instancePrototypeIndex - 1] = returnValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (returnValue instanceof Promise) {\n\t\t\t\t\treturnValue.then((settledValue) => {\n\t\t\t\t\t\tsettledResult.type = \"fulfilled\";\n\t\t\t\t\t\tsettledResult.value = settledValue;\n\t\t\t\t\t}, (rejectedValue) => {\n\t\t\t\t\t\tsettledResult.type = \"rejected\";\n\t\t\t\t\t\tsettledResult.value = rejectedValue;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tsettledResult.type = \"fulfilled\";\n\t\t\t\t\tsettledResult.value = returnValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn returnValue;\n\t}) };\n\tconst mock = namedObject[name];\n\tconst copyPropertiesFrom = original || pseudoOriginal;\n\tif (copyPropertiesFrom) {\n\t\tcopyOriginalStaticProperties(mock, copyPropertiesFrom);\n\t}\n\treturn mock;\n}\nfunction registerCalls(args, state, prototypeState) {\n\tstate.calls.push(args);\n\tprototypeState === null || prototypeState === void 0 ? void 0 : prototypeState.calls.push(args);\n}\nfunction registerInvocationOrder(order, state, prototypeState) {\n\tstate.invocationCallOrder.push(order);\n\tprototypeState === null || prototypeState === void 0 ? void 0 : prototypeState.invocationCallOrder.push(order);\n}\nfunction registerResult(result, state, prototypeState) {\n\tstate.results.push(result);\n\tprototypeState === null || prototypeState === void 0 ? void 0 : prototypeState.results.push(result);\n}\nfunction registerSettledResult(result, state, prototypeState) {\n\tstate.settledResults.push(result);\n\tprototypeState === null || prototypeState === void 0 ? void 0 : prototypeState.settledResults.push(result);\n}\nfunction registerInstance(instance, state, prototypeState) {\n\tconst instanceIndex = state.instances.push(instance);\n\tconst instancePrototypeIndex = prototypeState === null || prototypeState === void 0 ? void 0 : prototypeState.instances.push(instance);\n\treturn [instanceIndex, instancePrototypeIndex];\n}\nfunction registerContext(context, state, prototypeState) {\n\tconst contextIndex = state.contexts.push(context);\n\tconst contextPrototypeIndex = prototypeState === null || prototypeState === void 0 ? void 0 : prototypeState.contexts.push(context);\n\treturn [contextIndex, contextPrototypeIndex];\n}\nfunction copyOriginalStaticProperties(mock, original) {\n\tconst { properties, descriptors } = getAllProperties(original);\n\tfor (const key of properties) {\n\t\tconst descriptor = descriptors[key];\n\t\tconst mockDescriptor = getDescriptor(mock, key);\n\t\tif (mockDescriptor) {\n\t\t\tcontinue;\n\t\t}\n\t\tObject.defineProperty(mock, key, descriptor);\n\t}\n}\nconst ignoreProperties = new Set([\n\t\"length\",\n\t\"name\",\n\t\"prototype\",\n\tSymbol.for(\"nodejs.util.promisify.custom\")\n]);\nfunction getAllProperties(original) {\n\tconst properties = new Set();\n\tconst descriptors = {};\n\twhile (original && original !== Object.prototype && original !== Function.prototype) {\n\t\tconst ownProperties = [...Object.getOwnPropertyNames(original), ...Object.getOwnPropertySymbols(original)];\n\t\tfor (const prop of ownProperties) {\n\t\t\tif (descriptors[prop] || ignoreProperties.has(prop)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tproperties.add(prop);\n\t\t\tdescriptors[prop] = Object.getOwnPropertyDescriptor(original, prop);\n\t\t}\n\t\toriginal = Object.getPrototypeOf(original);\n\t}\n\treturn {\n\t\tproperties,\n\t\tdescriptors\n\t};\n}\nfunction getDefaultConfig(original) {\n\treturn {\n\t\tmockImplementation: undefined,\n\t\tmockOriginal: original,\n\t\tmockName: \"vi.fn()\",\n\t\tonceMockImplementations: []\n\t};\n}\nfunction getDefaultState() {\n\tconst state = {\n\t\tcalls: [],\n\t\tcontexts: [],\n\t\tinstances: [],\n\t\tinvocationCallOrder: [],\n\t\tsettledResults: [],\n\t\tresults: [],\n\t\tget lastCall() {\n\t\t\treturn state.calls.at(-1);\n\t\t}\n\t};\n\treturn state;\n}\nfunction restoreAllMocks() {\n\tfor (const restore of MOCK_RESTORE) {\n\t\trestore();\n\t}\n\tMOCK_RESTORE.clear();\n}\nfunction clearAllMocks() {\n\tREGISTERED_MOCKS.forEach((mock) => mock.mockClear());\n}\nfunction resetAllMocks() {\n\tREGISTERED_MOCKS.forEach((mock) => mock.mockReset());\n}\n\nexport { clearAllMocks, createMockInstance, fn, isMockFunction, resetAllMocks, restoreAllMocks, spyOn };\n"],"names":["isMockFunction","fn"],"mappings":"AAAA,SAASA,EAAeC,EAAI,CAC3B,OAAO,OAAOA,GAAO,YAAc,oBAAqBA,GAAMA,EAAG,kBAAoB,EACtF","x_google_ignoreList":[0]}