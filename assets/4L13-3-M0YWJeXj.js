var ue=Object.defineProperty;var le=(I,h,n)=>h in I?ue(I,h,{enumerable:!0,configurable:!0,writable:!0,value:n}):I[h]=n;var W=(I,h,n)=>le(I,typeof h!="symbol"?h+"":h,n);import{l as j}from"./shapes2d-Cs6625Hh.js";import{f as N}from"./fixeBordures-BSnKuTIe.js";import{l as A,V as S,s as B,c as X,u as Z,p as ee}from"./patternsPreDef-BJu_hkV3.js";import{p as T}from"./PointAbstrait-Cz1GEocE.js";import{p as ce}from"./polygones-BMzqJQvg.js";import{t as fe}from"./textes-BLrhx9_h.js";import{c as te}from"./lists-OzKsERu-.js";import{E as he,Y as se,_ as $e,al as be,aK as de,P as re,B as Q,aI as k,x as g,r as xe}from"./index-Dkwu26bg.js";import{m as H}from"./mathalea2d-DE7tFmfi.js";import{V as ye}from"./VisualPattern-DrFIwudX.js";import{b as _}from"./colors-vbveSA7f.js";import"./Figures2D-BKzLU3YL.js";import"./ObjetMathalea2D-CXcNXRpD.js";import"./transformations-CrKJZhMe.js";import"./droites-1cMQNrTw.js";import"./utilitairesGeometriques-rO8Jz15i.js";import"./segmentsVecteurs-DWWtoN_4.js";import"./vendors/roughjs-CycZv-lV.js";import"./Vide2d-lYMmc9eB.js";import"./Canvas3DElement-Ce07yeYA.js";import"./vendors/troika-three-text-CseoN0LQ.js";import"./vendors/three-q_6hD11P.js";import"./vendors/troika-worker-utils-DbVzmR1E.js";import"./vendors/webgl-sdf-generator-qD_8IFx2.js";import"./vendors/bidi-js-DLACMwmw.js";import"./vendors/troika-three-utils-DzUc9kqZ.js";import"./vendors/earcut-jJVragJp.js";import"./pattern-DWd8Ia-0.js";/* empty css                         */import"./vendors/svelte-BrkG1v2Q.js";import"./vendors/clsx-B-dksMZM.js";import"./vendors/esm-env-rsSWfq8L.js";import"./vendors/ua-parser-js-D4W63oil.js";import"./vendors/decimal.js-BceHFVC1.js";import"./vendors/katex-BISJkeK-.js";import"./vendors/seedrandom-Cz-2rAdY.js";import"./vendors/apigeom-CvUqzk7F.js";import"./vendors/mathjs-DKCMnljp.js";import"./vendors/babel_runtime-BFeZ_VDU.js";import"./vendors/javascript-natural-sort-QZS4Fyws.js";import"./vendors/escape-latex-BegatI0j.js";import"./vendors/complex.js-C1JbXRlX.js";import"./vendors/typed-function-CVM02vEe.js";import"./vendors/fraction.js-CYLvagDM.js";import"./vendors/tiny-emitter-DbO2P2s3.js";import"./vendors/xstate-BSXD3zxA.js";import"./vendors/crypto-js-DElKCTCw.js";import"./json/referentielStaticCH-DrWiqhRe.js";import"./json/referentielStaticFR-DTeSOhOd.js";import"./json/uuidsToUrlFR-Cc7zu7XX.js";import"./vendors/cortex-js_compute-engine-Bo_2zfG3.js";import"./vendors/jspreadsheet-ce-kKqtlqR-.js";import"./vendors/jsuites-D-TmSgJs.js";import"./vendors/jspreadsheet_formula-CXu1m5Ak.js";import"./vendors/mathlive-2YgxEGya.js";import"./vendors/bugsnag_js-B7oJ4uO9.js";import"./vendors/bugsnag_browser-CBi0d3dm.js";import"./vendors/big-integer-RrBdqg8C.js";import"./vendors/mixer_postmessage-rpc-JyZjM7pP.js";import"./vendors/eventemitter3-COjgItKg.js";import"./vendors/scratchblocks-BVPCj2Ee.js";import"./json/scratchFr-BNITwCy2.js";import"./json/refToUuidFR-DByOnDAE.js";import"./json/refToUuidCH-Co2Ho8bY.js";import"./json/codeToLevelList-BfkorBF2.js";import"./json/codeToThemeList-B4uzTsqe.js";import"./vendors/loadjs-Dy50zFDn.js";import"./json/referentielProfs-BdpwqI3j.js";import"./json/uuidsRessources-jdCgFfXb.js";import"./json/referentielBibliotheque-sQm1j5fm.js";import"./vendors/file-saver-Cqu1O8xU.js";import"./vendors/jszip-BuNf6wCF.js";import"./vendors/jszip-utils-DhFX1KUq.js";import"./vendors/copy-image-clipboard-Cf9y-QAU.js";import"./vendors/qrcode-BsrOgw3n.js";import"./vendors/dijkstrajs-COg3n3zL.js";import"./vendors/brace-DEOAbY2S.js";import"./json/referentielAppsTierce-SxU58PZT.js";import"./vendors/sortablejs-DdTU3J9A.js";import"./json/carouselContent-Bjt6Yxr-.js";import"./json/levelsThemesList-CXNnIZKX.js";import"./json/levelsThemesListCH-BErSids0.js";import"./json/referentiel2022CH-DjDOIBSG.js";import"./json/referentiel2022FR-BT6kfVfP.js";import"./json/referentielGeometrieDynamique-BJ2PHXsv.js";import"./json/referentielRessources-BU2QQoSD.js";import"./json/referentielsActivation-CpD_hoec.js";const ts="Comprendre un algorithme itératif",ss=!0,rs="mathLive",os="10/06/2025",is="22/11/2025",ns="328b3",as={"fr-fr":["4L13-3"],"fr-2016":["6I13"],"fr-ch":["autres-14"]};class ms extends he{constructor(){super();W(this,"destroyers",[]);this.nbQuestions=3,this.comment=`Étudier les premiers termes d'une série de motifs afin de donner le nombre de formes du motif suivant.

 Les patterns sont des motifs figuratifs qui évoluent selon des règles définies.

 Cet exercice contient des patterns issus de l'excellent site : https://www.visualpatterns.org/.<br>
Grâce au dernier paramètre, on peut imposer des patterns choisis dans cette <a href="https://coopmaths.fr/alea/?uuid=71ff5&s=6" target="_blank" style="color: blue">liste de patterns</a>.<br>
Si le nombre de questions est supérieur au nombre de patterns choisis, alors l'exercice sera complété par des patterns choisis au hasard.`,this.besoinFormulaireNumerique=["Nombre de figures par question",4],this.sup=3,this.besoinFormulaire4Texte=["Types de questions",`Nombres séparés par des tirets :
1: Motif suivant à dessiner
2 : Motif suivant (nombre)
3 : Motif 10 (nombre)
4 : Numéro du motif
5 : Motif 100 (nombre)
6 : Question au hasard parmi les 5 précédentes`],this.sup4="6";const n=A.length;this.besoinFormulaire5Texte=["Numéros des pattern désirés :",["Nombres séparés par des tirets  :",`Mettre des nombres entre 1 et ${n}.`,`Mettre ${n+1} pour laisser le hasard faire.`].join(`
`)],this.sup5=`${n+1}`}destroy(){this.destroyers.forEach(n=>n()),this.destroyers.length=0}nouvelleVersion(){this.destroyers.forEach(o=>o()),this.destroyers.length=0;const n=A.length;let f=se({saisie:this.sup5,max:n,defaut:n+1,melange:n+1,nbQuestions:this.nbQuestions}).map(Number);f=[...f,...$e(be(n))],f=de(f),f=f.slice(0,25),f=f.reverse();const oe=f.map(o=>A[o-1]),a=Math.max(2,this.sup),w=Array.from(new Set(se({saisie:this.sup4,min:1,max:5,defaut:1,melange:6,nbQuestions:5,shuffle:!1}).map(Number)));let F=0;for(let o=0,G=0;o<this.nbQuestions&&G<50;){const $=[],J=oe.pop();if(!J)continue;const i=J,l=i.fonctionNb(2)-i.fonctionNb(1),b=i.fonctionNb(1)-l,K=i.type==="linéaire"?`On constate que le nombre de formes augmente de $${l}$ à chaque étape.<br>
        Et que c'est aussi le nombre de formes à l'étape 1. Par conséquent, pour trouver le nombre de formes d'un motif il faut simplement multiplier par ${l} le numéro du motif.`:`On constate que le nombre de formes augmente de $${l}$ à chaque étape.<br>
        Cependant, il n'y a pas ${l} formes sur le motif 1, mais ${i.fonctionNb(1)}. Par conséquent, il faut multiplier le numéro du motif par ${l} et ${b<0?`retirer ${-b}`:`ajouter ${b}`}.`,s="iterate3d"in i?new S({initialCells:[],type:"iso",prefixId:`Ex${this.numeroExercice}Q${o}`,shapes:["cube"]}):new ye([]),D=[];let v=1/0,M=1/0,P=-1/0,C=-1/0;if(s instanceof S){s.shape=B(),s.iterate3d=i.iterate3d,$.push(X(`cubeIsoQ${o}F${a}`));const e=Math.PI/6;if(re.isHtml){const t=Z({pattern:s,i:o,j:a,angle:e,inCorrectionMode:!0});t&&this.destroyers.push(t),s.shape.codeSvg=`<use href="#cubeIsoQ${o}F${a}"></use>`,s.update3DCells(a).forEach(m=>{const[u,q]=ee(m[0],m[1],m[2],e),y=B(`cubeIsoQ${o}F${a}`,u,q);D.push(y),M=Math.min(M,-q/20),C=Math.max(C,-q/20),v=Math.min(v,u/20),P=Math.max(P,u/20)}),v-=5,P+=5,M-=5,C+=5}else D.push(...s.render(a,0,0,Math.PI/6)),{xmin:v,ymin:M,xmax:P,ymax:C}=N(D);$.push(...D)}else{const e=i;s.iterate=i.iterate,s.shapes=e.shapes||["carré","carré"];for(const t of s.shapes)if(t in j)$.push(j[t].shapeDef);else throw new Error(`Shape ${t} not found in listeShapes2DInfos or emojis.`);$.push(...s.render(a+1,0,0)),{xmin:v,ymin:M,xmax:P,ymax:C}=N($)}const ie=v,ne=P,ae=M,me=C;let L=0,O=0;const U=Math.PI/6;let E=`Voici les ${a} premiers motifs d'une série de motifs figuratifs. Ils évoluent selon des règles définies.<br>`;const c=[];for(let e=0;e<a;e++){if(c[e]=[],s instanceof S)c[e].push(X(`cubeIsoQ${o}F${e}`));else for(const y of s.shapes)if(y in j)c[e].push(j[y].shapeDef);else throw new Error(`Shape ${y} not found in listeShapes2DInfos or emojis.`);let t=1/0,r=1/0,m=-1/0,u=-1/0;if(s instanceof S)if(re.isHtml){const y=Z({pattern:s,i:o,j:e,angle:U,inCorrectionMode:!1});y&&this.destroyers.push(y),s.shape&&(s.shape.codeSvg=`<use href="#cubeIsoQ${o}F${e}"></use>`),s.update3DCells(e+1).forEach(V=>{const[R,z]=ee(V[0],V[1],V[2],U),pe=B(`cubeIsoQ${o}F${e}`,R,z);c[e].push(pe),r=Math.min(r,-z/20),u=Math.max(u,-z/20),t=Math.min(t,R/20),m=Math.max(m,R/20)}),t-=1,m+=1}else c[e].push(...s.render(e+1,0,0,Math.PI/6)),{xmin:t,ymin:r,xmax:m,ymax:u}=N(c[e]);else c[e].push(...s.render(e+1,0,0)),{xmin:t,ymin:r,xmax:m,ymax:u}=N(c[e]);c[e].push(fe(`Motif ${e+1}`,(m+t+1)/2,r-1.5,0,"black",.8,"milieu"));const q=ce(T(t-1,r-2),T(m+2,r-2),T(m+2,u+2),T(t-1,u+2));q.pointilles=4,c[e].push(q),L=Math.max(L,u),O=Math.min(O,r)}E+=c.map((e,t)=>H(Object.assign(N(e,{rxmin:0,rymin:-1,rxmax:0,rymax:1}),{id:`Motif${o}F${t}`,pixelsParCm:20,yMax:L,yMin:O,scale:.4,style:"display: inline-block",optionsTikz:"transform shape"}),e)).join(`
`),E+="<br><br>";let Y="";const d=[],x=[],p=s.shapes[0]in j?j[s.shapes[0]]:{articleCourt:"de ",nomPluriel:"cubes"};for(const e of w)switch(e){case 1:d.push(`
Dessiner le motif $${a+1}$.<br>`),x.push(`Voici le motif $${a+1}$ :<br>
              ${H(Object.assign({scale:.4,optionsTikz:"transform shape",id:`Motif${o}F${a}`},{xmin:ie,ymin:ae,xmax:ne,ymax:me}),$)}`);break;case 2:{const t=i.fonctionNb(a+1),r=Q(t,0);d.push(`
Quel sera le nombre ${p.articleCourt}${p.nomPluriel} dans le motif $${a+1}$ ?<br>${k({exercice:this,question:F++,objetReponse:{reponse:{value:r}},typeInteractivite:"mathlive"})}`),x.push(`Le motif $${a+1}$ contient $${g(Q(t,0))}$ ${p.nomPluriel}.<br>
          ${w.includes(1)?"":H(Object.assign(N($,{rxmin:-1,rymin:0,rxmax:0,rymax:1}),{scale:.4,optionsTikz:"transform shape"}),$)}`)}break;case 3:{const t=i.fonctionNb(10),r=Q(t,0);d.push(`
Quel sera le nombre ${p.articleCourt}${p.nomPluriel} pour le motif $10$ ?<br>${k({exercice:this,question:F++,objetReponse:{reponse:{value:r}},typeInteractivite:"mathlive"})}
            `),x.push(`Le motif $10$ contient $${g(r)}$ ${p.nomPluriel}.<br>
            En effet, la formule pour trouver le nombre ${p.articleCourt}${p.nomPluriel} est : $${g(i.formule.replaceAll("n","10"),_)}$.<br>
            ${K}`)}break;case 4:{const t=xe(20,80),r=i.fonctionNb(t),m=Q(r,0);d.push(`
Un motif de cette série contient $${m}$ ${p.nomPluriel}. À quel numéro de motif cela correspond-il ?<br>${k({exercice:this,question:F++,objetReponse:{reponse:{value:t.toString()}},typeInteractivite:"mathlive"})}
            `);const u=i.type==="linéaire"?`On constate que le nombre de formes  augmente de $${l}$ à chaque étape.<br>
        Et que c'est aussi le nombre de formes à l'étape 1. Par conséquent, pour trouver le numéro d'un motif dont on connait le nombre de formes, il faut simplement diviser ce nombre par ${l} pour trouver le numéro.`:`On constate que le nombre de formes augmente de $${l}$ à chaque étape.<br>
        Cependant, il n'y a pas ${l} formes sur le motif 1, mais ${i.fonctionNb(1)}. Par conséquent, il faut ${b<0?`ajouter ${-b}`:`retirer ${b}`} au nombre de formes puis diviser le résultat par ${l} : <br>
        $\\dfrac{${m} ${b<0?"+":"-"} ${Math.abs(b)}}{${l}}=${g(t)}$.`;x.push(`C'est le motif numéro $${g(t.toString())}$ qui contient $${g(Q(r,0),_)}$ ${s.shapes[0]}s.<br>
            ${u}`)}break;case 5:{const t=i.fonctionNb(100),r=Q(t,0);d.push(`
Quel sera le nombre ${p.articleCourt}${p.nomPluriel} pour le motif $100$ ?<br>${k({exercice:this,question:F++,objetReponse:{reponse:{value:r}},typeInteractivite:"mathlive"})}
            `),x.push(`Le motif $100$ contient $${g(r)}$ ${p.nomPluriel}.<br>
            En effet, la formule pour trouver le nombre ${p.articleCourt}${p.nomPluriel} est : $${g(i.formule.replaceAll("n","100"),_)}$.<br>
            ${K}`)}break}E+=d.length===1?d[0]:te({items:d,style:"alpha"}),Y+=x.length===1?x[0]:te({items:x,style:"alpha"}),this.questionJamaisPosee(o,w.join(""),i.numero)&&(this.listeQuestions.push(E),this.listeCorrections.push(Y),o++),G++}}}export{is as dateDeModifImportante,os as dateDePublication,ms as default,ss as interactifReady,rs as interactifType,as as refs,ts as titre,ns as uuid};
//# sourceMappingURL=4L13-3-M0YWJeXj.js.map
