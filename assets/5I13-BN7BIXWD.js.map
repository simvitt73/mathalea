{"version":3,"file":"5I13-BN7BIXWD.js","sources":["../../src/exercices/5e/5I13.ts"],"sourcesContent":["import {\n  cubeDef,\n  project3dIso,\n  shapeCubeIso,\n  updateCubeIso,\n} from '../../lib/2d/figures2d/Shape3d'\nimport { listeShapes2DInfos } from '../../lib/2d/figures2d/shapes2d'\nimport { fixeBordures } from '../../lib/2d/fixeBordures'\nimport {\n  listePatternsSansRatioNiFraction,\n  type PatternRiche,\n  type PatternRiche3D,\n} from '../../lib/2d/patterns/patternsPreDef'\nimport { VisualPattern } from '../../lib/2d/patterns/VisualPattern'\nimport { VisualPattern3D } from '../../lib/2d/patterns/VisualPattern3D'\nimport { point } from '../../lib/2d/PointAbstrait'\nimport { polygone } from '../../lib/2d/polygones'\nimport { texteParPosition } from '../../lib/2d/textes'\nimport { bleuMathalea } from '../../lib/colors'\nimport { createList } from '../../lib/format/lists'\nimport { ajouteQuestionMathlive } from '../../lib/interactif/questionMathLive'\nimport {\n  compteOccurences,\n  enleveDoublonNum,\n  remplaceDansTableau,\n  shuffle,\n} from '../../lib/outils/arrayOutils'\nimport { miseEnEvidence } from '../../lib/outils/embellissements'\nimport { range1 } from '../../lib/outils/nombres'\nimport { texNombre } from '../../lib/outils/texNombre'\nimport { context } from '../../modules/context'\nimport { mathalea2d } from '../../modules/mathalea2d'\nimport {\n  contraindreValeur,\n  gestionnaireFormulaireTexte,\n  randint,\n} from '../../modules/outils'\nimport type { NestedObjetMathalea2dArray } from '../../types/2d'\nimport Exercice from '../Exercice'\n\nexport const titre = \"Identifier la structure d'un motif (itératif)\"\nexport const interactifReady = true\nexport const interactifType = 'mathLive'\n\nexport const dateDeModifImportante = '22/11/2025'\n\n/**\n * Étudier les premiers termes d'une série de motifs afin de donner le nombre de formes du motif suivant.\n * Les patterns sont des motifs figuratifs qui évoluent selon des règles définies.\n * Cet exercice contient des patterns issus de l'excellent site : https://www.visualpatterns.org/\n * @author Jean-Claude Lhote (modif par Eric Elter au niveau des paramètres notamment)\n */\nexport const uuid = 'f8b5e'\n\nexport const refs = {\n  'fr-fr': ['5I13'],\n  'fr-ch': [],\n}\n\nexport default class PatternIteratif extends Exercice {\n  destroyers: (() => void)[] = []\n\n  constructor() {\n    super()\n    this.nbQuestions = 3\n    this.comment = ` Les patterns sont des motifs figuratifs qui évoluent selon des règles définies.<br>\n Cet exercice contient des patterns issus de l'excellent site : <a href=\"https://www.visualpatterns.org/\" target=\"_blank\" style=\"color: blue\">https://www.visualpatterns.org/</a>.<br>\n Cet exercice propose d'étudier les premiers termes d'une série de motifs afin de répondre à différentes questions possibles.<br>\nGrâce au premier paramètre, on peut choisir le nombre de motifs visibles.<br>\nGrâce au deuxième paramètre, on peut choisir les questions à poser.<br>\nGrâce au troisième paramètre, on peut imposer des patterns choisis dans cette <a href=\"https://coopmaths.fr/alea/?uuid=71ff5&s=3\" target=\"_blank\" style=\"color: blue\">liste de patterns</a>.<br>\nSi le nombre de questions est supérieur au nombre de patterns choisis, alors l'exercice sera complété par des patterns choisis au hasard.\n    `\n    this.besoinFormulaireNumerique = [\n      'Nombre de figures par question',\n      3,\n      'Deux figures\\nTrois Figures\\nQuatre Figures',\n    ]\n    this.sup = 2\n\n    this.besoinFormulaire2Texte = [\n      'Type de questions',\n      [\n        'Nombres séparés par des tirets :',\n        '1 : Motif suivant à dessiner',\n        '2 : Motif suivant (nombre)',\n        '3 : Motif 10 (nombre)',\n        '4 : Numéro du motif',\n        '5 : Motif 100 (nombre)',\n        '6 : Une question au hasard parmi les 5 précédentes',\n        '7 : Ensemble des 5 premières propositions',\n      ].join('\\n'),\n    ]\n    this.sup2 = '7'\n\n    const nbDePattern = listePatternsSansRatioNiFraction.length\n    this.besoinFormulaire3Texte = [\n      'Numéros des pattern désirés :',\n      [\n        'Nombres séparés par des tirets  :',\n        `Mettre des nombres entre 1 et ${nbDePattern}.`,\n        `Mettre 0 pour laisser le hasard faire.`,\n      ].join('\\n'),\n    ]\n\n    this.sup3 = `0`\n    this.listePackages = ['twemojis'] // this.listePackages est inutile mais la présence du mot \"twemojis\" est indispensable pour la sortie LaTeX.\n  }\n\n  destroy() {\n    // MGu quan l'exercice est supprimé par svelte : bouton supprimé\n    this.destroyers.forEach((destroy) => destroy())\n    this.destroyers.length = 0\n  }\n\n  nouvelleVersion(): void {\n    // MGu quand l'exercice est modifié, on détruit les anciens listeners\n    this.destroyers.forEach((destroy) => destroy())\n    this.destroyers.length = 0\n    // on ne conserve que les linéaires et les affines sans ratio, ni fraction, ni multiple shape\n    const nbFigures = contraindreValeur(2, 4, this.sup + 1, 4)\n\n    let typesQuestionsInitiales = gestionnaireFormulaireTexte({\n      saisie: this.sup2,\n      max: 6,\n      defaut: 1,\n      melange: 7,\n      nbQuestions: 5,\n      shuffle: false,\n    }).map(Number)\n    typesQuestionsInitiales = enleveDoublonNum(typesQuestionsInitiales)\n    if (typesQuestionsInitiales.length === 6)\n      typesQuestionsInitiales = range1(5)\n\n    const nbDePattern = listePatternsSansRatioNiFraction.length\n    let typesPattern = gestionnaireFormulaireTexte({\n      saisie: this.sup3,\n      max: nbDePattern,\n      defaut: 0,\n      melange: 0,\n      nbQuestions: this.nbQuestions,\n    }).map(Number)\n\n    typesPattern = [...typesPattern, ...shuffle(range1(nbDePattern))]\n    typesPattern = enleveDoublonNum(typesPattern)\n\n    let typesQuestions\n    let indexInteractif = 0\n    const listePreDef = typesPattern.map(\n      (i) => listePatternsSansRatioNiFraction[i - 1],\n    )\n\n    for (\n      let i = 0, cpt = 0;\n      i < Math.min(nbDePattern, this.nbQuestions) && cpt < 50;\n    ) {\n      if (compteOccurences(typesQuestionsInitiales, 6) > 0) {\n        typesQuestions = remplaceDansTableau(\n          typesQuestionsInitiales,\n          6,\n          randint(1, 5, typesQuestionsInitiales),\n        )\n        typesQuestions = enleveDoublonNum(typesQuestions)\n      } else typesQuestions = typesQuestionsInitiales\n\n      const objetsCorr: NestedObjetMathalea2dArray = []\n      const pat = listePreDef[i]\n      const delta = pat.fonctionNb(2) - pat.fonctionNb(1)\n      const b = pat.fonctionNb(1) - delta\n      const explain =\n        pat.type === 'linéaire'\n          ? `On constate que le nombre de formes augmente de $${delta}$ à chaque étape.<br>\n        Et que c'est aussi le nombre de formes à l'étape 1. Par conséquent, pour trouver le nombre de formes d'un motif il faut simplement multiplier par ${delta} le numéro du motif.`\n          : `On constate que le nombre de formes augmente de $${delta}$ à chaque étape.<br>\n        Cependant, il n'y a pas ${delta} formes sur le motif 1, mais ${pat.fonctionNb(1)}. Par conséquent, il faut multiplier le numéro du motif par ${delta} et ${b < 0 ? `retirer ${-b}` : `ajouter ${b}`}.`\n      const pattern =\n        'iterate3d' in pat\n          ? new VisualPattern3D({\n              initialCells: [],\n              type: 'iso',\n              shapes: pat.shapes,\n              prefixId: `Ex${this.numeroExercice}Q${i}`,\n            })\n          : new VisualPattern([])\n      if ('iterate3d' in pattern) {\n        pattern.shape = shapeCubeIso()\n        pattern.iterate3d = (pat as PatternRiche3D).iterate3d\n        objetsCorr.push(cubeDef(`cubeIsoQ${i}F0`))\n      } else {\n        const pat2D = pat as PatternRiche\n        pattern.iterate = (pat as PatternRiche).iterate\n        pattern.shapes = pat2D.shapes || ['carré', 'carré']\n        for (const shape of pattern.shapes) {\n          if (shape in listeShapes2DInfos) {\n            objetsCorr.push(listeShapes2DInfos[shape].shapeDef)\n          } else {\n            throw new Error(\n              `Shape ${shape} not found in listeShapes2DInfos or emojis.`,\n            )\n          }\n        }\n      }\n\n      const rendered = pattern.render(nbFigures + 1, 0, 0, Math.PI / 6)\n      objetsCorr.push(...rendered)\n      let yMax = 0\n      let yMin = 0\n      const angle = Math.PI / 6\n      let texte = `Voici les ${nbFigures} premiers motifs d'une série de motifs figuratifs. Ils évoluent selon des règles définies.<br>`\n      const figures: NestedObjetMathalea2dArray[] = []\n      for (let j = 0; j < nbFigures; j++) {\n        figures[j] = []\n        if ('iterate3d' in pattern) {\n          figures[j].push(cubeDef(`cubeIsoQ${i}F${j}`))\n        } else {\n          for (const shape of pattern.shapes) {\n            if (shape in listeShapes2DInfos) {\n              figures[j].push(listeShapes2DInfos[shape].shapeDef)\n            } else {\n              throw new Error(\n                `Shape ${shape} not found in listeShapes2DInfos or emojis.`,\n              )\n            }\n          }\n        }\n\n        let xmin = Infinity\n        let ymin = Infinity\n        let xmax = -Infinity\n        let ymax = -Infinity\n        if ('iterate3d' in pattern) {\n          if (pattern.shape == null) {\n            pattern.shape = shapeCubeIso(`cubeIsoQ${i}F${j}`, 0, 0, {\n              fillStyle: '#ffffff',\n              strokeStyle: '#000000',\n              lineWidth: 1,\n              opacite: 1,\n              scale: 1,\n            })\n          }\n          if (context.isHtml) {\n            const listeners = updateCubeIso({ pattern, i, j, angle })\n            if (listeners) this.destroyers.push(listeners)\n            pattern.shape.codeSvg = `<use href=\"#cubeIsoQ${i}F${j}\"></use>`\n            const cells = (pattern as VisualPattern3D).update3DCells(j + 1)\n            // Ajouter les SVG générés par svg() de chaque objet\n            cells.forEach((cell) => {\n              const [px, py] = project3dIso(cell[0], cell[1], cell[2], angle)\n              const obj = shapeCubeIso(`cubeIsoQ${i}F${j}`, px, py)\n              figures[j].push(obj)\n              ymin = Math.min(ymin, -py / 20)\n              ymax = Math.max(ymax, -py / 20)\n              xmin = Math.min(xmin, px / 20)\n              xmax = Math.max(xmax, px / 20)\n            })\n            xmin -= 1\n            xmax += 1\n          } else {\n            figures[j].push(\n              ...(pattern as VisualPattern3D).render(j + 1, 0, 0, Math.PI / 6),\n            )\n            ;({ xmin, ymin, xmax, ymax } = fixeBordures(figures[j]))\n          }\n        } else {\n          figures[j].push(...pattern.render(j + 1, 0, 0))\n          ;({ xmin, ymin, xmax, ymax } = fixeBordures(figures[j]))\n        }\n        figures[j].push(\n          texteParPosition(\n            `Motif ${j + 1}`,\n            (xmax + xmin + 1) / 2,\n            ymin - 1.5,\n            0,\n            'black',\n            0.8,\n            'milieu',\n          ),\n        )\n        const cadre = polygone(\n          point(xmin - 1, ymin - 2),\n          point(xmax + 2, ymin - 2),\n          point(xmax + 2, ymax + 2),\n          point(xmin - 1, ymax + 2),\n        )\n        cadre.pointilles = 4\n        figures[j].push(cadre)\n        yMax = Math.max(yMax, ymax)\n        yMin = Math.min(yMin, ymin)\n      }\n      texte += figures\n        .map((fig, index) =>\n          mathalea2d(\n            Object.assign(\n              fixeBordures(fig, { rxmin: 0, rymin: -1, rxmax: 0, rymax: 1 }),\n              {\n                id: `Motif${i}F${index}`,\n                pixelsParCm: 20,\n                yMax,\n                yMin,\n                scale: 0.4,\n                style: 'display: inline-block',\n                optionsTikz: 'transform shape',\n              },\n            ),\n            fig,\n          ),\n        )\n        .join('\\n')\n      let texteCorr = ''\n      const listeQuestions: string[] = []\n      const listeCorrections: string[] = []\n      const infosShape =\n        pattern.shapes[0] in listeShapes2DInfos\n          ? listeShapes2DInfos[pattern.shapes[0]]\n          : { articleCourt: 'de ', nomPluriel: 'cubes' }\n      const deMotif = `${infosShape.articleCourt}${infosShape.nomPluriel}`\n\n      for (const q of typesQuestions) {\n        switch (q) {\n          case 1:\n            listeQuestions.push(`\\nDessiner le motif $${nbFigures + 1}$.<br>`)\n            listeCorrections.push(`Voici le motif $${nbFigures + 1}$ :<br>\n              ${mathalea2d(Object.assign(fixeBordures(objetsCorr, { rxmin: 0, rymin: -1, rxmax: 0, rymax: 1 }), { scale: 0.4, optionsTikz: 'transform shape' }), objetsCorr)}`)\n            break\n          case 2:\n            {\n              const nbFormes = pat.fonctionNb(nbFigures + 1)\n              const nbTex = texNombre(nbFormes, 0)\n\n              listeQuestions.push(\n                `\\nQuel sera le nombre ${deMotif} dans le motif $${nbFigures + 1}$ ?<br>${ajouteQuestionMathlive(\n                  {\n                    exercice: this,\n                    question: indexInteractif++,\n                    objetReponse: { reponse: { value: nbTex } },\n                    typeInteractivite: 'mathlive',\n                  },\n                )}`,\n              )\n              listeCorrections.push(`Le motif $${nbFigures + 1}$ contient $${miseEnEvidence(texNombre(nbFormes, 0))}$ ${infosShape.nomPluriel}.<br>\n          ${!typesQuestions.includes(1) ? mathalea2d(Object.assign(fixeBordures(objetsCorr, { rxmin: -1, rymin: 0, rxmax: 0, rymax: 1 }), { scale: 0.4, optionsTikz: 'transform shape' }), objetsCorr) : ''}`)\n            }\n            break\n          case 3:\n            {\n              const nbFormes = pat.fonctionNb(10)\n              const nbTex = texNombre(nbFormes, 0)\n              listeQuestions.push(`\\nQuel sera le nombre ${deMotif} pour le motif $10$ ?<br>${ajouteQuestionMathlive(\n                {\n                  exercice: this,\n                  question: indexInteractif++,\n                  objetReponse: { reponse: { value: nbTex } },\n                  typeInteractivite: 'mathlive',\n                },\n              )}\n            `)\n              listeCorrections.push(`Le motif $10$ contient $${miseEnEvidence(nbTex)}$ ${infosShape.nomPluriel}.<br>\n            En effet, la formule pour trouver le nombre ${deMotif} est : $${miseEnEvidence(pat.formule.replaceAll('n', '10'), bleuMathalea)}$.<br>\n            ${explain}`)\n            }\n            break\n          case 4:\n            {\n              const etape = randint(20, 80)\n              const nbFormes = pat.fonctionNb(etape)\n              const nbTex = texNombre(nbFormes, 0)\n              listeQuestions.push(`\\nUn motif de cette série contient $${nbTex}$ ${infosShape.nomPluriel}. À quel numéro de motif cela correspond-il ?<br>${ajouteQuestionMathlive(\n                {\n                  exercice: this,\n                  question: indexInteractif++,\n                  objetReponse: { reponse: { value: etape.toString() } },\n                  typeInteractivite: 'mathlive',\n                },\n              )}\n            `)\n\n              const explain2 =\n                pat.type === 'linéaire'\n                  ? `On constate que le nombre de formes  augmente de $${delta}$ à chaque étape.<br>\n        Et que c'est aussi le nombre de formes à l'étape 1. Par conséquent, pour trouver le numéro d'un motif dont on connait le nombre de formes, il faut simplement diviser ce nombre par ${delta} pour trouver le numéro.`\n                  : `On constate que le nombre de formes augmente de $${delta}$ à chaque étape.<br>\n        Cependant, il n'y a pas ${delta} formes sur le motif 1, mais ${pat.fonctionNb(1)}. Par conséquent, il faut ${b < 0 ? `ajouter ${-b}` : `retirer ${b}`} au nombre de formes puis diviser le résultat par ${delta} : <br>\n        $\\\\dfrac{${nbTex} ${b < 0 ? '+' : '-'} ${Math.abs(b)}}{${delta}}=${miseEnEvidence(etape)}$.`\n              listeCorrections.push(`C'est le motif numéro $${miseEnEvidence(etape.toString())}$ qui contient $${miseEnEvidence(texNombre(nbFormes, 0), bleuMathalea)}$ ${infosShape.nomPluriel}.<br>\n            ${explain2}`)\n            }\n            break\n          case 5:\n            {\n              const nbFormes = pat.fonctionNb(100)\n              const nbTex = texNombre(nbFormes, 0)\n              listeQuestions.push(`\\nQuel sera le nombre ${deMotif} pour le motif $100$ ?<br>${ajouteQuestionMathlive(\n                {\n                  exercice: this,\n                  question: indexInteractif++,\n                  objetReponse: { reponse: { value: nbTex } },\n                  typeInteractivite: 'mathlive',\n                },\n              )}\n            `)\n              listeCorrections.push(`Le motif $100$ contient $${miseEnEvidence(nbTex)}$ formes ${deMotif}.<br>\n            En effet, la formule pour trouver le nombre ${deMotif} est : $${miseEnEvidence(pat.formule.replaceAll('n', '100'), bleuMathalea)}$.<br>\n            ${explain}`)\n            }\n            break\n        }\n      }\n      texte +=\n        listeQuestions.length === 1\n          ? '<br>' + listeQuestions[0]\n          : createList({\n              items: listeQuestions,\n              style: 'alpha',\n            })\n      texteCorr +=\n        listeCorrections.length === 1\n          ? '<br>' + listeCorrections[0]\n          : createList({\n              items: listeCorrections,\n              style: 'alpha',\n            })\n      if (this.questionJamaisPosee(i, typesQuestions.join(''), pat.numero)) {\n        this.listeQuestions.push(texte)\n        this.listeCorrections.push(texteCorr)\n        i++\n        cpt++\n      }\n    }\n  }\n}\n"],"names":["titre","interactifReady","interactifType","dateDeModifImportante","uuid","refs","PatternIteratif","Exercice","__publicField","nbDePattern","listePatternsSansRatioNiFraction","destroy","nbFigures","contraindreValeur","typesQuestionsInitiales","gestionnaireFormulaireTexte","enleveDoublonNum","range1","typesPattern","shuffle","typesQuestions","indexInteractif","listePreDef","i","cpt","compteOccurences","remplaceDansTableau","randint","objetsCorr","pat","delta","b","explain","pattern","VisualPattern3D","VisualPattern","shapeCubeIso","cubeDef","pat2D","shape","listeShapes2DInfos","rendered","yMax","yMin","angle","texte","figures","j","xmin","ymin","xmax","ymax","context","listeners","updateCubeIso","cell","px","py","project3dIso","obj","fixeBordures","texteParPosition","cadre","polygone","point","fig","index","mathalea2d","texteCorr","listeQuestions","listeCorrections","infosShape","deMotif","q","nbFormes","nbTex","texNombre","ajouteQuestionMathlive","miseEnEvidence","bleuMathalea","etape","explain2","createList"],"mappings":"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"}