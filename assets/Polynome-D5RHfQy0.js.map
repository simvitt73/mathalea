{"version":3,"file":"Polynome-D5RHfQy0.js","sources":["../../src/lib/mathFonctions/Polynome.ts"],"sourcesContent":["import Decimal from 'decimal.js'\nimport { abs, acos, equal, largerEq, max, polynomialRoot, round } from 'mathjs'\nimport FractionEtendue, { rationnalise } from '../../modules/FractionEtendue'\nimport { egal, randint } from '../../modules/outils'\nimport { generateCleaner } from '../interactif/comparisonFunctions'\nimport { choice } from '../outils/arrayOutils'\nimport {\n  ecritureAlgebrique,\n  ecritureAlgebriqueSauf1,\n  ecritureParentheseSiNegatif,\n  rienSi1,\n} from '../outils/ecritures'\nimport { texNombre } from '../outils/texNombre'\n\ntype NombreType = number | Decimal | FractionEtendue\n/**\n *\n * @param {Polynome} poly degré maximum = 3\n * @param {number} xG xG<xD\n * @param {number} xD\n * @return {{minLocal: number, maxLocal:number}}\n */\nexport function chercheMinMaxLocal({\n  poly,\n  xG,\n  xD,\n}: {\n  poly: Polynome\n  xG: number\n  xD: number\n}) {\n  const derivee = poly.derivee()\n  const yG = poly.fonction(xG)\n  const yD = poly.fonction(xD)\n  let minLocal, maxLocal\n  if (derivee.deg === 2) {\n    const a = Number(derivee.monomes[2])\n    const b = Number(derivee.monomes[1])\n    const c = Number(derivee.monomes[0])\n    const delta = b ** 2 - 4 * a * c\n    if (delta < 0) {\n      // la dérivée ne s'annule pas donc la fonction est monotone du signe de a\n      if (a > 0) {\n        // la fonction est croissante don le max est atteint en x[i+1]\n        maxLocal = yD\n        minLocal = yG\n      } else {\n        maxLocal = yG\n        minLocal = yD\n      }\n    } else if (delta === 0) {\n      // la dérivée s'annule une seule fois mais il faut vérifier que c'est sur l'intervalle x[i] x[i+1]\n      const racine = -b / 2 / a\n      if (racine > xG && racine < xG) {\n        // ça peut encore être un max ou un min !\n        if (a > 0) {\n          // c'est un minimum\n          maxLocal = Math.max(yG, yD)\n          minLocal = poly.fonction(racine)\n        } else {\n          // c'est un maximum\n          maxLocal = poly.fonction(racine)\n          minLocal = Math.min(yG, Number(yD))\n        }\n      } else {\n        // la racine n'est pas dans cet intervalle, donc la dérivée est monotone ici\n        maxLocal = Math.max(yG, Number(yD))\n        minLocal = Math.min(yG, Number(yD))\n      }\n    } else {\n      // delta >0 deux racines !\n      const ptiDelta = Math.sqrt(delta)\n      const r1 = a > 0 ? (-b - ptiDelta) / 2 / a : (-b + ptiDelta) / 2 / a\n      const r2 = a > 0 ? (-b + ptiDelta) / 2 / a : (-b - ptiDelta) / 2 / a\n      if (xG < r1 && r1 < xD) {\n        // r1 est dans l'intervalle\n        if (xG < r2 && r2 < xD) {\n          // r2 aussi !\n          if (a > 0) {\n            // croissant puis decroissant puis croissant : le max est soit en r1 soit en x[i+1]\n            maxLocal = Math.max(poly.fonction(r1), yD)\n            minLocal = Math.min(yG, poly.fonction(r2))\n          } else {\n            // a<0 décroissant puis croissant puis décroissant\n            minLocal = Math.min(poly.fonction(r1), yD)\n            maxLocal = Math.max(yG, poly.fonction(r2))\n          }\n        } else {\n          // r1 est dedans mais pas r2\n          if (a > 0) {\n            // on a un max en r1 et le min est soit en x[i] soit en x[i+1]\n            maxLocal = poly.fonction(r1)\n            minLocal = Math.min(yG, yD)\n          } else {\n            // minimum en r1, max en x[i] ou x[i+1]\n            minLocal = poly.fonction(r1)\n            maxLocal = Math.max(Number(yG), Number(yD))\n          }\n        }\n      } else {\n        // r1 n'est pas dans l'intervalle mais peut-être r2 y est\n        if (xG < r2 && r2 < xD) {\n          if (a > 0) {\n            // on a le min en r2 et le max en x[i] ou en x[i+1]\n            minLocal = poly.fonction(r2)\n            maxLocal = Math.max(xG, yD)\n          } else {\n            // on a le max en r2 et le min en x[i] ou en x[i+1]\n            maxLocal = poly.fonction(r2)\n            minLocal = Math.min(xG, yD)\n          }\n        } else {\n          // ni r1, ni r2 ne sont dans l'intervalle. La fonction est monotone\n          if (a > 0) {\n            if (r2 < xG || r1 > xD) {\n              // strictement croissante\n              maxLocal = yD\n              minLocal = yG\n            } else {\n              // normalemennt r1<x[i] et r2>x[i+1] strictement décroissante\n              maxLocal = yG\n              minLocal = yD\n            }\n          } else {\n            if (r2 < xG || r1 > xD) {\n              // strictement décroissante\n              maxLocal = yG\n              minLocal = yD\n            } else {\n              // normalemennt r1<x[i] et r2>x[i+1] strictement croissante\n              maxLocal = yD\n              minLocal = yG\n            }\n          }\n        }\n      }\n    }\n  } else if (derivee.deg === 1) {\n    // derivée affine, monotone croissante ou décroissante selon le signe de derivee[i].monomes[1]\n    const a = derivee.monomes[1]\n    if (Number(a) > 0) {\n      maxLocal = yD\n      minLocal = yG\n    } else {\n      maxLocal = yG\n      minLocal = yD\n    }\n  } else {\n    // constante !\n    minLocal = yG\n    maxLocal = yG\n  }\n  return { minLocal, maxLocal }\n}\n\n// un cleaner pour la méthode toMathExpr\nconst clean = generateCleaner(['virgules', 'fractions', 'espaces'])\n// une fonction pour ajouter deux nombres dont on ne connait pas le type\nconst somme = function (a: unknown, b: unknown) {\n  if (a instanceof Decimal) {\n    if (b instanceof Decimal) return a.add(b)\n    else if (b instanceof FractionEtendue) {\n      return a.add(new Decimal(b.valeurDecimale))\n    } else return a.add(new Decimal(String(b)))\n  }\n  if (a instanceof FractionEtendue) {\n    if (b instanceof FractionEtendue) return a.sommeFraction(b).simplifie()\n    else return a.sommeFraction(rationnalise(Number(b))).simplifie()\n  }\n  return Number(a) + Number(b)\n}\n// une fonction pour multiplier deux nombres dont on ne connait pas le type\nconst produit = function (a: unknown, b: unknown) {\n  if (typeof a === 'number' && typeof b === 'number') return a * b\n  if (a instanceof Decimal) {\n    if (b instanceof Decimal) return a.mul(b)\n    else if (b instanceof FractionEtendue) {\n      return a.mul(new Decimal(b.valeurDecimale))\n    } else return a.mul(new Decimal(String(b)))\n  }\n  if (a instanceof FractionEtendue) {\n    if (b instanceof FractionEtendue) return a.produitFraction(b).simplifie()\n    else return a.produitFraction(rationnalise(Number(b))).simplifie()\n  }\n}\n\nconst quotient = function (a: unknown, b: unknown) {\n  if (egal(Number(b), 0)) {\n    window.notify('quotient de Polynome.js a reçu un diviseur nul', {\n      dividende: a,\n      diviseur: b,\n    })\n  }\n  if (typeof a === 'number' && typeof b === 'number') return a / b\n  if (a instanceof Decimal) {\n    if (b instanceof Decimal) return a.div(b)\n    else if (b instanceof FractionEtendue) {\n      return a.div(new Decimal(b.valeurDecimale))\n    } else return a.div(new Decimal(String(b)))\n  }\n  if (a instanceof FractionEtendue) {\n    if (b instanceof FractionEtendue) return a.diviseFraction(b).simplifie()\n    else return a.diviseFraction(rationnalise(Number(b))).simplifie()\n  }\n}\n\nexport type CoeffType = NombreType | [number, boolean]\n/**\n * Avertissement ! pour l'instant la classe ne gère pas les coefficients fractionnaires !\n * @param {boolean} useFraction laissé à false pour l'instant (les coefficients fractionnaires ne sont pas encore utilisé et\n * @param {boolean} useDecimal useFraction a prévalence sur useDecimal pour avoir des décimaux, il faut que useFraction soit false (valeur par défaut donc c'est bon)\n * le code n'est pas dépourvu de problème si on utilise des coefficients fractionnaires !\n * rendant l'expression mathématique inutilisable avec Algebrite et aussi dans la définition de la fonction x=>f(x)\n * @param {boolean} rand Donner true si on veut un polynôme aléatoire\n * @param {number} deg à fournir >=0 en plus de rand === true pour fixer le degré\n * @param coeffs liste de coefficients par ordre de degré croissant OU liste de couples [valeurMax, relatif?]\n * @author Jean-Léon Henry, Jean-Claude Lhote\n * @example Polynome({ coeffs:[0, 2, 3] }) donne 3x²+2x\n * @example Polynome({ rand:true, deg:3 }) donne un ax³+bx²+cx+d à coefficients entiers dans [-10;10]\\{0}\n * @example Polynome({ rand:true, coeffs:[[10, true], 0, [5, false]] }) donne un ax²+b avec a∈[1;5] et b∈[-10;10]\\{0}\n */\nexport class Polynome {\n  monomes: (number | FractionEtendue | Decimal)[]\n  fonction: (x: number) => number\n  deg: number\n  useFraction: boolean\n  useDecimal: boolean\n  letter: string\n\n  constructor({\n    rand = false,\n    deg = -1,\n    coeffs,\n    useFraction = false,\n    useDecimal = false,\n    letter = 'x',\n  }: {\n    rand?: boolean\n    deg?: number\n    coeffs?: CoeffType[]\n    useFraction?: boolean\n    useDecimal?: boolean\n    letter?: string\n  }) {\n    this.letter = letter\n    if (rand) {\n      if (largerEq(deg, 0)) {\n        // on construit coeffs indépendamment de la valeur fournie\n        coeffs = new Array(deg + 1)\n        coeffs.fill([10, true])\n      }\n      // Création de this.monomes\n      this.monomes = coeffs!.map(function (el: unknown) {\n        if (typeof el === 'number') {\n          return el\n        } else if (Array.isArray(el)) {\n          if (el[0] === 0) return 0\n          if (useFraction) {\n            const den = choice([2, 4, 5])\n            const aFrac = new FractionEtendue(\n              ...(new Decimal(randint(1, den * Number(el[0])))\n                .div(den)\n                .toFraction(100)\n                .map(Number) as [number, number]),\n            )\n            return el[1] ? aFrac.multiplieEntier(choice([-1, 1])) : aFrac\n          } else if (useDecimal) {\n            const dec = new Decimal(randint(1, 10 * Number(el[0]))).div(10)\n            return el[1] ? dec.mul(choice([-1, 1])) : dec\n          } else {\n            return el[1]\n              ? choice([-1, 1]) * randint(1, Number(el[0]))\n              : randint(1, Number(el[0]))\n          }\n        } else if (el instanceof FractionEtendue) {\n          return el\n        } else if (el instanceof Decimal) {\n          return el\n        } else {\n          window.notify(\n            \"Dans Polynome, l'un des coefficient n'est pas d'un type attendu.\",\n            { coeff: el },\n          )\n          return NaN\n        }\n      })\n    } else {\n      // les coeffs sont fourni\n      this.monomes = coeffs!.map(function (el) {\n        if (el instanceof FractionEtendue) {\n          if (useFraction) {\n            return el\n          } else {\n            return new Decimal(`${el.num}/${el.den}`)\n          }\n        } else if (el instanceof Decimal) {\n          if (useDecimal) {\n            return el\n          } else {\n            return el.round()\n          }\n        }\n        return Number(el)\n      })\n    }\n    this.useFraction =\n      useFraction ??\n      this.monomes.filter((el) => el instanceof FractionEtendue).length > 0\n    this.useDecimal =\n      useDecimal ??\n      (this.monomes.filter((el) => el instanceof Decimal).length > 0 &&\n        this.monomes.filter((el) => el instanceof FractionEtendue).length === 0)\n\n    this.deg = this.monomes.length - 1\n    /**\n     * la fonction à utiliser pour tracer la courbe par exemple ou calculer des valeurs comme dans pol.image()\n     * const f = pol.fonction est une fonction utilisable dans courbe()\n     * @returns {function(number): number}\n     */\n    const monomes = this.monomes\n    this.fonction = function (x: number) {\n      let val = 0\n      for (let i = 0; i < monomes.length; i++) {\n        if (monomes[i] instanceof FractionEtendue) {\n          const m = monomes[i] as FractionEtendue\n          val = val + m.valeurDecimale * x ** i\n        } else if (monomes[i] instanceof Decimal) {\n          const m = monomes[i] as Decimal\n          val = val + m.toNumber() * x ** i\n        } else {\n          val = val + Number(monomes[i]) * x ** i\n        }\n      }\n      return val\n    }\n  }\n\n  isMon() {\n    return this.monomes.filter((el) => el !== 0).length === 1\n  }\n\n  isEqual(p: number | Polynome) {\n    if (typeof p === 'number') {\n      if (this.monomes[0] !== p) return false\n      for (let i = 1; i <= this.deg; i++) {\n        if (this.monomes[i] !== 0) {\n          return false\n        }\n      }\n      return true\n    }\n    if (p instanceof Polynome) {\n      const degP = p.deg\n      if (degP === this.deg) {\n        return this.monomes.filter((el, i) => el !== p.monomes[i]).length === 0\n      }\n      const degMin = Math.min(this.deg, p.deg)\n      for (let i = 0; i <= degMin; i++) {\n        if (!egal(Number(p.monomes[i]), Number(this.monomes[i]), 1e-15)) {\n          return false\n        }\n      }\n      for (let i = degMin + 1; i <= Math.max(p.deg, this.deg); i++) {\n        if (i <= this.deg) {\n          if (this.monomes[i] !== 0) return false\n        }\n        if (i <= p.deg) {\n          if (p.monomes[i] !== 0) return false\n        }\n      }\n      return true\n    }\n    window.notify(\n      `Polynome.isEqual a reçu comme argument autre chose qu'un number ou un polynôme : ${p}`,\n      { p },\n    )\n    return false\n  }\n\n  /**\n   * @param {boolean} alg si true alors le coefficient dominant est doté de son signe +/-\n   * @returns {string} expression mathématique compatible avec Algebrite\n   */\n  toMathExpr(alg = false) {\n    let res = ''\n    let maj = ''\n    for (const [i, c] of this.monomes.entries()) {\n      switch (i) {\n        case this.deg: {\n          let coeffD\n          if (c instanceof FractionEtendue) {\n            coeffD = alg\n              ? `${c.valeurDecimale < 0 ? (c.valeurAbsolue().valeurDecimale === 1 ? '-' : '-{' + String(c.n) + '/' + String(c.d) + '}') : c.valeurDecimale === 1 ? '+' : '+{' + String(c.n) + '/' + String(c.d)}+'}'`\n              : this.deg === 0\n                ? c.ecritureAlgebrique\n                : rienSi1(c)\n          } else {\n            coeffD = alg\n              ? ecritureAlgebriqueSauf1(c)\n              : this.deg === 0\n                ? ecritureAlgebrique(c)\n                : rienSi1(c)\n          }\n          switch (this.deg) {\n            case 1:\n              maj = egal(Number(c), 0, 1e-15) ? '' : `${coeffD}${this.letter}`\n              break\n            case 0:\n              maj = egal(Number(c), 0, 1e-15) ? '' : `${coeffD}`\n              break\n            default:\n              maj = egal(Number(c), 0, 1e-15)\n                ? ''\n                : `${coeffD}${this.letter}^${i}`\n          }\n          break\n        }\n        case 0:\n          maj = egal(Number(c), 0, 1e-15)\n            ? ''\n            : `${c instanceof FractionEtendue ? (c.valeurDecimale < 0 ? '-' : '+') + String(c.n) + '/' + String(c.d) : ecritureAlgebrique(c)}`\n          break\n        case 1:\n          maj = egal(Number(c), 0, 1e-15)\n            ? ''\n            : c instanceof FractionEtendue\n              ? `${\n                  c.valeurDecimale < 0\n                    ? c.valeurAbsolue().valeurDecimale === 1\n                      ? '-'\n                      : '-{' + String(c.n) + '/' + String(c.d)\n                    : c.valeurDecimale === 1\n                      ? '+'\n                      : '+{' + String(c.n) + '/' + String(c.d)\n                }` + `}${this.letter}`\n              : `${ecritureAlgebriqueSauf1(c)}${this.letter}`\n          break\n        default:\n          maj = egal(Number(c), 0, 1e-15)\n            ? ''\n            : c instanceof FractionEtendue\n              ? `${\n                  c.valeurDecimale < 0\n                    ? c.valeurAbsolue().valeurDecimale === 1\n                      ? '-'\n                      : '-{' + String(c.n) + '/' + String(c.d)\n                    : c.valeurDecimale === 1\n                      ? '+'\n                      : '+{' + String(c.n) + '/' + String(c.d)\n                }` + `}${this.letter}^${i}`\n              : `${ecritureAlgebriqueSauf1(c)}${this.letter}^${i}`\n          break\n      }\n      maj = clean(maj)\n      res = maj + res\n    }\n    return res\n  }\n\n  /**\n   * @param {boolean} alg si true alors le coefficient dominant est doté de son signe +/-\n   * @returns {string} expression mathématique\n   */\n  toLatex(alg = false) {\n    let res = ''\n    let maj = ''\n    for (const [i, c] of this.monomes.entries()) {\n      if (c instanceof FractionEtendue) {\n        if (c.valeurDecimale === 0) continue\n        switch (i) {\n          case this.deg: {\n            const coeffD = alg\n              ? `${c.valeurDecimale < 0 ? (c.valeurAbsolue().valeurDecimale === 1 ? '-' : c.texFSD) : c.valeurDecimale === 1 ? '+' : c.ecritureAlgebrique}`\n              : this.deg === 0\n                ? c.texFSD\n                : rienSi1(c)\n            if (this.deg === 0) return c.texFSD\n            switch (this.deg) {\n              case 1:\n                maj = egal(Number(c), 0, 1e-15) ? '' : `${coeffD}${this.letter}`\n                break\n              case 0:\n                maj = egal(Number(c), 0, 1e-15) ? '' : `${coeffD}`\n                break\n              default:\n                maj = egal(Number(c), 0, 1e-15)\n                  ? ''\n                  : `${coeffD}${this.letter}^{${i}}`\n            }\n            break\n          }\n          case 0:\n            maj = egal(Number(c), 0, 1e-15) ? '' : c.ecritureAlgebrique\n            break\n          case 1:\n            maj = egal(Number(c), 0, 1e-15)\n              ? ''\n              : `${\n                  c.valeurDecimale < 0\n                    ? c.valeurAbsolue().valeurDecimale === 1\n                      ? '-'\n                      : c.texFSD\n                    : c.valeurDecimale === 1\n                      ? '+'\n                      : c.ecritureAlgebrique\n                }${this.letter}`\n            break\n          default:\n            maj = egal(Number(c), 0, 1e-15)\n              ? ''\n              : `${\n                  c.valeurDecimale < 0\n                    ? c.valeurAbsolue().valeurDecimale === 1\n                      ? '-'\n                      : c.texFSD\n                    : c.valeurDecimale === 1\n                      ? '+'\n                      : c.ecritureAlgebrique\n                }${this.letter}^{${i}}`\n            break\n        }\n        res = maj + res\n      } else {\n        switch (i) {\n          case this.deg: {\n            const coeffD = alg\n              ? ecritureAlgebriqueSauf1(c)\n              : this.deg === 0\n                ? c\n                : rienSi1(Number(c))\n            if (this.deg === 0) return texNombre(c, 2)\n            switch (this.deg) {\n              case 1:\n                maj = egal(Number(c), 0, 1e-15) ? '' : `${coeffD}${this.letter}`\n                break\n              case 0:\n                maj = egal(Number(c), 0, 1e-15) ? '' : `${coeffD}`\n                break\n              default:\n                maj = egal(Number(c), 0, 1e-15)\n                  ? ''\n                  : `${coeffD}${this.letter}^{${i}}`\n            }\n            break\n          }\n          case 0:\n            maj = egal(Number(c), 0, 1e-15) ? '' : ecritureAlgebrique(c)\n            break\n          case 1:\n            maj = egal(Number(c), 0, 1e-15)\n              ? ''\n              : `${ecritureAlgebriqueSauf1(c)}${this.letter}`\n            break\n          default:\n            maj = egal(Number(c), 0, 1e-15)\n              ? ''\n              : `${ecritureAlgebriqueSauf1(c)}${this.letter}^{${i}}`\n            break\n        }\n        res = maj + res\n      }\n    }\n    return res\n  }\n\n  /**\n   * Polynome type conversion to String\n   * @returns le résultat de toMathExpr()\n   */\n  toString() {\n    return this.toLatex()\n  }\n\n  /**\n   * Ajoute un Polynome ou une constante\n   * @param {Polynome|number|Fraction} p\n   * @example p.add(3) pour ajouter la constante 3 à p\n   * @returns {Polynome} this+p\n   */\n  add(p: NombreType | Polynome) {\n    if (typeof p === 'number') {\n      const useFrac =\n        this.monomes.filter((el) => el instanceof FractionEtendue).length > 0\n      const coeffs = [...this.monomes]\n      coeffs[0] = somme(this.monomes[0], p)\n      return new Polynome({ coeffs, useFraction: useFrac })\n    } else if (p instanceof FractionEtendue) {\n      const coeffs = [...this.monomes]\n      coeffs[0] = somme(this.monomes[0], p)\n      return new Polynome({ coeffs, useFraction: true })\n    } else if (p instanceof Decimal) {\n      const useFrac =\n        this.monomes.filter((el) => el instanceof FractionEtendue).length > 0\n      const coeffs = [...this.monomes]\n      coeffs[0] = somme(p, this.monomes[0])\n      return new Polynome({ coeffs, useFraction: useFrac })\n    } else if (p instanceof Polynome) {\n      const useFrac =\n        p.monomes.filter((el) => el instanceof FractionEtendue).length > 0 ||\n        this.monomes.filter((el) => el instanceof FractionEtendue).length > 0\n      const degSomme = max(this.deg, p.deg)\n      const pInf = equal(p.deg, degSomme) ? this : p\n      const pSup = equal(p.deg, degSomme) ? p : this\n      const coeffSomme = pSup.monomes.map(function (el, index) {\n        return index <= pInf.deg ? somme(el, pInf.monomes[index]) : el\n      })\n      return new Polynome({ coeffs: coeffSomme, useFraction: useFrac })\n    } else {\n      window.notify(\n        \"Polynome.add(arg) : l'argument n'est ni un nombre, ni un polynome\",\n        { p },\n      )\n      return this\n    }\n  }\n\n  /**\n   *\n   * @param {Polynome|number|Fraction} q Polynome, nombre ou fraction\n   * @example poly = poly.multiply(fraction(1,3)) divise tous les coefficients de poly par 3.\n   * @returns q fois this\n   */\n  multiply(q: NombreType | Polynome): Polynome {\n    let coeffs: NombreType[]\n    const useFrac =\n      q instanceof Polynome\n        ? q.monomes.filter((el) => el instanceof FractionEtendue).length > 0 ||\n          this.monomes.filter((el) => el instanceof FractionEtendue).length > 0\n        : q instanceof FractionEtendue\n\n    if (typeof q === 'number' || q instanceof FractionEtendue) {\n      coeffs = this.monomes\n        .map(function (el) {\n          return produit(el, q)\n        })\n        .map((el) => el ?? 0)\n    } else if (q instanceof Polynome) {\n      coeffs = new Array(this.deg + q.deg + 1)\n      coeffs.fill(0)\n      for (let i = 0; i <= this.deg; i++) {\n        for (let j = 0; j <= q.deg; j++) {\n          coeffs[i + j] = somme(\n            coeffs[i + j],\n            produit(this.monomes[i], q.monomes[j]),\n          )\n        }\n      }\n    } else {\n      window.notify(\n        \"Polynome.multiply(arg) : l'argument n'est ni un nombre, ni un polynome\",\n        { q },\n      )\n      return this\n    }\n    return new Polynome({ coeffs, useFraction: useFrac })\n  }\n\n  /**\n   * Retourne la dérivée\n   * @returns {Polynome} dérivée de this\n   */\n  derivee() {\n    const coeffDerivee = this.monomes\n      .map(function (el, i) {\n        return produit(el, i)\n      })\n      .map((el) => el ?? 0)\n    coeffDerivee.shift()\n    for (let i = coeffDerivee.length - 1; i > 0; i--) {\n      if (coeffDerivee[i] === 0) {\n        coeffDerivee.pop()\n        continue\n      }\n      break\n    }\n    if (coeffDerivee.length === 0) return new Polynome({ deg: 0, coeffs: [0] })\n    return new Polynome({\n      coeffs: coeffDerivee,\n      useFraction: this.useFraction,\n      useDecimal: this.useDecimal,\n      letter: this.letter,\n    })\n  }\n\n  detailleCalculDerivee() {\n    let formeDerivee = ''\n    for (let index = this.monomes.length - 1; index > 0; index--) {\n      const el = this.monomes[index]\n      if (!egal(Number(el), 0)) {\n        formeDerivee +=\n          formeDerivee === ''\n            ? `${String(index)}\\\\times ${el instanceof FractionEtendue ? el.texParentheses : ecritureParentheseSiNegatif(el)}${index > 2 ? `${this.letter}^{${index - 1}}` : index === 2 ? this.letter : ''}`\n            : `+${String(index)}\\\\times ${el instanceof FractionEtendue ? el.texParentheses : ecritureParentheseSiNegatif(el)}${index > 2 ? `${this.letter}^{${index - 1}}` : index === 2 ? this.letter : ''}`\n      }\n    }\n    return formeDerivee\n  }\n\n  /**\n   * Retourne la primitive de constante 0 de this\n   * @returns {Polynome}\n   */\n  primitive0() {\n    let coeffPrimitive = this.monomes.map((el, i) => quotient(el, i + 1)) as (\n      | number\n      | FractionEtendue\n      | Decimal\n    )[]\n    coeffPrimitive = [0, ...coeffPrimitive]\n    const useFrac =\n      coeffPrimitive.filter((el) => el instanceof FractionEtendue).length > 0\n    const useDecim =\n      coeffPrimitive.filter((el) => el instanceof Decimal).length > 0 &&\n      !useFrac\n    return new Polynome({\n      coeffs: coeffPrimitive,\n      useFraction: useFrac,\n      useDecimal: useDecim,\n    })\n  }\n\n  racines() {\n    const antecedents: number[] = []\n    if (this.monomes.slice(1).filter((el) => el !== 0).length === 0) {\n      return null\n    }\n    const liste = polynomialRoot(...this.monomes.map((el) => Number(el)))\n    for (const valeur of liste) {\n      let arr\n      if (typeof valeur === 'number') {\n        arr = round(valeur, 3)\n      } else {\n        // complexe !\n        const module = valeur.toPolar().r\n        if (module < 1e-5) {\n          // module trop petit pour être complexe, c'est 0 !\n          arr = 0\n        } else {\n          const argument: number = valeur.arg() as number\n          if (\n            abs(argument) < 0.01 ||\n            abs(abs(argument) - Number(acos(-1))) < 0.001\n          ) {\n            // si l'argument est proche de 0 ou de Pi ou de -Pi\n            arr = round(valeur.re, 3) // on prend la partie réelle\n          } else {\n            arr = null // c'est une vraie racine complexe, du coup, on prend null\n          }\n        }\n      }\n      if (arr !== null) {\n        if (!antecedents.includes(arr)) {\n          antecedents.push(arr)\n        }\n      }\n    }\n    return antecedents\n  }\n\n  /**\n   * Appelle toMathExpr\n   * @param {Array} coeffs coefficients du polynôme par ordre de degré croissant\n   * @param {boolean} alg si true alors le coefficient dominant est doté de son signe +/-\n   * @returns {string} expression du polynome\n   */\n  static print(coeffs: number[], alg = false) {\n    const p = new Polynome({ coeffs })\n    return p.toLatex(alg)\n  }\n\n  /**\n   * Pour calculer l'image d'un nombre\n   * @param x\n   * @returns {math.Fraction | number | int} // à mon avis ça ne retourne que des number...\n   */\n  image(x: number) {\n    // const fonction = x => this.monomes.reduce((val, current, currentIndex) => val + current * x ** currentIndex, 0)\n    return this.fonction(x)\n  }\n\n  /**\n   * Construit un polynôme à partir de ses racines\n   * @param roots Liste des racines du polynôme\n   * @param useFraction Utiliser des fractions pour les coefficients\n   * @param useDecimal Utiliser des décimaux pour les coefficients\n   * @returns {Polynome} Polynôme dont les racines sont celles données en paramètre\n   * @example Polynome.fromRoots([1, 2, 3]) donne (x-1)(x-2)(x-3) = x³-6x²+11x-6\n   */\n  static fromRoots(\n    roots: NombreType[],\n    useFraction = false,\n    useDecimal = false,\n  ): Polynome {\n    if (roots.length === 0) {\n      return new Polynome({ coeffs: [1] })\n    }\n\n    // Commencer avec le polynôme constant 1\n    let result = new Polynome({ coeffs: [1], useFraction, useDecimal })\n\n    // Multiplier par chaque facteur (x - racine)\n    for (const root of roots) {\n      // Créer le polynôme (x - root) = [-root, 1]\n      const factor = new Polynome({\n        coeffs: [typeof root === 'number' ? -root : produit(root, -1), 1],\n        useFraction,\n        useDecimal,\n      })\n      result = result.multiply(factor)\n    }\n\n    return result\n  }\n}\n"],"names":["chercheMinMaxLocal","poly","xG","xD","derivee","yG","yD","minLocal","maxLocal","a","b","c","delta","racine","ptiDelta","r1","r2","clean","generateCleaner","somme","Decimal","FractionEtendue","rationnalise","produit","quotient","egal","Polynome","rand","deg","coeffs","useFraction","useDecimal","letter","__publicField","largerEq","el","den","choice","aFrac","randint","dec","monomes","x","val","i","m","p","degMin","alg","res","maj","coeffD","rienSi1","ecritureAlgebriqueSauf1","ecritureAlgebrique","texNombre","useFrac","degSomme","max","pInf","equal","coeffSomme","index","q","j","coeffDerivee","formeDerivee","ecritureParentheseSiNegatif","coeffPrimitive","useDecim","antecedents","liste","polynomialRoot","valeur","arr","round","argument","abs","acos","roots","result","root","factor"],"mappings":"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"}