{"version":3,"file":"outilsStat-B9fN2o02.js","sources":["../../src/modules/outilsStat.ts"],"sourcesContent":["import { lampeMessage } from '../lib/format/message'\nimport { texteGras } from '../lib/format/style'\nimport Stat from '../lib/mathFonctions/Stat'\nimport { choice, shuffle } from '../lib/outils/arrayOutils'\nimport { nomDuMois } from '../lib/outils/dateEtHoraires'\nimport { texFractionFromString } from '../lib/outils/deprecatedFractions'\nimport { ecritureParentheseSiNegatif } from '../lib/outils/ecritures'\nimport { miseEnEvidence } from '../lib/outils/embellissements'\nimport { arrondi } from '../lib/outils/nombres'\nimport { prenom } from '../lib/outils/Personne'\nimport { texNombre } from '../lib/outils/texNombre'\nimport FractionEtendue from './FractionEtendue'\nimport { randFloat, randint } from './outils'\n\nfunction underbraceMediane(nbVal: number) {\n  let sortie\n  if (nbVal % 2 === 0) {\n    // nb pair de valeurs\n    sortie = `$\\\\underbrace{1^e\\\\hspace{0.25cm}2^e ... ${nbVal / 2 - 1}^e}_{${nbVal / 2 - 1}\\\\; valeurs} \\\\hspace{0.25cm} ${nbVal / 2}^e \\\\hspace{0.25cm} ${nbVal / 2 + 1}^e \\\\hspace{0.25cm} \\\\underbrace{${nbVal / 2 + 2}^e ... ${nbVal}^e}_{${nbVal / 2 - 1}\\\\; valeurs}$`\n  } else {\n    // nb impair de valeurs\n    sortie = `$\\\\underbrace{1^e\\\\hspace{0.25cm}2^e ... ${(nbVal - 1) / 2}^e}_{${(nbVal - 1) / 2}\\\\; valeurs} \\\\hspace{0.25cm} ${(nbVal - 1) / 2 + 1}^e \\\\hspace{0.25cm} \\\\underbrace{${(nbVal - 1) / 2 + 2}^e ... ${nbVal}^e}_{${(nbVal - 1) / 2}\\\\; valeurs}$`\n  }\n  return sortie\n}\n\nfunction desTabEffCumul(\n  tirages: number[][],\n  effCumulBool: boolean,\n  categories: string[] = [],\n  lignes = [\n    'Catégories',\n    'Scores',\n    \"Nombre d'apparitions\",\n    \"Nombre d'apparitions cumulées\",\n  ],\n) {\n  let sortie\n  if (!effCumulBool) {\n    sortie = ''\n    if (tirages.length > 12) {\n      sortie += '$\\\\def\\\\arraystretch{1.5}\\\\begin{array}{|c' // construction du tableau des effectifs 1/2\n      for (let j = 0; j <= Math.round(tirages.length / 2); j++) {\n        sortie += '|c'\n      }\n      sortie += '}'\n      if (categories.length > 0) {\n        sortie += '\\\\hline ' + `\\\\text{${lignes[0]}} `\n        for (let j = 0; j < Math.round(tirages.length / 2); j++) {\n          sortie += '&\\\\text{' + categories[j] + '}'\n        }\n        sortie += '\\\\\\\\'\n      }\n      sortie += '\\\\hline  ' + `\\\\text{${lignes[1]}} `\n      for (let j = 0; j < Math.round(tirages.length / 2); j++) {\n        sortie += '&' + tirages[j][0]\n      }\n      sortie += '\\\\\\\\\\\\hline ' + `\\\\text{${lignes[2]}} `\n      for (let j = 0; j < Math.round(tirages.length / 2); j++) {\n        sortie += '&' + tirages[j][1]\n      }\n      sortie += '\\\\\\\\\\\\hline\\\\end{array}$<br><br>'\n\n      sortie += '$\\\\def\\\\arraystretch{1.5}\\\\begin{array}{|c' // construction du tableau des effectifs 2/2\n      for (let j = Math.round(tirages.length / 2); j <= tirages.length; j++) {\n        sortie += '|c'\n      }\n      sortie += '}'\n      if (categories.length > 0) {\n        sortie += '\\\\hline ' + `\\\\text{${lignes[0]}} `\n        for (let j = Math.round(tirages.length / 2); j < tirages.length; j++) {\n          sortie += '&\\\\text{' + categories[j] + '}'\n        }\n        sortie += '\\\\\\\\'\n      }\n      sortie += '\\\\hline ' + `\\\\text{${lignes[1]}} `\n      for (let j = Math.round(tirages.length / 2); j < tirages.length; j++) {\n        sortie += '&' + tirages[j][0]\n      }\n      sortie += '\\\\\\\\\\\\hline ' + `\\\\text{${lignes[2]}} `\n      for (let j = Math.round(tirages.length / 2); j < tirages.length; j++) {\n        sortie += '&' + tirages[j][1]\n      }\n      sortie += '\\\\\\\\\\\\hline\\\\end{array}$'\n    } else {\n      sortie += '$\\\\def\\\\arraystretch{1.5}\\\\begin{array}{|c' // construction du tableau des effectifs en un seul morceau\n      for (let j = 0; j <= tirages.length; j++) {\n        sortie += '|c'\n      }\n      sortie += '}'\n      if (categories.length > 0) {\n        sortie += '\\\\hline  ' + `\\\\text{${lignes[0]}} `\n        for (let j = 0; j < tirages.length; j++) {\n          sortie += '&\\\\text{' + categories[j] + '}'\n        }\n        sortie += '\\\\\\\\'\n      }\n      sortie += '\\\\hline  ' + `\\\\text{${lignes[1]}} `\n      for (let j = 0; j < tirages.length; j++) {\n        sortie += '&' + tirages[j][0]\n      }\n      sortie += '\\\\\\\\\\\\hline ' + `\\\\text{${lignes[2]}} `\n      for (let j = 0; j < tirages.length; j++) {\n        sortie += '&' + tirages[j][1]\n      }\n      sortie += '\\\\\\\\\\\\hline\\\\end{array}$'\n    }\n  } else {\n    sortie = ''\n    if (tirages.length > 12) {\n      sortie += '$\\\\def\\\\arraystretch{1.5}\\\\begin{array}{|c' // construction du tableau des effectifs 1/2\n      for (let j = 0; j <= Math.round(tirages.length / 2); j++) {\n        sortie += '|c'\n      }\n      sortie += '}'\n      if (categories.length > 0) {\n        sortie += '\\\\hline ' + `\\\\text{${lignes[0]}} `\n        for (let j = 0; j < Math.round(tirages.length / 2); j++) {\n          sortie += '&\\\\text{' + categories[j] + '}'\n        }\n        sortie += '\\\\\\\\'\n      }\n      sortie += '\\\\hline  ' + `\\\\text{${lignes[1]}} `\n      for (let j = 0; j < Math.round(tirages.length / 2); j++) {\n        sortie += '&' + tirages[j][0]\n      }\n      sortie += '\\\\\\\\\\\\hline  ' + `\\\\text{${lignes[2]}} `\n      for (let j = 0; j < Math.round(tirages.length / 2); j++) {\n        sortie += '&' + tirages[j][1]\n      }\n      sortie += '\\\\\\\\\\\\hline ' + `\\\\text{${lignes[3]}} `\n      for (let j = 0; j < Math.round(tirages.length / 2); j++) {\n        let cumul = 0\n        for (let k = 0; k <= j; k++) {\n          cumul += tirages[k][1]\n        }\n        sortie += '&' + cumul // tirages[j][1];\n      }\n      sortie += '\\\\\\\\\\\\hline\\\\end{array}$<br><br>'\n\n      sortie += '$\\\\def\\\\arraystretch{1.5}\\\\begin{array}{|c' // construction du tableau des effectifs 2/2\n      for (let j = Math.round(tirages.length / 2); j <= tirages.length; j++) {\n        sortie += '|c'\n      }\n      sortie += '}'\n      if (categories.length > 0) {\n        sortie += '\\\\hline ' + `\\\\text{${lignes[0]}} `\n        for (let j = Math.round(tirages.length / 2); j < tirages.length; j++) {\n          sortie += '&\\\\text{' + categories[j] + '}'\n        }\n        sortie += '\\\\\\\\'\n      }\n      sortie += '\\\\hline  ' + `\\\\text{${lignes[1]}} `\n      for (let j = Math.round(tirages.length / 2); j < tirages.length; j++) {\n        sortie += '&' + tirages[j][0]\n      }\n      sortie += '\\\\\\\\\\\\hline ' + `\\\\text{${lignes[2]}} `\n      for (let j = Math.round(tirages.length / 2); j < tirages.length; j++) {\n        sortie += '&' + tirages[j][1]\n      }\n      sortie += '\\\\\\\\\\\\hline ' + `\\\\text{${lignes[3]}} `\n      for (let j = Math.round(tirages.length / 2); j < tirages.length; j++) {\n        let cumul = 0\n        for (let k = 0; k <= j; k++) {\n          cumul += tirages[k][1]\n        }\n        sortie += '&' + cumul // tirages[j][1];\n      }\n      sortie += '\\\\\\\\\\\\hline\\\\end{array}$'\n    } else {\n      sortie += '$\\\\def\\\\arraystretch{1.5}\\\\begin{array}{|c' // construction du tableau des effectifs en un seul morceau\n      for (let j = 0; j <= tirages.length; j++) {\n        sortie += '|c'\n      }\n      sortie += '}'\n      if (categories.length > 0) {\n        sortie += '\\\\hline ' + `\\\\text{${lignes[0]}} `\n        for (let j = 0; j < tirages.length; j++) {\n          sortie += '&\\\\text{' + categories[j] + '}'\n        }\n        sortie += '\\\\\\\\'\n      }\n      sortie += '\\\\hline  ' + `\\\\text{${lignes[1]}} `\n      for (let j = 0; j < tirages.length; j++) {\n        sortie += '&' + tirages[j][0]\n      }\n      sortie += '\\\\\\\\\\\\hline ' + `\\\\text{${lignes[2]}} `\n      for (let j = 0; j < tirages.length; j++) {\n        sortie += '&' + tirages[j][1]\n      }\n      sortie += '\\\\\\\\\\\\hline ' + `\\\\text{${lignes[3]}} `\n      for (let j = 0; j < tirages.length; j++) {\n        let cumul = 0\n        for (let k = 0; k <= j; k++) {\n          cumul += tirages[k][1]\n        }\n        sortie += '&' + cumul // tirages[j][1];\n      }\n      sortie += '\\\\\\\\\\\\hline\\\\end{array}$'\n    }\n  }\n\n  return sortie\n}\n\nfunction computeMoyenne(notes: number[]): [string, number] {\n  let somme = 0\n  for (let j = 0; j < notes.length; j++) {\n    somme += notes[j]\n  }\n\n  return [texFractionFromString(somme, notes.length), somme]\n}\n\nfunction computeMediane(notes: number[]): [number | [number, number], number] {\n  const notesRangees = notes.sort((a, b) => a - b)\n  let mediane\n  if (notes.length % 2 === 0) {\n    // attention les indices commencent à 0 !\n    mediane = [\n      notesRangees[notes.length / 2 - 1],\n      notesRangees[notes.length / 2],\n    ] as [number, number]\n  } else {\n    mediane = notesRangees[(notes.length - 1) / 2] as number\n  }\n  let medianeCorr // pour la correction statique\n  Array.isArray(mediane)\n    ? (medianeCorr = (mediane[0] + mediane[1]) / 2)\n    : (medianeCorr = mediane)\n  return [mediane, medianeCorr]\n}\n\nfunction computeEtendue(notes: number[]): [number, number] {\n  let min = notes[0]\n  let max = notes[0]\n  for (let j = 1; j < notes.length; j++) {\n    // On cherche la note minimum et la note maximum\n    min = Math.min(notes[j], min)\n    max = Math.max(notes[j], max)\n  }\n  return [min, max]\n}\n\nfunction computeMoyenneTirages2D(\n  tirages: number[][],\n): [string, number, number] {\n  let somme = 0\n  let effectif = 0\n  for (let k = 0; k < tirages.length; k++) {\n    somme += tirages[k][0] * tirages[k][1]\n    effectif += tirages[k][1]\n  }\n  return [texFractionFromString(somme, effectif), somme, effectif]\n}\n\nfunction computeMedianeTirages2D(\n  nombreTirages: number,\n  tirages: number[][],\n): [[number, number] | [number], number] {\n  const scoresMedians: number[] = []\n  let medianeCorr // pour la correction statique\n  if (nombreTirages % 2 === 0) {\n    // on récupère le score des deux lancers médians\n    // compteur\n    let cpt = 0\n    // Pour cumuler les effectifs, tirages est un tableau 2D qui contient les couples [score,effectif]\n    let effCumulCroiss = tirages[0][1]\n    // On récupère le premier score médian\n    while (effCumulCroiss < nombreTirages / 2) {\n      cpt += 1\n      effCumulCroiss += tirages[cpt][1]\n    }\n\n    scoresMedians.push(tirages[cpt][0])\n    // On récupère le second score médian\n    cpt = 0\n    effCumulCroiss = tirages[0][1]\n    while (effCumulCroiss < nombreTirages / 2 + 1) {\n      cpt += 1\n      effCumulCroiss += tirages[cpt][1]\n    }\n\n    scoresMedians.push(tirages[cpt][0])\n    scoresMedians[0] === scoresMedians[1]\n      ? (medianeCorr = scoresMedians[0])\n      : (medianeCorr = (scoresMedians[0] + scoresMedians[1]) / 2)\n  } else {\n    // Le nombre de lancers est impair ici\n    // on récupère le score des deux lancers médians\n    // compteur\n    let cpt = 0\n    // Pour cumuler les effectifs, tirages est un tableau 2D qui contient les couples [score,effectif]\n    let effCumulCroiss = tirages[0][1]\n    // On récupère le premier score médian\n    while (effCumulCroiss <= nombreTirages / 2) {\n      cpt += 1\n      effCumulCroiss += tirages[cpt][1]\n    }\n\n    scoresMedians.push(tirages[cpt][0])\n    medianeCorr = scoresMedians[0]\n  }\n  const scoreMed = scoresMedians.slice(0, 2) as [number, number]\n  return [scoreMed, medianeCorr]\n}\n\nfunction texteCorrMoyenneNotes(\n  notesSeries: number[] | number[][],\n  somme: number,\n  nombreNotes: number,\n  notes = 'notes',\n) {\n  const data = [\n    ['notes', 'la moyenne des notes', ''],\n    ['lancers', 'la moyenne des lancers', ''],\n    [\n      'températures',\n      'la moyenne des températures',\n      ' $\\\\mathbf{^\\\\circ\\\\text{C}}$',\n    ],\n    ['salaires', 'le salaire moyen', ' €'],\n    ['pointures', 'la pointure moyenne', ''],\n  ]\n\n  const noteStr = data.find((el) => el[0] === notes) || ['', '', '']\n\n  let texteCorr = ''\n  if (\n    notesSeries !== undefined &&\n    notesSeries instanceof Array &&\n    notesSeries.length > 0 &&\n    notesSeries[0] instanceof Array &&\n    notesSeries[0].length > 0\n  ) {\n    // tableau à deux entrées\n    const noteSeries = notesSeries as number[][]\n    texteCorr += '$\\\\text{Moyenne} = '\n    texteCorr += `\\\\dfrac{${notesSeries[0][0]} \\\\times ${notesSeries[0][1]}`\n    let eff = `${notesSeries[0][1]}`\n    for (let j = 1; j < notesSeries.length; j++) {\n      if (notesSeries.length < 10) {\n        texteCorr += `+ ${noteSeries[j][0]} \\\\times ${noteSeries[j][1]}`\n        eff += `+ ${noteSeries[j][1]}`\n      } else {\n        if (j < 3)\n          texteCorr += `+ ${noteSeries[j][0]} \\\\times ${noteSeries[j][1]}`\n        if (j < 3) eff += `+ ${noteSeries[j][1]}`\n        if (j === 3) texteCorr += '+ \\\\ldots '\n        if (j === 3) eff += '+ \\\\ldots '\n        if (j + 3 >= noteSeries.length)\n          texteCorr += `+ ${noteSeries[j][0]} \\\\times ${noteSeries[j][1]}`\n        if (j + 3 >= noteSeries.length) eff += `+ ${noteSeries[j][1]}`\n      }\n    }\n    texteCorr += `}{${eff}}=\\\\dfrac{${texNombre(somme, 0)}}{${texNombre(nombreNotes, 0)}}$. <br>`\n  } else {\n    // tableau à une entrée\n    texteCorr += '$\\\\text{Moyenne} = '\n    texteCorr += `\\\\dfrac{${notesSeries[0]} `\n    for (let j = 1; j < notesSeries.length; j++) {\n      if (notesSeries.length < 10) {\n        texteCorr += `+ ${notesSeries[j]}`\n      } else {\n        if (j < 3) texteCorr += `+ ${notesSeries[j]}`\n        if (j === 3) texteCorr += '+ \\\\ldots '\n        if (j + 3 >= notesSeries.length) texteCorr += `+ ${notesSeries[j]}`\n      }\n    }\n    texteCorr += `}{${notesSeries.length}}=\\\\dfrac{${texNombre(somme, 0)}}{${texNombre(nombreNotes, 0)}}$. <br>`\n  }\n  texteCorr += `La somme des ${notes} est : $${texNombre(somme, 0)}$.<br> Il y a $${texNombre(nombreNotes, 0)}$ ${notes}.<br>`\n  texteCorr += `Donc ${noteStr[1]} est $${new FractionEtendue(somme, nombreNotes).texFSD}`\n  if (arrondi(somme / nombreNotes, 1) === somme / nombreNotes) {\n    // moyenne exacte\n    texteCorr += `=${miseEnEvidence(texNombre(somme / nombreNotes, 1))}$${noteStr[2]}.<br>`\n  } else {\n    // moyenne arrondie\n    texteCorr += `\\\\approx${miseEnEvidence(texNombre(somme / nombreNotes, 1))}$${noteStr[2]}.<br>`\n  }\n  return texteCorr\n}\n\nfunction texteCorrEtendueNotes(min: number, max: number, note = 'note') {\n  const data = [\n    ['note', 'La note la plus basse', 'La note la plus haute', ''],\n    [\n      'lancer',\n      'Le résultat du lancer le plus faible',\n      'Le résultat du lancer le plus élevé',\n      '',\n    ],\n    [\n      'température',\n      'La température la plus basse',\n      'La température la plus haute',\n      ' $\\\\mathbf{^\\\\circ\\\\text{C}}$',\n    ],\n    ['salaire', 'Le salaire le plus bas', 'Le salaire le plus haut', ' €'],\n    ['pointure', 'La pointure la plus basse', 'La pointure la plus haute', ''],\n  ]\n  const notes = data.find((el) => el[0] === note) || ['', '', '', '']\n  let texteCorr = `${notes[1]} est $${min}$${notes[3]}.<br>${notes[2]} est $${max}$${notes[3]}.<br>`\n  texteCorr += `Donc l'étendue des ${note}s est  $${texNombre(max, 1)}-${ecritureParentheseSiNegatif(min)}=${miseEnEvidence(texNombre(max - min, 1))}$ ${notes[3]}.`\n  return texteCorr + '<br>'\n}\n\nfunction texteCorrMedianeTemperatures(\n  temperatures: number[],\n  medianeCorr: number,\n  scoresMedians: [number, number] | number,\n) {\n  if (typeof scoresMedians === 'number')\n    scoresMedians = [scoresMedians, scoresMedians]\n  return texteCorrMedianeNotes(\n    temperatures,\n    medianeCorr,\n    scoresMedians,\n    'température',\n  )\n}\n\nfunction texteCorrMedianeNotes(\n  notes: number[],\n  medianeCorr: number,\n  scoresMedians: [number, number] | number,\n  note = 'note',\n) {\n  if (typeof scoresMedians === 'number') {\n    scoresMedians = [scoresMedians, scoresMedians]\n  }\n  const data = [\n    ['note', '', '', ''],\n    ['température', ' $\\\\mathbf{^\\\\circ\\\\text{C}}$', '', ''],\n  ]\n  const noteStr = data.find((el) => el[0] === note) || ['', '', '', '']\n  let texteCorr = `Au total, il y a $${notes.length}$ ${noteStr[0]}s. `\n  if (notes.length % 2 === 0) {\n    texteCorr += `Le nombre de ${noteStr[0]}s est pair.<br>`\n  } else {\n    texteCorr += `Le nombre de ${noteStr[0]}s est impair.<br>`\n  }\n\n  texteCorr += `Les ${noteStr[0]}s sont rangées dans l'ordre croissant : <br> $${notes[0]}$`\n  for (let j = 1; j < notes.length - 1; j++) {\n    if (notes.length < 10) {\n      texteCorr += `; $${notes[j]}$ `\n    } else {\n      if (j < 2) texteCorr += `; $${notes[j]}$ `\n      if (j === 2) texteCorr += '; $\\\\dots$ '\n      if (notes.length % 2 === 0 && j === notes.length / 2 - 2)\n        texteCorr += `; $${notes[j]}$ `\n      if (notes.length % 2 === 0 && j === notes.length / 2 - 1)\n        texteCorr += `; $${notes[j]}$ `\n      if (notes.length % 2 === 0 && j === notes.length / 2)\n        texteCorr += `; $${notes[j]}$ `\n      if (notes.length % 2 === 0 && j === notes.length / 2 + 1)\n        texteCorr += `; $${notes[j]}$ `\n      if (notes.length % 2 === 0 && j === notes.length / 2 + 2)\n        texteCorr += '; $\\\\dots$ '\n      if (notes.length % 2 === 1 && j === (notes.length - 1) / 2 - 1)\n        texteCorr += `; $${notes[j]}$ `\n      if (notes.length % 2 === 1 && j === (notes.length - 1) / 2)\n        texteCorr += `; $${notes[j]}$ `\n      if (notes.length % 2 === 1 && j === (notes.length - 1) / 2 + 1)\n        texteCorr += `; $${notes[j]}$ `\n      if (notes.length % 2 === 1 && j === (notes.length - 1) / 2 + 1)\n        texteCorr += '; $\\\\dots$ '\n      if (j + 2 > notes.length - 1) texteCorr += `; $${notes[j]}$ `\n    }\n  }\n  texteCorr += `et $${notes[notes.length - 1]}$.<br>`\n\n  if (notes.length % 2 === 0) {\n    texteCorr += `Les valeurs centrales sont la $${notes.length / 2}^{e}$ valeur et la $${notes.length / 2 + 1}^{e}$ valeur.<br>\n    En effet, ${underbraceMediane(notes.length)}<br>\n    Une médiane peut être la demi-somme des deux valeurs centrales. <br>\n    La $${notes.length / 2}^{e}$ valeur est $${scoresMedians[0]}$ et la $${notes.length / 2 + 1}^{e}$ valeur est $${scoresMedians[1]}$.<br>`\n  } else {\n    texteCorr += `La valeur centrale est donc la $${(notes.length + 1) / 2}^{e}$ valeur.<br>\n    En effet, ${underbraceMediane(notes.length)}<br>\n    La médiane est donc la $${(notes.length + 1) / 2}^{e}$ ${noteStr[0]}.<br>`\n  }\n\n  texteCorr += `D'où la médiane des ${noteStr[0]}s est ${scoresMedians[0] === scoresMedians[1] ? '' : `$\\\\mathbf{(${scoresMedians[0]} + ${scoresMedians[1]}) \\\\div 2=}$`} $${miseEnEvidence(texNombre(medianeCorr))}$${noteStr[1]}.<br>`\n  /* if (notes.length % 2 === 0) {\n    texteCorr += lampeMessage({\n      titre: 'Interprétation',\n      texte: `Il y a bien $${notes.length / 2}$ ${noteStr[0]}s inférieures ou égales à  $${texNombre(medianeCorr, 1)}$ et $${notes.length / 2}$ ${noteStr[0]}s supérieures ou égales à  $${texNombre(medianeCorr, 1)}$.`,\n      couleur: 'nombres',\n    })\n  } else {\n    texteCorr += lampeMessage({\n      titre: 'Interprétation',\n      texte: `Il y a bien $${(notes.length - 1) / 2}$ ${noteStr[0]}s inférieures ou égales à  $${texNombre(medianeCorr, 1)}$ et $${(notes.length - 1) / 2}$ ${noteStr[0]}s supérieures ou égales à  $${texNombre(medianeCorr, 1)}$.`,\n      couleur: 'nombres',\n    })\n  } */\n  return texteCorr\n}\n\nfunction texteCorrMedianeTirages2DSalaires(\n  nombreTirages: number,\n  medianeCorr: number,\n  scoresMedians: [number] | [number, number],\n  salaires: number[][],\n  categories: string[],\n  salaire = 'salaire',\n) {\n  const data = [\n    [\n      'note',\n      'F',\n      'la médiane des notes',\n      '',\n      `Le nombre de notes est $${nombreTirages}$.`,\n      ['', 'Note', 'Coefficient (Effectif)', 'Effectif cumulé'],\n    ],\n    [\n      'salaire',\n      'M',\n      'le salaire médian',\n      ' €',\n      `Dans l'entreprise, le nombre de salariés est $${nombreTirages}$.`,\n      ['Catégorie', 'Salaire en €', 'Effectif', 'Effectif cumulé'],\n    ],\n    [\n      'pointure',\n      'M',\n      'la pointure médiane',\n      '',\n      `Le nombre de pointures relevées est $${nombreTirages}$.`,\n      ['', 'Pointure', 'Effectif', 'Effectif cumulé'],\n    ],\n  ]\n  const salairesStr = data.find((el) => el[0] === salaire) ?? [\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n  ]\n\n  let texteCorr = salairesStr[4] + '<br>'\n  if (nombreTirages % 2 === 0) {\n    texteCorr += `Ce nombre est pair, les ${salairesStr[0]}s sont rangé${salairesStr[0] === 'M' ? '' : 'e'}s dans l'ordre croissant.<br>\n              Les deux valeurs centrales sont la $${nombreTirages / 2}^{e}$ valeur et la $${nombreTirages / 2 + 1}^{e}$ valeur.<br>\n              En effet, ${underbraceMediane(nombreTirages)} <br>\n              Une médiane peut être la demi-somme des deux valeurs centrales. <br>\n              On peut ajouter une ligne avec les effectifs cumulés pour trouver ces deux valeurs.<br><br>\n              ${desTabEffCumul(salaires, true, categories, salairesStr[5] as string[])}<br><br>\n              La $${nombreTirages / 2}^{e}$ valeur est $${scoresMedians[0]}$ et la $${nombreTirages / 2 + 1}^{e}$ valeur est $${scoresMedians[1]}$.<br>`\n    texteCorr += `D'où ${salairesStr[2]} est ${scoresMedians[0] === scoresMedians[1] ? '' : `$(${scoresMedians[0]} + ${scoresMedians[1]}) \\\\div 2=$`} $${miseEnEvidence(texNombre(medianeCorr))}$${salairesStr[3]}.<br>`\n    /* texteCorr += lampeMessage({\n      titre: 'Interprétation',\n      texte: `Il y a bien $${nombreTirages / 2}$ ${salairesStr[0]}s dont la valeur est inférieure ou égale à  $${texNombre(medianeCorr, 1)}$${salairesStr[3]} et $${nombreTirages / 2}$ ${salairesStr[0]}s dont la valeur est supérieure ou égale à  $${texNombre(medianeCorr, 1)}$${salairesStr[3]}.`,\n      couleur: 'nombres',\n    }) */\n  } else {\n    // Le nombre de tirages est impair\n    texteCorr += `Ce nombre est impair, les ${salairesStr[0]}s sont rangé${salairesStr[0] === 'M' ? '' : 'e'}s dans l'ordre croissant.<br>\n                  La valeur centrale est la $${(nombreTirages - 1) / 2 + 1}^{e}$ valeur.<br>\n                  En effet, ${underbraceMediane(nombreTirages)} <br>\n                  La médiane est donc la $${(nombreTirages - 1) / 2 + 1}^{e}$ valeur.<br>\n                  On peut ajouter une ligne avec les effectifs cumulés pour trouver cette valeur.<br><br>\n                  ${desTabEffCumul(salaires, true, categories, salairesStr[5] as string[])}<br><br>`\n    texteCorr += `D'où ${salairesStr[2]} est $${miseEnEvidence(texNombre(medianeCorr))}$ ${salairesStr[3]}.<br>`\n    /* texteCorr += lampeMessage({\n      titre: 'Interprétation',\n      texte: `Il y a bien $${(nombreTirages - 1) / 2}$ ${salairesStr[0]}s dont la valeur est inférieure ou égale à  $${texNombre(medianeCorr, 1)}$${salairesStr[3]} et $${(nombreTirages - 1) / 2}$ ${salairesStr[0]}s dont la valeur est supérieure ou égale à  $${texNombre(medianeCorr, 1)}$${salairesStr[3]}.`,\n      couleur: 'nombres',\n    }) */\n  }\n  return texteCorr\n}\n\nfunction texteCorrMedianeTirages2D(\n  nombreTirages: number,\n  medianeCorr: number,\n  scoresMedians: [number, number] | [number],\n  tirages: number[][],\n) {\n  let texteCorr = `Au total, $${nombreTirages}$ lancers ont été réalisés.<br>`\n  if (nombreTirages % 2 === 0) {\n    texteCorr += `Le nombre de lancers est pair, les scores sont rangés dans l'ordre croissant.<br>\n              Les deux valeurs centrales sont la $${nombreTirages / 2}^{e}$ et la $${nombreTirages / 2 + 1}^{e}$ valeur.<br>\n              En effet, ${underbraceMediane(nombreTirages)} <br>\n              Une médiane peut être la demi-somme des deux valeurs centrales. <br>\n              On peut ajouter une ligne avec les effectifs cumulés pour trouver ces deux valeurs.<br><br>\n              ${desTabEffCumul(tirages, true)}<br><br>\n              La $${nombreTirages / 2}^{e}$ valeur est $${scoresMedians[0]}$ et la $${nombreTirages / 2 + 1}^{e}$ valeur est $${scoresMedians[1]}$.<br>`\n    texteCorr += `D'où le score médian est ${scoresMedians[0] === scoresMedians[1] ? '' : `$(${scoresMedians[0]} + ${scoresMedians[1]}) \\\\div 2=$`} $${miseEnEvidence(texNombre(medianeCorr))}$.<br>`\n    /* texteCorr += lampeMessage({\n      titre: 'Interprétation',\n      texte: `Il y a bien $${nombreTirages / 2}$ lancers dont le score est inférieur ou égal à  $${texNombre(medianeCorr, 1)}$ et $${nombreTirages / 2}$ lancers dont le score est supérieur ou égal à  $${texNombre(medianeCorr, 1)}$.`,\n      couleur: 'nombres',\n    }) */\n  } else {\n    // Le nombre de lancers est impair ici\n    texteCorr += `Le nombre de lancers est impair, les scores sont rangés dans l'ordre croissant.<br>\n                  La valeur centrale est la $${(nombreTirages - 1) / 2 + 1}^{e}$ valeur.<br>\n                  En effet, ${underbraceMediane(nombreTirages)} <br>\n                  La médiane est donc le $${(nombreTirages - 1) / 2 + 1}^{e}$ lancer.<br>\n                  On peut ajouter une ligne avec les effectifs cumulés pour trouver cette valeur.<br><br>\n                  ${desTabEffCumul(tirages, true)}<br><br>`\n    texteCorr += `D'où le score médian est $${miseEnEvidence(texNombre(medianeCorr))}$.<br>`\n    /* texteCorr += lampeMessage({\n      titre: 'Interprétation',\n      texte: `Il y a bien $${(nombreTirages - 1) / 2}$ lancers dont le score est inférieur ou égal à  $${texNombre(medianeCorr, 1)}$ et $${(nombreTirages - 1) / 2}$ lancers dont le score est supérieur ou égal à  $${texNombre(medianeCorr, 1)}$.`,\n      couleur: 'nombres',\n    }) */\n  }\n  return texteCorr\n}\n\nfunction texteNotes(notes: number[]) {\n  let texte = `${prenom()} a obtenu ces notes ce trimestre-ci en mathématiques :<br>`\n  texte += `$${notes[0]}$`\n  for (let j = 1; j < notes.length - 1; j++) {\n    texte += `; $${notes[j]}$ `\n  } // On liste les notes (série brute)\n  texte += `et $${notes[notes.length - 1]}$.`\n  return texte\n}\n\nfunction texteTemperatures(\n  annee: number,\n  mois: number,\n  temperatures: number[],\n) {\n  let texte = `En ${nomDuMois(mois)} ${annee}, à ${choice(['Moscou', 'Berlin', 'Paris', 'Bruxelles', 'Rome', 'Belgrade'])}, on a relevé les températures suivantes : <br>`\n  texte += '<br>$\\\\def\\\\arraystretch{1.5}\\\\begin{array}{|c' // On construit le tableau des températures\n  texte += '|c'\n  for (let j = 0; j < Math.round(temperatures.length / 2); j++) {\n    texte += '|c'\n  }\n  texte += '}\\\\hline  \\\\text{Jour}'\n  for (let j = 0; j < Math.round(temperatures.length / 2); j++) {\n    texte += '&' + texNombre(j + 1, 1)\n  }\n  texte += '\\\\\\\\\\\\hline \\\\text{Température en}  ^\\\\circ\\\\text{C}'\n  for (let j = 0; j < Math.round(temperatures.length / 2); j++) {\n    texte += '&' + temperatures[j]\n  }\n  texte += '\\\\\\\\\\\\hline\\\\end{array}$<br><br>'\n  texte += '$\\\\def\\\\arraystretch{1.5}\\\\begin{array}{|c' // On construit le tableau des températures\n  texte += '|c'\n  for (\n    let j = Math.round(temperatures.length / 2);\n    j < temperatures.length;\n    j++\n  ) {\n    texte += '|c'\n  }\n  texte += '}\\\\hline  \\\\text{Jour}'\n  for (\n    let j = Math.round(temperatures.length / 2);\n    j < temperatures.length;\n    j++\n  ) {\n    texte += '&' + texNombre(j + 1, 1)\n  }\n  texte += '\\\\\\\\\\\\hline \\\\text{Température en}  ^\\\\circ\\\\text{C}'\n  for (\n    let j = Math.round(temperatures.length / 2);\n    j < temperatures.length;\n    j++\n  ) {\n    texte += '&' + temperatures[j]\n  }\n  texte += '\\\\\\\\\\\\hline\\\\end{array}$'\n  texte += '<br>'\n  return texte\n}\n\nfunction texteSalaires(\n  salaires: number[][],\n  categoriesCol: string[],\n  salaire = 'salaires',\n) {\n  const data = [\n    [\n      'salaires',\n      \"La grille des salaires des employés d'une PME est donnée par le tableau ci-dessous\",\n      ['Catégories', 'Salaires en €', 'Effectif'],\n    ],\n    [\n      'notes',\n      `Voici les notes obtenues par ${prenom()} en mathématiques cette année`,\n      ['', 'Note', 'Effectif'],\n    ],\n    [\n      'pointures',\n      `Pour passer une commande de chaussures de foot, ${prenom()} a noté les pointures des membres de son club dans un tableau`,\n      ['', 'Pointure', 'Effectif'],\n    ],\n  ]\n  const salairesStr = data.find((el) => el[0] === salaire) || ['', '', '', '']\n  let texte = salairesStr[1] + ' :<br> '\n  texte +=\n    '<br>' +\n    desTabEffCumul(salaires, false, categoriesCol, salairesStr[2] as string[]) +\n    '<br>'\n  return texte\n}\n\nfunction texteTirages2D(\n  nombreDes: number,\n  nombreTirages: number,\n  nombreFaces: 4 | 6 | 8 | 10,\n  tirages: number[][],\n  aveclampeMessage = true,\n) {\n  let texte = ''\n  if (nombreDes > 1) {\n    texte = `On a réalisé $${nombreTirages}$ lancers de $${nombreDes}$ dés à $${nombreFaces}$ faces.<br>\n            On a relevé la somme des $${nombreDes}$ dés.<br>`\n  } else {\n    texte = `On a réalisé $${nombreTirages}$ lancers d'un dé à $${nombreFaces}$ faces.<br>`\n  }\n  texte += aveclampeMessage\n    ? lampeMessage({\n        titre: 'Vocabulaire',\n        texte: `Le solide qui correspond à ce type de dé s'appelle ${texteGras(solidName(nombreFaces))}.`,\n        couleur: 'nombres',\n      })\n    : ''\n  texte += 'Les résultats sont inscrits dans le tableau ci-dessous :<br><br>'\n  texte += desTabEffCumul(tirages, false) + '<br>'\n  return texte\n}\n\nfunction solidName(nbCot: 4 | 6 | 8 | 10) {\n  switch (nbCot) {\n    case 4:\n      return 'tétraèdre'\n    case 6:\n      return 'hexaèdre'\n    case 8:\n      return 'octaèdre'\n    case 10:\n    default:\n      return 'décaèdre'\n  }\n}\n\n/**\n * Construit une série numérique (triée) compatible avec les résumés fournis.\n * Paramètres requis : q1, mediane, q3, etendue. La moyenne est optionnelle.\n * La série ne contiendra pas de valeurs aberrantes (selon la règle 1.5*IQR).\n * Retourne un tableau trié de longueur n (par défaut 20).\n */\nexport function creerSerieDeQuartiles({\n  q1,\n  mediane,\n  q3,\n  min,\n  max,\n  n = 20,\n  isInteger = false,\n}: {\n  q1: number\n  mediane: number\n  q3: number\n  min: number\n  max: number\n  n?: number\n  isInteger?: boolean\n}): number[] {\n  if (n < 5) {\n    throw new Error('La taille de la série doit être au moins de 5')\n  }\n\n  // Si entier demandé, arrondir quantiles et min/max, garantir ordre\n  if (isInteger) {\n    q1 = Math.round(q1)\n    mediane = Math.round(mediane)\n    q3 = Math.round(q3)\n    min = Math.round(min)\n    max = Math.round(max)\n    if (q1 > mediane) mediane = q1\n    if (mediane > q3) q3 = mediane\n    if (min > q1) min = q1\n    if (max < q3) max = q3\n  }\n\n  const serie: number[] = []\n  const quartileCount = Math.floor(n / 4)\n  const remaining = n - 3 * quartileCount\n\n  // Génération contrôlée par quartiles\n  for (let i = 0; i < quartileCount; i++) {\n    const value = q1 - (q1 - min) * (Math.random() * 0.5 + 0.1)\n    serie.push(isInteger ? Math.round(value) : value)\n  }\n  for (let i = 0; i < quartileCount; i++) {\n    const value = q1 + (mediane - q1) * (Math.random() * 0.8 + 0.1)\n    serie.push(isInteger ? Math.round(value) : value)\n  }\n  for (let i = 0; i < quartileCount; i++) {\n    const value = mediane + (q3 - mediane) * (Math.random() * 0.8 + 0.1)\n    serie.push(isInteger ? Math.round(value) : value)\n  }\n  for (let i = 0; i < remaining; i++) {\n    const value = q3 + (max - q3) * (Math.random() * 0.5 + 0.1)\n    serie.push(isInteger ? Math.round(value) : value)\n  }\n\n  // Trier puis forcer les positions de quartiles (une ou deux positions selon n)\n  serie.sort((a, b) => a - b)\n\n  const getQuartilePositions = (which: 'q1' | 'q2' | 'q3'): number[] => {\n    const mid = Math.floor(n / 2)\n    const lowerLen = mid\n    if (which === 'q1') {\n      if (lowerLen % 2 === 1) {\n        return [Math.floor(lowerLen / 2)]\n      } else {\n        return [lowerLen / 2 - 1, lowerLen / 2]\n      }\n    } else if (which === 'q2') {\n      if (n % 2 === 1) {\n        return [mid]\n      } else {\n        return [mid - 1, mid]\n      }\n    } else {\n      const start = n - lowerLen\n      if (lowerLen % 2 === 1) {\n        return [start + Math.floor(lowerLen / 2)]\n      } else {\n        return [start + lowerLen / 2 - 1, start + lowerLen / 2]\n      }\n    }\n  }\n\n  const applyQuartileValue = (positions: number[], value: number) => {\n    if (positions.length === 1) {\n      serie[positions[0]] = isInteger ? Math.round(value) : value\n    } else {\n      const v = isInteger ? Math.round(value) : value\n      serie[positions[0]] = v\n      serie[positions[1]] = v\n    }\n  }\n  applyQuartileValue(getQuartilePositions('q1'), q1)\n  applyQuartileValue(getQuartilePositions('q2'), mediane)\n  applyQuartileValue(getQuartilePositions('q3'), q3)\n\n  // S'assurer que min et max sont bien les extrêmes de la série\n  serie[0] = isInteger ? Math.round(min) : min\n  serie[n - 1] = isInteger ? Math.round(max) : max\n\n  // Clamp sur [min,max] (sécurité)\n  for (let i = 0; i < n; i++) {\n    if (serie[i] < min) serie[i] = min\n    if (serie[i] > max) serie[i] = max\n  }\n\n  // Réparer monotonicité : avant puis arrière\n  for (let i = 1; i < n; i++) {\n    if (serie[i] < serie[i - 1]) {\n      const apres = serie[i]\n      serie[i] = apres\n      serie[i - 1] = apres\n      i++\n    }\n  }\n\n  // Vérification stricte : recalculer les quartiles et comparer\n  const stat = new Stat(serie)\n  const qs = stat.quartiles()\n  const eq = (a: number, b: number) =>\n    isInteger ? a === b : Math.abs(a - b) < 1e-9\n  if (!eq(qs.q1, q1) || !eq(qs.q2, mediane) || !eq(qs.q3, q3)) {\n    throw new Error(\n      'Impossible de construire une série respectant exactement les quartiles demandés avec les contraintes fournies',\n    )\n  }\n\n  // Enfin s'assurer que min/max sont bien les extrêmes après réajustements\n  if (\n    serie[0] !== (isInteger ? Math.round(min) : min) ||\n    serie[n - 1] !== (isInteger ? Math.round(max) : max)\n  ) {\n    throw new Error(\n      'Impossible de conserver min/max comme extrêmes sans violer les quartiles demandés',\n    )\n  }\n\n  return serie\n}\n\n/**\n * Génère une série de `n` valeurs, dont la moyenne est exactement `mean` et l'étendue est exactement `range`.\n * Les valeurs sont comprises entre min et max où max - min = range.\n *\n * @param mean - moyenne cible (requis)\n * @param range - étendue cible (max - min) (requis)\n * @param n - nombre de valeurs (par défaut 20)\n * @param isInteger - si les valeurs doivent être entières (par défaut false)\n * @param precision - précision décimale pour les flottants (par défaut 2)\n * @param gaussian - si les valeurs doivent suivre une distribution gaussienne (par défaut false)\n * @returns série de nombres de longueur `n`, avec moyenne exacte = `mean` et étendue exacte = `range`\n */\nexport function creerSerieDeMoyenneEtEtendue({\n  mean,\n  range,\n  n = 20,\n  isInteger = false,\n  precision = 2,\n  gaussian = false,\n}: {\n  mean: number\n  range: number\n  n?: number\n  isInteger?: boolean\n  precision?: number\n  gaussian?: boolean\n}): number[] {\n  if (n <= 0) throw new Error('n doit être supérieur à 0')\n  if (range < 0) throw new Error('range doit être positif ou nul')\n  if (!isFinite(mean)) throw new Error('mean doit être un nombre fini')\n\n  // Calculer min et max pour avoir exactement l'étendue voulue\n  const min = isInteger ? Math.floor(mean - range / 2) : mean - range / 2\n  const max = min + range\n\n  const serie: number[] = []\n\n  if (n === 1) {\n    // Cas spécial : une seule valeur = la moyenne\n    serie.push(isInteger ? Math.round(mean) : mean)\n    return serie\n  }\n\n  // Générateur de nombre aléatoire gaussien (Box-Muller)\n  const gaussianRandom = (): number => {\n    let u1 = 0\n    let u2 = 0\n    while (u1 === 0) u1 = Math.random() // Éviter log(0)\n    while (u2 === 0) u2 = Math.random()\n    const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2)\n    return z0\n  }\n\n  if (gaussian) {\n    // Distribution gaussienne\n    // L'écart-type est estimé pour que ~99.7% des valeurs soient dans [min, max]\n    const stdDev = range / 6 // 3 sigma = range\n\n    // Générer n valeurs gaussiennes\n    for (let i = 0; i < n; i++) {\n      let value = mean + gaussianRandom() * stdDev\n\n      // Clamp les valeurs hors limites\n      value = Math.max(min, Math.min(max, value))\n\n      if (isInteger) {\n        value = Math.round(value)\n      } else {\n        value =\n          Math.round(value * Math.pow(10, precision)) / Math.pow(10, precision)\n      }\n      serie.push(value)\n    }\n\n    // Réajuster la moyenne si nécessaire\n    const actualSum = serie.reduce((a, b) => a + b, 0)\n    const requiredSum = mean * n\n    let diff = requiredSum - actualSum\n\n    if (Math.abs(diff) > 0.001) {\n      for (let i = 0; i < n && Math.abs(diff) > 0.001; i++) {\n        const oldVal = serie[i]\n        let newVal = oldVal + diff / (n - i)\n\n        // Clamp\n        newVal = Math.max(min, Math.min(max, newVal))\n\n        if (isInteger) {\n          newVal = Math.round(newVal)\n        } else {\n          newVal =\n            Math.round(newVal * Math.pow(10, precision)) /\n            Math.pow(10, precision)\n        }\n\n        diff -= newVal - oldVal\n        serie[i] = newVal\n      }\n    }\n  } else {\n    // Initialiser avec min et max (pour assurer l'étendue exacte)\n    serie.push(isInteger ? Math.round(min) : min)\n    serie.push(isInteger ? Math.round(max) : max)\n\n    // Calcul de la somme requise\n    const requiredSum = mean * n\n    const currentSum = serie[0] + serie[1]\n    let remaining = requiredSum - currentSum\n\n    // Remplir le reste des valeurs\n    for (let i = 2; i < n; i++) {\n      let value: number\n      if (i < n - 1) {\n        // Pour les valeurs intermédiaires, générer aléatoirement dans [min, max]\n        value = isInteger\n          ? randint(Math.ceil(min), Math.floor(max))\n          : randFloat(min, max, precision)\n      } else {\n        // Dernière valeur : calculer exactement pour atteindre la moyenne\n        value = remaining\n        if (isInteger) {\n          value = Math.round(value)\n        } else {\n          value =\n            Math.round(value * Math.pow(10, precision)) /\n            Math.pow(10, precision)\n        }\n      }\n\n      // Vérifier que la valeur respecte les bornes\n      if (value < min) value = min\n      if (value > max) value = max\n\n      serie.push(value)\n      remaining -= value\n    }\n\n    // Réajustement si nécessaire pour les erreurs d'arrondi\n    if (Math.abs(remaining) > 0.001) {\n      // Ajouter le reste à une valeur intermédiaire (pas min ni max)\n      let adjusted = false\n      for (let i = 1; i < n - 1; i++) {\n        const newVal = serie[i] + remaining\n        if (newVal >= min && newVal <= max) {\n          serie[i] = isInteger\n            ? Math.round(newVal)\n            : Math.round(newVal * Math.pow(10, precision)) /\n              Math.pow(10, precision)\n          adjusted = true\n          break\n        }\n      }\n      if (!adjusted) {\n        console.warn(\n          `Impossible d'atteindre exactement la moyenne ${mean} avec l'étendue ${range}. Écart : ${remaining}`,\n        )\n      }\n    }\n  }\n\n  // Mélanger la série avant de la retourner\n  return shuffle(serie)\n}\n\nexport function creerSerieDeValeurs(\n  values: number[],\n  n: number,\n): [number, number][] {\n  const objetSerie: Record<number, number> = {}\n  for (const val of values) {\n    objetSerie[val] = 0\n  }\n  for (let i = 0; i < n; i++) {\n    const val = values[randint(0, values.length - 1)]\n    objetSerie[val] += 1\n  }\n  const serie: [number, number][] = []\n  for (const key in objetSerie) {\n    serie.push([Number(key), objetSerie[key]])\n  }\n  return serie\n}\n\nexport const OutilsStats = {\n  desTabEffCumul,\n  // consigne\n  texteNotes,\n  texteTirages2D,\n  texteSalaires,\n  texteTemperatures,\n  // correction\n  texteCorrMoyenneNotes,\n  texteCorrMedianeTirages2D,\n  texteCorrMedianeTirages2DSalaires,\n  texteCorrMedianeTemperatures,\n  texteCorrMedianeNotes,\n  texteCorrEtendueNotes,\n  // calcul\n  computeEtendue,\n  computeMoyenne,\n  computeMediane,\n  computeMoyenneTirages2D,\n  computeMedianeTirages2D,\n}\n"],"names":["underbraceMediane","nbVal","sortie","desTabEffCumul","tirages","effCumulBool","categories","lignes","j","cumul","k","computeMoyenne","notes","somme","texFractionFromString","computeMediane","notesRangees","a","b","mediane","medianeCorr","computeEtendue","min","max","computeMoyenneTirages2D","effectif","computeMedianeTirages2D","nombreTirages","scoresMedians","cpt","effCumulCroiss","texteCorrMoyenneNotes","notesSeries","nombreNotes","noteStr","el","texteCorr","noteSeries","eff","texNombre","FractionEtendue","arrondi","miseEnEvidence","texteCorrEtendueNotes","note","ecritureParentheseSiNegatif","texteCorrMedianeTemperatures","temperatures","texteCorrMedianeNotes","texteCorrMedianeTirages2DSalaires","salaires","salaire","salairesStr","texteCorrMedianeTirages2D","texteNotes","texte","prenom","texteTemperatures","annee","mois","nomDuMois","choice","texteSalaires","categoriesCol","texteTirages2D","nombreDes","nombreFaces","aveclampeMessage","lampeMessage","texteGras","solidName","nbCot","creerSerieDeQuartiles","q1","q3","n","isInteger","serie","quartileCount","remaining","i","value","getQuartilePositions","which","mid","lowerLen","start","applyQuartileValue","positions","v","apres","qs","Stat","eq","creerSerieDeMoyenneEtEtendue","mean","range","precision","gaussian","gaussianRandom","u1","u2","stdDev","actualSum","diff","oldVal","newVal","requiredSum","currentSum","randint","randFloat","adjusted","shuffle","creerSerieDeValeurs","values","objetSerie","val","key","OutilsStats"],"mappings":"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"}