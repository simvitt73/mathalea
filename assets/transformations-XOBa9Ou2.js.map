{"version":3,"file":"transformations-XOBa9Ou2.js","sources":["../../src/lib/2d/transformations.ts"],"sourcesContent":["import { egal } from '../../modules/outils'\nimport { Droite, droite } from './droites'\nimport type {\n  IDroite,\n  IPoint,\n  IPointAbstrait,\n  IPolygone,\n  ISegment,\n  IVecteur,\n} from './Interfaces'\nimport type { ObjetMathalea2D } from './ObjetMathalea2D'\nimport { PointAbstrait, pointAbstrait } from './PointAbstrait'\nimport { Polygone, polygone } from './polygones'\nimport { Segment, segment } from './segmentsVecteurs'\nimport { Vecteur, vecteur } from './Vecteur'\n\n/**\n * Convertit un angle en degrés vers des radians\n */\nfunction degToRad(deg: number): number {\n  return (deg * Math.PI) / 180\n}\n\n/**\n * M = translation(O,v) //M est l'image de O dans la translation de vecteur v\n * M = translation(O,v,'M') //M est l'image de O dans la translation de vecteur v et se nomme M\n * M = translation(O,v,'M','below') //M est l'image de O dans la translation de vecteur v, se nomme M et le nom est en dessous du point\n * @param {ObjecMathalea2d} O objet à translater (PointAbstrait, Droite, Segment, Polygone ou Vecteur)\n * @param {Vecteur} v vecteur de translation\n * @param {string} nom nom du translaté pour un PointAbstrait\n * @param {string} positionLabel Position du label pour un PointAbstrait\n * @param {string} [color='black'] Code couleur HTML acceptée\n * @author Rémi Angot\n */\n\n// Surcharges (entrées typées avec les interfaces, retours classes concrètes)\nexport function translation(\n  O: IVecteur,\n  v: IVecteur | Vecteur | PointAbstrait,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Vecteur\nexport function translation(\n  O: IPolygone,\n  v: IVecteur | Vecteur | PointAbstrait,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Polygone\nexport function translation(\n  O: IDroite,\n  v: IVecteur | Vecteur | PointAbstrait,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Droite\nexport function translation(\n  O: ISegment,\n  v: IVecteur | Vecteur | PointAbstrait,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Segment\nexport function translation(\n  O: IPointAbstrait,\n  v: IVecteur | Vecteur | PointAbstrait,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): PointAbstrait\nexport function translation(\n  O: IPoint,\n  v: IVecteur | Vecteur | PointAbstrait,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): PointAbstrait\nexport function translation(\n  O: PointAbstrait,\n  v: IVecteur | Vecteur | PointAbstrait,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): PointAbstrait\nexport function translation(\n  O: ObjetMathalea2D,\n  v: IVecteur | Vecteur | PointAbstrait,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): ObjetMathalea2D\n\n// Implémentation (type union d'interfaces, garde par propriétés)\nexport function translation(\n  O:\n    | IPointAbstrait\n    | IPoint\n    | PointAbstrait\n    | IDroite\n    | ISegment\n    | IPolygone\n    | IVecteur\n    | ObjetMathalea2D,\n  vecteurTranslation: IVecteur | Vecteur | PointAbstrait, // ← Renommer le paramètre\n  nom = '',\n  positionLabel = 'above',\n  color = 'black',\n):\n  | PointAbstrait\n  | PointAbstrait\n  | Droite\n  | Segment\n  | Polygone\n  | Vecteur\n  | ObjetMathalea2D {\n  // Points (PointAbstrait ou PointAbstrait)\n  if (O instanceof PointAbstrait || O instanceof PointAbstrait) {\n    const x = O.x + vecteurTranslation.x\n    const y = O.y + vecteurTranslation.y\n    if (O instanceof PointAbstrait) {\n      return pointAbstrait(x, y, nom, positionLabel)\n    } else {\n      return pointAbstrait(x, y, nom, positionLabel)\n    }\n  }\n\n  // Polygone\n  if ('listePoints' in O) {\n    const p2: PointAbstrait[] = []\n    for (let i = 0; i < O.listePoints.length; i++) {\n      const pi = translation(\n        O.listePoints[i] as PointAbstrait,\n        vecteurTranslation,\n      ) as PointAbstrait\n      pi.nom = O.listePoints[i].nom + \"'\"\n      p2[i] = pi\n    }\n    return polygone(p2, color)\n  }\n\n  // Droite\n  if ('pente' in O) {\n    const M = translation(\n      pointAbstrait(O.x1, O.y1),\n      vecteurTranslation,\n    ) as PointAbstrait\n    const N = translation(\n      pointAbstrait(O.x2, O.y2),\n      vecteurTranslation,\n    ) as PointAbstrait\n    return droite(M, N, color)\n  }\n\n  // Segment\n  if ('extremite1' in O && 'extremite2' in O) {\n    const M = translation(\n      O.extremite1 as PointAbstrait,\n      vecteurTranslation,\n    ) as PointAbstrait\n    const N = translation(\n      O.extremite2 as PointAbstrait,\n      vecteurTranslation,\n    ) as PointAbstrait\n    const s = segment(M, N, color)\n    ;(s as any).styleExtremites = (O as any).styleExtremites\n    return s\n  }\n\n  if ('norme' in O) {\n    // Vecteur: invariant par translation -> renvoyer un vecteur identique\n    return vecteur(O.x, O.y)\n  }\n  return O as unknown as ObjetMathalea2D\n}\n\n/**\n * M = translation2Points(O,A,B) //M est l'image de O dans la translation qui transforme A en B\n * M = translation2Points(O,A,B,'M') //M est l'image de O dans la translation qui transforme A en B et se nomme M\n * M = translation2Points(O,A,B,'M','below') //M est l'image de O dans la translation qui transforme A en B, se nomme M et le nom est en dessous du point\n *\n * @author Rémi Angot\n */\n\n// Surcharges\nexport function translation2Points(\n  O: IPointAbstrait,\n  A: IPointAbstrait,\n  B: IPointAbstrait,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): PointAbstrait\nexport function translation2Points(\n  O: IPoint,\n  A: IPointAbstrait,\n  B: IPointAbstrait,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): PointAbstrait\nexport function translation2Points(\n  O: IDroite,\n  A: IPointAbstrait,\n  B: IPointAbstrait,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Droite\nexport function translation2Points(\n  O: ISegment,\n  A: IPointAbstrait,\n  B: IPointAbstrait,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Segment\nexport function translation2Points(\n  O: IPolygone,\n  A: IPointAbstrait,\n  B: IPointAbstrait,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Polygone\nexport function translation2Points(\n  O: IVecteur,\n  A: IPointAbstrait,\n  B: IPointAbstrait,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Vecteur\n\n// Implémentation\nexport function translation2Points(\n  O: IPointAbstrait | IPoint | IDroite | ISegment | IPolygone | IVecteur,\n  A: IPointAbstrait,\n  B: IPointAbstrait,\n  nom = '',\n  positionLabel = 'above',\n  color = 'black',\n): PointAbstrait | PointAbstrait | Droite | Segment | Polygone | Vecteur {\n  // Points (PointAbstrait ou PointAbstrait)\n  if (O instanceof PointAbstrait || O instanceof PointAbstrait) {\n    const x = O.x + B.x - A.x\n    const y = O.y + B.y - A.y\n    if (O instanceof PointAbstrait) {\n      return pointAbstrait(x, y, nom, positionLabel)\n    } else {\n      return pointAbstrait(x, y, nom, positionLabel)\n    }\n  }\n\n  // Polygone\n  if ('listePoints' in O) {\n    const p2: PointAbstrait[] = []\n    for (let i = 0; i < O.listePoints.length; i++) {\n      const pi = translation2Points(O.listePoints[i], A, B) as PointAbstrait\n      pi.nom = O.listePoints[i].nom + \"'\"\n      p2[i] = pi\n    }\n    return polygone(p2, color)\n  }\n\n  // Droite\n  if ('pente' in O) {\n    const M = translation2Points(\n      pointAbstrait(O.x1, O.y1),\n      A,\n      B,\n    ) as PointAbstrait\n    const N = translation2Points(\n      pointAbstrait(O.x2, O.y2),\n      A,\n      B,\n    ) as PointAbstrait\n    return droite(M, N, color)\n  }\n\n  // Segment\n  if ('extremite1' in O && 'extremite2' in O) {\n    const M = translation2Points(O.extremite1, A, B) as PointAbstrait\n    const N = translation2Points(O.extremite2, A, B) as PointAbstrait\n    const s = segment(M, N, color)\n    ;(s as any).styleExtremites = (O as any).styleExtremites\n    return s\n  }\n\n  // Vecteur (ne change pas par translation)\n  if ('x' in O && 'y' in O) {\n    return vecteur(O.x, O.y)\n  }\n\n  // Fallback\n  return O as unknown as PointAbstrait\n}\n\n/**\n * @param {PointAbstrait|PointAbstrait|Polygone|Droite|Vecteur|Segment} A PointAbstrait, Polygone, Droite, Segment ou Vecteur\n * @param {PointAbstrait} O Centre de rotation\n * @param {number} angle Angle de rotation\n * @param {string} [nom=''] Nom de l'image\n * @param {string} [positionLabel='above']\n * @param {string} [color='black'] Code couleur HTML acceptée\n * @return L'image de A par la rotation de centre O et d'angle angle\n * @author Rémi Angot et Jean-Claude Lhote\n */\n\nexport function rotation(\n  A: IDroite,\n  O: PointAbstrait,\n  angle: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Droite\nexport function rotation(\n  A: ISegment,\n  O: PointAbstrait,\n  angle: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Segment\nexport function rotation(\n  A: IPolygone,\n  O: PointAbstrait,\n  angle: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Polygone\nexport function rotation(\n  A: IVecteur,\n  O: PointAbstrait,\n  angle: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): IVecteur\n\nexport function rotation(\n  A: PointAbstrait,\n  O: PointAbstrait,\n  angle: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): PointAbstrait\n\n// Implémentation (avec classes concrètes pour instanceof)\nexport function rotation(\n  A: IPointAbstrait | IPoint | IDroite | ISegment | IPolygone | IVecteur,\n  O: PointAbstrait,\n  angle: number,\n  nom = '',\n  positionLabel = 'above',\n  color = 'black',\n): PointAbstrait | Droite | Segment | Polygone | Vecteur {\n  if (A instanceof PointAbstrait || A instanceof PointAbstrait) {\n    const x =\n      O.x +\n      (A.x - O.x) * Math.cos((angle * Math.PI) / 180) -\n      (A.y - O.y) * Math.sin((angle * Math.PI) / 180)\n    const y =\n      O.y +\n      (A.x - O.x) * Math.sin((angle * Math.PI) / 180) +\n      (A.y - O.y) * Math.cos((angle * Math.PI) / 180)\n    if (A instanceof PointAbstrait) {\n      return pointAbstrait(x, y, nom, positionLabel)\n    } else {\n      return pointAbstrait(x, y, nom, positionLabel)\n    }\n  }\n  if (A instanceof Polygone) {\n    const p2 = []\n    for (let i = 0; i < A.listePoints.length; i++) {\n      p2[i] = rotation(A.listePoints[i], O, angle) as PointAbstrait\n      p2[i].nom = A.listePoints[i].nom + \"'\"\n    }\n    return polygone(p2, color)\n  }\n  if ('pente' in A) {\n    const M = rotation(\n      pointAbstrait(A.x1, A.y1) as PointAbstrait,\n      O,\n      angle,\n    ) as PointAbstrait\n    const N = rotation(\n      pointAbstrait(A.x2, A.y2) as PointAbstrait,\n      O,\n      angle,\n    ) as PointAbstrait\n    return droite(M, N, '', color)\n  }\n  if (A instanceof Segment) {\n    const M = rotation(A.extremite1 as PointAbstrait, O, angle) as PointAbstrait\n    const N = rotation(A.extremite2 as PointAbstrait, O, angle) as PointAbstrait\n    const s = segment(M, N, color)\n    s.styleExtremites = A.styleExtremites\n    return s\n  }\n  // Vecteur\n  let x = 0\n  let y = 0\n\n  if ('x' in A && 'y' in A) {\n    x =\n      A.x * Math.cos((angle * Math.PI) / 180) -\n      A.y * Math.sin((angle * Math.PI) / 180)\n    y =\n      A.x * Math.sin((angle * Math.PI) / 180) +\n      A.y * Math.cos((angle * Math.PI) / 180)\n  }\n  return vecteur(x, y) as Vecteur\n}\n\n/** Construit l'image d'un objet par homothétie\n * @param {PointAbstrait|Segment|Droite|Polygone|Vecteur} Objet Objet MathAlea2d choisi parmi un point, un segment, une droite, un polygone ou un vecteur\n * @param {PointAbstrait} O Centre de l'homothétie\n * @param {number} k Rapport de l'homothétie\n * @param {string} [nom = ''] Nom du point-image\n * @param {string} [positionLabel = 'above'] Position du point-image. Les possibilités sont : 'left', 'right', 'below', 'above', 'above right', 'above left', 'below right', 'below left'. Si on se trompe dans l'orthographe, ce sera 'above left' et si on ne précise rien, pour un point ce sera 'above'.\n * @param {string} [color='black']  Couleur de l'image : du type 'blue' ou du type '#f15929' (non valable pour un point et pour un vecteur)\n * @example p2 = homothetie(p1 ,I ,2)\n * // p2 est l'image de p1 par une homothétie de centre I et de rapport 2\n * @example N = homothetie(M, I, 0.5, 'point N', 'right')\n * // N est l'image de M par une homothétie de centre I et de rapport 0.5.  Le point sera affiché comme \"point N\" et ce nom sera écrit à droite de sa position.\n * @example s = homothetie(segment(A, B), I, -0.5, '', '','blue')\n * // s est l'image du segment [AB] par une homothétie de centre I et de rapport -0.5.  s sera en bleu.\n * @author Rémi Angot\n * @return {PointAbstrait|Segment|Droite|Polygone|Vecteur}\n */\n\n// Surcharges\nexport function homothetie(\n  Objet: IPointAbstrait,\n  O: IPointAbstrait,\n  k: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): PointAbstrait\nexport function homothetie(\n  Objet: IPoint,\n  O: IPointAbstrait,\n  k: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): PointAbstrait\nexport function homothetie(\n  Objet: IDroite,\n  O: IPointAbstrait,\n  k: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Droite\nexport function homothetie(\n  Objet: ISegment,\n  O: IPointAbstrait,\n  k: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Segment\nexport function homothetie(\n  Objet: IPolygone,\n  O: IPointAbstrait,\n  k: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Polygone\nexport function homothetie(\n  Objet: IVecteur,\n  O: IPointAbstrait,\n  k: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Vecteur\n\n// Implémentation\nexport function homothetie(\n  objet: IPointAbstrait | IPoint | IDroite | ISegment | IPolygone | IVecteur,\n  O: IPointAbstrait,\n  k: number,\n  nom = '',\n  positionLabel = 'above',\n  color = 'black',\n): PointAbstrait | PointAbstrait | Droite | Segment | Polygone | Vecteur {\n  // Points (PointAbstrait ou PointAbstrait)\n  if (objet instanceof PointAbstrait || objet instanceof PointAbstrait) {\n    const x = O.x + k * (objet.x - O.x)\n    const y = O.y + k * (objet.y - O.y)\n    if (objet instanceof PointAbstrait) {\n      return pointAbstrait(x, y, nom, positionLabel)\n    } else {\n      return pointAbstrait(x, y, nom, positionLabel)\n    }\n  }\n\n  // Polygone\n  if ('listePoints' in objet) {\n    const p2: PointAbstrait[] = []\n    for (let i = 0; i < objet.listePoints.length; i++) {\n      p2[i] = homothetie(objet.listePoints[i], O, k) as PointAbstrait\n      p2[i].nom = objet.listePoints[i].nom + \"'\"\n    }\n    return polygone(p2, color)\n  }\n\n  // Droite\n  if ('pente' in objet) {\n    const M = homothetie(\n      pointAbstrait(objet.x1, objet.y1),\n      O,\n      k,\n    ) as PointAbstrait\n    const N = homothetie(\n      pointAbstrait(objet.x2, objet.y2),\n      O,\n      k,\n    ) as PointAbstrait\n    return droite(M, N, '', color)\n  }\n\n  // Segment\n  if ('extremite1' in objet && 'extremite2' in objet) {\n    const M = homothetie(objet.extremite1, O, k) as PointAbstrait\n    const N = homothetie(objet.extremite2, O, k) as PointAbstrait\n    const s = segment(M, N, color)\n    ;(s as any).styleExtremites = (objet as any).styleExtremites\n    return s\n  }\n\n  // Vecteur\n\n  return vecteur(objet.x * k, objet.y * k)\n}\n\n/**\n * Renvoie le  symétrique de A par la droite d.\n * @return {PointAbstrait|Polygone|Droite|Segment|Vecteur} M image de A par la symétrie axiale d'axe d.\n * @author Jean-Claude Lhote\n */\n\n// Surcharges\nexport function symetrieAxiale(\n  A: IPolygone,\n  d: IDroite,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Polygone\nexport function symetrieAxiale(\n  A: IVecteur,\n  d: IDroite,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Vecteur\nexport function symetrieAxiale(\n  A: IDroite,\n  d: IDroite,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Droite\nexport function symetrieAxiale(\n  A: ISegment,\n  d: IDroite,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Segment\nexport function symetrieAxiale(\n  A: IPointAbstrait,\n  d: IDroite,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): PointAbstrait\nexport function symetrieAxiale(\n  A: IPoint,\n  d: IDroite,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): PointAbstrait\n\n// Implémentation\nexport function symetrieAxiale(\n  A: IPointAbstrait | IPoint | IDroite | ISegment | IPolygone | IVecteur,\n  d: IDroite,\n  nom = '',\n  positionLabel = 'above',\n  color = 'black',\n): PointAbstrait | PointAbstrait | Droite | Segment | Polygone | Vecteur {\n  let x: number, y: number\n  const a = d.a\n  const b = d.b\n  const c = d.c\n  const k = 1 / (a * a + b * b)\n\n  // Points (PointAbstrait ou PointAbstrait)\n  if (A instanceof PointAbstrait || A instanceof PointAbstrait) {\n    if (a === 0) {\n      x = A.x\n      y = -(A.y + (2 * c) / b)\n    } else if (b === 0) {\n      y = A.y\n      x = -(A.x + (2 * c) / a)\n    } else {\n      x = k * ((b * b - a * a) * A.x - 2 * a * b * A.y - 2 * a * c)\n      y =\n        k *\n          ((a * a - b * b) * A.y - 2 * a * b * A.x + (a * a * c) / b - b * c) -\n        c / b\n    }\n    if (A instanceof PointAbstrait) {\n      return pointAbstrait(x, y, nom, positionLabel)\n    } else {\n      return pointAbstrait(x, y, nom, positionLabel)\n    }\n  }\n\n  // Polygone\n  if ('listePoints' in A) {\n    const p2: PointAbstrait[] = []\n    for (let i = 0; i < A.listePoints.length; i++) {\n      p2[i] = symetrieAxiale(A.listePoints[i], d) as PointAbstrait\n      p2[i].nom = A.listePoints[i].nom + \"'\"\n    }\n    return polygone(p2, color)\n  }\n\n  // Droite\n  if (A instanceof Droite || 'pente' in A) {\n    const M = symetrieAxiale(pointAbstrait(A.x1, A.y1), d) as PointAbstrait\n    const N = symetrieAxiale(pointAbstrait(A.x2, A.y2), d) as PointAbstrait\n    return droite(M, N, color)\n  }\n\n  // Segment\n  if ('extremite1' in A && 'extremite2' in A) {\n    const M = symetrieAxiale(A.extremite1, d) as PointAbstrait\n    const N = symetrieAxiale(A.extremite2, d) as PointAbstrait\n    const s = segment(M, N, color)\n    ;(s as any).styleExtremites = (A as any).styleExtremites\n    return s\n  }\n\n  // Vecteur\n  let O: PointAbstrait\n  if (egal(b, 0)) {\n    O = pointAbstrait(-c / a, 0)\n  } else {\n    O = pointAbstrait(0, -c / b)\n  }\n  const M = translation(O, A as IVecteur) as PointAbstrait\n  const N = symetrieAxiale(M, d) as PointAbstrait\n  const v = vecteur(N.x - O.x, N.y - O.y)\n  return v\n}\n\n/**\n * N = projectionOrtho(M,d,'N','below left')\n * @author Jean-Claude Lhote\n */\n// Surcharges\nexport function projectionOrtho(\n  M: IPointAbstrait,\n  d: IDroite,\n  nom?: string,\n  positionLabel?: string,\n): PointAbstrait\nexport function projectionOrtho(\n  M: IPoint,\n  d: IDroite,\n  nom?: string,\n  positionLabel?: string,\n): PointAbstrait\nexport function projectionOrtho(\n  M: IVecteur,\n  d: IDroite,\n  nom?: string,\n  positionLabel?: string,\n): Vecteur\n\n// Implémentation\nexport function projectionOrtho(\n  M: IPointAbstrait | IPoint | IVecteur,\n  d: IDroite,\n  nom = '',\n  positionLabel = 'above',\n): PointAbstrait | PointAbstrait | Vecteur {\n  const a = d.a\n  const b = d.b\n  const c = d.c\n  const k = 1 / (a * a + b * b)\n  let x: number, y: number\n\n  // Points (PointAbstrait ou PointAbstrait)\n  if (M instanceof PointAbstrait || M instanceof PointAbstrait) {\n    if (a === 0) {\n      x = M.x\n      y = -c / b\n    } else if (b === 0) {\n      y = M.y\n      x = -c / a\n    } else {\n      x = k * (b * b * M.x - a * b * M.y - a * c)\n      y = k * (-a * b * M.x + a * a * M.y + (a * a * c) / b) - c / b\n    }\n    if (M instanceof PointAbstrait) {\n      return pointAbstrait(x, y, nom, positionLabel)\n    } else {\n      return pointAbstrait(x, y, nom, positionLabel)\n    }\n  }\n\n  // Vecteur\n  let O: PointAbstrait\n  if (egal(b, 0)) O = pointAbstrait(-c / a, 0)\n  else O = pointAbstrait(0, -c / b)\n  const A = translation(O, M as IVecteur) as PointAbstrait\n  const N = projectionOrtho(A, d) as PointAbstrait\n  const v = vecteur(O, N)\n  return v\n}\n\n/**\n * Construit l'image d'un objet par affinité orthogonale\n * @param {PointAbstrait|PointAbstrait|Segment|Droite|Polygone|Vecteur} Objet Objet MathAlea2d choisi parmi un point, un segment, une droite, un polygone ou un vecteur\n * @param {Droite} d Direction de l'affinité\n * @param {number} k Rapport de l'affinité\n * @param {string} [nom=''] Nom de l'image (uniquement valable pour un point)\n * @param {string} [positionLabel = 'above'] Position de l'image (uniquement valable pour un point)\n * @param {string} [color='black']  Couleur de la valeur indiquée : du type 'blue' ou du type '#f15929' (non valable pour un point et pour un vecteur)\n * @author Jean-Claude Lhote\n * @example p2 = affiniteOrtho(p1,droite(B, C),k)\n * // p2 est l'image de p1 par une affinité orthogonale dont la direction est la droite (BC) et de rapport k\n * @example N = affiniteOrtho(M,d,0.5,'point N','right')\n * // N est l'image du point M par une affinité orthogonale de direction d et de rapport 0.5. Le point sera affiché comme \"point N\" et ce nom sera écrit à droite de sa position.\n * @example s = affiniteOrtho(segment(A, B),d,0.1,'','','red')\n * // s est l'image du segment [AB] par une affinité orthogonale de direction d et de rapport 0.1. s sera rouge.\n * @return {PointAbstrait|PointAbstrait|Segment|Droite|Polygone|Vecteur} Retourne un objet du même type que le paramètre objet de la fonction\n */\n// JSDOC Validee par EE Juin 2022\n\n// Surcharges\n\nexport function affiniteOrtho(\n  A: IPoint,\n  d: IDroite,\n  k: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): PointAbstrait\nexport function affiniteOrtho(\n  A: IDroite,\n  d: IDroite,\n  k: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Droite\nexport function affiniteOrtho(\n  A: ISegment,\n  d: IDroite,\n  k: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Segment\nexport function affiniteOrtho(\n  A: IPolygone,\n  d: IDroite,\n  k: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Polygone\nexport function affiniteOrtho(\n  A: IVecteur,\n  d: IDroite,\n  k: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Vecteur\nexport function affiniteOrtho(\n  A: IPointAbstrait,\n  d: IDroite,\n  k: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): PointAbstrait\n\n// Implémentation\nexport function affiniteOrtho(\n  A: IPointAbstrait | IPoint | IDroite | ISegment | IPolygone | IVecteur,\n  d: IDroite,\n  k: number,\n  nom = '',\n  positionLabel = 'above',\n  color = 'black',\n): PointAbstrait | PointAbstrait | Droite | Segment | Polygone | Vecteur {\n  const a = d.a\n  const b = d.b\n  const c = d.c\n  const q = 1 / (a * a + b * b)\n  let x: number, y: number\n\n  // Points (PointAbstrait ou PointAbstrait)\n  if (A instanceof PointAbstrait || A instanceof PointAbstrait) {\n    if (a === 0) {\n      x = A.x\n      y = k * A.y + (c * (k - 1)) / b\n    } else if (b === 0) {\n      y = A.y\n      x = k * A.x + (c * (k - 1)) / a\n    } else {\n      x = q * (b * b * A.x - a * b * A.y - a * c) * (1 - k) + k * A.x\n      y =\n        q * (a * a * A.y - a * b * A.x + (a * a * c) / b) * (1 - k) +\n        (k * c) / b +\n        k * A.y -\n        c / b\n    }\n    if (A instanceof PointAbstrait) {\n      return pointAbstrait(x, y, nom, positionLabel)\n    } else {\n      return pointAbstrait(x, y, nom, positionLabel)\n    }\n  }\n\n  // Polygone\n  if (A instanceof Polygone) {\n    const p2: PointAbstrait[] = []\n    for (let i = 0; i < A.listePoints.length; i++) {\n      p2[i] = affiniteOrtho(A.listePoints[i], d, k) as PointAbstrait\n      p2[i].nom = A.listePoints[i].nom + \"'\"\n    }\n    return polygone(p2, color)\n  }\n\n  // Droite\n  if ('pente' in A) {\n    const M = affiniteOrtho(pointAbstrait(A.x1, A.y1), d, k) as PointAbstrait\n    const N = affiniteOrtho(pointAbstrait(A.x2, A.y2), d, k) as PointAbstrait\n    return droite(M, N, color)\n  }\n\n  // Segment\n  if (A instanceof Segment) {\n    const M = affiniteOrtho(A.extremite1, d, k) as PointAbstrait\n    const N = affiniteOrtho(A.extremite2, d, k) as PointAbstrait\n    const s = segment(M, N, color)\n    ;(s as any).styleExtremites = (A as any).styleExtremites\n    return s\n  }\n\n  // Vecteur\n  let O: PointAbstrait\n  if (egal(b, 0)) {\n    O = pointAbstrait(-c / a, 0)\n  } else {\n    O = pointAbstrait(0, -c / b)\n  }\n  const M = translation(O, A as IVecteur)\n  const N = affiniteOrtho(M, d, k)\n  return new Vecteur(O, N)\n}\n\n/**\n *\n * @param {PointAbstrait|PointAbstrait|Polygone|Droite|Vecteur|Segment} A // Le point dont on veut l'image\n * @param {PointAbstrait} O // Le centre de la similitude\n * @param {number} a // L'angle de la rotation\n * @param {number} k // le rapport de l'homothétie\n * @param {string} nom\n * @param {string} positionLabel\n * M = similitude(B,O,30,1.1,'M') // Le point M est l'image de B dans la similitude de centre O d'angle 30° et de rapport 1.1\n * @author Jean-Claude Lhote\n */\n\n// Surcharges\nexport function similitude(\n  A: IPointAbstrait,\n  O: IPointAbstrait,\n  a: number,\n  k: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): PointAbstrait\nexport function similitude(\n  A: IPoint,\n  O: IPointAbstrait,\n  a: number,\n  k: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): PointAbstrait\nexport function similitude(\n  A: IDroite,\n  O: IPointAbstrait,\n  a: number,\n  k: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Droite\nexport function similitude(\n  A: ISegment,\n  O: IPointAbstrait,\n  a: number,\n  k: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Segment\nexport function similitude(\n  A: IPolygone,\n  O: IPointAbstrait,\n  a: number,\n  k: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Polygone\nexport function similitude(\n  A: IVecteur,\n  O: IPointAbstrait,\n  a: number,\n  k: number,\n  nom?: string,\n  positionLabel?: string,\n  color?: string,\n): Vecteur\n\n// Implémentation\nexport function similitude(\n  A: IPointAbstrait | IPoint | IDroite | ISegment | IPolygone | IVecteur,\n  O: IPointAbstrait,\n  a: number,\n  k: number,\n  nom = '',\n  positionLabel = 'above',\n  color = 'black',\n): PointAbstrait | PointAbstrait | Droite | Segment | Polygone | Vecteur {\n  // Points (PointAbstrait ou PointAbstrait)\n  if (A instanceof PointAbstrait || A instanceof PointAbstrait) {\n    const ra = degToRad(a)\n    const x =\n      O.x + k * (Math.cos(ra) * (A.x - O.x) - Math.sin(ra) * (A.y - O.y))\n    const y =\n      O.y + k * (Math.cos(ra) * (A.y - O.y) + Math.sin(ra) * (A.x - O.x))\n    if (A instanceof PointAbstrait) {\n      return pointAbstrait(x, y, nom, positionLabel)\n    } else {\n      return pointAbstrait(x, y, nom, positionLabel)\n    }\n  }\n\n  // Polygone\n  if ('listePoints' in A) {\n    const p2: PointAbstrait[] = []\n    for (let i = 0; i < A.listePoints.length; i++) {\n      p2[i] = similitude(A.listePoints[i], O, a, k) as PointAbstrait\n      p2[i].nom = A.listePoints[i].nom + \"'\"\n    }\n    return polygone(p2, color)\n  }\n\n  // Droite\n  if ('pente' in A) {\n    const M = similitude(pointAbstrait(A.x1, A.y1), O, a, k) as PointAbstrait\n    const N = similitude(pointAbstrait(A.x2, A.y2), O, a, k) as PointAbstrait\n    return droite(M, N, color)\n  }\n\n  // Segment\n  if ('extremite1' in A && 'extremite2' in A) {\n    const M = similitude(A.extremite1, O, a, k) as PointAbstrait\n    const N = similitude(A.extremite2, O, a, k) as PointAbstrait\n    const s = segment(M, N, color)\n    ;(s as any).styleExtremites = (A as any).styleExtremites\n    return s\n  }\n\n  // Vecteur\n  let v = A as Vecteur\n  const V = rotation(v as any, O as PointAbstrait, a)\n  v = homothetie(V, O, k) as unknown as Vecteur\n  return v\n}\n"],"names":["degToRad","deg","translation","O","vecteurTranslation","nom","positionLabel","color","PointAbstrait","x","y","pointAbstrait","p2","i","pi","polygone","M","N","droite","s","segment","vecteur","translation2Points","A","B","rotation","angle","Polygone","Segment","homothetie","objet","k","symetrieAxiale","d","a","b","Droite","egal","projectionOrtho","c","affiniteOrtho","q","Vecteur","similitude","ra","v","V"],"mappings":"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"}