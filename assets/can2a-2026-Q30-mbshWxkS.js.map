{"version":3,"file":"can2a-2026-Q30-mbshWxkS.js","sources":["../../src/exercices/can/can2a-2026/can2a-2026-Q30.ts"],"sourcesContent":["import { grille } from '../../../lib/2d/Grille'\nimport { pointAbstrait } from '../../../lib/2d/PointAbstrait'\nimport { polyline } from '../../../lib/2d/Polyline'\nimport {\n  segment,\n  segmentAvecExtremites,\n} from '../../../lib/2d/segmentsVecteurs'\nimport { latex2d } from '../../../lib/2d/textes'\nimport { milieu } from '../../../lib/2d/utilitairesPoint'\nimport { KeyboardType } from '../../../lib/interactif/claviers/keyboard'\nimport { choice } from '../../../lib/outils/arrayOutils'\nimport { miseEnEvidence } from '../../../lib/outils/embellissements'\nimport FractionEtendue from '../../../modules/FractionEtendue'\nimport { mathalea2d } from '../../../modules/mathalea2d'\nimport { randint } from '../../../modules/outils'\nimport type { NestedObjetMathalea2dArray } from '../../../types/2d'\nimport ExerciceCan from '../../ExerciceCan'\nexport const titre = \"Déterminer la longueur d'une ligne brisée\"\nexport const interactifReady = true\nexport const interactifType = 'mathLive'\nexport const uuid = 'ehwt2'\nexport const refs = {\n  'fr-fr': [],\n  'fr-ch': ['NR'],\n}\nconst creerQuestionLigneBrisee = () => {\n  // Choix aléatoire de la longueur de l'unité (en carreaux)\n  const longueurUnite = choice([3, 4, 5, 6])\n\n  // Définir les limites de la grille\n  const xmin = -1\n  const ymin = -2\n  const xmax = 7\n  const ymax = 5\n\n  // Créer la grille\n  const grilleObj = grille(-2, ymin, xmax, ymax - 1, 'gray', 1, 1)\n\n  // Créer le segment unité en haut\n  const G = pointAbstrait(0, 4, 'G', 'above')\n  const H = pointAbstrait(longueurUnite, 4, 'H', 'above')\n  const segmentUnite = segment(G, H)\n  segmentUnite.epaisseur = 2\n  segmentUnite.styleExtremites = '<->'\n  segmentUnite.tailleExtremites = 8\n\n  // Générer aléatoirement une ligne brisée\n  // La ligne brisée aura entre longueurUnite et 3*longueurUnite carreaux de longueur\n  const longueurLigneBrisee = randint(longueurUnite + 1, 3 * longueurUnite)\n\n  // Créer les points de la ligne brisée\n  // On commence à (0, 2) et on crée des segments horizontaux et verticaux\n  const points = [pointAbstrait(0, 2)]\n  let xActuel = 0\n  let yActuel = 2\n  let longueurRestante = longueurLigneBrisee\n  const xMaxLigne = 6 // Limite horizontale pour la ligne brisée\n  let longueurReelle = 0 // Longueur réelle de la ligne brisée créée\n\n  while (longueurRestante > 0) {\n    // Alterner entre segments horizontaux et verticaux\n    if (points.length % 2 === 1) {\n      // Segment horizontal\n      // Calculer la longueur maximale possible sans sortir de la grille\n      const longueurMax = Math.min(xMaxLigne - xActuel, longueurRestante)\n      if (longueurMax <= 0) {\n        // Si on ne peut plus avancer horizontalement, on arrête\n        break\n      }\n      const longueur = Math.min(randint(1, 3), longueurMax)\n      xActuel += longueur\n      points.push(pointAbstrait(xActuel, yActuel))\n      longueurRestante -= longueur\n      longueurReelle += longueur\n    } else {\n      // Segment vertical\n      const direction = choice([-1, 1])\n      const longueur = Math.min(randint(1, 2), longueurRestante)\n      const nouveauY = yActuel + direction * longueur\n      // Limiter y entre 0 et 3 et calculer la longueur effective\n      const yFinal = Math.max(0, Math.min(3, nouveauY))\n      const longueurEffective = Math.abs(yFinal - yActuel)\n      yActuel = yFinal\n      points.push(pointAbstrait(xActuel, yActuel))\n      longueurRestante -= longueurEffective\n      longueurReelle += longueurEffective\n    }\n  }\n  const ligneBrisee = polyline(...points)\n  ligneBrisee.epaisseur = 3\n\n  // Assembler les objets\n  const objets = []\n  objets.push(\n    latex2d('1 u.\\\\ell.', milieu(G, H).x, milieu(G, H).y + 0.5, {\n      letterSize: 'normalsize',\n    }),\n    grilleObj,\n    segmentUnite,\n    ligneBrisee,\n  )\n\n  return {\n    objets,\n    longueurUnite,\n    longueurLigneBrisee: longueurReelle, // Retourner la longueur réelle\n    xmin,\n    ymin,\n    xmax,\n    ymax,\n  }\n}\n/**\n * Modèle d'exercice très simple pour la course aux nombres\n * @author Gilles Mora\n\n*/\nexport default class Can2a2026Q30 extends ExerciceCan {\n  enonce(): void {\n    this.formatChampTexte = KeyboardType.clavierDeBaseAvecFraction\n    this.optionsChampTexte = { texteAvant: ' ', texteApres: 'u.$\\\\ell$' }\n    let questionData\n    // Fonction pour créer aléatoirement une question de ligne brisée sur grille\n    if (this.canOfficielle || this.sup) {\n      const objets: NestedObjetMathalea2dArray = []\n      objets.push(grille(0, 0, 7, 4, 'gray', 1, 1))\n      const G = pointAbstrait(0, 4)\n      const H = pointAbstrait(3, 4)\n      const segmentUnite = segmentAvecExtremites(G, H)\n      segmentUnite.epaisseur = 2\n      segmentUnite.styleExtremites = '<->'\n      segmentUnite.tailleExtremites = 8\n      objets.push(segmentUnite)\n      objets.push(\n        latex2d('1 u.\\\\ell.', milieu(G, H).x, milieu(G, H).y + 0.5, {\n          letterSize: 'normalsize',\n        }),\n      )\n      const ligneBrisee = polyline(\n        pointAbstrait(1, 3),\n        pointAbstrait(1, 1),\n        pointAbstrait(3, 1),\n        pointAbstrait(3, 3),\n        pointAbstrait(5, 3),\n        pointAbstrait(5, 1),\n        pointAbstrait(6, 1),\n        pointAbstrait(6, 3),\n      )\n      ligneBrisee.epaisseur = 3\n      objets.push(ligneBrisee)\n      questionData = {\n        objets,\n        longueurUnite: 3,\n        longueurLigneBrisee: 13,\n        xmin: -0.2,\n        ymin: 0,\n        xmax: 7,\n        ymax: 5,\n      }\n    } else {\n      questionData = creerQuestionLigneBrisee()\n    }\n    const b = questionData.longueurUnite\n    const longueurCarreaux = questionData.longueurLigneBrisee\n\n    this.reponse = new FractionEtendue(longueurCarreaux, b)\n\n    this.question = 'Longueur de la ligne brisée en u.$\\\\ell$.<br>'\n    this.question +=\n      mathalea2d(\n        {\n          xmin: questionData.xmin - 0.5,\n          ymin: questionData.ymin,\n          xmax: questionData.xmax,\n          ymax: questionData.ymax,\n          pixelsParCm: 20,\n          scale: 0.5,\n          style: 'margin: auto',\n        },\n        questionData.objets,\n      ) + `<br>`\n\n    this.correction = `Une unité correspond à $${b}$ carreaux, la ligne brisée mesure $${longueurCarreaux}$ carreaux, soit $${miseEnEvidence(this.reponse.texFraction)}$ u.l. `\n\n    this.canEnonce = this.question\n    this.canReponseACompleter = '$\\\\ldots$ u.$\\\\ell$.'\n  }\n\n  nouvelleVersion(): void {\n    this.enonce()\n  }\n}\n"],"names":["titre","interactifReady","interactifType","uuid","refs","creerQuestionLigneBrisee","longueurUnite","choice","xmin","ymin","xmax","ymax","grilleObj","grille","G","pointAbstrait","H","segmentUnite","segment","longueurLigneBrisee","randint","points","xActuel","yActuel","longueurRestante","xMaxLigne","longueurReelle","longueurMax","longueur","direction","nouveauY","yFinal","longueurEffective","ligneBrisee","polyline","objets","latex2d","milieu","Can2a2026Q30","ExerciceCan","KeyboardType","questionData","segmentAvecExtremites","b","longueurCarreaux","FractionEtendue","mathalea2d","miseEnEvidence"],"mappings":"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"}