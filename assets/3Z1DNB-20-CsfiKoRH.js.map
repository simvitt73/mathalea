{"version":3,"file":"3Z1DNB-20-CsfiKoRH.js","sources":["../../src/exercices/3e/3Z1DNB-20.ts"],"sourcesContent":["import { cercle } from '../../lib/2d/cercle'\nimport { fixeBordures } from '../../lib/2d/fixeBordures'\nimport { point } from '../../lib/2d/PointAbstrait'\nimport { polygoneRegulierParCentreEtRayon } from '../../lib/2d/polygonesParticuliers'\nimport { segment } from '../../lib/2d/segmentsVecteurs'\nimport { texteParPosition } from '../../lib/2d/textes'\nimport { rotation } from '../../lib/2d/transformations'\nimport { createList } from '../../lib/format/lists'\nimport { deuxColonnesResp } from '../../lib/format/miseEnPage'\nimport { choice } from '../../lib/outils/arrayOutils'\nimport { miseEnEvidence, texteItalique } from '../../lib/outils/embellissements'\nimport { prenomF, prenomM } from '../../lib/outils/Personne'\nimport {\n  decompositionFacteursPremiers,\n  ppcm,\n  texFactorisation,\n} from '../../lib/outils/primalite'\nimport { texNombre } from '../../lib/outils/texNombre'\nimport Hms from '../../modules/Hms'\nimport { mathalea2d } from '../../modules/mathalea2d'\nimport { randint } from '../../modules/outils'\nimport ExerciceBrevetA from '../ExerciceBrevetA'\n\nexport const uuid = 'ec6ad'\nexport const refs = {\n  'fr-fr': ['3Z1DNB-20'],\n  'fr-ch': [],\n}\nexport const titre =\n  \"Préparation DNB : arithmétique, prise d'initiatives et nombres premiers\"\nexport const dateDePublication = '14/04/2025'\n\n/**\n * @Author Jean-Claude Lhote\n * Cet exerice exploite la nouvelle classe d'exercice que j'ai conçue pour les sujets de brevet\n * Il s'agit d'un exercice de type Brevet Aléatoirisé\n * La méthode privée appliquerLesValeurs permet de générer les valeurs aléatoires et de construire l'énoncé et la correction\n * La méthode versionOriginale permet de générer les valeurs de l'exercice telles qu'elles sont dans le sujet original\n * La méthode versionAleatoire permet de générer des valeurs aléatoires pour l'exercice\n */\nexport default class ExerciceCentresEtrangers262024 extends ExerciceBrevetA {\n  constructor() {\n    super()\n    this.besoinFormulaireCaseACocher = ['Sujet original', false]\n    this.sup = false\n    this.introduction = texteItalique(\n      \"D'après l'exercice 2 du brevet Centres étrangers Juin 2024.<br>\",\n    )\n\n    this.versionAleatoire()\n  }\n\n  private appliquerLesValeurs(\n    nbEx1: number,\n    nbEx2: number,\n    dureeEx1: number,\n    dureeEx2: number,\n    repos1: number,\n    repos2: number,\n    duree3: number,\n    prenom1: string,\n    prenom2: string,\n  ): void {\n    const duree1 = dureeEx1 * nbEx1 + repos1 * nbEx1\n    const duree2 = dureeEx2 * nbEx2 + repos2 * nbEx2\n    const ppcM = ppcm(duree1, duree2)\n    this.enonce = `Un entraîneur de sport prépare deux circuits d'entraînement contenant plusieurs exercices de cardio et de renforcement musculaire :<br>\n  ${createList({\n    items: [\n      \"Un circuit commence à l'exercice 1 et se termine en revenant à l'exercice 1.\",\n      `Le circuit 1 contient ${nbEx1} exercices. Chaque exercice dure ${dureeEx1} secondes et doit être suivi de ${repos1} secondes de repos permettant de se rendre à l'exercice suivant.`,\n      `Le circuit 2 contient ${nbEx2} exercices. Chaque exercice dure ${dureeEx2} secondes et doit être suivi de ${repos2} secondes de repos permettant de se rendre à l'exercice suivant.`,\n    ],\n    style: 'fleches',\n  })}`\n    const depArr = texteParPosition('Départ / Arrivée', 0, 10)\n    const fleche = segment(point(0, 9.5), point(0, 8.5))\n    fleche.styleExtremites = '->'\n    const centrum = point(0, 3)\n    const poly1 = rotation(\n      polygoneRegulierParCentreEtRayon(centrum, 3.5, nbEx1),\n      centrum,\n      90,\n    )\n    const exos1 = poly1.listePoints.map((el, i) => cercle(el, 0.5))\n    const textEx1 = poly1.listePoints.map((el, i) =>\n      texteParPosition(`Ex ${i + 1}`, el.x * 1.4, (el.y - 3) * 1.4 + 3),\n    )\n    const poly2 = rotation(\n      polygoneRegulierParCentreEtRayon(centrum, 3.5, nbEx2),\n      centrum,\n      90,\n    )\n    const exos2 = poly2.listePoints.map((el, i) => cercle(el, 0.5))\n    const textEx2 = poly2.listePoints.map((el, i) =>\n      texteParPosition(`Ex ${i + 1}`, el.x * 1.4, (el.y - 3) * 1.4 + 3),\n    )\n    const objets1 = [depArr, fleche, poly1, ...exos1, ...textEx1]\n    const objets2 = [depArr, fleche, poly2, ...exos2, ...textEx2]\n    const figure1 = mathalea2d(\n      Object.assign(\n        { pixelsParCm: 20, scale: 0.5, style: 'display: inline' },\n        fixeBordures(objets1),\n      ),\n      objets1,\n    )\n    const figure2 = mathalea2d(\n      Object.assign(\n        { pixelsParCm: 20, scale: 0.5, style: 'display: inline' },\n        fixeBordures(objets2),\n      ),\n      objets2,\n    )\n    this.enonce += `\\n\\n${deuxColonnesResp(figure1, figure2, { largeur1: 50, widthmincol1: '300px', widthmincol2: '300px' })}`\n    const question1 = `Montrer que le circuit 1 s'effectue en $${duree1}$ secondes et que le circuit 2 s'effectue en $${duree2}$ secondes.`\n    const correction1 = `Le circuit 1, c'est quand on enchaîne $${nbEx1}$ fois $${dureeEx1}$ secondes d'exercice et $${repos1}$ secondes de repos, soit $${nbEx1}$ fois  $${dureeEx1} + ${repos1}$ secondes.<br>\n    On a donc bien besoin de : $${nbEx1} \\\\times ${dureeEx1 + repos1} = ${miseEnEvidence(texNombre(duree1, 0))}$ secondes pour effectuer le circuit 1.<br>\n    Pour le circuit 2 : même principe, on enchaîne $${nbEx2}$ fois $${dureeEx2}$ secondes d'exercice et $${repos2}$ secondes de repos :<br>\n    $${nbEx2} \\\\times (${dureeEx2} + ${repos2}) = ${nbEx2} \\\\times ${dureeEx2 + repos2} = ${duree2}$ secondes.<br>\n    On a donc bien besoin de $${miseEnEvidence(texNombre(duree2, 0))}$ secondes pour effectuer le circuit 2.`\n    const question2 = `Donner la décomposition en produit de facteurs premiers de $${duree1}$ et de $${duree2}$.`\n    const correction2 = `$${duree1}=${decompositionFacteursPremiers(duree1)}$ soit $${miseEnEvidence(texFactorisation(duree1, true))}$<br>\n    $${duree2}=${decompositionFacteursPremiers(duree2)}$ soit $${miseEnEvidence(texFactorisation(duree2, true))}$`\n    const question3 = `Une séance d'entraînement est constituée de plusieurs tours du même circuit.<br>\n    Au coup de sifflet de l'entraîneur, ${prenom1} commence une séance d'entraînement sur le circuit 1 et ${prenom2} sur le circuit 2.<br>\n    ${createList({\n      items: [\n        `Expliquer pourquoi, lorsque $${texNombre(duree3, 0)}$ secondes se sont écoulées à partir du coup de sifflet, ${prenom1} se trouve de nouveau au départ du circuit 1.<br>\n        Préciser où se trouve ${prenom2} sur le circuit 2 lorsque $${texNombre(duree3, 0)}$ secondes se sont écoulées.`,\n        `Après le coup de sifflet, combien de temps faut-il à ${prenom1} et à ${prenom2} pour se retrouver en même temps pour la première fois au départ de leur circuit ? Exprimer cette durée en minutes et secondes.`,\n      ],\n      style: 'alpha',\n    })}`\n    const reste = duree3 % duree2\n    const quotient = Math.floor(duree3 / duree2)\n    const dureeEx2PlusRep2 = dureeEx2 + repos2\n    const reste2 = reste % dureeEx2PlusRep2\n    const quotient2 = Math.floor(reste / dureeEx2PlusRep2)\n\n    const correction3aa = `Tout d'abord la division euclidienne de $${texNombre(duree3, 0)}$ par $${duree2}$ donne cette égalité : $${texNombre(duree3, 0)}=${duree2}\\\\times${quotient}+${reste}$.<br>\n    Ensuite, pour passer d'un exercice du circuit 2 à l'autre, il faut : $${dureeEx2} + ${repos2}= ${dureeEx2PlusRep2}$ secondes.<br>\n    Donc la division euclidienne de $${reste}$ par $${dureeEx2PlusRep2}$ donne cette égalité : $${reste}=${dureeEx2PlusRep2}\\\\times${quotient2}+${reste2}$.<br>\n    Donc depuis le coup de sifflet, il s'est écoulé : $${texNombre(duree3, 0)}=${duree2}\\\\times${quotient}+${dureeEx2PlusRep2}\\\\times${quotient2}+${reste2}$ secondes.<br>\n    ${prenom2} a donc effectué $${miseEnEvidence(quotient)}$ fois le circuit 2 complètement et ${quotient2 === 0 ? \"n'a pas encore terminé le premier exercice.\" : `a fait ensuite $${miseEnEvidence(quotient2)}$ exercice${quotient2 > 1 ? 's' : ''} complètement avec le repos associé.`}<br>\n    ${reste2 > dureeEx2 ? `Comme $${reste2}>${dureeEx2}$, ${prenom2} a fini l'exercice ${quotient2 + 1} et se dirige actuellement en se reposant vers l'exercice ${(quotient2 + 2) % nbEx2}` : reste2 === 0 ? `${prenom2} est alors au début de l'exercice ${quotient2 + 1} du circuit 2` : `Comme $${reste2} <${dureeEx2}$, ${prenom2} est donc à l'exercice ${quotient2 + 1} du circuit 2`}`\n    const correction3a = `Lorsque $${texNombre(duree3, 0)}$ secondes se sont écoulées à partir du coup de sifflet, ${prenom1} se trouve de nouveau au départ du circuit 1 car $${duree3} = ${duree1}\\\\times${duree3 / duree1}$, donc comme $${duree3 / duree1}$ est un nombre entier, cela signifie que ${prenom1} a effectué $${duree3 / duree1}$ fois le circuit 1 complètement, et n'a pas encore commencé la $${duree3 / duree1 + 1}$e répétition : ${prenom1} est donc à nouveau au départ du circuit 1.<br>`\n    const duree = new Hms({ second: ppcM }).normalize()\n\n    const correction3b = `Pour que ${prenom1} et ${prenom2} se retrouvent en même temps au départ de leur circuit, il faut qu'il se soit écoulé une durée multiple de $${duree1}$ et de $${duree2}$.<br>\n    Donc, il faut chercher le premier multiple commun entre $${duree1}$ et $${duree2}$.<br>\n    En écrivant la liste des multiples de ces deux nombres, le premier multiple commun est $${texNombre(ppcM, 0)}$.<br>\n    Nous pouvons aussi utiliser les décompositions en produit de facteurs premiers de $${duree1}$ et de $${duree2}$ pour trouver le PPCM.<br>\n    Il suffit de prendre tous les facteurs présents dans les deux décomposition avec la puissance maximale rencontrée.<br>\n    Soit : $${miseEnEvidence(`${texFactorisation(ppcM, true)}=${texNombre(ppcM, 0)}`)}$.<br>\n    Nous avons : $${texNombre(ppcM, 0)}=60\\\\times${Math.floor(ppcM / 60)}${ppcM % 60 === 0 ? '' : `+${ppcM % 60}`}$.<br>\n    Donc $${texNombre(ppcM, 0)}~\\\\text{s}=${miseEnEvidence(`${duree.minute}~\\\\text{min}${ppcM % 60 === 0 ? '' : `~${duree.second}~\\\\text{s}`}`)}$.<br>`\n    const listeQuestions = createList({\n      items: [question1, question2, question3],\n      style: 'nombres',\n    })\n    this.enonce += `\\n\\n${listeQuestions}`\n    this.correction = createList({\n      items: [\n        correction1,\n        correction2,\n        createList({\n          items: [correction3a + correction3aa, correction3b],\n          style: 'alpha',\n        }),\n      ],\n      style: 'nombres',\n    }).replaceAll('+0', '')\n  }\n\n  versionOriginale: () => void = () => {\n    this.appliquerLesValeurs(5, 10, 40, 30, 16, 5, 2800, 'Camille', 'Dominique')\n  }\n\n  versionAleatoire: () => void = () => {\n    let nbEx1: number\n    let nbEx2: number\n    let dureeEx1: number\n    let dureeEx2: number\n    let repos1: number\n    let repos2: number\n    let duree3: number\n    let duree1: number\n    let duree2: number\n    let ppcM: number\n    do {\n      nbEx1 = choice([4, 6, 8])\n      nbEx2 = choice([10, 12])\n      dureeEx1 = randint(6, 10) * 5\n      dureeEx2 = dureeEx1 - 10\n      repos1 = randint(3, 5) * 4\n      repos2 = randint(1, 3) * 5\n      duree1 = dureeEx1 * nbEx1 + repos1 * nbEx1\n      duree2 = dureeEx2 * nbEx2 + repos2 * nbEx2\n      duree3 = duree1 * randint(1, 3) * 2\n      ppcM = ppcm(duree1, duree2)\n    } while (\n      ppcM === duree1 ||\n      ppcM === duree2 ||\n      ppcM >= 3600 ||\n      duree3 % duree2 === 0\n    )\n    const prenom1 = prenomF()\n    const prenom2 = prenomM()\n\n    this.appliquerLesValeurs(\n      nbEx1,\n      nbEx2,\n      dureeEx1,\n      dureeEx2,\n      repos1,\n      repos2,\n      duree3,\n      Array.isArray(prenom1) ? prenom1[0] : prenom1,\n      Array.isArray(prenom2) ? prenom2[0] : prenom2,\n    )\n  }\n}\n"],"names":["uuid","refs","titre","dateDePublication","ExerciceCentresEtrangers262024","ExerciceBrevetA","__publicField","nbEx1","nbEx2","dureeEx1","dureeEx2","repos1","repos2","duree3","duree1","duree2","ppcM","choice","randint","ppcm","prenom1","prenomF","prenom2","prenomM","texteItalique","createList","depArr","texteParPosition","fleche","segment","point","centrum","poly1","rotation","polygoneRegulierParCentreEtRayon","exos1","el","i","cercle","textEx1","poly2","exos2","textEx2","objets1","objets2","figure1","mathalea2d","fixeBordures","figure2","deuxColonnesResp","question1","correction1","miseEnEvidence","texNombre","question2","correction2","decompositionFacteursPremiers","texFactorisation","question3","reste","quotient","dureeEx2PlusRep2","reste2","quotient2","correction3aa","correction3a","duree","Hms","correction3b","listeQuestions"],"mappings":"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"}