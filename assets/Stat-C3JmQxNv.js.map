{"version":3,"file":"Stat-C3JmQxNv.js","sources":["../../src/lib/mathFonctions/Stat.ts"],"sourcesContent":["import { context } from '../../modules/context'\nimport { mathalea2d } from '../../modules/mathalea2d'\nimport type { NestedObjetMathalea2dArray } from '../../types/2d'\nimport { BoiteBuilder } from '../2d/BoiteBuilder'\nimport { colorToLatexOrHTML } from '../2d/colorToLatexOrHtml'\nimport { fixeBordures } from '../2d/fixeBordures'\nimport { point } from '../2d/PointAbstrait'\nimport { polygone } from '../2d/polygones'\nimport { segment } from '../2d/segmentsVecteurs'\nimport { latex2d } from '../2d/textes'\nimport { tracePoint } from '../2d/TracePoint'\nimport { milieu } from '../2d/utilitairesPoint'\nimport { vide2d } from '../2d/Vide2d'\nimport { shuffle } from '../outils/arrayOutils'\nimport { texNombre } from '../outils/texNombre'\n\n/**\n * Classe pour les statistiques descriptives\n * Accepte une série de nombres ou une série de paires [valeur, effectif]\n * Fournit des méthodes pour calculer la moyenne, la variance, l'écart-type, la médiane, le mode, le min, le max, l'étendue et le coefficient de variation\n * Inclut également des méthodes statiques pour effectuer les mêmes calculs sur un tableau de nombres\n * @author Jean-Claude Lhote (aidé par GPT-5 mini)\n */\nexport default class Stat {\n  serie: (number | string)[]\n  serieTableau: [number, number][] | [string, number][]\n  isQualitative: boolean = false\n  constructor(\n    serie: Array<number | string | [number | string, number]>,\n    isQualitative = false,\n    shuffled = true,\n  ) {\n    if (!Array.isArray(serie) || serie.length === 0) {\n      throw new Error('La série doit être un array non vide')\n    }\n\n    // Construire flatSerie en acceptant soit des valeurs simples, soit des paires [valeur, effectif]\n    const flatSerie: (number | string)[] = []\n    for (const el of serie) {\n      if (Array.isArray(el)) {\n        if (el.length !== 2) {\n          throw new Error('Chaque paire doit être [valeur, effectif]')\n        }\n        const [val, freq] = el as [number | string, number]\n        if (typeof freq !== 'number' || !isFinite(freq) || freq < 0) {\n          throw new Error(\"L'effectif doit être un nombre positif\")\n        }\n        const n = Math.floor(freq)\n        for (let i = 0; i < n; i++) {\n          flatSerie.push(val)\n        }\n      } else {\n        flatSerie.push(el as number | string)\n      }\n    }\n\n    if (flatSerie.length === 0) {\n      throw new Error('Après expansion, la série est vide')\n    }\n\n    // Déterminer homogénéité et type final\n    const hasString = flatSerie.some((v) => typeof v === 'string')\n\n    let processed: (number | string)[]\n    let inferredQualitative: boolean\n    if (hasString) {\n      // si au moins une valeur n'est pas numérique, tout convertir en string -> qualitatif\n      processed = flatSerie.map((v) => String(v))\n      inferredQualitative = true\n    } else {\n      // tout numérique\n      processed = flatSerie.map((v) => Number(v))\n      inferredQualitative = false\n    }\n\n    // Respecter le paramètre isQualitative s'il est fourni, sinon utiliser l'inférence\n    this.isQualitative =\n      typeof isQualitative === 'boolean' ? isQualitative : inferredQualitative\n\n    // stocker la série (mélangée pour éviter biais d'ordre)\n    if (shuffled) {\n      this.serie = shuffle(processed)\n    } else {\n      this.serie = processed\n    }\n\n    // construire this.serieTableau : tableau [valeur, effectif]\n    const counts = new Map<number | string, number>()\n    for (const v of this.serie) {\n      counts.set(v, (counts.get(v) || 0) + 1)\n    }\n\n    if (this.isQualitative) {\n      this.serieTableau = Array.from(counts.entries()).map(([val, f]) => [\n        String(val),\n        f,\n      ]) as [string, number][]\n    } else {\n      this.serieTableau = Array.from(counts.entries()).map(([val, f]) => [\n        Number(val as number),\n        f,\n      ]) as [number, number][]\n      // s'assurer que les paires sont ordonnées par valeur croissante pour les séries quantitatives\n      ;(this.serieTableau as [number, number][]).sort((a, b) => a[0] - b[0])\n    }\n  }\n\n  moyenne(): number {\n    if (this.isQualitative) {\n      throw new Error('Moyenne non définie : la série est qualitative')\n    }\n    const tableau = (this.serie as number[]).map(Number)\n    const somme = tableau.reduce((acc, val) => acc + val, 0)\n    return somme / tableau.length\n  }\n\n  variance(): number {\n    if (this.isQualitative) {\n      throw new Error('Variance non définie : la série est qualitative')\n    }\n    const moyenne = this.moyenne()\n    const sommeDesCarres = (this.serie as number[]).reduce(\n      (acc, val) => acc + Math.pow(Number(val) - moyenne, 2),\n      0,\n    )\n    return sommeDesCarres / (this.serie as number[]).length\n  }\n\n  ecartType(): number {\n    if (this.isQualitative) {\n      throw new Error('Écart-type non défini : la série est qualitative')\n    }\n    return Math.sqrt(this.variance())\n  }\n\n  mediane(): number {\n    if (this.isQualitative) {\n      throw new Error('Médiane non définie : la série est qualitative')\n    }\n    const sorted = [...(this.serie as number[])]\n      .map(Number)\n      .sort((a, b) => a - b)\n    const mid = Math.floor(sorted.length / 2)\n    if (sorted.length % 2 === 0) {\n      return (sorted[mid - 1] + sorted[mid]) / 2\n    } else {\n      return sorted[mid]\n    }\n  }\n\n  // helper pour calculer médiane d'un tableau numérique (intern)\n  private medianeArray(tableau: number[]): number {\n    const sorted = [...tableau].sort((a, b) => a - b)\n    const mid = Math.floor(sorted.length / 2)\n    if (sorted.length % 2 === 0) {\n      return (sorted[mid - 1] + sorted[mid]) / 2\n    } else {\n      return sorted[mid]\n    }\n  }\n\n  mode(): number[] {\n    if (this.isQualitative) {\n      throw new Error(\n        'Mode (numérique) : la série est qualitative — utiliser this.serieTableau pour les modalités',\n      )\n    }\n    const frequencyMap: { [key: number]: number } = {}\n    for (const num of this.serie as number[]) {\n      const k = Number(num)\n      frequencyMap[k] = (frequencyMap[k] || 0) + 1\n    }\n    const maxFrequency = Math.max(...Object.values(frequencyMap))\n    return Object.keys(frequencyMap)\n      .filter((key) => frequencyMap[Number(key)] === maxFrequency)\n      .map(Number)\n  }\n\n  min(): number {\n    if (this.isQualitative) {\n      throw new Error('Min non défini : la série est qualitative')\n    }\n    return Math.min(...(this.serie as number[]).map(Number))\n  }\n\n  max(): number {\n    if (this.isQualitative) {\n      throw new Error('Max non défini : la série est qualitative')\n    }\n    return Math.max(...(this.serie as number[]).map(Number))\n  }\n\n  etendue(): number {\n    if (this.isQualitative) {\n      throw new Error('Étendue non définie : la série est qualitative')\n    }\n    return this.max() - this.min()\n  }\n\n  coefVariation(): number {\n    if (this.isQualitative) {\n      throw new Error(\n        'Coefficient de variation non défini : la série est qualitative',\n      )\n    }\n    return this.ecartType() / this.moyenne()\n  }\n\n  get q1(): number {\n    return this.quartiles().q1\n  }\n\n  get q3(): number {\n    return this.quartiles().q3\n  }\n\n  quartiles(): { q1: number; q2: number; q3: number } {\n    if (this.isQualitative) {\n      throw new Error('Quartiles non définis : la série est qualitative')\n    }\n    const values = [...(this.serie as number[])]\n      .map(Number)\n      .sort((a, b) => a - b)\n    const n = values.length\n    const mid = Math.floor(n / 2)\n    const lower = n % 2 === 0 ? values.slice(0, mid) : values.slice(0, mid)\n    const upper = n % 2 === 0 ? values.slice(mid) : values.slice(mid + 1)\n    const q1 = lower.length ? this.medianeArray(lower) : values[0]\n    const q2 = this.medianeArray(values)\n    const q3 = upper.length\n      ? this.medianeArray(upper)\n      : values[values.length - 1]\n    return { q1, q2, q3 }\n  }\n\n  ecartInterQuartile(): number {\n    if (this.isQualitative) {\n      throw new Error(\n        'Écart interquartile non défini : la série est qualitative',\n      )\n    }\n    const { q1, q3 } = this.quartiles()\n    return q3 - q1\n  }\n\n  serieTriee(): number[] {\n    if (this.isQualitative) {\n      throw new Error(\n        'Série triée (numérique) non disponible : la série est qualitative',\n      )\n    }\n    return [...(this.serie as number[])].map(Number).sort((a, b) => a - b)\n  }\n\n  /**\n   * Calcule les éléments nécessaires pour tracer une boite à moustache (boxplot)\n   * Retourne q1, q2, q3, iqr, fences, whiskers, outliers, min, max, l'étendue et les valeurs triées\n   */\n  boiteAMoustache(): {\n    q1: number\n    q2: number\n    q3: number\n    iqr: number\n    borneInferieure: number\n    borneSuperieure: number\n    moustacheInferieure: number\n    moustacheSuperieure: number\n    valeursAberrantes: number[]\n    min: number\n    max: number\n    valeurs: number[]\n  } {\n    if (this.isQualitative) {\n      throw new Error(\n        'Boîte à moustache non applicable : la série est qualitative',\n      )\n    }\n    const values = [...(this.serie as number[])]\n      .map(Number)\n      .sort((a, b) => a - b)\n    const n = values.length\n    const mid = Math.floor(n / 2)\n    const lower = n % 2 === 0 ? values.slice(0, mid) : values.slice(0, mid)\n    const upper = n % 2 === 0 ? values.slice(mid) : values.slice(mid + 1)\n    const q1 = lower.length ? this.medianeArray(lower) : values[0]\n    const q2 = this.medianeArray(values)\n    const q3 = upper.length\n      ? this.medianeArray(upper)\n      : values[values.length - 1]\n    const iqr = q3 - q1\n    const borneInferieure = q1 - 1.5 * iqr\n    const borneSuperieure = q3 + 1.5 * iqr\n    const moustacheInferieure =\n      values.find((v) => v >= borneInferieure) ?? values[0]\n    const moustacheSuperieure =\n      [...values].reverse().find((v) => v <= borneSuperieure) ??\n      values[values.length - 1]\n    const valeursAberrantes = values.filter(\n      (v) => v < moustacheInferieure || v > moustacheSuperieure,\n    )\n    return {\n      q1,\n      q2,\n      q3,\n      iqr,\n      borneInferieure,\n      borneSuperieure,\n      moustacheInferieure,\n      moustacheSuperieure,\n      valeursAberrantes,\n      min: values[0],\n      max: values[values.length - 1],\n      valeurs: values,\n    }\n  }\n\n  traceBoiteAMoustache({\n    size = 10,\n    height = 4,\n    legendeOn = true,\n    valeursOn = true,\n    echelle = 1,\n  }: {\n    size?: number\n    height?: number\n    legendeOn?: boolean\n    valeursOn?: boolean\n    echelle?: number\n  }): string {\n    if (this.isQualitative) {\n      throw new Error(\n        'Trace boîte à moustache non applicable : la série est qualitative',\n      )\n    }\n\n    const boxplotData = this.boiteAMoustache()\n    const etendue = boxplotData.max - boxplotData.min\n    const scale = etendue / size\n\n    const extremiteDroite = point(-1, 0)\n    const extremiteGauche = point(size + 1, 0)\n    const minPoint = point(0, 0)\n    const maxPoint = point(size, 0)\n    const q1Point = point(\n      (size * (boxplotData.q1 - boxplotData.min)) / etendue,\n      0,\n    )\n    const q2Point = point(\n      (size * (boxplotData.q2 - boxplotData.min)) / etendue,\n      0,\n    )\n    const q3Point = point(\n      (size * (boxplotData.q3 - boxplotData.min)) / etendue,\n      0,\n    )\n    const minDownPoint = point(minPoint.x, echelle * 0.8)\n    const minUpPoint = point(minPoint.x, 2.4 * echelle)\n    const maxDownPoint = point(maxPoint.x, echelle * 0.8)\n    const maxUpPoint = point(maxPoint.x, 2.4 * echelle)\n    const minMiddlePoint = milieu(minDownPoint, minUpPoint)\n    const maxMiddlePoint = milieu(maxDownPoint, maxUpPoint)\n    const q1DownPoint = point(q1Point.x, echelle * 0.8)\n    const q1UpPoint = point(q1Point.x, 2.4 * echelle)\n    const q2DownPoint = point(q2Point.x, echelle * 0.8)\n    const q2UpPoint = point(q2Point.x, 2.4 * echelle)\n    const q3DownPoint = point(q3Point.x, echelle * 0.8)\n    const q3UpPoint = point(q3Point.x, 2.4 * echelle)\n    const q1MiddlePoint = milieu(q1DownPoint, q1UpPoint)\n    const q3MiddlePoint = milieu(q3DownPoint, q3UpPoint)\n    const lineMin = segment(minDownPoint, minUpPoint, 'blue')\n    const lineMax = segment(maxDownPoint, maxUpPoint, 'blue')\n    const lineQ2 = segment(q2DownPoint, q2UpPoint, 'blue')\n    const lineQ0Q1 =\n      minMiddlePoint.x === q1MiddlePoint.x\n        ? vide2d()\n        : segment(minMiddlePoint, q1MiddlePoint, 'blue')\n    const lineQ3Q4 =\n      q3MiddlePoint.x === maxMiddlePoint.x\n        ? vide2d()\n        : segment(q3MiddlePoint, maxMiddlePoint, 'blue')\n    lineMin.epaisseur = 2\n    lineMax.epaisseur = 2\n    lineQ2.epaisseur = 2\n    lineQ0Q1.epaisseur = 2\n    lineQ3Q4.epaisseur = 2\n    const box = polygone(\n      [q1DownPoint, q1UpPoint, q3UpPoint, q3DownPoint],\n      'blue',\n    )\n    box.epaisseur = 2\n    box.couleurDeRemplissage = colorToLatexOrHTML('blue')\n    box.opaciteDeRemplissage = 0.15\n\n    const lineBase = segment(extremiteDroite, extremiteGauche)\n    lineBase.epaisseur = 1\n    lineBase.styleExtremites = '->'\n    lineBase.couleur = 'black'\n    const plots = tracePoint(q1Point, q2Point, q3Point, minPoint, maxPoint)\n    plots.taille = 2\n    plots.epaisseur = 2\n    plots.style = '.'\n    // Ajout des différents éléments à tracer\n    const objetsToTrace: NestedObjetMathalea2dArray = [\n      lineBase,\n      plots,\n      lineMin,\n      lineMax,\n      lineQ2,\n      lineQ0Q1,\n      lineQ3Q4,\n      box,\n    ]\n    // Ajout des étiquettes (valeurs numériques)\n    if (valeursOn) {\n      objetsToTrace.push(\n        latex2d(texNombre(boxplotData.min), minPoint.x, minPoint.y - 0.8, {\n          letterSize: 'scriptsize',\n        }),\n        latex2d(texNombre(boxplotData.q1), q1Point.x, q1Point.y - 0.8, {\n          letterSize: 'scriptsize',\n        }),\n        latex2d(texNombre(boxplotData.q2), q2Point.x, q2Point.y - 0.8, {\n          letterSize: 'scriptsize',\n        }),\n        latex2d(texNombre(boxplotData.q3), q3Point.x, q3Point.y - 0.8, {\n          letterSize: 'scriptsize',\n        }),\n        latex2d(texNombre(boxplotData.max), maxPoint.x, maxPoint.y - 0.8, {\n          letterSize: 'scriptsize',\n        }),\n      )\n    }\n    // Ajout des étiquettes (noms)\n    if (legendeOn) {\n      objetsToTrace.push(\n        latex2d('\\\\text{Min}', minPoint.x, minPoint.y - 1.6, {\n          letterSize: 'scriptsize',\n        }),\n        latex2d('Q_1', q1Point.x, q1Point.y - 1.6, {\n          letterSize: 'scriptsize',\n        }),\n        latex2d('\\\\text{Méd}', q2Point.x, q2Point.y - 1.6, {\n          letterSize: 'scriptsize',\n        }),\n        latex2d('Q_3', q3Point.x, q3Point.y - 1.6, {\n          letterSize: 'scriptsize',\n        }),\n        latex2d('\\\\text{Max}', maxPoint.x, maxPoint.y - 1.6, {\n          letterSize: 'scriptsize',\n        }),\n      )\n    }\n    if (context.isHtml) {\n      return mathalea2d(\n        Object.assign({}, fixeBordures(objetsToTrace)),\n        objetsToTrace,\n      )\n    } else {\n      return ` \\\\begin{tikzpicture}[every node/.style={inner sep=0pt,font=\\\\scriptsize},%\n      boxplot prepared/every whisker/.style={ultra thick}]\n    \\\\begin{axis}[\n        clip=false,\n        y=1cm,\n        ymin=-0.5cm,\n        xmin=${boxplotData.min - scale},\n        xmax=${boxplotData.max + scale},\n        height=${height}cm,\n        width=${size / 2}cm,\n        ytick=\\\\empty,\n        axis y line=left,\n        axis x line=middle,\n        xtick = \\\\empty,\n        y axis line style={draw=none},\n        enlarge y limits={abs=5mm},\n      ]\n      \\\\addplot+[\n        boxplot prepared ={\n            every box/.style={ultra thick,fill=blue!15},\n            every whisker/.style={ultra thick},\n            every median/.style={ultra thick},\n            lower whisker=${texNombre(boxplotData.moustacheInferieure, 2)},\n            lower quartile=${boxplotData.q1},\n            median=${boxplotData.q2},\n            upper quartile=${boxplotData.q3},\n            upper whisker=${texNombre(boxplotData.moustacheSuperieure, 2)},\n          },\n      ] coordinates {};\n      \\\\foreach \\\\x/\\\\name [count=\\\\xi from 0] in {${boxplotData.min}/Min,${boxplotData.q1}/Q1,${boxplotData.q2}/Méd,${boxplotData.q3}/Q3,${boxplotData.max}/Max} {\n          \\\\edef\\\\temp{\\\\noexpand\\\\fill (\\\\x,0) coordinate (a\\\\xi) circle (2pt);\n            ${valeursOn ? '\\\\noexpand\\\\node[below=2mm of a\\\\xi] {\\\\x};' : ''}\n            ${legendeOn ? '\\\\noexpand\\\\node[below=4mm of a\\\\xi]  {\\\\name};' : ''}\n          }\n          \\\\temp\n        }\n    \\\\end{axis}\n  \\\\end{tikzpicture}\n`\n    }\n  }\n\n  listeSerie({\n    precision = 2,\n    separateur = '; ',\n    triee = false,\n    tableau = false,\n    motValeurs = 'Valeurs',\n  } = {}): string {\n    const escapeLatex = (s: string) =>\n      String(s).replace(/([%&$#_{}\\\\^~])/g, '\\\\$1')\n\n    if (!tableau) {\n      // affichage linéaire : gérer qualitatives et numériques séparément\n      if (this.isQualitative) {\n        const arr = triee\n          ? [...this.serie].map(String).sort()\n          : this.serie.slice()\n        return arr\n          .map((v) => `$\\\\text{${escapeLatex(String(v))}}$`)\n          .join(separateur)\n      } else {\n        const arr = triee ? this.serieTriee() : (this.serie as number[])\n        return arr\n          .map((n) => `$${texNombre(Number(n), precision)}$`)\n          .join(separateur)\n      }\n    } else {\n      // mode tableau : construire lignes valeurs / effectifs en tenant compte du type\n      const entries = this.serieTableau as Array<[number | string, number]>\n      const nCols = entries.length\n      const valuesRow = entries\n        .map(([v]) =>\n          this.isQualitative\n            ? `\\\\text{${escapeLatex(String(v))}}`\n            : texNombre(Number(v), precision),\n        )\n        .join(' & ')\n      const effectsRow = entries.map(([, f]) => String(f)).join(' & ')\n      const cols = '|l|' + 'c|'.repeat(nCols)\n      return `$\\\\begin{array}{${cols}}\n\\\\hline\n\\\\text{${motValeurs}} & ${valuesRow} \\\\\\\\ \\\\hline\n\\\\text{effectifs} & ${effectsRow} \\\\\\\\ \\\\hline\n\\\\end{array}$`\n    }\n  }\n\n  diagramme({\n    cumul = false,\n    croissance = true,\n    barres = true,\n    percentVsEffectifs = false,\n    effectifsOn = false,\n    valuesOn = true,\n  } = {}) {\n    const precision = 2\n    // copier et trier selon croissance\n    // Distinction explicite entre série qualitative et quantitative :\n    // - qualitative : conserver l'ordre d'entrée (ou l'inverser si croissance=false)\n    // - quantitative : trier numériquement par valeur (croissance ou décroissance)\n    let pairs: Array<[number | string, number]> = (\n      this.serieTableau as Array<[number | string, number]>\n    ).slice()\n    if (this.isQualitative) {\n      if (!croissance) pairs.reverse()\n    } else {\n      pairs = (pairs as [number, number][])\n        .slice()\n        .sort((a, b) => (croissance ? a[0] - b[0] : b[0] - a[0]))\n    }\n\n    const total = pairs.reduce((s, [, f]) => s + f, 0)\n    // calcul des valeurs à tracer (effectifs ou pourcentages / cumul)\n    const ys: number[] = []\n    if (cumul) {\n      let acc = 0\n      for (const [, f] of pairs) {\n        acc += f\n        ys.push(percentVsEffectifs ? (acc / total) * 100 : acc)\n      }\n    } else {\n      for (const [, f] of pairs) {\n        ys.push(percentVsEffectifs ? (f / total) * 100 : f)\n      }\n    }\n\n    // labels et positions x\n    const xs = pairs.map(([v]) => v)\n    const labelsTex = pairs.map(([v]) =>\n      this.isQualitative ? String(v) : texNombre(Number(v), precision),\n    )\n\n    // construire coords selon qualitative / quantitative\n    let coords = ''\n    if (this.isQualitative) {\n      // utiliser labels symboliques\n      coords = labelsTex\n        .map((lab, i) => `(${lab},${Number(ys[i].toFixed(3))})`)\n        .join(' ')\n    } else {\n      // positions numériques respectant l'échelle\n      coords = xs\n        .map((x, i) => `(${Number(x).toFixed(6)},${Number(ys[i].toFixed(6))})`)\n        .join(' ')\n    }\n\n    const yName = percentVsEffectifs ? 'fréquences' : 'effectifs'\n    const ylabel = percentVsEffectifs ? 'Fréquences en \\\\%' : 'Effectifs'\n    const title = `${\n      barres\n        ? cumul\n          ? `diagramme cumulé (${croissance ? 'croissant' : 'décroissant'})`\n          : 'Diagramme en barres'\n        : cumul\n          ? `Polygone des ${yName} cumulé${yName === 'fréquences' ? 'es' : 's'} (${croissance ? 'croissantes' : 'décroissantes'})`\n          : `Polygone des ${yName}`\n    } `\n\n    if (context.isHtml) {\n      // code HTML existant inchangé\n      const yMax = 8\n      const nbValeursDifferentes = this.serieTableau.length\n      const nbValeurs = this.serie.length\n      const echelleYCumul = nbValeurs < 15 ? 2 : nbValeurs < 30 ? 5 : 10\n      const echelleYPercent = 25\n      const effectifMax = Math.max(...ys)\n      const gridOpacity = 0.5\n      const topCadre = 8.7\n      // Pour les séries qualitatives, les valeurs x sont des positions 1..N\n      let min: number, max: number\n      if (this.isQualitative) {\n        min = 0\n        max = (this.serieTableau as [any, number][]).length + 1\n      } else {\n        const numericSerie = (this.serie as number[]).map(Number)\n        min = Math.min(...numericSerie) - 1\n        max = Math.max(...numericSerie) + 1\n      }\n\n      const echelleY = effectifMax < 15 ? 2 : effectifMax < 30 ? 3 : 4\n      let yLabelsAndOrdinate: [number, number][] = []\n      if (percentVsEffectifs) {\n        yLabelsAndOrdinate = Array.from({ length: 5 }, (_, i) => [\n          i * 25,\n          (i * echelleYPercent * yMax) / 100,\n        ])\n      } else {\n        if (cumul) {\n          yLabelsAndOrdinate = Array.from(\n            {\n              length: Math.ceil(nbValeurs / echelleYCumul) + 1,\n            },\n            (_, i) => [i * echelleYCumul, (i * 8 * echelleYCumul) / nbValeurs],\n          )\n        } else {\n          yLabelsAndOrdinate = Array.from({\n            length: Math.ceil((effectifMax + 1) / echelleY),\n          }).map((_, i) => [i * echelleY, (i * 8 * echelleY) / effectifMax])\n        }\n      }\n\n      const cadre = new BoiteBuilder({\n        xMin: 0,\n        xMax: (max - min) * 2,\n        yMin: 0,\n        yMax: topCadre,\n      }).render()\n\n      const histo: NestedObjetMathalea2dArray = [cadre]\n      for (const [i, yPos] of yLabelsAndOrdinate) {\n        histo.push(\n          latex2d(`${texNombre(i, 0)}`, -0.5, yPos + 0.1, {\n            letterSize: 'scriptsize',\n          }),\n        )\n      }\n      for (const yLabel of yLabelsAndOrdinate) {\n        const line = segment(\n          point(0, yLabel[1]),\n          point((nbValeursDifferentes + 1) * 2, yLabel[1]),\n          'lightgray',\n        )\n        line.opacite = gridOpacity\n        histo.push(line)\n      }\n      let xPosNext = 0\n      let xPos = 0\n      let yPos = 0\n      let yPosNext = 0\n      for (let i = 0; i < pairs.length; i++) {\n        // normaliser la valeur courante et la suivante selon le type de série\n        const [valRaw /* number|string */ /* freq */] = pairs[i]\n        const nextRaw = i < pairs.length - 1 ? pairs[i + 1][0] : pairs[i][0]\n        // convertir en nombre uniquement si la série est quantitative\n        const valNum = this.isQualitative ? NaN : Number(valRaw)\n        const nextNum = this.isQualitative ? NaN : Number(nextRaw)\n\n        xPos = this.isQualitative ? (i + 1) * 2 : (valNum - min) * 2 + 1\n        xPosNext = this.isQualitative ? (i + 2) * 2 : (nextNum - min) * 2 + 1\n        yPos = cumul\n          ? percentVsEffectifs\n            ? (ys[i] * yMax) / 100\n            : (ys[i] * yMax) / nbValeurs\n          : percentVsEffectifs\n            ? (ys[i] * yMax) / 100\n            : (ys[i] * yMax) / effectifMax\n        if (i < pairs.length - 1) {\n          yPosNext = cumul\n            ? percentVsEffectifs\n              ? (ys[i + 1] * yMax) / 100\n              : (ys[i + 1] * yMax) / nbValeurs\n            : percentVsEffectifs\n              ? (ys[i + 1] * yMax) / 100\n              : (ys[i + 1] * yMax) / effectifMax\n        } else {\n          yPosNext = yPos\n        }\n        const verticalLine = segment(\n          point(xPos, 0),\n          point(xPos, topCadre),\n          'lightgray',\n        )\n        verticalLine.epaisseur = 1\n        verticalLine.opacite = gridOpacity\n\n        histo.push(verticalLine)\n        if (barres) {\n          const barre = new BoiteBuilder({\n            xMin: xPos - 0.2,\n            xMax: xPos + 0.2,\n            yMin: 0,\n            yMax: yPos,\n          })\n            .addColor({\n              color: 'blue',\n              colorBackground: '#9699FF',\n              backgroudOpacity: 1,\n            })\n            .render()\n\n          histo.push(barre)\n        } else {\n          if (i < pairs.length - 1) {\n            const line = segment(\n              point(xPos, yPos),\n              point(xPosNext, yPosNext),\n              'blue',\n            )\n            line.epaisseur = 2\n            line.opacite = 0.5\n            histo.push(line)\n          }\n        }\n        if (effectifsOn) {\n          const effectifTex = latex2d(\n            `${texNombre(ys[i], 0)}${percentVsEffectifs ? '\\\\%' : ''}`,\n            xPos,\n            yPos + 0.5,\n            { letterSize: 'scriptsize' },\n          )\n          histo.push(effectifTex)\n        }\n        if (valuesOn) {\n          // afficher la valeur : texte brut pour qualitative, format numérique sinon\n          const label = this.isQualitative\n            ? String(valRaw)\n            : texNombre(valNum, precision)\n          histo.push(\n            latex2d(label, xPos, -0.5, {\n              letterSize: 'scriptsize',\n            }),\n          )\n        }\n        const texLabel = latex2d(`\\\\text{${ylabel}}`, -1.5, topCadre / 2, {\n          letterSize: 'normalsize',\n          orientation: 90,\n          opacity: 0.7,\n        })\n        histo.push(texLabel)\n        const texteTitle = latex2d(\n          `\\\\text{${title}}`,\n          nbValeursDifferentes + 1,\n          topCadre + 0.5,\n          {\n            letterSize: 'normalsize',\n            opacity: 0.7,\n          },\n        )\n        histo.push(texteTitle)\n      }\n\n      return mathalea2d(\n        Object.assign({ style: 'display: inline-block' }, fixeBordures(histo)),\n        histo,\n      )\n    } else {\n      // choisir le style (barres ou polygone)\n      const addplot = barres\n        ? `\\\\addplot+[ybar, bar width=${(() => {\n            if (this.isQualitative) return '12pt'\n            // convertir les xs en nombres puis trier (filtrer les NaN par sécurité)\n            const xsNumeric = xs\n              .map((v) => Number(v))\n              .filter((n) => Number.isFinite(n))\n              .slice()\n              .sort((a, b) => a - b)\n            if (xsNumeric.length < 2) return '12pt'\n            let minDiff = Infinity\n            for (let i = 0; i < xsNumeric.length - 1; i++) {\n              minDiff = Math.min(minDiff, xsNumeric[i + 1] - xsNumeric[i])\n            }\n            // bar width en unités x (60% du pas minimal)\n            return `${(minDiff * 0.6).toFixed(6)}`\n          })()}, draw=black, fill=blue!40] coordinates { ${coords} };`\n        : `\\\\addplot+[sharp plot, thick, mark=*, mark options={fill=blue}] coordinates { ${coords} };`\n\n      // Options conditionnelles pour pgfplots selon les flags fournis\n      const axisOptionsArr: string[] = []\n      axisOptionsArr.push(`title={${title}}`)\n      axisOptionsArr.push(`ylabel={${ylabel}}`)\n      axisOptionsArr.push(`xlabel={Valeurs}`)\n      axisOptionsArr.push(`ymin=0`)\n      axisOptionsArr.push(`enlarge x limits=0.15`)\n      axisOptionsArr.push(`grid=major`)\n      axisOptionsArr.push(`width=12cm`)\n      axisOptionsArr.push(`height=6cm`)\n      // nodes near coords / formatage des effectifs\n      if (effectifsOn) {\n        if (percentVsEffectifs) {\n          axisOptionsArr.push(\n            'nodes near coords={\\\\pgfmathprintnumber[fixed,precision=0]{\\\\pgfplotspointmeta}\\\\%}',\n          )\n        } else {\n          axisOptionsArr.push('nodes near coords')\n        }\n        axisOptionsArr.push(\n          'nodes near coords align={vertical}',\n          'every node near coord/.append style={font=\\\\scriptsize}',\n        )\n      }\n      // gestion des valeurs sur l'axe des x\n      if (this.isQualitative) {\n        if (valuesOn) {\n          axisOptionsArr.push(\n            `symbolic x coords={${labelsTex.join(',')}}`,\n            'xtick=data',\n          )\n        } else {\n          axisOptionsArr.push(\n            'symbolic x coords={' + labelsTex.join(',') + '}',\n            'xtick=\\\\empty',\n          )\n        }\n      } else {\n        // axe quantitatif : positions numériques, xticks positionnés sur xs si valuesOn\n        // convertir xs en nombres (sécurité contre valeurs qualitatives) et filtrer les NaN\n        const xsNumeric = xs\n          .map((v) => Number(v))\n          .filter((n) => Number.isFinite(n))\n          .slice()\n          .sort((a, b) => a - b)\n\n        // fallback si conversion impossible\n        const xmin = xsNumeric.length ? xsNumeric[0] : 0\n        const xmax = xsNumeric.length ? xsNumeric[xsNumeric.length - 1] : 1\n\n        axisOptionsArr.push(\n          `xmin=${Number((xmin - (xmax - xmin) * 0.05).toFixed(6))}`,\n        )\n        axisOptionsArr.push(\n          `xmax=${Number((xmax + (xmax - xmin) * 0.05).toFixed(6))}`,\n        )\n\n        if (valuesOn && xsNumeric.length) {\n          const xticks = xsNumeric.map((v) => Number(v.toFixed(6))).join(',')\n          axisOptionsArr.push(`xtick={${xticks}}`)\n          const xticklabels = labelsTex.join(',')\n          axisOptionsArr.push(`xticklabels={${xticklabels}}`)\n        } else {\n          axisOptionsArr.push('xtick=\\\\empty')\n        }\n      }\n\n      return `\\\\begin{tikzpicture}\n  \\\\begin{axis}[\n    ${axisOptionsArr.join(',\\n    ')}\n  ]\n    ${addplot}\n  \\\\end{axis}\n\\\\end{tikzpicture}`\n    }\n  }\n}\n"],"names":["Stat","serie","isQualitative","shuffled","__publicField","flatSerie","el","val","freq","n","i","hasString","v","processed","inferredQualitative","shuffle","counts","f","a","b","tableau","acc","moyenne","sorted","mid","frequencyMap","num","k","maxFrequency","key","values","lower","upper","q1","q2","q3","iqr","borneInferieure","borneSuperieure","moustacheInferieure","moustacheSuperieure","valeursAberrantes","size","height","legendeOn","valeursOn","echelle","boxplotData","etendue","scale","extremiteDroite","point","extremiteGauche","minPoint","maxPoint","q1Point","q2Point","q3Point","minDownPoint","minUpPoint","maxDownPoint","maxUpPoint","minMiddlePoint","milieu","maxMiddlePoint","q1DownPoint","q1UpPoint","q2DownPoint","q2UpPoint","q3DownPoint","q3UpPoint","q1MiddlePoint","q3MiddlePoint","lineMin","segment","lineMax","lineQ2","lineQ0Q1","vide2d","lineQ3Q4","box","polygone","colorToLatexOrHTML","lineBase","plots","tracePoint","objetsToTrace","latex2d","texNombre","context","mathalea2d","fixeBordures","precision","separateur","triee","motValeurs","escapeLatex","s","entries","nCols","valuesRow","effectsRow","cumul","croissance","barres","percentVsEffectifs","effectifsOn","valuesOn","pairs","total","ys","xs","labelsTex","coords","lab","x","yName","ylabel","title","nbValeursDifferentes","nbValeurs","echelleYCumul","echelleYPercent","effectifMax","gridOpacity","topCadre","min","max","numericSerie","echelleY","yLabelsAndOrdinate","_","histo","BoiteBuilder","yPos","yLabel","line","xPosNext","xPos","yPosNext","valRaw","nextRaw","valNum","nextNum","verticalLine","barre","effectifTex","label","texLabel","texteTitle","addplot","xsNumeric","minDiff","axisOptionsArr","xmin","xmax","xticks","xticklabels"],"mappings":"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"}