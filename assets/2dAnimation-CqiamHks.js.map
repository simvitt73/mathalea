{"version":3,"file":"2dAnimation-CqiamHks.js","sources":["../../src/modules/2dAnimation.ts"],"sourcesContent":["/**\n * Rend visible un element d'après son id\n * @param {number} id id propre à un objet MathALEA2d\n * @example montrerParDiv(s2.id) // Affiche l'objet s2\n * @author Rémi Angot\n */\n\nimport type { DemiDroite } from '../lib/2d/DemiDroite'\nimport type { Droite } from '../lib/2d/droites'\nimport { fixeBordures } from '../lib/2d/fixeBordures'\nimport type { IDroite, IPolygone, IVecteur } from '../lib/2d/Interfaces'\nimport { ObjetMathalea2D } from '../lib/2d/ObjetMathalea2D'\nimport type { PointAbstrait } from '../lib/2d/PointAbstrait'\nimport type { Polygone } from '../lib/2d/polygones'\nimport type { Segment } from '../lib/2d/segmentsVecteurs'\nimport {\n  affiniteOrtho,\n  homothetie,\n  rotation,\n  symetrieAxiale,\n  translation,\n} from '../lib/2d/transformations'\nimport type { Vecteur } from '../lib/2d/Vecteur'\nimport { arrondi } from '../lib/outils/nombres'\n\n// JSDOC Validee par EE Juin 2022\nexport function montrerParDiv(id: string) {\n  const elt = document.getElementById(id)\n  if (elt != null) {\n    elt.style.visibility = 'visible'\n  } else {\n    console.log(id + \" n'existe pas et ne peut pas être rendu visible.\")\n  }\n}\n\n/**\n * Rend invisible un element d'après son id\n * @param {number} id id propre à un objet MathALEA2d\n * @example cacherParDiv(s2.id) // Cache l'objet s2\n * @author Rémi Angot\n */\n// JSDOC Validee par EE Juin 2022\nexport function cacherParDiv(id: string) {\n  const elt = document.getElementById(id)\n  if (elt != null) {\n    elt.style.visibility = 'hidden'\n  } else {\n    console.log(id + \" n'existe pas et ne peut pas être caché.\")\n  }\n}\n\n/**\n * Masque un objet pendant t0 secondes puis l'affiche pendant (t-t0) secondes avant de recommencer r fois ce cycle en tout\n * @param {ObjetMathalea2D} objet Objet MathALEA2d masqué puis affiché\n * @param {number} [t0=1] Temps en secondes avant l'apparition.\n * @param {number} [t=5] Temps à partir duquel l'animation recommence.\n * @param {string|number} [r='Infinity'] Nombre de répétitions (infini si ce n'est pas un nombre).\n * @example afficherTempo(ob1)\n * // Affiche ob1 au bout de 1 seconde, pendant 4 secondes puis le masque. Ce cycle est répété indéfiniment.\n * @example afficherTempo(ob1,2,9,10)\n * // Sur un cycle de 9 secondes, affiche ob1 au bout de 2 seconde puis le masque en fin de cycle. Ce cycle est répété 10 fois.\n */\n// JSDOC Validee par EE Juin 2022\nexport function afficherTempo(\n  objet: ObjetMathalea2D,\n  t0 = 1,\n  t = 5,\n  r: number | string = 'Infinity',\n) {\n  let compteur = 1 // Nombre d'animations\n  const checkExist = setInterval(function () {\n    if (document.getElementById(String(objet.id))) {\n      clearInterval(checkExist)\n      cacherParDiv(String(objet.id))\n      if (Number(r) === 1) {\n        // On le montre au bout de t0 et on ne le cache plus\n        setTimeout(function () {\n          montrerParDiv(String(objet.id))\n        }, t0 * 1000)\n      } else {\n        const cacheRepete = setInterval(function () {\n          cacherParDiv(String(objet.id))\n        }, t * 1000) // On cache tous les t s\n        setTimeout(function () {\n          montrerParDiv(String(objet.id)) // On attend t0 pour montrer\n          const montreRepete = setInterval(function () {\n            montrerParDiv(String(objet.id))\n            compteur++\n            if (typeof r === 'number') {\n              if (compteur >= r) {\n                clearInterval(cacheRepete)\n                clearInterval(montreRepete)\n              }\n            }\n          }, t * 1000) // On montre tous les t s (vu qu'on a décalé de t0)\n        }, t0 * 1000) // Fin de l'animation en boucle\n      }\n    }\n  }, 100) // vérifie toutes les  100ms que le div existe\n}\n\n/**\n * Affiche un objet pendant t0 secondes puis le cache pendant (t-t0) secondes avant de recommencer r fois ce cycle en tout\n * @param {ObjetMathalea2D} objet Objet MathALEA2d affiché puis masqué\n * @param {number} [t0=1] Temps en secondes avant l'apparition\n * @param {number} [t=5] Temps à partir duquel l'animation recommence\n * @param {string|number} [r='Infinity'] Nombre de répétitions (infini si ce n'est pas un nombre)\n * @example cacherTempo(figure1)\n * // Affiche figure1 pendant 1 seconde, puis le cache pendant 4 secondes et recommence ce cycle indéfiniment.\n * @example cacherTempo(figure1,2,8,3)\n * // Affiche figure1 pendant 2 secondes, puis le cache pendant 6 secondes et recommence ce cycle 3 fois en tout.\n * @author Eric Elter\n */\n// JSDOC Validee par EE Juin 2022\nexport function cacherTempo(\n  objet: ObjetMathalea2D,\n  t0 = 1,\n  t = 5,\n  r: number | string = 'Infinity',\n) {\n  let compteur = 1 // Nombre d'animations\n  const checkExist = setInterval(function () {\n    if (document.getElementById(String(objet.id))) {\n      clearInterval(checkExist)\n      montrerParDiv(String(objet.id))\n      if (Number(r) === 1) {\n        // On le cache au bout de t0 et on ne le montre plus\n        setTimeout(function () {\n          cacherParDiv(String(objet.id))\n        }, t0 * 1000)\n      } else {\n        const montreRepete = setInterval(function () {\n          montrerParDiv(String(objet.id))\n        }, t * 1000) // On cache tous les t s\n        setTimeout(function () {\n          cacherParDiv(String(objet.id)) // On attend t0 pour montrer\n          const cacheRepete = setInterval(function () {\n            cacherParDiv(String(objet.id))\n            compteur++\n            if (typeof r === 'number') {\n              if (compteur >= r) {\n                clearInterval(cacheRepete)\n                clearInterval(montreRepete)\n              }\n            }\n          }, t * 1000) // On montre tous les t s (vu qu'on a décalé de t0)\n        }, t0 * 1000) // Fin de l'animation en boucle\n      }\n    }\n  }, 100) // vérifie toutes les  100ms que le div existe\n}\n\n/**\n * Masque une suite d'objets puis les affiche un par un, de t secondes en t secondes avant de recommencer r fois, tApresDernier secondes après l'affichage de tous les objets\n * @param {ObjetMathalea2D[]} objets Liste d'objets MathALEA2d masqués puis affichés\n * @param {number} [t = 1] Temps en secondes entre l'apparition de chaque objet\n * @param {string} [r = 'Infinity'] Nombre de répétitions (infini si ce n'est pas un nombre).\n * @param {number} [tApresDernier = 5] Temps, après l'affichage du dernier objet, à partir duquel l'animation recommence.\n * @example afficherUnParUn([s1,s2])\n * // Affiche s1 au bout de 1 seconde, puis s2 après 1 nouvelle seconde, puis les masque après 5 secondes. Ce cycle est répété indéfiniment.\n * @example afficherUnParUn([s1,s2],2,9,10)\n * // Affiche s1 au bout de 2 secondes, puis s2 après 2 nouvelles secondes, puis les masque après 10 secondes. Ce cycle est répété en tout 9 fois.\n * @author Rémi Angot\n */\n// JSDOC Validee par EE Juin 2022\nexport function afficherUnParUn(\n  objets: ObjetMathalea2D[],\n  t = 1,\n  r = 'Infinity',\n  tApresDernier = 5,\n) {\n  let t0 = t\n  const tf = objets.length * t + tApresDernier\n  for (const objet of objets) {\n    afficherTempo(objet, t0, tf, r)\n    t0 += t\n  }\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%% LES TRANSFORMATIONS ANIMÉES %%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/**\n * Fait apparaître une liste d'objets de façon animée.\n * @param {ObjetMathalea2D[]} liste liste d'objets à faire apparaître\n * @param {number} [dur = 2] Durée de l'animation en secondes\n * @param {number} [pourcentage = 0.5] Pourcentage de la durée à partir de laquelle les objets sont visibles\n * @param {number|string} [repeat = 'indefinite'] Nombre de répétitions de l'animation, peut être un entier.\n * @author Rémi Angot\n */\n// JSDOC Non Validee EE Juin 2022 (non testée)\nexport class ApparitionAnimee extends ObjetMathalea2D {\n  liste: ObjetMathalea2D | ObjetMathalea2D[]\n  dur: number\n  pourcentage: number\n  repeat: string\n\n  constructor(\n    liste: ObjetMathalea2D | ObjetMathalea2D[],\n    dur = 2,\n    pourcentage = 0.5,\n    repeat = 'indefinite',\n  ) {\n    super()\n    this.liste = liste\n    this.dur = dur\n    this.pourcentage = pourcentage\n    this.repeat = repeat\n  }\n\n  svg(coeff: number) {\n    let code = '<g> '\n    if (Array.isArray(this.liste)) {\n      for (const objet of this.liste) {\n        code += '\\n' + objet.svg(coeff)\n      }\n    } else {\n      // si ce n'est pas une liste\n      code += '\\n' + this.liste.svg(coeff)\n    }\n    code += `<animate attributeType=\"CSS\"\n    attributeName=\"visibility\"\n    from=\"hidden\"\n    to=\"hidden\"\n    values=\"hidden;visible;hidden\"\n    keyTimes=\"0; ${this.pourcentage}; 1\"\n    dur=\"${this.dur}\"\n    repeatCount=\"${this.repeat}\"/>`\n    code += '</g>'\n    return code\n  }\n\n  tikz() {\n    return ''\n  }\n}\n/**\n * Fait apparaître une liste d'objets de façon animée\n * @param {ObjetMathalea2D[]} liste liste d'objets à faire apparaître\n * @param {number} [dur = 2] Durée de l'animation en secondes\n * @param {number} [pourcentage = 0.5] Pourcentage de la durée à partir de laquelle les objets sont visibles\n * @param {number|string} [repeat = 'indefinite'] Nombre de répétitions de l'animation, peut être un entier\n * @return {ApparitionAnimee}\n * @example Fonction non utilisée donc pas d'exemple, fonction non testée, peut être bugguée\n * @author Rémi Angot\n */\n// JSDOC Non Validee EE Juin 2022 (impossible à tester car non utilisée)\nexport function apparitionAnimee(\n  liste: ObjetMathalea2D | ObjetMathalea2D[],\n  dur = 2,\n  pourcentage = 0.5,\n  repeat = 'indefinite',\n) {\n  return new ApparitionAnimee(liste, dur, pourcentage, repeat)\n}\n/**\n * translationAnimee(s,v) //Animation de la translation de vecteur v pour s\n * translationAnimee([a,b,c],v) //Animation de la translation de vecteur v pour les objets a, b et v\n *\n * @author Rémi Angot\n */\nexport class TranslationAnimee extends ObjetMathalea2D {\n  liste:\n    | (PointAbstrait | Droite | Segment | DemiDroite | Polygone)[]\n    | PointAbstrait\n    | Droite\n    | Segment\n    | DemiDroite\n    | Polygone\n\n  v: Vecteur\n  animation: string\n  constructor(\n    liste: (PointAbstrait | Droite | Segment | DemiDroite | Polygone)[],\n    v: Vecteur,\n    animation = 'begin=\"0s\" dur=\"2s\" repeatCount=\"indefinite\"',\n  ) {\n    super()\n    this.liste = Array.isArray(liste) ? liste : [liste]\n    this.v = v\n    this.animation = animation\n    const liste2 = this.liste.map((el) => translation(el, v as IVecteur))\n    const bordures = fixeBordures(\n      this.liste.concat(\n        liste2 as\n          | (PointAbstrait | Droite | Segment | DemiDroite | Polygone)[]\n          | PointAbstrait\n          | Droite\n          | Segment\n          | DemiDroite\n          | Polygone,\n      ),\n    )\n    this.bordures = [bordures.xmin, bordures.ymin, bordures.xmax, bordures.ymax]\n  }\n\n  svg(coeff: number) {\n    let code = '<g> '\n    if (Array.isArray(this.liste)) {\n      for (const objet of this.liste) {\n        code += '\\n' + objet.svg(coeff)\n      }\n    } else {\n      // si ce n'est pas une liste\n      code += '\\n' + this.liste.svg(coeff)\n    }\n    if (Array.isArray(this.v)) {\n      code += '<animateMotion path=\"M 0 0 l'\n      for (const vecteur of this.v) {\n        code += ` ${vecteur.xSVG(coeff)} ${vecteur.ySVG(coeff)} `\n      }\n      code += `${this.animation} />`\n    } else {\n      code += `<animateMotion path=\"M 0 0 l ${this.v.xSVG(coeff)} ${this.v.ySVG(coeff)} \" ${this.animation} />`\n    }\n    code += '</g>'\n    return code\n  }\n\n  tikz() {\n    return ''\n  }\n}\nexport function translationAnimee(\n  liste: (PointAbstrait | Droite | Segment | DemiDroite | Polygone)[],\n  v: Vecteur,\n  animation = 'begin=\"0s\" dur=\"2s\" repeatCount=\"indefinite\"',\n) {\n  return new TranslationAnimee(liste, v, animation)\n}\n\n/**\n * rotationAnimee(s,O,a) //Animation de la rotation de centre O et d'angle a pour s\n * rotationAnimee([a,b,c],O,a) //Animation de la rotation de centre O et d'angle a pour les objets a, b et c\n *\n * @author Rémi Angot\n */\nexport class RotationAnimee extends ObjetMathalea2D {\n  liste: (PointAbstrait | Droite | Segment | DemiDroite | Polygone)[]\n  O: PointAbstrait\n  angle: number\n  animation: string\n  constructor(\n    liste:\n      | (PointAbstrait | Droite | Segment | DemiDroite | Polygone)[]\n      | Droite\n      | Segment\n      | DemiDroite\n      | Polygone\n      | PointAbstrait,\n    O: PointAbstrait,\n    angle: number,\n    animation = 'begin=\"0s\" dur=\"2s\" repeatCount=\"indefinite\"',\n  ) {\n    super()\n    this.liste = (Array.isArray(liste) ? liste : [liste]) as (\n      | PointAbstrait\n      | Droite\n      | Segment\n      | DemiDroite\n      | Polygone\n    )[]\n    this.O = O\n    this.angle = angle\n    this.animation = animation\n    const liste2 = this.liste.map(\n      (el) =>\n        rotation(el as any, O, angle) as\n          | PointAbstrait\n          | Droite\n          | Segment\n          | DemiDroite\n          | Polygone,\n    )\n    const bordures = fixeBordures([...this.liste.concat(liste2)])\n    this.bordures = [bordures.xmin, bordures.ymin, bordures.xmax, bordures.ymax]\n  }\n\n  svg(coeff: number) {\n    let code = '<g> '\n    for (const objet of this.liste) {\n      code += '\\n' + objet.svg(coeff)\n    }\n\n    code += `<animateTransform\n  attributeName=\"transform\"\n  type=\"rotate\"\n  from=\"0 ${this.O.xSVG(coeff)} ${this.O.ySVG(coeff)}\"\n  to=\"${-this.angle} ${this.O.xSVG(coeff)} ${this.O.ySVG(coeff)}\"\n  ${this.animation}\n  />`\n    code += '</g>'\n    return code\n  }\n\n  tikz() {\n    return ''\n  }\n}\nexport function rotationAnimee(\n  liste:\n    | (PointAbstrait | Droite | Segment | DemiDroite | Polygone)[]\n    | Droite\n    | Segment\n    | DemiDroite\n    | Polygone\n    | PointAbstrait,\n  O: PointAbstrait | PointAbstrait,\n  angle: number,\n  animation = 'begin=\"0s\" dur=\"2s\" repeatCount=\"indefinite\"',\n) {\n  return new RotationAnimee(liste, O, angle, animation)\n}\n/**\n * homothetieAnimee(s,O,k) //Animation de la homothetie de centre O et de rapport k pour s\n * homothetieAnimee([a,b,c],O,k) //Animation de la homothetie de centre O et de rapport k pour les objets a, b et v\n *\n * @author Rémi Angot\n */\nexport class HomothetieAnimee extends ObjetMathalea2D {\n  p: Polygone\n  O: PointAbstrait\n  k: number\n  animation: string\n  constructor(\n    p: Polygone,\n    O: PointAbstrait,\n    k: number,\n    animation = 'begin=\"0s\" dur=\"2s\" repeatCount=\"indefinite\"',\n  ) {\n    super()\n    this.p = p\n    this.O = O\n    this.k = k\n    this.animation = animation\n    const bordures =\n      this.k > 1\n        ? fixeBordures([this.O, homothetie(this.p, this.O, this.k)])\n        : fixeBordures([this.O, this.p])\n    this.bordures = [bordures.xmin, bordures.ymin, bordures.xmax, bordures.ymax]\n    if (this.k > 1) {\n      this.bordures = homothetie(this.p, this.O, this.k).bordures\n    }\n    this.bordures = homothetie(this.p, this.O, this.k).bordures\n  }\n\n  svg(coeff: number) {\n    const binomesXY1 = this.p.binomesXY(coeff)\n    const p2 = homothetie(this.p, this.O, this.k)\n    const binomesXY2 = p2.binomesXY(coeff)\n    const code = `<polygon stroke=\"${this.p.color[0]}\" stroke-width=\"${this.p.epaisseur}\" fill=\"${this.p.couleurDeRemplissage[0]}\" >\n  <animate attributeName=\"points\" ${this.animation}\n  from=\"${binomesXY1}\"\n  to=\"${binomesXY2}\"\n  />\n  </polygon>`\n    return code\n  }\n\n  tikz() {\n    return ''\n  }\n}\nexport function homothetieAnimee(\n  p: Polygone,\n  O: PointAbstrait,\n  k: number,\n  animation = 'begin=\"0s\" dur=\"2s\" repeatCount=\"indefinite\"',\n) {\n  return new HomothetieAnimee(p, O, k, animation)\n}\n\n/**\n * symetrieAnimee(s,d) //Animation de la symetrie d'axe (d) pour s\n * symetrieAnimee([a,b,c],d) //Animation de la symetrie d'axe (d) pour les objets a, b et v\n *\n * @author Rémi Angot\n */\nexport class SymetrieAnimee extends ObjetMathalea2D {\n  p: IPolygone\n  d: IDroite\n  animation: string\n  constructor(\n    p: IPolygone,\n    d: IDroite,\n    animation = 'begin=\"0s\" dur=\"2s\" repeatCount=\"indefinite\"',\n  ) {\n    super()\n    this.p = p\n    this.d = d\n    this.animation = animation\n    const bordures = fixeBordures([p, symetrieAxiale(p as any, d as Droite)])\n    this.bordures = [bordures.xmin, bordures.ymin, bordures.xmax, bordures.ymax]\n  }\n\n  svg(coeff: number) {\n    const binomesXY1 = this.p.binomesXY(coeff)\n    const p2 = symetrieAxiale(this.p, this.d as IDroite)\n    const binomesXY2 = p2.binomesXY(coeff)\n    const code = `<polygon stroke=\"${this.p.color[0]}\" stroke-width=\"${this.p.epaisseur}\" fill=\"${this.p.couleurDeRemplissage[0]}\" >\n    <animate attributeName=\"points\" ${this.animation}\n    from=\"${binomesXY1}\"\n    to=\"${binomesXY2}\"\n    />\n    </polygon>`\n    return code\n  }\n\n  tikz() {\n    return ''\n  }\n}\nexport function symetrieAnimee(\n  p: IPolygone,\n  d: IDroite,\n  animation = 'begin=\"0s\" dur=\"2s\" repeatCount=\"indefinite\"',\n) {\n  return new SymetrieAnimee(p, d, animation)\n}\n\nexport class AffiniteOrthoAnimee extends ObjetMathalea2D {\n  p: IPolygone\n  d: IDroite\n  k: number\n  animation: string\n  constructor(\n    p: IPolygone,\n    d: IDroite,\n    k: number,\n    animation = 'begin=\"0s\" dur=\"2s\" repeatCount=\"indefinite\"',\n  ) {\n    super()\n    this.p = p\n    this.d = d\n    this.k = k\n    this.animation = animation\n    const bordures = fixeBordures([p, affiniteOrtho(p, d, k)])\n    this.bordures = [bordures.xmin, bordures.ymin, bordures.xmax, bordures.ymax]\n  }\n\n  svg(coeff: number) {\n    const binomesXY1 = this.p.binomesXY(coeff)\n    const p2 = affiniteOrtho(this.p, this.d, this.k)\n    const binomesXY2 = p2.binomesXY(coeff)\n    const code = `<polygon stroke=\"${this.p.color[0]}\" stroke-width=\"${this.p.epaisseur}\" fill=\"${this.p.couleurDeRemplissage[0]}\" >\n    <animate attributeName=\"points\" ${this.animation}\n    from=\"${binomesXY1}\"\n    to=\"${binomesXY2}\"\n    />\n    </polygon>`\n    return code\n  }\n\n  tikz() {\n    return ''\n  }\n}\nexport function affiniteOrthoAnimee(\n  p: IPolygone,\n  d: IDroite,\n  k: number,\n  animation = 'begin=\"0s\" dur=\"2s\" repeatCount=\"indefinite\"',\n) {\n  return new AffiniteOrthoAnimee(p, d, k, animation)\n}\n\nexport class TranslationPuisRotationAnimee extends ObjetMathalea2D {\n  figure1: ObjetMathalea2D | ObjetMathalea2D[]\n  v: IVecteur\n  figure2: ObjetMathalea2D | ObjetMathalea2D[]\n  O: PointAbstrait\n  angle: number\n  t1: number\n  t2: number\n  numId: string\n  constructor(\n    numId: string,\n    figure1: ObjetMathalea2D | ObjetMathalea2D[],\n    v: Vecteur,\n    figure2: ObjetMathalea2D | ObjetMathalea2D[],\n    O: PointAbstrait,\n    angle: number,\n    t1 = 5,\n    t2 = 2,\n  ) {\n    super()\n    this.figure1 = figure1\n    this.v = v\n    this.figure2 = figure2\n    this.O = O\n    this.angle = angle\n    this.t1 = t1\n    this.t2 = t2\n    this.numId = numId\n  }\n\n  svg(coeff: number): string {\n    if (Array.isArray(this.figure2)) {\n      this.figure2.forEach((fig) => {\n        afficherTempo(fig, this.t1, this.t1 + this.t2, 1)\n      })\n    } else {\n      afficherTempo(this.figure2, this.t1, this.t1 + this.t2, 1)\n    }\n    let code = '<g> '\n    // Translation de figure1 de vecteur v\n    if (Array.isArray(this.figure1)) {\n      // Si la figure1 est constituée d'une liste d'éléments\n      for (const objet of this.figure1) {\n        code += '\\n' + objet.svg(coeff)\n      }\n    } else {\n      // Si la figure1 n'est constituée que d'un élément\n      code += '\\n' + this.figure1.svg(coeff)\n    }\n    code += `<animateTransform\n    attributeName=\"transform\"\n    attributeType=\"XML\"\n    type=\"translate\"\n    from=\"0 0\"\n    to=\"${arrondi(this.v.xSVG(coeff), 0)} ${arrondi(this.v.ySVG(coeff), 0)}\"\n    begin=\"0s\" dur=\"${this.t1}s\" fill=\"freeze\"  repeatCount=\"1\" id=\"translat${this.numId}\"\n    /></path></g>`\n    if (Array.isArray(this.figure1)) {\n      this.figure1.forEach((fig) => {\n        cacherTempo(fig, this.t1, 0, 1)\n      })\n    } else {\n      cacherTempo(this.figure1, this.t1, 0, 1)\n    }\n\n    // Rotation de figure2 de centre O et de angle angle\n    code += '<g>'\n    if (Array.isArray(this.figure2)) {\n      // Si la figure2 est constituée d'une liste d'éléments\n      for (const objet of this.figure2) {\n        code += '\\n' + objet.svg(coeff)\n      }\n    } else {\n      // Si la figure2 n'est constituée que d'un élément\n      code += '\\n' + this.figure2.svg(coeff)\n    }\n    code += `<animateTransform\n  attributeName=\"transform\"\n  type=\"rotate\"\n  from=\"0 ${this.O.xSVG(coeff)} ${this.O.ySVG(coeff)}\"\n  to=\"${-this.angle} ${this.O.xSVG(coeff)} ${this.O.ySVG(coeff)}\"\n  begin=\"translat${this.numId}.end\" dur=\"${this.t2}s\" fill=\"freeze\" repeatCount=\"1\" id=\"rotat-${this.numId}\"\n  /></path>`\n\n    code += '</g>'\n    return code\n  }\n}\nexport function translationPuisRotationAnimees(\n  numId: string,\n  figure1: ObjetMathalea2D | ObjetMathalea2D[],\n  v: Vecteur,\n  figure2: ObjetMathalea2D | ObjetMathalea2D[],\n  O: PointAbstrait,\n  angle: number,\n  t1 = 5,\n  t2 = 2,\n) {\n  return new TranslationPuisRotationAnimee(\n    numId,\n    figure1,\n    v,\n    figure2,\n    O,\n    angle,\n    t1,\n    t2,\n  )\n}\n"],"names":["montrerParDiv","id","elt","cacherParDiv","afficherTempo","objet","t0","r","compteur","checkExist","cacheRepete","montreRepete","cacherTempo","ApparitionAnimee","ObjetMathalea2D","liste","dur","pourcentage","repeat","__publicField","coeff","code","apparitionAnimee","TranslationAnimee","v","animation","liste2","el","translation","bordures","fixeBordures","vecteur","translationAnimee","RotationAnimee","O","angle","rotation","rotationAnimee","SymetrieAnimee","p","d","symetrieAxiale","binomesXY1","binomesXY2","symetrieAnimee","TranslationPuisRotationAnimee","numId","figure1","figure2","t1","t2","fig","arrondi","translationPuisRotationAnimees"],"mappings":"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"}