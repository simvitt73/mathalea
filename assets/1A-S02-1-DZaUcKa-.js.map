{"version":3,"file":"1A-S02-1-DZaUcKa-.js","sources":["../../src/exercices/1e/1A-S02-1.ts"],"sourcesContent":["import { texteGras } from '../../lib/outils/embellissements'\nimport { texNombre } from '../../lib/outils/texNombre'\nimport { randint } from '../../modules/outils'\nimport { nombreElementsDifferents } from '../ExerciceQcm'\n// import ExerciceQcmA from '../../ExerciceQcmA'\nimport ExerciceQcmA from '../ExerciceQcmA'\n\nexport const uuid = '9aef1'\nexport const refs = {\n  'fr-fr': ['1A-S02-1', '3AutoP04-1'],\n  'fr-ch': [],\n}\nexport const interactifReady = true\nexport const interactifType = 'qcm'\nexport const amcReady = 'true'\nexport const amcType = 'qcmMono'\nexport const titre = \"Déterminer la médiane d'une série à faible effectif\"\nexport const dateDePublication = '01/08/2025'\n// Ceci est un exemple de QCM avec version originale et version aléatoire\n/**\n *\n * @author Stéphane Guyon\n *\n */\n\nexport default class MedianeQCM extends ExerciceQcmA {\n  // Ceci est la fonction qui s'occupe d'écrire l'énoncé, la correction et les réponses\n  // Elle factorise le code qui serait dupliqué dans versionAleatoire et versionOriginale\n  private appliquerLesValeurs(\n    effectif: number,\n    valeurs: number[],\n    rang: number,\n    mediane: number,\n    serieClassee: number[],\n  ): void {\n    let distracteur2: number\n    if (effectif % 2 === 0) {\n      // cas série effectif pair\n      distracteur2 = (valeurs[rang - 1] + valeurs[rang]) / 2\n    } else {\n      // cas série effectif impair\n      distracteur2 = valeurs[rang - 1]\n    }\n    let distracteur3: number\n    let distracteur4: number\n    if (effectif % 2 === 0) {\n      // cas série effectif pair\n      distracteur3 = serieClassee[rang - 1]\n      distracteur4 = serieClassee[rang]\n    } else {\n      // cas série effectif impair\n      distracteur3 = serieClassee[rang - 2]\n      distracteur4 = serieClassee[rang]\n    }\n    function rendreDistracteursDistincts(\n      mediane: number,\n      distracteur2: number,\n      distracteur3: number,\n      distracteur4: number,\n    ): { d3: number; d4: number } {\n      const interdits = new Set([mediane, distracteur2])\n\n      const ajustements = [0, 1, -1, 2, -2]\n\n      // Trouver une valeur valide pour distracteur3\n      const d3Valides = ajustements\n        .map((delta) => distracteur3 + delta)\n        .filter((val) => !interdits.has(val))\n\n      if (d3Valides.length === 0)\n        throw new Error('Impossible de rendre distracteur3 distinct')\n\n      const d3 = d3Valides[0]\n      interdits.add(d3)\n\n      // Trouver une valeur valide pour distracteur4\n      const d4Valides = ajustements\n        .map((delta) => distracteur4 + delta)\n        .filter((val) => !interdits.has(val))\n\n      if (d4Valides.length === 0)\n        throw new Error('Impossible de rendre distracteur4 distinct')\n\n      const d4 = d4Valides[0]\n\n      return { d3, d4 }\n    }\n    let d3 = distracteur3\n    let d4 = distracteur4\n    const result = rendreDistracteursDistincts(\n      mediane,\n      distracteur2,\n      distracteur3,\n      distracteur4,\n    )\n    d3 = result.d3\n    d4 = result.d4\n    this.reponses = [\n      `$${texNombre(mediane)}$`,\n      ` $${texNombre(d3)}$`,\n      `$${texNombre(d4)}$`,\n      `$${texNombre(distracteur2)}$`,\n    ]\n\n    this.enonce = `On donne la série statistique suivante : \n    ${valeurs.join(' ; ')}<br>\n    Parmi ces propositions, laquelle peut être la médiane de la série ?`\n    this.correction = `La série triée dans l'ordre croissant est : ${serieClassee.join('  ;  ')}.`\n    this.correction += `<br>La série comporte $${effectif}$ valeurs, qui est `\n    if (effectif % 2 === 0) {\n      this.correction += `un nombre pair, donc une médiane est une valeur ${texteGras('strictement')} comprise entre les termes de rang $${rang}$ et $${rang + 1}$\n      , soit entre $${serieClassee[rang - 1]}$ et $${serieClassee[rang]}$. <br>Prenons la moyenne de ces deux valeurs :<br>\n       $\\\\dfrac{${texNombre(serieClassee[rang - 1])} + ${texNombre(serieClassee[rang])}}{2} = ${texNombre(mediane)}$.<br>`\n    } else {\n      this.correction += `un nombre impair,  donc la médiane est le terme de rang $${rang}$.<br>`\n    }\n    this.correction += `La médiane est donc $${texNombre(mediane)}$.`\n    this.reponse = `$${texNombre(mediane)}$`\n  }\n\n  versionOriginale: () => void = () => {\n    this.appliquerLesValeurs(4, [3, 8, 5, 2], 2, 4, [2, 3, 5, 8]) // valeurs originales\n    this.reponses = ['4', '6,5', '5', '8']\n  }\n\n  versionAleatoire: () => void = () => {\n    const n = 4 // nombre de réponses différentes voulues (on rappelle que la première réponse est la bonne)\n    do {\n      const effectif = randint(5, 10) // nombre de valeurs dans la série\n      const valeurs: number[] = [] // On ditribue des valeurs distinctes à la série\n      while (valeurs.length < effectif) {\n        const val = randint(2, 20)\n        if (!valeurs.includes(val)) {\n          valeurs.push(val)\n        }\n      }\n      const serieClassee = [...valeurs].sort((a, b) => a - b)\n      const rang = effectif % 2 === 0 ? effectif / 2 : (effectif + 1) / 2\n      // Attention, le rang donne le bon rang dans la série impaire, mais le rang inférieur dans la série paire.\n      let mediane: number\n      if (effectif % 2 === 0) {\n        mediane = (serieClassee[rang - 1] + serieClassee[rang]) / 2\n      } else {\n        mediane = serieClassee[rang - 1]\n      }\n\n      // On adapte la série de l'énoncé pour créer un distracteur qui utilise la bonne méthode mais dans la série de l'énoncé :\n      if (effectif % 2 === 0) {\n        // cas série effectif pair\n        if (mediane === (valeurs[rang - 1] + valeurs[rang]) / 2) {\n          // Interchanger les valeurs de valeurs[rang-1] et valeurs[rang-2]\n          const temp = valeurs[rang - 1]\n          valeurs[rang - 1] = valeurs[rang - 2]\n          valeurs[rang - 2] = temp\n        }\n      } else {\n        // cas série effectif impair\n        if (mediane === valeurs[rang - 1]) {\n          const temp = valeurs[rang - 1]\n          valeurs[rang - 1] = valeurs[rang - 2]\n          valeurs[rang - 2] = temp\n        }\n      }\n\n      this.appliquerLesValeurs(effectif, valeurs, rang, mediane, serieClassee)\n    } while (nombreElementsDifferents(this.reponses) < n)\n  }\n\n  // Ici il n'y a rien à faire, on appelle juste la version aleatoire (pour un qcm aleatoirisé, c'est le fonctionnement par défaut)\n  constructor() {\n    super()\n    this.options = { vertical: false, ordered: false }\n    this.versionAleatoire()\n  }\n}\n"],"names":["uuid","refs","interactifReady","interactifType","amcReady","amcType","titre","dateDePublication","MedianeQCM","ExerciceQcmA","__publicField","effectif","randint","valeurs","val","serieClassee","a","b","rang","mediane","temp","nombreElementsDifferents","distracteur2","distracteur3","distracteur4","rendreDistracteursDistincts","interdits","ajustements","d3Valides","delta","d3","d4Valides","d4","result","texNombre","texteGras"],"mappings":"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"}